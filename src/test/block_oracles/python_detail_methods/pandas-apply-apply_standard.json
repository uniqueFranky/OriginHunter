{
  "origin": "codeshovel",
  "repositoryName": "pandas",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/pandas/.git",
  "startCommitName": "555e6e1cbb852b2b0c2cd13f6f575656254160f6",
  "sourceFileName": "apply.py",
  "functionName": "apply_standard",
  "functionId": "FrameApply__apply_standard___self",
  "sourceFilePath": "pandas/core/apply.py",
  "functionAnnotation": "",
  "functionStartLine": 267,
  "functionEndLine": 316,
  "numCommitsSeen": 33,
  "timeTaken": 7138,
  "changeHistory": [
    "f7d6b584f83babf3f5c6d1610f6150d809be460f",
    "2bf5ce76ded6e05aba88f27adc6459d32c5f6144",
    "d691ec01cdd892920a4eabca458f72025a2e1b8b",
    "a85f1d7dcbddb32eaf6b848bf184ae422b7771fa",
    "0436570f05c3b6e7bbb7c7d8fc8fa2f28a0420a8",
    "d9b3993cc3722ddd01367089d374652c0b5ce0ce",
    "9c37226a228784e993a220a02424fc8b68fe8257",
    "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
    "26a2d41ebdb506e2419f2b38a53ecf622d16c319",
    "6b0c7e72b141831b7a9a5651f9e19eef53ec9e76",
    "bcaa5da3671b2fd1b3dfca98ebd529d3525815c0",
    "76b35c6662136302d212448906c1c8bf8225fffd"
  ],
  "changeHistoryShort": {
    "f7d6b584f83babf3f5c6d1610f6150d809be460f": "Ybodychange",
    "2bf5ce76ded6e05aba88f27adc6459d32c5f6144": "Ybodychange",
    "d691ec01cdd892920a4eabca458f72025a2e1b8b": "Ybodychange",
    "a85f1d7dcbddb32eaf6b848bf184ae422b7771fa": "Ybodychange",
    "0436570f05c3b6e7bbb7c7d8fc8fa2f28a0420a8": "Ybodychange",
    "d9b3993cc3722ddd01367089d374652c0b5ce0ce": "Ybodychange",
    "9c37226a228784e993a220a02424fc8b68fe8257": "Ybodychange",
    "bb6135880e5e453d7701764b9f2e4ad3356a68d7": "Ybodychange",
    "26a2d41ebdb506e2419f2b38a53ecf622d16c319": "Ybodychange",
    "6b0c7e72b141831b7a9a5651f9e19eef53ec9e76": "Ybodychange",
    "bcaa5da3671b2fd1b3dfca98ebd529d3525815c0": "Ybodychange",
    "76b35c6662136302d212448906c1c8bf8225fffd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f7d6b584f83babf3f5c6d1610f6150d809be460f": {
      "type": "Ybodychange",
      "commitMessage": "REF: eliminate statefulness in FrameApply (#29620)\n\n",
      "commitDate": "2019/11/15 下午10:53",
      "commitName": "f7d6b584f83babf3f5c6d1610f6150d809be460f",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2019/11/15 上午2:06",
      "commitNameOld": "2bf5ce76ded6e05aba88f27adc6459d32c5f6144",
      "commitAuthorOld": "Aivengoe",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not isinstance(self.agg_axis, ABCMultiIndex)\n        ):\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy \u003d self.obj._constructor_sliced(\n                empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n            )\n\n            try:\n                result \u003d libreduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n\n        # compute the result using the series generator\n        results, res_index \u003d self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results, res_index)\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 264,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,49 +1,49 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n             and not self.dtypes.apply(is_extension_array_dtype).any()\n             # Disallow complex_internals since libreduction shortcut\n             #  cannot handle MultiIndex\n             and not isinstance(self.agg_axis, ABCMultiIndex)\n         ):\n \n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n \n             # Preserve subclass for e.g. test_subclassed_apply\n             dummy \u003d self.obj._constructor_sliced(\n                 empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n             )\n \n             try:\n                 result \u003d libreduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n             except ValueError as err:\n                 if \"Function does not reduce\" not in str(err):\n                     # catch only ValueError raised intentionally in libreduction\n                     raise\n             except TypeError:\n                 # e.g. test_apply_ignore_failures we just ignore\n                 if not self.ignore_failures:\n                     raise\n             except ZeroDivisionError:\n                 # reached via numexpr; fall back to python implementation\n                 pass\n             else:\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n \n         # compute the result using the series generator\n-        results \u003d self.apply_series_generator()\n+        results, res_index \u003d self.apply_series_generator()\n \n         # wrap results\n-        return self.wrap_results(results)\n+        return self.wrap_results(results, res_index)\n",
      "extendedDetails": {}
    },
    "2bf5ce76ded6e05aba88f27adc6459d32c5f6144": {
      "type": "Ybodychange",
      "commitMessage": "Replace _has_complex_internals #29227 (#29237)\n\n",
      "commitDate": "2019/11/15 上午2:06",
      "commitName": "2bf5ce76ded6e05aba88f27adc6459d32c5f6144",
      "commitAuthor": "Aivengoe",
      "commitDateOld": "2019/11/14 下午9:27",
      "commitNameOld": "d691ec01cdd892920a4eabca458f72025a2e1b8b",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not isinstance(self.agg_axis, ABCMultiIndex)\n        ):\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy \u003d self.obj._constructor_sliced(\n                empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n            )\n\n            try:\n                result \u003d libreduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n\n        # compute the result using the series generator\n        results \u003d self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results)\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 271,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,49 +1,49 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n             and not self.dtypes.apply(is_extension_array_dtype).any()\n             # Disallow complex_internals since libreduction shortcut\n             #  cannot handle MultiIndex\n-            and not self.agg_axis._has_complex_internals\n+            and not isinstance(self.agg_axis, ABCMultiIndex)\n         ):\n \n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n \n             # Preserve subclass for e.g. test_subclassed_apply\n             dummy \u003d self.obj._constructor_sliced(\n                 empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n             )\n \n             try:\n                 result \u003d libreduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n             except ValueError as err:\n                 if \"Function does not reduce\" not in str(err):\n                     # catch only ValueError raised intentionally in libreduction\n                     raise\n             except TypeError:\n                 # e.g. test_apply_ignore_failures we just ignore\n                 if not self.ignore_failures:\n                     raise\n             except ZeroDivisionError:\n                 # reached via numexpr; fall back to python implementation\n                 pass\n             else:\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n \n         # compute the result using the series generator\n         results \u003d self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results(results)\n",
      "extendedDetails": {}
    },
    "d691ec01cdd892920a4eabca458f72025a2e1b8b": {
      "type": "Ybodychange",
      "commitMessage": "REF: make FrameApply less stateful, no self.results (#29585)\n\n",
      "commitDate": "2019/11/14 下午9:27",
      "commitName": "d691ec01cdd892920a4eabca458f72025a2e1b8b",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2019/11/13 上午7:44",
      "commitNameOld": "57e1b346c8ca15186f6fde134f83d09db90e695e",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 1.57,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not self.agg_axis._has_complex_internals\n        ):\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy \u003d self.obj._constructor_sliced(\n                empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n            )\n\n            try:\n                result \u003d libreduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n\n        # compute the result using the series generator\n        results \u003d self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results)\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 271,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,49 +1,49 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n             and not self.dtypes.apply(is_extension_array_dtype).any()\n             # Disallow complex_internals since libreduction shortcut\n             #  cannot handle MultiIndex\n             and not self.agg_axis._has_complex_internals\n         ):\n \n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n \n             # Preserve subclass for e.g. test_subclassed_apply\n             dummy \u003d self.obj._constructor_sliced(\n                 empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n             )\n \n             try:\n                 result \u003d libreduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n             except ValueError as err:\n                 if \"Function does not reduce\" not in str(err):\n                     # catch only ValueError raised intentionally in libreduction\n                     raise\n             except TypeError:\n                 # e.g. test_apply_ignore_failures we just ignore\n                 if not self.ignore_failures:\n                     raise\n             except ZeroDivisionError:\n                 # reached via numexpr; fall back to python implementation\n                 pass\n             else:\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n \n         # compute the result using the series generator\n-        self.apply_series_generator()\n+        results \u003d self.apply_series_generator()\n \n         # wrap results\n-        return self.wrap_results()\n+        return self.wrap_results(results)\n",
      "extendedDetails": {}
    },
    "a85f1d7dcbddb32eaf6b848bf184ae422b7771fa": {
      "type": "Ybodychange",
      "commitMessage": "DEPR: is_extension_type (#29457)\n\n",
      "commitDate": "2019/11/8 下午10:37",
      "commitName": "a85f1d7dcbddb32eaf6b848bf184ae422b7771fa",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2019/11/8 上午4:48",
      "commitNameOld": "66cb166c96173ac53516f2e4292edd4a4c40ece7",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not self.agg_axis._has_complex_internals\n        ):\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy \u003d self.obj._constructor_sliced(\n                empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n            )\n\n            try:\n                result \u003d libreduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 221,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,49 +1,49 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n-            and not self.dtypes.apply(is_extension_type).any()\n+            and not self.dtypes.apply(is_extension_array_dtype).any()\n             # Disallow complex_internals since libreduction shortcut\n             #  cannot handle MultiIndex\n             and not self.agg_axis._has_complex_internals\n         ):\n \n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n \n             # Preserve subclass for e.g. test_subclassed_apply\n             dummy \u003d self.obj._constructor_sliced(\n                 empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n             )\n \n             try:\n                 result \u003d libreduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n             except ValueError as err:\n                 if \"Function does not reduce\" not in str(err):\n                     # catch only ValueError raised intentionally in libreduction\n                     raise\n             except TypeError:\n                 # e.g. test_apply_ignore_failures we just ignore\n                 if not self.ignore_failures:\n                     raise\n             except ZeroDivisionError:\n                 # reached via numexpr; fall back to python implementation\n                 pass\n             else:\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n \n         # compute the result using the series generator\n         self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "0436570f05c3b6e7bbb7c7d8fc8fa2f28a0420a8": {
      "type": "Ybodychange",
      "commitMessage": "BUG: Fix TypeError raised in libreduction (#28643)\n\n",
      "commitDate": "2019/10/3 上午3:58",
      "commitName": "0436570f05c3b6e7bbb7c7d8fc8fa2f28a0420a8",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2019/9/27 下午7:48",
      "commitNameOld": "a6fe80366d88aa1f150f880516d49ee3eadffed7",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 5.34,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not self.agg_axis._has_complex_internals\n        ):\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy \u003d self.obj._constructor_sliced(\n                empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n            )\n\n            try:\n                result \u003d libreduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 267,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,35 +1,49 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n             and not self.dtypes.apply(is_extension_type).any()\n+            # Disallow complex_internals since libreduction shortcut\n+            #  cannot handle MultiIndex\n+            and not self.agg_axis._has_complex_internals\n         ):\n \n-            # Create a dummy Series from an empty array\n-            from pandas import Series\n-\n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n-            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n+\n+            # Preserve subclass for e.g. test_subclassed_apply\n+            dummy \u003d self.obj._constructor_sliced(\n+                empty_arr, index\u003dindex, dtype\u003dvalues.dtype\n+            )\n \n             try:\n                 result \u003d libreduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n-                return self.obj._constructor_sliced(result, index\u003dlabels)\n-            except Exception:\n+            except ValueError as err:\n+                if \"Function does not reduce\" not in str(err):\n+                    # catch only ValueError raised intentionally in libreduction\n+                    raise\n+            except TypeError:\n+                # e.g. test_apply_ignore_failures we just ignore\n+                if not self.ignore_failures:\n+                    raise\n+            except ZeroDivisionError:\n+                # reached via numexpr; fall back to python implementation\n                 pass\n+            else:\n+                return self.obj._constructor_sliced(result, index\u003dlabels)\n \n         # compute the result using the series generator\n         self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "d9b3993cc3722ddd01367089d374652c0b5ce0ce": {
      "type": "Ybodychange",
      "commitMessage": "reduction-\u003e libreduction for grepability (#28184)\n\n",
      "commitDate": "2019/8/30 下午10:28",
      "commitName": "d9b3993cc3722ddd01367089d374652c0b5ce0ce",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2019/8/5 下午2:31",
      "commitNameOld": "9c37226a228784e993a220a02424fc8b68fe8257",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 25.33,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n        ):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n            try:\n                result \u003d libreduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 261,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,35 +1,35 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n             and not self.dtypes.apply(is_extension_type).any()\n         ):\n \n             # Create a dummy Series from an empty array\n             from pandas import Series\n \n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n             dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n \n             try:\n-                result \u003d reduction.compute_reduction(\n+                result \u003d libreduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n             except Exception:\n                 pass\n \n         # compute the result using the series generator\n         self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "9c37226a228784e993a220a02424fc8b68fe8257": {
      "type": "Ybodychange",
      "commitMessage": "CLN: rename reduce--\u003edo_reduce (#27706)\n\n",
      "commitDate": "2019/8/5 下午2:31",
      "commitName": "9c37226a228784e993a220a02424fc8b68fe8257",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2019/7/4 上午11:28",
      "commitNameOld": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
      "commitAuthorOld": "Joris Van den Bossche",
      "daysBetweenCommits": 32.13,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n        ):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n            try:\n                result \u003d reduction.compute_reduction(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 261,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,35 +1,35 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (\n             self.result_type in [\"reduce\", None]\n             and not self.dtypes.apply(is_extension_type).any()\n         ):\n \n             # Create a dummy Series from an empty array\n             from pandas import Series\n \n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n             dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n \n             try:\n-                result \u003d reduction.reduce(\n+                result \u003d reduction.compute_reduction(\n                     values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                 )\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n             except Exception:\n                 pass\n \n         # compute the result using the series generator\n         self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "bb6135880e5e453d7701764b9f2e4ad3356a68d7": {
      "type": "Ybodychange",
      "commitMessage": "STYLE: Apply black formatting\n",
      "commitDate": "2019/7/4 上午11:28",
      "commitName": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
      "commitAuthor": "Joris Van den Bossche",
      "commitDateOld": "2019/4/25 上午5:02",
      "commitNameOld": "88062f75dbca929ec082295c936edd07cc912dbf",
      "commitAuthorOld": "topper-123",
      "daysBetweenCommits": 70.27,
      "commitsBetweenForRepo": 439,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n        ):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n            try:\n                result \u003d reduction.reduce(\n                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n                )\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 261,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,33 +1,35 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n-        if (self.result_type in [\u0027reduce\u0027, None] and\n-                not self.dtypes.apply(is_extension_type).any()):\n+        if (\n+            self.result_type in [\"reduce\", None]\n+            and not self.dtypes.apply(is_extension_type).any()\n+        ):\n \n             # Create a dummy Series from an empty array\n             from pandas import Series\n+\n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n             dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n \n             try:\n-                result \u003d reduction.reduce(values, self.f,\n-                                          axis\u003dself.axis,\n-                                          dummy\u003ddummy,\n-                                          labels\u003dlabels)\n+                result \u003d reduction.reduce(\n+                    values, self.f, axis\u003dself.axis, dummy\u003ddummy, labels\u003dlabels\n+                )\n                 return self.obj._constructor_sliced(result, index\u003dlabels)\n             except Exception:\n                 pass\n \n         # compute the result using the series generator\n         self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "26a2d41ebdb506e2419f2b38a53ecf622d16c319": {
      "type": "Ybodychange",
      "commitMessage": "Keep subclassing in apply (#19823)\n\n",
      "commitDate": "2018/2/24 下午11:10",
      "commitName": "26a2d41ebdb506e2419f2b38a53ecf622d16c319",
      "commitAuthor": "Jaume Bonet",
      "commitDateOld": "2018/2/7 下午9:06",
      "commitNameOld": "6b0c7e72b141831b7a9a5651f9e19eef53ec9e76",
      "commitAuthorOld": "Jeff Reback",
      "daysBetweenCommits": 17.09,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (self.result_type in [\u0027reduce\u0027, None] and\n                not self.dtypes.apply(is_extension_type).any()):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n            try:\n                result \u003d reduction.reduce(values, self.f,\n                                          axis\u003dself.axis,\n                                          dummy\u003ddummy,\n                                          labels\u003dlabels)\n                return self.obj._constructor_sliced(result, index\u003dlabels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 213,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,33 +1,33 @@\n     def apply_standard(self):\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n \n         # we cannot reduce using non-numpy dtypes,\n         # as demonstrated in gh-12244\n         if (self.result_type in [\u0027reduce\u0027, None] and\n                 not self.dtypes.apply(is_extension_type).any()):\n \n             # Create a dummy Series from an empty array\n             from pandas import Series\n             values \u003d self.values\n             index \u003d self.obj._get_axis(self.axis)\n             labels \u003d self.agg_axis\n             empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n             dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n \n             try:\n                 result \u003d reduction.reduce(values, self.f,\n                                           axis\u003dself.axis,\n                                           dummy\u003ddummy,\n                                           labels\u003dlabels)\n-                return Series(result, index\u003dlabels)\n+                return self.obj._constructor_sliced(result, index\u003dlabels)\n             except Exception:\n                 pass\n \n         # compute the result using the series generator\n         self.apply_series_generator()\n \n         # wrap results\n         return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "6b0c7e72b141831b7a9a5651f9e19eef53ec9e76": {
      "type": "Ybodychange",
      "commitMessage": "API/BUG: .apply will correctly infer output shape when axis\u003d1 (#18577)\n\ncloses #16353\r\ncloses #17348\r\ncloses #17437\r\ncloses #18573\r\ncloses #17970\r\ncloses #17892\r\ncloses #17602\r\ncloses #18775\r\ncloses #18901\r\ncloses #18919\r\n",
      "commitDate": "2018/2/7 下午9:06",
      "commitName": "6b0c7e72b141831b7a9a5651f9e19eef53ec9e76",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2018/1/22 上午1:57",
      "commitNameOld": "bcaa5da3671b2fd1b3dfca98ebd529d3525815c0",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 16.8,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (self.result_type in [\u0027reduce\u0027, None] and\n                not self.dtypes.apply(is_extension_type).any()):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n            values \u003d self.values\n            index \u003d self.obj._get_axis(self.axis)\n            labels \u003d self.agg_axis\n            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n            try:\n                result \u003d reduction.reduce(values, self.f,\n                                          axis\u003dself.axis,\n                                          dummy\u003ddummy,\n                                          labels\u003dlabels)\n                return Series(result, index\u003dlabels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 211,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,38 +1,33 @@\n     def apply_standard(self):\n-        from pandas import Series\n-\n-        reduce \u003d self.reduce\n-        if reduce is None:\n-            reduce \u003d True\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n-        if reduce:\n+\n+        # we cannot reduce using non-numpy dtypes,\n+        # as demonstrated in gh-12244\n+        if (self.result_type in [\u0027reduce\u0027, None] and\n+                not self.dtypes.apply(is_extension_type).any()):\n+\n+            # Create a dummy Series from an empty array\n+            from pandas import Series\n             values \u003d self.values\n+            index \u003d self.obj._get_axis(self.axis)\n+            labels \u003d self.agg_axis\n+            empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n+            dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n \n-            # we cannot reduce using non-numpy dtypes,\n-            # as demonstrated in gh-12244\n-            if not is_extension_type(values):\n-\n-                # Create a dummy Series from an empty array\n-                index \u003d self.obj._get_axis(self.axis)\n-                empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n-\n-                dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n-\n-                try:\n-                    labels \u003d self.agg_axis\n-                    result \u003d reduction.reduce(values, self.f,\n-                                              axis\u003dself.axis,\n-                                              dummy\u003ddummy,\n-                                              labels\u003dlabels)\n-                    return Series(result, index\u003dlabels)\n-                except Exception:\n-                    pass\n+            try:\n+                result \u003d reduction.reduce(values, self.f,\n+                                          axis\u003dself.axis,\n+                                          dummy\u003ddummy,\n+                                          labels\u003dlabels)\n+                return Series(result, index\u003dlabels)\n+            except Exception:\n+                pass\n \n         # compute the result using the series generator\n-        results, res_index, res_columns \u003d self._apply_series_generator()\n+        self.apply_series_generator()\n \n         # wrap results\n-        return self.wrap_results(results, res_index, res_columns)\n+        return self.wrap_results()\n",
      "extendedDetails": {}
    },
    "bcaa5da3671b2fd1b3dfca98ebd529d3525815c0": {
      "type": "Ybodychange",
      "commitMessage": "separate _libs/src/reduce.pyx to _libs.reduction (#19306)\n\n",
      "commitDate": "2018/1/22 上午1:57",
      "commitName": "bcaa5da3671b2fd1b3dfca98ebd529d3525815c0",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2017/12/14 下午7:36",
      "commitNameOld": "76b35c6662136302d212448906c1c8bf8225fffd",
      "commitAuthorOld": "Jeff Reback",
      "daysBetweenCommits": 38.26,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "actualSource": "    def apply_standard(self):\n        from pandas import Series\n\n        reduce \u003d self.reduce\n        if reduce is None:\n            reduce \u003d True\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n        if reduce:\n            values \u003d self.values\n\n            # we cannot reduce using non-numpy dtypes,\n            # as demonstrated in gh-12244\n            if not is_extension_type(values):\n\n                # Create a dummy Series from an empty array\n                index \u003d self.obj._get_axis(self.axis)\n                empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n                dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n                try:\n                    labels \u003d self.agg_axis\n                    result \u003d reduction.reduce(values, self.f,\n                                              axis\u003dself.axis,\n                                              dummy\u003ddummy,\n                                              labels\u003dlabels)\n                    return Series(result, index\u003dlabels)\n                except Exception:\n                    pass\n\n        # compute the result using the series generator\n        results, res_index, res_columns \u003d self._apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results, res_index, res_columns)\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 128,
      "functionName": "apply_standard",
      "functionAnnotation": "",
      "diff": "@@ -1,38 +1,38 @@\n     def apply_standard(self):\n         from pandas import Series\n \n         reduce \u003d self.reduce\n         if reduce is None:\n             reduce \u003d True\n \n         # try to reduce first (by default)\n         # this only matters if the reduction in values is of different dtype\n         # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n         if reduce:\n             values \u003d self.values\n \n             # we cannot reduce using non-numpy dtypes,\n             # as demonstrated in gh-12244\n             if not is_extension_type(values):\n \n                 # Create a dummy Series from an empty array\n                 index \u003d self.obj._get_axis(self.axis)\n                 empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n \n                 dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n \n                 try:\n                     labels \u003d self.agg_axis\n-                    result \u003d lib.reduce(values, self.f,\n-                                        axis\u003dself.axis,\n-                                        dummy\u003ddummy,\n-                                        labels\u003dlabels)\n+                    result \u003d reduction.reduce(values, self.f,\n+                                              axis\u003dself.axis,\n+                                              dummy\u003ddummy,\n+                                              labels\u003dlabels)\n                     return Series(result, index\u003dlabels)\n                 except Exception:\n                     pass\n \n         # compute the result using the series generator\n         results, res_index, res_columns \u003d self._apply_series_generator()\n \n         # wrap results\n         return self.wrap_results(results, res_index, res_columns)\n",
      "extendedDetails": {}
    },
    "76b35c6662136302d212448906c1c8bf8225fffd": {
      "type": "Yintroduced",
      "commitMessage": "CLN: factor apply out of frame.py (#18754)\n\n",
      "commitDate": "2017/12/14 下午7:36",
      "commitName": "76b35c6662136302d212448906c1c8bf8225fffd",
      "commitAuthor": "Jeff Reback",
      "diff": "@@ -0,0 +1,38 @@\n+    def apply_standard(self):\n+        from pandas import Series\n+\n+        reduce \u003d self.reduce\n+        if reduce is None:\n+            reduce \u003d True\n+\n+        # try to reduce first (by default)\n+        # this only matters if the reduction in values is of different dtype\n+        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n+        if reduce:\n+            values \u003d self.values\n+\n+            # we cannot reduce using non-numpy dtypes,\n+            # as demonstrated in gh-12244\n+            if not is_extension_type(values):\n+\n+                # Create a dummy Series from an empty array\n+                index \u003d self.obj._get_axis(self.axis)\n+                empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n+\n+                dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n+\n+                try:\n+                    labels \u003d self.agg_axis\n+                    result \u003d lib.reduce(values, self.f,\n+                                        axis\u003dself.axis,\n+                                        dummy\u003ddummy,\n+                                        labels\u003dlabels)\n+                    return Series(result, index\u003dlabels)\n+                except Exception:\n+                    pass\n+\n+        # compute the result using the series generator\n+        results, res_index, res_columns \u003d self._apply_series_generator()\n+\n+        # wrap results\n+        return self.wrap_results(results, res_index, res_columns)\n",
      "actualSource": "    def apply_standard(self):\n        from pandas import Series\n\n        reduce \u003d self.reduce\n        if reduce is None:\n            reduce \u003d True\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can\u0027t directly reduce\n        if reduce:\n            values \u003d self.values\n\n            # we cannot reduce using non-numpy dtypes,\n            # as demonstrated in gh-12244\n            if not is_extension_type(values):\n\n                # Create a dummy Series from an empty array\n                index \u003d self.obj._get_axis(self.axis)\n                empty_arr \u003d np.empty(len(index), dtype\u003dvalues.dtype)\n\n                dummy \u003d Series(empty_arr, index\u003dindex, dtype\u003dvalues.dtype)\n\n                try:\n                    labels \u003d self.agg_axis\n                    result \u003d lib.reduce(values, self.f,\n                                        axis\u003dself.axis,\n                                        dummy\u003ddummy,\n                                        labels\u003dlabels)\n                    return Series(result, index\u003dlabels)\n                except Exception:\n                    pass\n\n        # compute the result using the series generator\n        results, res_index, res_columns \u003d self._apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results, res_index, res_columns)\n",
      "path": "pandas/core/apply.py",
      "functionStartLine": 128,
      "functionName": "apply_standard",
      "functionAnnotation": ""
    }
  }
}