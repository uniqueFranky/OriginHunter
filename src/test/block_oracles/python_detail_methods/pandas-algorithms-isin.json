{
  "origin": "codeshovel",
  "repositoryName": "pandas",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/pandas/.git",
  "startCommitName": "555e6e1cbb852b2b0c2cd13f6f575656254160f6",
  "sourceFileName": "algorithms.py",
  "functionName": "isin",
  "functionId": "__isin___comps__values",
  "sourceFilePath": "pandas/core/algorithms.py",
  "functionAnnotation": "",
  "functionStartLine": 380,
  "functionEndLine": 450,
  "numCommitsSeen": 233,
  "timeTaken": 18791,
  "changeHistory": [
    "109d682215eeaded5966de5d898c2832bc98ebe0",
    "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
    "1a42c70e532ae01c95596d071ab62dc535e2bac9",
    "2c2b6585c1c45889d32491b4a0403617a2d48e17",
    "020e9485baf9889c508154fe95663b5ab2210bc4",
    "2d0c96119391c85bd4f7ffbb847759ee3777162a",
    "60fe82c8a2829e831d28cf6d4b3595637c3c5802",
    "04db779d4c93d286bb0ab87780a85d50ec490266",
    "dfaf8c6918ff20ef781d3177f464a29e70ee5d65",
    "870b6a6d6415c76d051b287adcb180ac3020b6e8",
    "793020293ee1e5fa023f45c12943a4ac51cc23d0",
    "a1dfb037de79e6982a0e7ccf883e5af11e9cc843",
    "e053ee301d82a44ddc86dc7e164fea2d5c5178f8",
    "0cfc08cf4584e8442c84c30d53f1dceafeac5abf",
    "179363765110611ad10883bab55d79785369da9b",
    "32dd92912f15a5c66035f5674c116d23f21bdbca",
    "aa9d0cf7fa0061058125d79d22d86f82f69c9185",
    "7dd4091458d9117e57d2ad9ce3126855bd00108c",
    "05e734ab171be0fda838c6b12839c38fa588da2c",
    "77257662de12ea14e753c4d9ad8c2796f4825254"
  ],
  "changeHistoryShort": {
    "109d682215eeaded5966de5d898c2832bc98ebe0": "Ymultichange(Yreturntypechange,Ybodychange)",
    "bb6135880e5e453d7701764b9f2e4ad3356a68d7": "Ybodychange",
    "1a42c70e532ae01c95596d071ab62dc535e2bac9": "Ybodychange",
    "2c2b6585c1c45889d32491b4a0403617a2d48e17": "Ybodychange",
    "020e9485baf9889c508154fe95663b5ab2210bc4": "Ybodychange",
    "2d0c96119391c85bd4f7ffbb847759ee3777162a": "Ybodychange",
    "60fe82c8a2829e831d28cf6d4b3595637c3c5802": "Ybodychange",
    "04db779d4c93d286bb0ab87780a85d50ec490266": "Ybodychange",
    "dfaf8c6918ff20ef781d3177f464a29e70ee5d65": "Ybodychange",
    "870b6a6d6415c76d051b287adcb180ac3020b6e8": "Ybodychange",
    "793020293ee1e5fa023f45c12943a4ac51cc23d0": "Ybodychange",
    "a1dfb037de79e6982a0e7ccf883e5af11e9cc843": "Ybodychange",
    "e053ee301d82a44ddc86dc7e164fea2d5c5178f8": "Ybodychange",
    "0cfc08cf4584e8442c84c30d53f1dceafeac5abf": "Ybodychange",
    "179363765110611ad10883bab55d79785369da9b": "Ybodychange",
    "32dd92912f15a5c66035f5674c116d23f21bdbca": "Ybodychange",
    "aa9d0cf7fa0061058125d79d22d86f82f69c9185": "Ybodychange",
    "7dd4091458d9117e57d2ad9ce3126855bd00108c": "Ybodychange",
    "05e734ab171be0fda838c6b12839c38fa588da2c": "Ybodychange",
    "77257662de12ea14e753c4d9ad8c2796f4825254": "Yintroduced"
  },
  "changeHistoryDetails": {
    "109d682215eeaded5966de5d898c2832bc98ebe0": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "CLN: algorithms cleanup, de-duplication, typing (#29280)\n\n",
      "commitDate": "2019/10/30 下午7:50",
      "commitName": "109d682215eeaded5966de5d898c2832bc98ebe0",
      "commitAuthor": "jbrockmendel",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "CLN: algorithms cleanup, de-duplication, typing (#29280)\n\n",
          "commitDate": "2019/10/30 下午7:50",
          "commitName": "109d682215eeaded5966de5d898c2832bc98ebe0",
          "commitAuthor": "jbrockmendel",
          "commitDateOld": "2019/10/30 上午12:06",
          "commitNameOld": "26cd577c209fcb184369b556747daa0e1dbdd34a",
          "commitAuthorOld": "jbrockmendel",
          "daysBetweenCommits": 0.82,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "def isin(comps, values) -\u003e np.ndarray:\n    \"\"\"\n    Compute the isin boolean array.\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    ndarray[bool]\n        Same length as `comps`.\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{comps_type}]\".format(\n                comps_type\u003dtype(comps).__name__\n            )\n        )\n    if not is_list_like(values):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{values_type}]\".format(\n                values_type\u003dtype(values).__name__\n            )\n        )\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype \u003d _ensure_data(comps)\n    values, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d htable.ismember_object\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d np.in1d\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\"int64\", copy\u003dFalse)\n            comps \u003d comps.astype(\"int64\", copy\u003dFalse)\n            f \u003d htable.ismember_int64\n        except (TypeError, ValueError, OverflowError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\"float64\", copy\u003dFalse)\n            comps \u003d comps.astype(\"float64\", copy\u003dFalse)\n            f \u003d htable.ismember_float64\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
          "path": "pandas/core/algorithms.py",
          "functionStartLine": 380,
          "functionName": "isin",
          "functionAnnotation": "",
          "diff": "@@ -1,69 +1,70 @@\n-def isin(comps, values):\n+def isin(comps, values) -\u003e np.ndarray:\n     \"\"\"\n-    Compute the isin boolean array\n+    Compute the isin boolean array.\n \n     Parameters\n     ----------\n     comps : array-like\n     values : array-like\n \n     Returns\n     -------\n-    boolean array same length as comps\n+    ndarray[bool]\n+        Same length as `comps`.\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\n             \"only list-like objects are allowed to be passed\"\n             \" to isin(), you passed a [{comps_type}]\".format(\n                 comps_type\u003dtype(comps).__name__\n             )\n         )\n     if not is_list_like(values):\n         raise TypeError(\n             \"only list-like objects are allowed to be passed\"\n             \" to isin(), you passed a [{values_type}]\".format(\n                 values_type\u003dtype(values).__name__\n             )\n         )\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n     comps \u003d com.values_from_object(comps)\n \n-    comps, dtype, _ \u003d _ensure_data(comps)\n-    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n+    comps, dtype \u003d _ensure_data(comps)\n+    values, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n-    f \u003d lambda x, y: htable.ismember_object(x, values)\n+    f \u003d htable.ismember_object\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n-        f \u003d lambda x, y: np.in1d(x, y)\n+        f \u003d np.in1d\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\"int64\", copy\u003dFalse)\n             comps \u003d comps.astype(\"int64\", copy\u003dFalse)\n-            f \u003d lambda x, y: htable.ismember_int64(x, y)\n+            f \u003d htable.ismember_int64\n         except (TypeError, ValueError, OverflowError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\"float64\", copy\u003dFalse)\n             comps \u003d comps.astype(\"float64\", copy\u003dFalse)\n-            f \u003d lambda x, y: htable.ismember_float64(x, y)\n+            f \u003d htable.ismember_float64\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "np.ndarray"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "CLN: algorithms cleanup, de-duplication, typing (#29280)\n\n",
          "commitDate": "2019/10/30 下午7:50",
          "commitName": "109d682215eeaded5966de5d898c2832bc98ebe0",
          "commitAuthor": "jbrockmendel",
          "commitDateOld": "2019/10/30 上午12:06",
          "commitNameOld": "26cd577c209fcb184369b556747daa0e1dbdd34a",
          "commitAuthorOld": "jbrockmendel",
          "daysBetweenCommits": 0.82,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "def isin(comps, values) -\u003e np.ndarray:\n    \"\"\"\n    Compute the isin boolean array.\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    ndarray[bool]\n        Same length as `comps`.\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{comps_type}]\".format(\n                comps_type\u003dtype(comps).__name__\n            )\n        )\n    if not is_list_like(values):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{values_type}]\".format(\n                values_type\u003dtype(values).__name__\n            )\n        )\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype \u003d _ensure_data(comps)\n    values, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d htable.ismember_object\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d np.in1d\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\"int64\", copy\u003dFalse)\n            comps \u003d comps.astype(\"int64\", copy\u003dFalse)\n            f \u003d htable.ismember_int64\n        except (TypeError, ValueError, OverflowError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\"float64\", copy\u003dFalse)\n            comps \u003d comps.astype(\"float64\", copy\u003dFalse)\n            f \u003d htable.ismember_float64\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
          "path": "pandas/core/algorithms.py",
          "functionStartLine": 380,
          "functionName": "isin",
          "functionAnnotation": "",
          "diff": "@@ -1,69 +1,70 @@\n-def isin(comps, values):\n+def isin(comps, values) -\u003e np.ndarray:\n     \"\"\"\n-    Compute the isin boolean array\n+    Compute the isin boolean array.\n \n     Parameters\n     ----------\n     comps : array-like\n     values : array-like\n \n     Returns\n     -------\n-    boolean array same length as comps\n+    ndarray[bool]\n+        Same length as `comps`.\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\n             \"only list-like objects are allowed to be passed\"\n             \" to isin(), you passed a [{comps_type}]\".format(\n                 comps_type\u003dtype(comps).__name__\n             )\n         )\n     if not is_list_like(values):\n         raise TypeError(\n             \"only list-like objects are allowed to be passed\"\n             \" to isin(), you passed a [{values_type}]\".format(\n                 values_type\u003dtype(values).__name__\n             )\n         )\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n     comps \u003d com.values_from_object(comps)\n \n-    comps, dtype, _ \u003d _ensure_data(comps)\n-    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n+    comps, dtype \u003d _ensure_data(comps)\n+    values, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n-    f \u003d lambda x, y: htable.ismember_object(x, values)\n+    f \u003d htable.ismember_object\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n-        f \u003d lambda x, y: np.in1d(x, y)\n+        f \u003d np.in1d\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\"int64\", copy\u003dFalse)\n             comps \u003d comps.astype(\"int64\", copy\u003dFalse)\n-            f \u003d lambda x, y: htable.ismember_int64(x, y)\n+            f \u003d htable.ismember_int64\n         except (TypeError, ValueError, OverflowError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\"float64\", copy\u003dFalse)\n             comps \u003d comps.astype(\"float64\", copy\u003dFalse)\n-            f \u003d lambda x, y: htable.ismember_float64(x, y)\n+            f \u003d htable.ismember_float64\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
          "extendedDetails": {}
        }
      ]
    },
    "bb6135880e5e453d7701764b9f2e4ad3356a68d7": {
      "type": "Ybodychange",
      "commitMessage": "STYLE: Apply black formatting\n",
      "commitDate": "2019/7/4 上午11:28",
      "commitName": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
      "commitAuthor": "Joris Van den Bossche",
      "commitDateOld": "2019/7/1 下午11:57",
      "commitNameOld": "46adc5b1c2aacb312d72729af72bc0ad600917c0",
      "commitAuthorOld": "Joris Van den Bossche",
      "daysBetweenCommits": 2.48,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{comps_type}]\".format(\n                comps_type\u003dtype(comps).__name__\n            )\n        )\n    if not is_list_like(values):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{values_type}]\".format(\n                values_type\u003dtype(values).__name__\n            )\n        )\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\"int64\", copy\u003dFalse)\n            comps \u003d comps.astype(\"int64\", copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\"float64\", copy\u003dFalse)\n            comps \u003d comps.astype(\"float64\", copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_float64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 412,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,63 +1,69 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps : array-like\n     values : array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n-        raise TypeError(\"only list-like objects are allowed to be passed\"\n-                        \" to isin(), you passed a [{comps_type}]\"\n-                        .format(comps_type\u003dtype(comps).__name__))\n+        raise TypeError(\n+            \"only list-like objects are allowed to be passed\"\n+            \" to isin(), you passed a [{comps_type}]\".format(\n+                comps_type\u003dtype(comps).__name__\n+            )\n+        )\n     if not is_list_like(values):\n-        raise TypeError(\"only list-like objects are allowed to be passed\"\n-                        \" to isin(), you passed a [{values_type}]\"\n-                        .format(values_type\u003dtype(values).__name__))\n+        raise TypeError(\n+            \"only list-like objects are allowed to be passed\"\n+            \" to isin(), you passed a [{values_type}]\".format(\n+                values_type\u003dtype(values).__name__\n+            )\n+        )\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n     comps \u003d com.values_from_object(comps)\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n-            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n-            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n+            values \u003d values.astype(\"int64\", copy\u003dFalse)\n+            comps \u003d comps.astype(\"int64\", copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError, OverflowError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n-            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n-            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n+            values \u003d values.astype(\"float64\", copy\u003dFalse)\n+            comps \u003d comps.astype(\"float64\", copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_float64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "1a42c70e532ae01c95596d071ab62dc535e2bac9": {
      "type": "Ybodychange",
      "commitMessage": "Add missing spacing before or after a param name in docstrings (#23738)\n\n",
      "commitDate": "2018/11/18 上午7:08",
      "commitName": "1a42c70e532ae01c95596d071ab62dc535e2bac9",
      "commitAuthor": "Srinivas Reddy Thatiparthy (శ్రీనివాస్  రెడ్డి తాటిపర్తి)",
      "commitDateOld": "2018/11/18 上午6:58",
      "commitNameOld": "2c25bd1b3ad0e21a4fd43141e65c4de7ad6f30b4",
      "commitAuthorOld": "Tarbo Fukazawa",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_float64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 384,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,63 +1,63 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n-    comps: array-like\n-    values: array-like\n+    comps : array-like\n+    values : array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{comps_type}]\"\n                         .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{values_type}]\"\n                         .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n     comps \u003d com.values_from_object(comps)\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError, OverflowError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_float64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "2c2b6585c1c45889d32491b4a0403617a2d48e17": {
      "type": "Ybodychange",
      "commitMessage": "CLN: Remove special handling of nans in the float64-case of isin (#22117)\n\n",
      "commitDate": "2018/8/10 下午6:18",
      "commitName": "2c2b6585c1c45889d32491b4a0403617a2d48e17",
      "commitAuthor": "realead",
      "commitDateOld": "2018/8/9 下午6:38",
      "commitNameOld": "020e9485baf9889c508154fe95663b5ab2210bc4",
      "commitAuthorOld": "Michael Odintsov",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_float64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 384,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,64 +1,63 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{comps_type}]\"\n                         .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{values_type}]\"\n                         .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n     comps \u003d com.values_from_object(comps)\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError, OverflowError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n-            checknull \u003d isna(values).any()\n-            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n+            f \u003d lambda x, y: htable.ismember_float64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "020e9485baf9889c508154fe95663b5ab2210bc4": {
      "type": "Ybodychange",
      "commitMessage": "BUG: Fix using \"inf\"/\"-inf\" in na_values for csv with int index column (#22169)\n\n",
      "commitDate": "2018/8/9 下午6:38",
      "commitName": "020e9485baf9889c508154fe95663b5ab2210bc4",
      "commitAuthor": "Michael Odintsov",
      "commitDateOld": "2018/7/25 上午6:10",
      "commitNameOld": "2d0c96119391c85bd4f7ffbb847759ee3777162a",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 15.52,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 384,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,64 +1,64 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{comps_type}]\"\n                         .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{values_type}]\"\n                         .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n     comps \u003d com.values_from_object(comps)\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n-        except (TypeError, ValueError):\n+        except (TypeError, ValueError, OverflowError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "2d0c96119391c85bd4f7ffbb847759ee3777162a": {
      "type": "Ybodychange",
      "commitMessage": "CLN: De-privatize core.common funcs, remove unused (#22001)\n\n",
      "commitDate": "2018/7/25 上午6:10",
      "commitName": "2d0c96119391c85bd4f7ffbb847759ee3777162a",
      "commitAuthor": "jbrockmendel",
      "commitDateOld": "2018/7/17 下午8:21",
      "commitNameOld": "537b65cb0fd2aa318e089c5e38f09e81d1a3fe35",
      "commitAuthorOld": "jbrockmendel",
      "daysBetweenCommits": 7.41,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com.values_from_object(comps)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 384,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,64 +1,64 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{comps_type}]\"\n                         .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{values_type}]\"\n                         .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     if is_categorical_dtype(comps):\n         # TODO(extension)\n         # handle categoricals\n         return comps._values.isin(values)\n \n-    comps \u003d com._values_from_object(comps)\n+    comps \u003d com.values_from_object(comps)\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "60fe82c8a2829e831d28cf6d4b3595637c3c5802": {
      "type": "Ybodychange",
      "commitMessage": "PERF: GH2003 Series.isin for categorical dtypes (#20522)\n\n",
      "commitDate": "2018/4/25 下午8:38",
      "commitName": "60fe82c8a2829e831d28cf6d4b3595637c3c5802",
      "commitAuthor": "Artem Bogachev",
      "commitDateOld": "2018/3/27 下午11:40",
      "commitNameOld": "766a4800b4d9b7e847577b74b24128fcda8eeb55",
      "commitAuthorOld": "Tom Augspurger",
      "daysBetweenCommits": 28.87,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps \u003d com._values_from_object(comps)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 384,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,57 +1,64 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{comps_type}]\"\n                         .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{values_type}]\"\n                         .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d construct_1d_object_array_from_listlike(list(values))\n \n+    if is_categorical_dtype(comps):\n+        # TODO(extension)\n+        # handle categoricals\n+        return comps._values.isin(values)\n+\n+    comps \u003d com._values_from_object(comps)\n+\n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "04db779d4c93d286bb0ab87780a85d50ec490266": {
      "type": "Ybodychange",
      "commitMessage": "Construct 1d array from listlike (#18769)\n\n",
      "commitDate": "2017/12/19 下午10:41",
      "commitName": "04db779d4c93d286bb0ab87780a85d50ec490266",
      "commitAuthor": "Pietro Battiston",
      "commitDateOld": "2017/12/4 下午6:49",
      "commitNameOld": "aa5b6e6b53637ca861d7b6cbae2878e7c4687199",
      "commitAuthorOld": "topper-123",
      "daysBetweenCommits": 15.16,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d construct_1d_object_array_from_listlike(list(values))\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 381,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,57 +1,57 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{comps_type}]\"\n                         .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a [{values_type}]\"\n                         .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n-        values \u003d lib.list_to_object_array(list(values))\n+        values \u003d construct_1d_object_array_from_listlike(list(values))\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "dfaf8c6918ff20ef781d3177f464a29e70ee5d65": {
      "type": "Ybodychange",
      "commitMessage": "CLN: replace %s syntax with .format in core.tools, algorithms.py, base.py (#17305)\n\n",
      "commitDate": "2017/8/22 下午9:57",
      "commitName": "dfaf8c6918ff20ef781d3177f464a29e70ee5d65",
      "commitAuthor": "jschendel",
      "commitDateOld": "2017/8/22 下午5:50",
      "commitNameOld": "870b6a6d6415c76d051b287adcb180ac3020b6e8",
      "commitAuthorOld": "Jeff Reback",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type\u003dtype(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type\u003dtype(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d lib.list_to_object_array(list(values))\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 380,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,57 +1,57 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n-                        \" to isin(), you passed a \"\n-                        \"[{0}]\".format(type(comps).__name__))\n+                        \" to isin(), you passed a [{comps_type}]\"\n+                        .format(comps_type\u003dtype(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n-                        \" to isin(), you passed a \"\n-                        \"[{0}]\".format(type(values).__name__))\n+                        \" to isin(), you passed a [{values_type}]\"\n+                        .format(values_type\u003dtype(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d lib.list_to_object_array(list(values))\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n \n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "870b6a6d6415c76d051b287adcb180ac3020b6e8": {
      "type": "Ybodychange",
      "commitMessage": "DEPS: set min versions (#17002)\n\ncloses #15206, numpy \u003e\u003d 1.9\r\ncloses #15543, matplotlib \u003e\u003d 1.4.3\r\nscipy \u003e\u003d 0.14.0",
      "commitDate": "2017/8/22 下午5:50",
      "commitName": "870b6a6d6415c76d051b287adcb180ac3020b6e8",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2017/7/30 下午5:43",
      "commitNameOld": "6b8e43688f3363ab19c8a3049e0ade70c13bd4b2",
      "commitAuthorOld": "Matthew Roeschke",
      "daysBetweenCommits": 23.01,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d lib.list_to_object_array(list(values))\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 380,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,59 +1,57 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d lib.list_to_object_array(list(values))\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n-    # GH11232\n-    # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n+\n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n-    if ((_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000 and\n-       not is_object_dtype(comps)):\n+    if len(comps) \u003e 1000000 and not is_object_dtype(comps):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "793020293ee1e5fa023f45c12943a4ac51cc23d0": {
      "type": "Ybodychange",
      "commitMessage": "COMPAT: rename isnull -\u003e isna, notnull -\u003e notna (#16972)\n\ncloses #15001\r\n",
      "commitDate": "2017/7/25 下午6:18",
      "commitName": "793020293ee1e5fa023f45c12943a4ac51cc23d0",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2017/7/21 下午7:05",
      "commitNameOld": "4efe6560e07f28de6a1834fa90e31cef31b0fb18",
      "commitAuthorOld": "Jeff Reback",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d lib.list_to_object_array(list(values))\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if ((_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000 and\n       not is_object_dtype(comps)):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isna(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 379,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,59 +1,59 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d lib.list_to_object_array(list(values))\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n     # GH16012\n     # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n     if ((_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000 and\n        not is_object_dtype(comps)):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n-            checknull \u003d isnull(values).any()\n+            checknull \u003d isna(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "a1dfb037de79e6982a0e7ccf883e5af11e9cc843": {
      "type": "Ybodychange",
      "commitMessage": "BUG: Large object array isin\n\ncloses #16012\n\nAuthor: Morgan Stuart \u003cmorgansstuart243@gmail.com\u003e\n\nCloses #16969 from Morgan243/large_array_isin and squashes the following commits:\n\n31cb4b3 [Morgan Stuart] Removed unneeded details from whatsnew description\n4b59745 [Morgan Stuart] Linting errors; additional test clarification\n186607b [Morgan Stuart] BUG #16012 - fix isin for large object arrays\n",
      "commitDate": "2017/7/19 上午7:33",
      "commitName": "a1dfb037de79e6982a0e7ccf883e5af11e9cc843",
      "commitAuthor": "Morgan Stuart",
      "commitDateOld": "2017/7/11 下午6:40",
      "commitNameOld": "d236f31c7cfc740549b363926580ec0c94559b25",
      "commitAuthorOld": "aviolov",
      "daysBetweenCommits": 7.54,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d lib.list_to_object_array(list(values))\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n    # GH16012\n    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n    if ((_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000 and\n       not is_object_dtype(comps)):\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isnull(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 372,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,56 +1,59 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d lib.list_to_object_array(list(values))\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n-    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n+    # GH16012\n+    # Ensure np.in1d doesn\u0027t get object types or it *may* throw an exception\n+    if ((_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000 and\n+       not is_object_dtype(comps)):\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isnull(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "e053ee301d82a44ddc86dc7e164fea2d5c5178f8": {
      "type": "Ybodychange",
      "commitMessage": "BUG: fix isin with Series of tuples values (#16394) (#16434)\n\n* Swiched out \"values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\" for \"values \u003d lib.list_to_object_array(list(values))\" in the isin() method found in core/algorithms.py\r\nAdded test for comparing to a list of tuples\r\n",
      "commitDate": "2017/5/23 下午3:51",
      "commitName": "e053ee301d82a44ddc86dc7e164fea2d5c5178f8",
      "commitAuthor": "jaredsnyder",
      "commitDateOld": "2017/4/25 下午7:16",
      "commitNameOld": "8d122e633a6b08e3f9dfad80050da42d789210d4",
      "commitAuthorOld": "Jeff Reback",
      "daysBetweenCommits": 27.86,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d lib.list_to_object_array(list(values))\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isnull(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 367,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,56 +1,56 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n-        values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n+        values \u003d lib.list_to_object_array(list(values))\n \n     comps, dtype, _ \u003d _ensure_data(comps)\n     values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isnull(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "0cfc08cf4584e8442c84c30d53f1dceafeac5abf": {
      "type": "Ybodychange",
      "commitMessage": "CLN: algos (#15929)\n\n* CLN: clean up select_n algos\r\n\r\n* CLN: clean ensure_data\r\n\r\ncloses #15903\r\n\r\n* return ndtype, so can eliminate special cases\r\n\r\n* unique\r\n\r\n* fixups\r\n",
      "commitDate": "2017/4/7 上午8:16",
      "commitName": "0cfc08cf4584e8442c84c30d53f1dceafeac5abf",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2017/4/6 下午9:40",
      "commitNameOld": "c1122523ede85340b042b83b629731db8176378f",
      "commitAuthorOld": "Roger Thomas",
      "daysBetweenCommits": 0.44,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n\n    comps, dtype, _ \u003d _ensure_data(comps)\n    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isnull(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 284,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,83 +1,56 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n-    from pandas import DatetimeIndex, TimedeltaIndex, PeriodIndex\n-\n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n \n-    if needs_i8_conversion(comps):\n-        if is_period_dtype(values):\n-            comps \u003d PeriodIndex(comps)\n-            values \u003d PeriodIndex(values)\n-        elif is_timedelta64_dtype(comps):\n-            comps \u003d TimedeltaIndex(comps)\n-            values \u003d TimedeltaIndex(values)\n-        else:\n-            comps \u003d DatetimeIndex(comps)\n-            values \u003d DatetimeIndex(values)\n-\n-        values \u003d values.asi8\n-        comps \u003d comps.asi8\n-    elif is_bool_dtype(comps):\n-\n-        try:\n-            comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n-            values \u003d np.asarray(values).view(\u0027uint8\u0027)\n-        except TypeError:\n-            # object array conversion will fail\n-            pass\n-    elif is_numeric_dtype(comps):\n-        comps \u003d np.asarray(comps)\n-        values \u003d np.asarray(values)\n-    else:\n-        comps \u003d np.asarray(comps).astype(object)\n-        values \u003d np.asarray(values).astype(object)\n+    comps, dtype, _ \u003d _ensure_data(comps)\n+    values, _, _ \u003d _ensure_data(values, dtype\u003ddtype)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isnull(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "179363765110611ad10883bab55d79785369da9b": {
      "type": "Ybodychange",
      "commitMessage": "TST: suppress some numpy warnings (#15811)\n\n* BUG: incorrect conversion on isin algos with m8\r\n\r\n* TST: suppress some warnings\r\n",
      "commitDate": "2017/3/27 上午2:26",
      "commitName": "179363765110611ad10883bab55d79785369da9b",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2017/3/22 下午7:55",
      "commitNameOld": "2a3b05a3a7167c7b384375e9442c350f740e9629",
      "commitAuthorOld": "Dominik Stanczak",
      "daysBetweenCommits": 4.27,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    from pandas import DatetimeIndex, TimedeltaIndex, PeriodIndex\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n\n    if needs_i8_conversion(comps):\n        if is_period_dtype(values):\n            comps \u003d PeriodIndex(comps)\n            values \u003d PeriodIndex(values)\n        elif is_timedelta64_dtype(comps):\n            comps \u003d TimedeltaIndex(comps)\n            values \u003d TimedeltaIndex(values)\n        else:\n            comps \u003d DatetimeIndex(comps)\n            values \u003d DatetimeIndex(values)\n\n        values \u003d values.asi8\n        comps \u003d comps.asi8\n    elif is_bool_dtype(comps):\n\n        try:\n            comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n            values \u003d np.asarray(values).view(\u0027uint8\u0027)\n        except TypeError:\n            # object array conversion will fail\n            pass\n    elif is_numeric_dtype(comps):\n        comps \u003d np.asarray(comps)\n        values \u003d np.asarray(values)\n    else:\n        comps \u003d np.asarray(comps).astype(object)\n        values \u003d np.asarray(values).astype(object)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isnull(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 154,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,80 +1,83 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n-    from pandas import DatetimeIndex, PeriodIndex\n+    from pandas import DatetimeIndex, TimedeltaIndex, PeriodIndex\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n \n     if needs_i8_conversion(comps):\n         if is_period_dtype(values):\n             comps \u003d PeriodIndex(comps)\n             values \u003d PeriodIndex(values)\n+        elif is_timedelta64_dtype(comps):\n+            comps \u003d TimedeltaIndex(comps)\n+            values \u003d TimedeltaIndex(values)\n         else:\n             comps \u003d DatetimeIndex(comps)\n             values \u003d DatetimeIndex(values)\n \n         values \u003d values.asi8\n         comps \u003d comps.asi8\n     elif is_bool_dtype(comps):\n \n         try:\n             comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n             values \u003d np.asarray(values).view(\u0027uint8\u0027)\n         except TypeError:\n             # object array conversion will fail\n             pass\n     elif is_numeric_dtype(comps):\n         comps \u003d np.asarray(comps)\n         values \u003d np.asarray(values)\n     else:\n         comps \u003d np.asarray(comps).astype(object)\n         values \u003d np.asarray(values).astype(object)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     f \u003d lambda x, y: htable.ismember_object(x, values)\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n         f \u003d lambda x, y: np.in1d(x, y)\n     elif is_integer_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n             f \u003d lambda x, y: htable.ismember_int64(x, y)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     elif is_float_dtype(comps):\n         try:\n             values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n             comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n             checknull \u003d isnull(values).any()\n             f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n         except (TypeError, ValueError):\n             values \u003d values.astype(object)\n             comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "32dd92912f15a5c66035f5674c116d23f21bdbca": {
      "type": "Ybodychange",
      "commitMessage": "CLN: relocate lib.ismember* to hashtable space\n\n- fixes .isin on 32-bit (hopefully)\n- perf about 30% better\n- releases GIL\n\nAuthor: Jeff Reback \u003cjeff@reback.net\u003e\n\nCloses #15773 from jreback/ismember and squashes the following commits:\n\na7dfe51 [Jeff Reback] CLN: relocate lib.ismember* to hashtable space\n",
      "commitDate": "2017/3/22 上午7:19",
      "commitName": "32dd92912f15a5c66035f5674c116d23f21bdbca",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2017/3/22 上午1:40",
      "commitNameOld": "aa9d0cf7fa0061058125d79d22d86f82f69c9185",
      "commitAuthorOld": "Jeff Reback",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    from pandas import DatetimeIndex, PeriodIndex\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n\n    if needs_i8_conversion(comps):\n        if is_period_dtype(values):\n            comps \u003d PeriodIndex(comps)\n            values \u003d PeriodIndex(values)\n        else:\n            comps \u003d DatetimeIndex(comps)\n            values \u003d DatetimeIndex(values)\n\n        values \u003d values.asi8\n        comps \u003d comps.asi8\n    elif is_bool_dtype(comps):\n\n        try:\n            comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n            values \u003d np.asarray(values).view(\u0027uint8\u0027)\n        except TypeError:\n            # object array conversion will fail\n            pass\n    elif is_numeric_dtype(comps):\n        comps \u003d np.asarray(comps)\n        values \u003d np.asarray(values)\n    else:\n        comps \u003d np.asarray(comps).astype(object)\n        values \u003d np.asarray(values).astype(object)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f \u003d lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n            f \u003d lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n            checknull \u003d isnull(values).any()\n            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values \u003d values.astype(object)\n            comps \u003d comps.astype(object)\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 154,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,62 +1,80 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n \n     from pandas import DatetimeIndex, PeriodIndex\n \n     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n         values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n \n     if needs_i8_conversion(comps):\n         if is_period_dtype(values):\n             comps \u003d PeriodIndex(comps)\n             values \u003d PeriodIndex(values)\n         else:\n             comps \u003d DatetimeIndex(comps)\n             values \u003d DatetimeIndex(values)\n \n         values \u003d values.asi8\n         comps \u003d comps.asi8\n     elif is_bool_dtype(comps):\n \n         try:\n             comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n             values \u003d np.asarray(values).view(\u0027uint8\u0027)\n         except TypeError:\n             # object array conversion will fail\n             pass\n-    else:\n+    elif is_numeric_dtype(comps):\n         comps \u003d np.asarray(comps)\n         values \u003d np.asarray(values)\n+    else:\n+        comps \u003d np.asarray(comps).astype(object)\n+        values \u003d np.asarray(values).astype(object)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n+    f \u003d lambda x, y: htable.ismember_object(x, values)\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n-        f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n-    elif is_int64_dtype(comps):\n-        f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n-    else:\n-        f \u003d lambda x, y: lib.ismember(x, set(values))\n+        f \u003d lambda x, y: np.in1d(x, y)\n+    elif is_integer_dtype(comps):\n+        try:\n+            values \u003d values.astype(\u0027int64\u0027, copy\u003dFalse)\n+            comps \u003d comps.astype(\u0027int64\u0027, copy\u003dFalse)\n+            f \u003d lambda x, y: htable.ismember_int64(x, y)\n+        except (TypeError, ValueError):\n+            values \u003d values.astype(object)\n+            comps \u003d comps.astype(object)\n+\n+    elif is_float_dtype(comps):\n+        try:\n+            values \u003d values.astype(\u0027float64\u0027, copy\u003dFalse)\n+            comps \u003d comps.astype(\u0027float64\u0027, copy\u003dFalse)\n+            checknull \u003d isnull(values).any()\n+            f \u003d lambda x, y: htable.ismember_float64(x, y, checknull)\n+        except (TypeError, ValueError):\n+            values \u003d values.astype(object)\n+            comps \u003d comps.astype(object)\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "aa9d0cf7fa0061058125d79d22d86f82f69c9185": {
      "type": "Ybodychange",
      "commitMessage": "BUG: various 32bit compat issues\n\ncloses #14866    xref #14183\n\nAuthor: Jeff Reback \u003cjeff@reback.net\u003e\n\nCloses #15766 from jreback/32bit and squashes the following commits:\n\n93c03e3 [Jeff Reback] BUG: 32bit compat for .get_indexer\n4163918 [Jeff Reback] BUG: fix isin for 32bit platform issues\n1bb2f60 [Jeff Reback] BUG: cut/qcut should always return int64 bins\n",
      "commitDate": "2017/3/22 上午1:40",
      "commitName": "aa9d0cf7fa0061058125d79d22d86f82f69c9185",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2017/3/21 上午6:47",
      "commitNameOld": "f2e942e185da9369f2c1f4d3b38f57af7b4243bd",
      "commitAuthorOld": "Matt Roeschke",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    from pandas import DatetimeIndex, PeriodIndex\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n\n    if needs_i8_conversion(comps):\n        if is_period_dtype(values):\n            comps \u003d PeriodIndex(comps)\n            values \u003d PeriodIndex(values)\n        else:\n            comps \u003d DatetimeIndex(comps)\n            values \u003d DatetimeIndex(values)\n\n        values \u003d values.asi8\n        comps \u003d comps.asi8\n    elif is_bool_dtype(comps):\n\n        try:\n            comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n            values \u003d np.asarray(values).view(\u0027uint8\u0027)\n        except TypeError:\n            # object array conversion will fail\n            pass\n    else:\n        comps \u003d np.asarray(comps)\n        values \u003d np.asarray(values)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n    elif is_int64_dtype(comps):\n        f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n    else:\n        f \u003d lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 154,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,50 +1,62 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n-    comps \u003d np.asarray(comps)\n     if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n-    if not isinstance(values, np.ndarray):\n-        values \u003d list(values)\n+\n+    from pandas import DatetimeIndex, PeriodIndex\n+\n+    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n+        values \u003d np.array(list(values), dtype\u003d\u0027object\u0027)\n+\n+    if needs_i8_conversion(comps):\n+        if is_period_dtype(values):\n+            comps \u003d PeriodIndex(comps)\n+            values \u003d PeriodIndex(values)\n+        else:\n+            comps \u003d DatetimeIndex(comps)\n+            values \u003d DatetimeIndex(values)\n+\n+        values \u003d values.asi8\n+        comps \u003d comps.asi8\n+    elif is_bool_dtype(comps):\n+\n+        try:\n+            comps \u003d np.asarray(comps).view(\u0027uint8\u0027)\n+            values \u003d np.asarray(values).view(\u0027uint8\u0027)\n+        except TypeError:\n+            # object array conversion will fail\n+            pass\n+    else:\n+        comps \u003d np.asarray(comps)\n+        values \u003d np.asarray(values)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n         f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n-    else:\n-        f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n-\n-    # may need i8 conversion for proper membership testing\n-    if is_datetime64_dtype(comps):\n-        from pandas.tseries.tools import to_datetime\n-        values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n-        comps \u003d comps.view(\u0027i8\u0027)\n-    elif is_timedelta64_dtype(comps):\n-        from pandas.tseries.timedeltas import to_timedelta\n-        values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n-        comps \u003d comps.view(\u0027i8\u0027)\n     elif is_int64_dtype(comps):\n-        pass\n+        f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n     else:\n         f \u003d lambda x, y: lib.ismember(x, set(values))\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "7dd4091458d9117e57d2ad9ce3126855bd00108c": {
      "type": "Ybodychange",
      "commitMessage": "CLN: reorg type inference \u0026 introspection\n\ncloses #12503\n\nAuthor: Jeff Reback \u003cjeff@reback.net\u003e\n\nCloses #13147 from jreback/types and squashes the following commits:\n\n244649a [Jeff Reback] CLN: reorg type inference \u0026 introspection\n",
      "commitDate": "2016/7/13 下午7:52",
      "commitName": "7dd4091458d9117e57d2ad9ce3126855bd00108c",
      "commitAuthor": "Jeff Reback",
      "commitDateOld": "2016/5/1 下午11:27",
      "commitNameOld": "05e734ab171be0fda838c6b12839c38fa588da2c",
      "commitAuthorOld": "Maoyuan Liu",
      "daysBetweenCommits": 72.85,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    comps \u003d np.asarray(comps)\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n    if not isinstance(values, np.ndarray):\n        values \u003d list(values)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n    else:\n        f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n\n    # may need i8 conversion for proper membership testing\n    if is_datetime64_dtype(comps):\n        from pandas.tseries.tools import to_datetime\n        values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n        comps \u003d comps.view(\u0027i8\u0027)\n    elif is_timedelta64_dtype(comps):\n        from pandas.tseries.timedeltas import to_timedelta\n        values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n        comps \u003d comps.view(\u0027i8\u0027)\n    elif is_int64_dtype(comps):\n        pass\n    else:\n        f \u003d lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 115,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,50 +1,50 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n-    if not com.is_list_like(comps):\n+    if not is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     comps \u003d np.asarray(comps)\n-    if not com.is_list_like(values):\n+    if not is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n     if not isinstance(values, np.ndarray):\n         values \u003d list(values)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n         f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n     else:\n         f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n \n     # may need i8 conversion for proper membership testing\n-    if com.is_datetime64_dtype(comps):\n+    if is_datetime64_dtype(comps):\n         from pandas.tseries.tools import to_datetime\n         values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n         comps \u003d comps.view(\u0027i8\u0027)\n-    elif com.is_timedelta64_dtype(comps):\n+    elif is_timedelta64_dtype(comps):\n         from pandas.tseries.timedeltas import to_timedelta\n         values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n         comps \u003d comps.view(\u0027i8\u0027)\n-    elif com.is_int64_dtype(comps):\n+    elif is_int64_dtype(comps):\n         pass\n     else:\n         f \u003d lambda x, y: lib.ismember(x, set(values))\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "05e734ab171be0fda838c6b12839c38fa588da2c": {
      "type": "Ybodychange",
      "commitMessage": "BUG: .isin(...) now coerces sets to lists\n\ncloses #12988\ncloses #13014\n",
      "commitDate": "2016/5/1 下午11:27",
      "commitName": "05e734ab171be0fda838c6b12839c38fa588da2c",
      "commitAuthor": "Maoyuan Liu",
      "commitDateOld": "2016/4/30 上午1:15",
      "commitNameOld": "8439d28f07fece62bc873f306cdd248ad22e665b",
      "commitAuthorOld": "sinhrks",
      "daysBetweenCommits": 1.93,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not com.is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    comps \u003d np.asarray(comps)\n    if not com.is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n    if not isinstance(values, np.ndarray):\n        values \u003d list(values)\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n    else:\n        f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n\n    # may need i8 conversion for proper membership testing\n    if com.is_datetime64_dtype(comps):\n        from pandas.tseries.tools import to_datetime\n        values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n        comps \u003d comps.view(\u0027i8\u0027)\n    elif com.is_timedelta64_dtype(comps):\n        from pandas.tseries.timedeltas import to_timedelta\n        values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n        comps \u003d comps.view(\u0027i8\u0027)\n    elif com.is_int64_dtype(comps):\n        pass\n    else:\n        f \u003d lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 94,
      "functionName": "isin",
      "functionAnnotation": "",
      "diff": "@@ -1,48 +1,50 @@\n def isin(comps, values):\n     \"\"\"\n     Compute the isin boolean array\n \n     Parameters\n     ----------\n     comps: array-like\n     values: array-like\n \n     Returns\n     -------\n     boolean array same length as comps\n     \"\"\"\n \n     if not com.is_list_like(comps):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(comps).__name__))\n     comps \u003d np.asarray(comps)\n     if not com.is_list_like(values):\n         raise TypeError(\"only list-like objects are allowed to be passed\"\n                         \" to isin(), you passed a \"\n                         \"[{0}]\".format(type(values).__name__))\n+    if not isinstance(values, np.ndarray):\n+        values \u003d list(values)\n \n     # GH11232\n     # work-around for numpy \u003c 1.8 and comparisions on py3\n     # faster for larger cases to use np.in1d\n     if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n         f \u003d lambda x, y: np.in1d(x, np.asarray(list(y)))\n     else:\n         f \u003d lambda x, y: lib.ismember_int64(x, set(y))\n \n     # may need i8 conversion for proper membership testing\n     if com.is_datetime64_dtype(comps):\n         from pandas.tseries.tools import to_datetime\n         values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n         comps \u003d comps.view(\u0027i8\u0027)\n     elif com.is_timedelta64_dtype(comps):\n         from pandas.tseries.timedeltas import to_timedelta\n         values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n         comps \u003d comps.view(\u0027i8\u0027)\n     elif com.is_int64_dtype(comps):\n         pass\n     else:\n         f \u003d lambda x, y: lib.ismember(x, set(values))\n \n     return f(comps, values)\n \n",
      "extendedDetails": {}
    },
    "77257662de12ea14e753c4d9ad8c2796f4825254": {
      "type": "Yintroduced",
      "commitMessage": "COMPAT/PERF: lib.ismember_int64 on older numpies/cython not comparing correctly\nPERF: use np.in1d on larger isin sizes\n",
      "commitDate": "2015/10/6 下午9:54",
      "commitName": "77257662de12ea14e753c4d9ad8c2796f4825254",
      "commitAuthor": "Jeff Reback",
      "diff": "@@ -0,0 +1,47 @@\n+def isin(comps, values):\n+    \"\"\"\n+    Compute the isin boolean array\n+\n+    Parameters\n+    ----------\n+    comps: array-like\n+    values: array-like\n+\n+    Returns\n+    -------\n+    boolean array same length as comps\n+    \"\"\"\n+\n+    if not com.is_list_like(comps):\n+        raise TypeError(\"only list-like objects are allowed to be passed\"\n+                        \" to isin(), you passed a \"\n+                        \"[{0}]\".format(type(comps).__name__))\n+    comps \u003d np.asarray(comps)\n+    if not com.is_list_like(values):\n+        raise TypeError(\"only list-like objects are allowed to be passed\"\n+                        \" to isin(), you passed a \"\n+                        \"[{0}]\".format(type(values).__name__))\n+\n+    # GH11232\n+    # work-around for numpy \u003c 1.8 and comparisions on py3\n+    # faster for larger cases to use np.in1d\n+    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n+        f \u003d lambda x, y: np.in1d(x,np.asarray(list(y)))\n+    else:\n+        f \u003d lambda x, y: lib.ismember_int64(x,set(y))\n+\n+    # may need i8 conversion for proper membership testing\n+    if com.is_datetime64_dtype(comps):\n+        from pandas.tseries.tools import to_datetime\n+        values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n+        comps \u003d comps.view(\u0027i8\u0027)\n+    elif com.is_timedelta64_dtype(comps):\n+        from pandas.tseries.timedeltas import to_timedelta\n+        values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n+        comps \u003d comps.view(\u0027i8\u0027)\n+    elif com.is_int64_dtype(comps):\n+        pass\n+    else:\n+        f \u003d lambda x, y: lib.ismember(x, set(values))\n+\n+    return f(comps, values)\n",
      "actualSource": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not com.is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    comps \u003d np.asarray(comps)\n    if not com.is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    # GH11232\n    # work-around for numpy \u003c 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) \u003e 1000000:\n        f \u003d lambda x, y: np.in1d(x,np.asarray(list(y)))\n    else:\n        f \u003d lambda x, y: lib.ismember_int64(x,set(y))\n\n    # may need i8 conversion for proper membership testing\n    if com.is_datetime64_dtype(comps):\n        from pandas.tseries.tools import to_datetime\n        values \u003d to_datetime(values)._values.view(\u0027i8\u0027)\n        comps \u003d comps.view(\u0027i8\u0027)\n    elif com.is_timedelta64_dtype(comps):\n        from pandas.tseries.timedeltas import to_timedelta\n        values \u003d to_timedelta(values)._values.view(\u0027i8\u0027)\n        comps \u003d comps.view(\u0027i8\u0027)\n    elif com.is_int64_dtype(comps):\n        pass\n    else:\n        f \u003d lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n",
      "path": "pandas/core/algorithms.py",
      "functionStartLine": 70,
      "functionName": "isin",
      "functionAnnotation": ""
    }
  }
}