{
  "origin": "codeshovel",
  "repositoryName": "django",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/django/.git",
  "startCommitName": "39791c8e6de3a71879eb26dd9f8d01273847f395",
  "sourceFileName": "forms.py",
  "functionName": "changed_data",
  "functionId": "BaseForm__changed_data___self",
  "sourceFilePath": "django/forms/forms.py",
  "functionAnnotation": "@cached_property",
  "functionStartLine": 429,
  "functionEndLine": 451,
  "numCommitsSeen": 281,
  "timeTaken": 9935,
  "changeHistory": [
    "f5c6d3c8d9fa2158734858fa0a7ac917c384cb97",
    "c6c00fbfbb659de4beaad3c612c271ac74f892a7",
    "deed00c0d803d324a3dfdeba52458b6b009c1a90",
    "d74e33eb0ec289d3125a5a8048d756f9d232bd62",
    "210d0489c5daad56b806f8165f9fe09fb3c2a019",
    "acd7b34aafe352ef604edcb73f75041c5cbba6b9",
    "d0788c277035727b7b070abd0f02d075acffc84f",
    "cbfb8ed53b31ec9701f5fb8e519a8644fd4c8095",
    "892bc91cb0036d6868081363628f65094c4790d6",
    "58062a6302a2bf1013d100deb053ccae2298bb84",
    "ebb504db692cac496f4f45762d1d14644c9fa6fa",
    "7c7ad041b358a9819b3bd9f93d4834df4a5b5d57",
    "46786b4193e04d398532bbfc3dcf63c03c1793cb",
    "a19ed8aea395e8e07164ff7d85bd7dff2f24edca"
  ],
  "changeHistoryShort": {
    "f5c6d3c8d9fa2158734858fa0a7ac917c384cb97": "Ybodychange",
    "c6c00fbfbb659de4beaad3c612c271ac74f892a7": "Ymultichange(Ybodychange,Yannotationchange)",
    "deed00c0d803d324a3dfdeba52458b6b009c1a90": "Ybodychange",
    "d74e33eb0ec289d3125a5a8048d756f9d232bd62": "Ybodychange",
    "210d0489c5daad56b806f8165f9fe09fb3c2a019": "Ybodychange",
    "acd7b34aafe352ef604edcb73f75041c5cbba6b9": "Ybodychange",
    "d0788c277035727b7b070abd0f02d075acffc84f": "Ybodychange",
    "cbfb8ed53b31ec9701f5fb8e519a8644fd4c8095": "Ybodychange",
    "892bc91cb0036d6868081363628f65094c4790d6": "Ybodychange",
    "58062a6302a2bf1013d100deb053ccae2298bb84": "Ymultichange(Yrename,Yannotationchange)",
    "ebb504db692cac496f4f45762d1d14644c9fa6fa": "Ybodychange",
    "7c7ad041b358a9819b3bd9f93d4834df4a5b5d57": "Ybodychange",
    "46786b4193e04d398532bbfc3dcf63c03c1793cb": "Yfilerename",
    "a19ed8aea395e8e07164ff7d85bd7dff2f24edca": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f5c6d3c8d9fa2158734858fa0a7ac917c384cb97": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #27068 -- Unified form field initial data retrieval.\n\n",
      "commitDate": "2016/8/19 上午8:55",
      "commitName": "f5c6d3c8d9fa2158734858fa0a7ac917c384cb97",
      "commitAuthor": "Jon Dufresne",
      "commitDateOld": "2016/7/27 下午8:14",
      "commitNameOld": "a5f85d891b51d7ceb4f9e422e3e4f5c741062288",
      "commitAuthorOld": "Tim Graham",
      "daysBetweenCommits": 22.53,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "actualSource": "    @cached_property\n    def changed_data(self):\n        data \u003d []\n        for name, field in self.fields.items():\n            prefixed_name \u003d self.add_prefix(name)\n            data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                # Use the BoundField\u0027s initial as this is the value passed to\n                # the widget.\n                initial_value \u003d self[name].initial\n            else:\n                initial_prefixed_name \u003d self.add_initial_prefix(name)\n                hidden_widget \u003d field.hidden_widget()\n                try:\n                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    data.append(name)\n                    continue\n            if field.has_changed(initial_value, data_value):\n                data.append(name)\n        return data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 428,
      "functionName": "changed_data",
      "functionAnnotation": "@cached_property",
      "diff": "@@ -1,23 +1,23 @@\n     @cached_property\n     def changed_data(self):\n         data \u003d []\n         for name, field in self.fields.items():\n             prefixed_name \u003d self.add_prefix(name)\n             data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n             if not field.show_hidden_initial:\n-                initial_value \u003d self.initial.get(name, field.initial)\n-                if callable(initial_value):\n-                    initial_value \u003d initial_value()\n+                # Use the BoundField\u0027s initial as this is the value passed to\n+                # the widget.\n+                initial_value \u003d self[name].initial\n             else:\n                 initial_prefixed_name \u003d self.add_initial_prefix(name)\n                 hidden_widget \u003d field.hidden_widget()\n                 try:\n                     initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                         self.data, self.files, initial_prefixed_name))\n                 except ValidationError:\n                     # Always assume data has changed if validation fails.\n                     data.append(name)\n                     continue\n             if field.has_changed(initial_value, data_value):\n                 data.append(name)\n         return data\n",
      "extendedDetails": {}
    },
    "c6c00fbfbb659de4beaad3c612c271ac74f892a7": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Used @cached_property for BaseForm.changed_data.\n",
      "commitDate": "2015/8/4 下午7:12",
      "commitName": "c6c00fbfbb659de4beaad3c612c271ac74f892a7",
      "commitAuthor": "Curtis Maloney",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Used @cached_property for BaseForm.changed_data.\n",
          "commitDate": "2015/8/4 下午7:12",
          "commitName": "c6c00fbfbb659de4beaad3c612c271ac74f892a7",
          "commitAuthor": "Curtis Maloney",
          "commitDateOld": "2015/7/17 上午1:36",
          "commitNameOld": "1ef4aeab403f7fb74c0b9b11fde854fd03afc40c",
          "commitAuthorOld": "Claude Paroz",
          "daysBetweenCommits": 18.73,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "actualSource": "    @cached_property\n    def changed_data(self):\n        data \u003d []\n        for name, field in self.fields.items():\n            prefixed_name \u003d self.add_prefix(name)\n            data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                initial_value \u003d self.initial.get(name, field.initial)\n                if callable(initial_value):\n                    initial_value \u003d initial_value()\n            else:\n                initial_prefixed_name \u003d self.add_initial_prefix(name)\n                hidden_widget \u003d field.hidden_widget()\n                try:\n                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    data.append(name)\n                    continue\n            if field.has_changed(initial_value, data_value):\n                data.append(name)\n        return data\n",
          "path": "django/forms/forms.py",
          "functionStartLine": 438,
          "functionName": "changed_data",
          "functionAnnotation": "@cached_property",
          "diff": "@@ -1,24 +1,23 @@\n-    @property\n+    @cached_property\n     def changed_data(self):\n-        if self._changed_data is None:\n-            self._changed_data \u003d []\n-            for name, field in self.fields.items():\n-                prefixed_name \u003d self.add_prefix(name)\n-                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n-                if not field.show_hidden_initial:\n-                    initial_value \u003d self.initial.get(name, field.initial)\n-                    if callable(initial_value):\n-                        initial_value \u003d initial_value()\n-                else:\n-                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n-                    hidden_widget \u003d field.hidden_widget()\n-                    try:\n-                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n-                            self.data, self.files, initial_prefixed_name))\n-                    except ValidationError:\n-                        # Always assume data has changed if validation fails.\n-                        self._changed_data.append(name)\n-                        continue\n-                if field.has_changed(initial_value, data_value):\n-                    self._changed_data.append(name)\n-        return self._changed_data\n+        data \u003d []\n+        for name, field in self.fields.items():\n+            prefixed_name \u003d self.add_prefix(name)\n+            data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n+            if not field.show_hidden_initial:\n+                initial_value \u003d self.initial.get(name, field.initial)\n+                if callable(initial_value):\n+                    initial_value \u003d initial_value()\n+            else:\n+                initial_prefixed_name \u003d self.add_initial_prefix(name)\n+                hidden_widget \u003d field.hidden_widget()\n+                try:\n+                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n+                        self.data, self.files, initial_prefixed_name))\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    data.append(name)\n+                    continue\n+            if field.has_changed(initial_value, data_value):\n+                data.append(name)\n+        return data\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Used @cached_property for BaseForm.changed_data.\n",
          "commitDate": "2015/8/4 下午7:12",
          "commitName": "c6c00fbfbb659de4beaad3c612c271ac74f892a7",
          "commitAuthor": "Curtis Maloney",
          "commitDateOld": "2015/7/17 上午1:36",
          "commitNameOld": "1ef4aeab403f7fb74c0b9b11fde854fd03afc40c",
          "commitAuthorOld": "Claude Paroz",
          "daysBetweenCommits": 18.73,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "actualSource": "    @cached_property\n    def changed_data(self):\n        data \u003d []\n        for name, field in self.fields.items():\n            prefixed_name \u003d self.add_prefix(name)\n            data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                initial_value \u003d self.initial.get(name, field.initial)\n                if callable(initial_value):\n                    initial_value \u003d initial_value()\n            else:\n                initial_prefixed_name \u003d self.add_initial_prefix(name)\n                hidden_widget \u003d field.hidden_widget()\n                try:\n                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    data.append(name)\n                    continue\n            if field.has_changed(initial_value, data_value):\n                data.append(name)\n        return data\n",
          "path": "django/forms/forms.py",
          "functionStartLine": 438,
          "functionName": "changed_data",
          "functionAnnotation": "@cached_property",
          "diff": "@@ -1,24 +1,23 @@\n-    @property\n+    @cached_property\n     def changed_data(self):\n-        if self._changed_data is None:\n-            self._changed_data \u003d []\n-            for name, field in self.fields.items():\n-                prefixed_name \u003d self.add_prefix(name)\n-                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n-                if not field.show_hidden_initial:\n-                    initial_value \u003d self.initial.get(name, field.initial)\n-                    if callable(initial_value):\n-                        initial_value \u003d initial_value()\n-                else:\n-                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n-                    hidden_widget \u003d field.hidden_widget()\n-                    try:\n-                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n-                            self.data, self.files, initial_prefixed_name))\n-                    except ValidationError:\n-                        # Always assume data has changed if validation fails.\n-                        self._changed_data.append(name)\n-                        continue\n-                if field.has_changed(initial_value, data_value):\n-                    self._changed_data.append(name)\n-        return self._changed_data\n+        data \u003d []\n+        for name, field in self.fields.items():\n+            prefixed_name \u003d self.add_prefix(name)\n+            data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n+            if not field.show_hidden_initial:\n+                initial_value \u003d self.initial.get(name, field.initial)\n+                if callable(initial_value):\n+                    initial_value \u003d initial_value()\n+            else:\n+                initial_prefixed_name \u003d self.add_initial_prefix(name)\n+                hidden_widget \u003d field.hidden_widget()\n+                try:\n+                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n+                        self.data, self.files, initial_prefixed_name))\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    data.append(name)\n+                    continue\n+            if field.has_changed(initial_value, data_value):\n+                data.append(name)\n+        return data\n",
          "extendedDetails": {
            "oldValue": "@property",
            "newValue": "@cached_property"
          }
        }
      ]
    },
    "deed00c0d803d324a3dfdeba52458b6b009c1a90": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #23162 -- Renamed forms.Field._has_changed() to has_changed().\n",
      "commitDate": "2014/8/15 下午8:14",
      "commitName": "deed00c0d803d324a3dfdeba52458b6b009c1a90",
      "commitAuthor": "Gabriel Muñumel",
      "commitDateOld": "2014/8/4 下午7:47",
      "commitNameOld": "5e06fa1469180909c51c07151692412269e51ea3",
      "commitAuthorOld": "Vincent-Vega",
      "daysBetweenCommits": 11.02,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual fields whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value \u003d initial_value()\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    try:\n                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if field.has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 420,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,30 +1,30 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual fields whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                     if callable(initial_value):\n                         initial_value \u003d initial_value()\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     try:\n                         initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                             self.data, self.files, initial_prefixed_name))\n                     except ValidationError:\n                         # Always assume data has changed if validation fails.\n                         self._changed_data.append(name)\n                         continue\n-                if field._has_changed(initial_value, data_value):\n+                if field.has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "d74e33eb0ec289d3125a5a8048d756f9d232bd62": {
      "type": "Ybodychange",
      "commitMessage": "Removed backwards compatibility code to call field.widget._has_changed()\n\nThis logic should be moved to field._has_changed() as described\nin ebb504db692cac496f4f45762d1d14644c9fa6f - refs #16612.\n",
      "commitDate": "2014/3/22 上午7:34",
      "commitName": "d74e33eb0ec289d3125a5a8048d756f9d232bd62",
      "commitAuthor": "Tim Graham",
      "commitDateOld": "2014/3/8 下午4:57",
      "commitNameOld": "210d0489c5daad56b806f8165f9fe09fb3c2a019",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 13.61,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value \u003d initial_value()\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    try:\n                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 406,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,36 +1,30 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                     if callable(initial_value):\n                         initial_value \u003d initial_value()\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     try:\n                         initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                             self.data, self.files, initial_prefixed_name))\n                     except ValidationError:\n                         # Always assume data has changed if validation fails.\n                         self._changed_data.append(name)\n                         continue\n-                if hasattr(field.widget, \u0027_has_changed\u0027):\n-                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n-                        \" define it at field level instead.\",\n-                        RemovedInDjango18Warning, stacklevel\u003d2)\n-                    if field.widget._has_changed(initial_value, data_value):\n-                        self._changed_data.append(name)\n-                elif field._has_changed(initial_value, data_value):\n+                if field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "210d0489c5daad56b806f8165f9fe09fb3c2a019": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #21188 -- Introduced subclasses for to-be-removed-in-django-XX warnings\n\nThanks Anssi Kääriäinen for the idea and Simon Charette for the\nreview.\n",
      "commitDate": "2014/3/8 下午4:57",
      "commitName": "210d0489c5daad56b806f8165f9fe09fb3c2a019",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2014/3/3 下午8:38",
      "commitNameOld": "0d912258921a442c48d5787228db2db5af7e8fa5",
      "commitAuthorOld": "Rodolfo Carvalho",
      "daysBetweenCommits": 4.85,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value \u003d initial_value()\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    try:\n                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        RemovedInDjango18Warning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 406,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,36 +1,36 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                     if callable(initial_value):\n                         initial_value \u003d initial_value()\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     try:\n                         initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                             self.data, self.files, initial_prefixed_name))\n                     except ValidationError:\n                         # Always assume data has changed if validation fails.\n                         self._changed_data.append(name)\n                         continue\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n-                        DeprecationWarning, stacklevel\u003d2)\n+                        RemovedInDjango18Warning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "acd7b34aafe352ef604edcb73f75041c5cbba6b9": {
      "type": "Ybodychange",
      "commitMessage": "Advanced deprecation warnings for Django 1.7.\n",
      "commitDate": "2013/6/30 上午12:49",
      "commitName": "acd7b34aafe352ef604edcb73f75041c5cbba6b9",
      "commitAuthor": "Aymeric Augustin",
      "commitDateOld": "2013/6/18 下午11:49",
      "commitNameOld": "3128f3d38d1db0bc01da9a4bf4be81119079d73a",
      "commitAuthorOld": "Baptiste Mispelon",
      "daysBetweenCommits": 11.04,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value \u003d initial_value()\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    try:\n                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        DeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 326,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,36 +1,36 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                     if callable(initial_value):\n                         initial_value \u003d initial_value()\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     try:\n                         initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                             self.data, self.files, initial_prefixed_name))\n                     except ValidationError:\n                         # Always assume data has changed if validation fails.\n                         self._changed_data.append(name)\n                         continue\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n-                        PendingDeprecationWarning, stacklevel\u003d2)\n+                        DeprecationWarning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "d0788c277035727b7b070abd0f02d075acffc84f": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #18709 -- Check if initial_value is a callable\n\nIn _get_changed_data, check if initial_value is a callable and call it\nif it is.\n",
      "commitDate": "2013/5/22 上午7:05",
      "commitName": "d0788c277035727b7b070abd0f02d075acffc84f",
      "commitAuthor": "Jeroen Dekkers",
      "commitDateOld": "2013/5/18 上午12:08",
      "commitNameOld": "9c487b5974ee7e7f196079611d7352364e8873ed",
      "commitAuthorOld": "Aymeric Augustin",
      "daysBetweenCommits": 4.29,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value \u003d initial_value()\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    try:\n                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 331,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,34 +1,36 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n+                    if callable(initial_value):\n+                        initial_value \u003d initial_value()\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     try:\n                         initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                             self.data, self.files, initial_prefixed_name))\n                     except ValidationError:\n                         # Always assume data has changed if validation fails.\n                         self._changed_data.append(name)\n                         continue\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n                         PendingDeprecationWarning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "cbfb8ed53b31ec9701f5fb8e519a8644fd4c8095": {
      "type": "Ybodychange",
      "commitMessage": "Fixed a regression in forms changed_data\n\nThanks Loic Bistuer for spotting the regression and the initial\npatch. Refs #16612.\n",
      "commitDate": "2013/3/9 上午1:19",
      "commitName": "cbfb8ed53b31ec9701f5fb8e519a8644fd4c8095",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2013/3/1 下午4:35",
      "commitNameOld": "892bc91cb0036d6868081363628f65094c4790d6",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 7.36,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    try:\n                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 331,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,29 +1,34 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n-                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n-                        self.data, self.files, initial_prefixed_name))\n+                    try:\n+                        initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n+                            self.data, self.files, initial_prefixed_name))\n+                    except ValidationError:\n+                        # Always assume data has changed if validation fails.\n+                        self._changed_data.append(name)\n+                        continue\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n                         PendingDeprecationWarning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "892bc91cb0036d6868081363628f65094c4790d6": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #16612 -- Improved has_changed detection for localized field values\n\nThanks Simon Charette for the review.\n",
      "commitDate": "2013/3/1 下午4:35",
      "commitName": "892bc91cb0036d6868081363628f65094c4790d6",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2013/2/25 上午5:59",
      "commitNameOld": "5eebb49c690097ec950b4db2a8eaa892c27433c0",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 4.44,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 331,
      "functionName": "changed_data",
      "functionAnnotation": "@property",
      "diff": "@@ -1,29 +1,29 @@\n     @property\n     def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n-                    initial_value \u003d hidden_widget.value_from_datadict(\n-                        self.data, self.files, initial_prefixed_name)\n+                    initial_value \u003d field.to_python(hidden_widget.value_from_datadict(\n+                        self.data, self.files, initial_prefixed_name))\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n                         PendingDeprecationWarning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n",
      "extendedDetails": {}
    },
    "58062a6302a2bf1013d100deb053ccae2298bb84": {
      "type": "Ymultichange(Yrename,Yannotationchange)",
      "commitMessage": "Used property decorators in django/forms.py\n",
      "commitDate": "2013/1/26 上午5:41",
      "commitName": "58062a6302a2bf1013d100deb053ccae2298bb84",
      "commitAuthor": "Claude Paroz",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Used property decorators in django/forms.py\n",
          "commitDate": "2013/1/26 上午5:41",
          "commitName": "58062a6302a2bf1013d100deb053ccae2298bb84",
          "commitAuthor": "Claude Paroz",
          "commitDateOld": "2013/1/26 上午3:50",
          "commitNameOld": "ebb504db692cac496f4f45762d1d14644c9fa6fa",
          "commitAuthorOld": "Claude Paroz",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    initial_value \u003d hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
          "path": "django/forms/forms.py",
          "functionStartLine": 326,
          "functionName": "changed_data",
          "functionAnnotation": "@property",
          "diff": "@@ -1,28 +1,29 @@\n-    def _get_changed_data(self):\n+    @property\n+    def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     initial_value \u003d hidden_widget.value_from_datadict(\n                         self.data, self.files, initial_prefixed_name)\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n                         PendingDeprecationWarning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n-        return self._changed_data\n\\ No newline at end of file\n+        return self._changed_data\n",
          "extendedDetails": {
            "oldValue": "_get_changed_data",
            "newValue": "changed_data"
          }
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Used property decorators in django/forms.py\n",
          "commitDate": "2013/1/26 上午5:41",
          "commitName": "58062a6302a2bf1013d100deb053ccae2298bb84",
          "commitAuthor": "Claude Paroz",
          "commitDateOld": "2013/1/26 上午3:50",
          "commitNameOld": "ebb504db692cac496f4f45762d1d14644c9fa6fa",
          "commitAuthorOld": "Claude Paroz",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    initial_value \u003d hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n",
          "path": "django/forms/forms.py",
          "functionStartLine": 326,
          "functionName": "changed_data",
          "functionAnnotation": "@property",
          "diff": "@@ -1,28 +1,29 @@\n-    def _get_changed_data(self):\n+    @property\n+    def changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     initial_value \u003d hidden_widget.value_from_datadict(\n                         self.data, self.files, initial_prefixed_name)\n                 if hasattr(field.widget, \u0027_has_changed\u0027):\n                     warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                         \" define it at field level instead.\",\n                         PendingDeprecationWarning, stacklevel\u003d2)\n                     if field.widget._has_changed(initial_value, data_value):\n                         self._changed_data.append(name)\n                 elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n-        return self._changed_data\n\\ No newline at end of file\n+        return self._changed_data\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@property"
          }
        }
      ]
    },
    "ebb504db692cac496f4f45762d1d14644c9fa6fa": {
      "type": "Ybodychange",
      "commitMessage": "Moved has_changed logic from widget to form field\n\nRefs #16612. Thanks Aymeric Augustin for the suggestion.\n",
      "commitDate": "2013/1/26 上午3:50",
      "commitName": "ebb504db692cac496f4f45762d1d14644c9fa6fa",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2012/8/12 下午8:44",
      "commitNameOld": "d4a0b27838c815af87698920cc4db7d2afd6f05b",
      "commitAuthorOld": "Aymeric Augustin",
      "daysBetweenCommits": 166.3,
      "commitsBetweenForRepo": 1092,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    initial_value \u003d hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if hasattr(field.widget, \u0027_has_changed\u0027):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel\u003d2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data",
      "path": "django/forms/forms.py",
      "functionStartLine": 325,
      "functionName": "_get_changed_data",
      "functionAnnotation": "",
      "diff": "@@ -1,22 +1,28 @@\n     def _get_changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                 if not field.show_hidden_initial:\n                     initial_value \u003d self.initial.get(name, field.initial)\n                 else:\n                     initial_prefixed_name \u003d self.add_initial_prefix(name)\n                     hidden_widget \u003d field.hidden_widget()\n                     initial_value \u003d hidden_widget.value_from_datadict(\n                         self.data, self.files, initial_prefixed_name)\n-                if field.widget._has_changed(initial_value, data_value):\n+                if hasattr(field.widget, \u0027_has_changed\u0027):\n+                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n+                        \" define it at field level instead.\",\n+                        PendingDeprecationWarning, stacklevel\u003d2)\n+                    if field.widget._has_changed(initial_value, data_value):\n+                        self._changed_data.append(name)\n+                elif field._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c7ad041b358a9819b3bd9f93d4834df4a5b5d57": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #7975 -- Callable defaults in inline model formsets now work correctly. Based on patch from msaelices. Thanks for your hard work msaelices.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@8816 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/9/2 上午5:28",
      "commitName": "7c7ad041b358a9819b3bd9f93d4834df4a5b5d57",
      "commitAuthor": "Brian Rosner",
      "commitDateOld": "2008/8/31 下午7:39",
      "commitNameOld": "24bacb19dea298943f54155f911df380c73f9ea2",
      "commitAuthorOld": "Malcolm Tredinnick",
      "daysBetweenCommits": 1.41,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value \u003d self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n                    hidden_widget \u003d field.hidden_widget()\n                    initial_value \u003d hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data",
      "path": "django/forms/forms.py",
      "functionStartLine": 255,
      "functionName": "_get_changed_data",
      "functionAnnotation": "",
      "diff": "@@ -1,16 +1,22 @@\n     def _get_changed_data(self):\n         if self._changed_data is None:\n             self._changed_data \u003d []\n             # XXX: For now we\u0027re asking the individual widgets whether or not the\n             # data has changed. It would probably be more efficient to hash the\n             # initial data, store it in a hidden field, and compare a hash of the\n             # submitted data, but we\u0027d need a way to easily get the string value\n             # for a given field. Right now, that logic is embedded in the render\n             # method of each widget.\n             for name, field in self.fields.items():\n                 prefixed_name \u003d self.add_prefix(name)\n                 data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n-                initial_value \u003d self.initial.get(name, field.initial)\n+                if not field.show_hidden_initial:\n+                    initial_value \u003d self.initial.get(name, field.initial)\n+                else:\n+                    initial_prefixed_name \u003d self.add_initial_prefix(name)\n+                    hidden_widget \u003d field.hidden_widget()\n+                    initial_value \u003d hidden_widget.value_from_datadict(\n+                        self.data, self.files, initial_prefixed_name)\n                 if field.widget._has_changed(initial_value, data_value):\n                     self._changed_data.append(name)\n         return self._changed_data\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46786b4193e04d398532bbfc3dcf63c03c1793cb": {
      "type": "Yfilerename",
      "commitMessage": "Fixed #7741: django.newforms is now django.forms. This is obviously a backwards-incompatible change. There\u0027s a warning upon import of django.newforms itself, but deeper imports will raise errors.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@7971 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/7/19 上午9:22",
      "commitName": "46786b4193e04d398532bbfc3dcf63c03c1793cb",
      "commitAuthor": "Jacob Kaplan-Moss",
      "commitDateOld": "2008/7/19 上午9:07",
      "commitNameOld": "39af2738fd64ba7f4c4af0783590e2b2b7b88460",
      "commitAuthorOld": "Russell Keith-Magee",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                initial_value \u003d self.initial.get(name, field.initial)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data",
      "path": "django/forms/forms.py",
      "functionStartLine": 249,
      "functionName": "_get_changed_data",
      "functionAnnotation": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "django/newforms/forms.py",
        "newPath": "django/forms/forms.py"
      }
    },
    "a19ed8aea395e8e07164ff7d85bd7dff2f24edca": {
      "type": "Yintroduced",
      "commitMessage": "Merged the newforms-admin branch into trunk.\n\nThis is a backward incompatible change. The admin contrib app has been\nrefactored. The newforms module has several improvements including FormSets\nand Media definitions.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@7967 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/7/19 上午7:54",
      "commitName": "a19ed8aea395e8e07164ff7d85bd7dff2f24edca",
      "commitAuthor": "Brian Rosner",
      "diff": "@@ -0,0 +1,16 @@\n+    def _get_changed_data(self):\n+        if self._changed_data is None:\n+            self._changed_data \u003d []\n+            # XXX: For now we\u0027re asking the individual widgets whether or not the\n+            # data has changed. It would probably be more efficient to hash the\n+            # initial data, store it in a hidden field, and compare a hash of the\n+            # submitted data, but we\u0027d need a way to easily get the string value\n+            # for a given field. Right now, that logic is embedded in the render\n+            # method of each widget.\n+            for name, field in self.fields.items():\n+                prefixed_name \u003d self.add_prefix(name)\n+                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n+                initial_value \u003d self.initial.get(name, field.initial)\n+                if field.widget._has_changed(initial_value, data_value):\n+                    self._changed_data.append(name)\n+        return self._changed_data\n\\ No newline at end of file\n",
      "actualSource": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data \u003d []\n            # XXX: For now we\u0027re asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we\u0027d need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name \u003d self.add_prefix(name)\n                data_value \u003d field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                initial_value \u003d self.initial.get(name, field.initial)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data",
      "path": "django/newforms/forms.py",
      "functionStartLine": 249,
      "functionName": "_get_changed_data",
      "functionAnnotation": ""
    }
  }
}