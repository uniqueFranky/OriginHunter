{
  "statementVersions": [
    {
      "commit": "ca278a8694f42e569a6d9f7d71c669465019bf06",
      "startLine": 23,
      "endLine": 43,
      "methodCode": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \"__file__\"):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name == \"__main__\":\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided \"\n                'module \"%s\".  This can happen because the '\n                \"module came from an import hook that does \"\n                \"not provide file name information or because \"\n                \"it's a namespace package.  In this case \"\n                \"the root path needs to be explicitly \"\n                \"provided.\" % import_name\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n"
    },
    {
      "commit": "025589ee766249652e2e097da05808fe64911ddc",
      "startLine": 23,
      "endLine": 43,
      "methodCode": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \"__file__\"):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name == \"__main__\":\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided \"\n                'module \"%s\".  This can happen because the '\n                \"module came from an import hook that does \"\n                \"not provide file name information or because \"\n                \"it's a namespace package.  In this case \"\n                \"the root path needs to be explicitly \"\n                \"provided.\" % import_name\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n"
    },
    {
      "commit": "52fa195d459a70f8ef73e954b20a9512b2f5001b",
      "startLine": 23,
      "endLine": 41,
      "methodCode": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, '__file__'):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name == '__main__':\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, 'get_filename'):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, '__file__', None)\n\n        # If we don't have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError('No root path can be found for the provided '\n                               'module \"%s\".  This can happen because the '\n                               'module came from an import hook that does '\n                               'not provide file name information or because '\n                               'it\\'s a namespace package.  In this case '\n                               'the root path needs to be explicitly '\n                               'provided.' % import_name)\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n"
    },
    {
      "commit": "d4b3d16c142e2189c6faf8f784a195e7f827c596",
      "startLine": 23,
      "endLine": 41,
      "methodCode": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, '__file__'):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name == '__main__':\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, 'get_filename'):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, '__file__', None)\n\n        # If we don't have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError('No root path can be found for the provided '\n                               'module \"%s\".  This can happen because the '\n                               'module came from an import hook that does '\n                               'not provide file name information or because '\n                               'it\\'s a namespace package.  In this case '\n                               'the root path needs to be explictly '\n                               'provided.' % import_name)\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n"
    },
    {
      "commit": "8071f11328ab2b767608c5c63d0bad72d9408120",
      "startLine": 23,
      "endLine": 28,
      "methodCode": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, '__file__'):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name == '__main__':\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, 'get_filename'):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        filepath = sys.modules[import_name].__file__\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n"
    },
    {
      "commit": "a3b30b7e3b026e821716be63d586e078eaa6ee7f",
      "startLine": 12,
      "endLine": 17,
      "methodCode": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    loader = pkgutil.get_loader(import_name)\n    if loader is None or import_name == '__main__':\n        # import name is not found, or interactive/main module\n        return os.getcwd()\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    if hasattr(loader, 'get_filename'):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        filepath = sys.modules[import_name].__file__\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n"
    }
  ]
}