{
  "statementVersions": [
    {
      "commit": "f7d6b584f83babf3f5c6d1610f6150d809be460f",
      "startLine": 9,
      "endLine": 43,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not isinstance(self.agg_axis, ABCMultiIndex)\n        ):\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy = self.obj._constructor_sliced(\n                empty_arr, index=index, dtype=values.dtype\n            )\n\n            try:\n                result = libreduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index=labels)\n\n        # compute the result using the series generator\n        results, res_index = self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results, res_index)\n"
    },
    {
      "commit": "2bf5ce76ded6e05aba88f27adc6459d32c5f6144",
      "startLine": 9,
      "endLine": 43,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not isinstance(self.agg_axis, ABCMultiIndex)\n        ):\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy = self.obj._constructor_sliced(\n                empty_arr, index=index, dtype=values.dtype\n            )\n\n            try:\n                result = libreduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index=labels)\n\n        # compute the result using the series generator\n        results = self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results)\n"
    },
    {
      "commit": "d691ec01cdd892920a4eabca458f72025a2e1b8b",
      "startLine": 9,
      "endLine": 43,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not self.agg_axis._has_complex_internals\n        ):\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy = self.obj._constructor_sliced(\n                empty_arr, index=index, dtype=values.dtype\n            )\n\n            try:\n                result = libreduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index=labels)\n\n        # compute the result using the series generator\n        results = self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results)\n"
    },
    {
      "commit": "a85f1d7dcbddb32eaf6b848bf184ae422b7771fa",
      "startLine": 9,
      "endLine": 43,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_array_dtype).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not self.agg_axis._has_complex_internals\n        ):\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy = self.obj._constructor_sliced(\n                empty_arr, index=index, dtype=values.dtype\n            )\n\n            try:\n                result = libreduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index=labels)\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "0436570f05c3b6e7bbb7c7d8fc8fa2f28a0420a8",
      "startLine": 9,
      "endLine": 43,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n            # Disallow complex_internals since libreduction shortcut\n            #  cannot handle MultiIndex\n            and not self.agg_axis._has_complex_internals\n        ):\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n\n            # Preserve subclass for e.g. test_subclassed_apply\n            dummy = self.obj._constructor_sliced(\n                empty_arr, index=index, dtype=values.dtype\n            )\n\n            try:\n                result = libreduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n            except ValueError as err:\n                if \"Function does not reduce\" not in str(err):\n                    # catch only ValueError raised intentionally in libreduction\n                    raise\n            except TypeError:\n                # e.g. test_apply_ignore_failures we just ignore\n                if not self.ignore_failures:\n                    raise\n            except ZeroDivisionError:\n                # reached via numexpr; fall back to python implementation\n                pass\n            else:\n                return self.obj._constructor_sliced(result, index=labels)\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "d9b3993cc3722ddd01367089d374652c0b5ce0ce",
      "startLine": 9,
      "endLine": 29,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n        ):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n            dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n            try:\n                result = libreduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n                return self.obj._constructor_sliced(result, index=labels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "9c37226a228784e993a220a02424fc8b68fe8257",
      "startLine": 9,
      "endLine": 29,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n        ):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n            dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n            try:\n                result = reduction.compute_reduction(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n                return self.obj._constructor_sliced(result, index=labels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
      "startLine": 9,
      "endLine": 29,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (\n            self.result_type in [\"reduce\", None]\n            and not self.dtypes.apply(is_extension_type).any()\n        ):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n            dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n            try:\n                result = reduction.reduce(\n                    values, self.f, axis=self.axis, dummy=dummy, labels=labels\n                )\n                return self.obj._constructor_sliced(result, index=labels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "26a2d41ebdb506e2419f2b38a53ecf622d16c319",
      "startLine": 9,
      "endLine": 27,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (self.result_type in ['reduce', None] and\n                not self.dtypes.apply(is_extension_type).any()):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n            dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n            try:\n                result = reduction.reduce(values, self.f,\n                                          axis=self.axis,\n                                          dummy=dummy,\n                                          labels=labels)\n                return self.obj._constructor_sliced(result, index=labels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "6b0c7e72b141831b7a9a5651f9e19eef53ec9e76",
      "startLine": 9,
      "endLine": 27,
      "methodCode": "    def apply_standard(self):\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n\n        # we cannot reduce using non-numpy dtypes,\n        # as demonstrated in gh-12244\n        if (self.result_type in ['reduce', None] and\n                not self.dtypes.apply(is_extension_type).any()):\n\n            # Create a dummy Series from an empty array\n            from pandas import Series\n            values = self.values\n            index = self.obj._get_axis(self.axis)\n            labels = self.agg_axis\n            empty_arr = np.empty(len(index), dtype=values.dtype)\n            dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n            try:\n                result = reduction.reduce(values, self.f,\n                                          axis=self.axis,\n                                          dummy=dummy,\n                                          labels=labels)\n                return Series(result, index=labels)\n            except Exception:\n                pass\n\n        # compute the result using the series generator\n        self.apply_series_generator()\n\n        # wrap results\n        return self.wrap_results()\n"
    },
    {
      "commit": "bcaa5da3671b2fd1b3dfca98ebd529d3525815c0",
      "startLine": 11,
      "endLine": 32,
      "methodCode": "    def apply_standard(self):\n        from pandas import Series\n\n        reduce = self.reduce\n        if reduce is None:\n            reduce = True\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n        if reduce:\n            values = self.values\n\n            # we cannot reduce using non-numpy dtypes,\n            # as demonstrated in gh-12244\n            if not is_extension_type(values):\n\n                # Create a dummy Series from an empty array\n                index = self.obj._get_axis(self.axis)\n                empty_arr = np.empty(len(index), dtype=values.dtype)\n\n                dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n                try:\n                    labels = self.agg_axis\n                    result = reduction.reduce(values, self.f,\n                                              axis=self.axis,\n                                              dummy=dummy,\n                                              labels=labels)\n                    return Series(result, index=labels)\n                except Exception:\n                    pass\n\n        # compute the result using the series generator\n        results, res_index, res_columns = self._apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results, res_index, res_columns)\n"
    },
    {
      "commit": "76b35c6662136302d212448906c1c8bf8225fffd",
      "startLine": 11,
      "endLine": 32,
      "methodCode": "    def apply_standard(self):\n        from pandas import Series\n\n        reduce = self.reduce\n        if reduce is None:\n            reduce = True\n\n        # try to reduce first (by default)\n        # this only matters if the reduction in values is of different dtype\n        # e.g. if we want to apply to a SparseFrame, then can't directly reduce\n        if reduce:\n            values = self.values\n\n            # we cannot reduce using non-numpy dtypes,\n            # as demonstrated in gh-12244\n            if not is_extension_type(values):\n\n                # Create a dummy Series from an empty array\n                index = self.obj._get_axis(self.axis)\n                empty_arr = np.empty(len(index), dtype=values.dtype)\n\n                dummy = Series(empty_arr, index=index, dtype=values.dtype)\n\n                try:\n                    labels = self.agg_axis\n                    result = lib.reduce(values, self.f,\n                                        axis=self.axis,\n                                        dummy=dummy,\n                                        labels=labels)\n                    return Series(result, index=labels)\n                except Exception:\n                    pass\n\n        # compute the result using the series generator\n        results, res_index, res_columns = self._apply_series_generator()\n\n        # wrap results\n        return self.wrap_results(results, res_index, res_columns)\n"
    }
  ]
}