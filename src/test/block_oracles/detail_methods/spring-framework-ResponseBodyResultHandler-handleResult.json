{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ResponseBodyResultHandler.java",
  "functionName": "handleResult",
  "functionId": "handleResult___exchange-ServerWebExchange__result-HandlerResult",
  "sourceFilePath": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 83,
  "functionEndLine": 87,
  "numCommitsSeen": 99,
  "timeTaken": 1760,
  "changeHistory": [
    "db69a082d9449ecb13f615316a382c100cab1f23",
    "fafd2d20e177d56b5d08dfa630b920d7095877da",
    "101220bad1ac3b4082a08aff4e9c8254e71febaf",
    "8c7658144284f2f47124c6ac8131f53320091551",
    "dffd6d674ab9415caed1b82755634f52383cd7ba",
    "9aa6f5caacac316c74e374550a387f222e7e1921",
    "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1",
    "318b15c321963ad772ae9e4762c25b205047a463",
    "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
    "37404d081e807c1f4926590a78f1d4da266fb5c3",
    "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
    "91d063899bd816cc57815ac0b2317b3ab674868e",
    "804f69c8b6e8156462449a310a1e0865eb329b61",
    "6b7360fed1741bd9f7208f993f1df0036e2137d6",
    "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
    "7f786ce4d7a8b51a02133d7db404d9f038d5a927",
    "4197f002d87c1c02455cc640e20f89b28b10d271",
    "e92174c772c0d787be7721ae00c7189f16b05fb5",
    "381855aaf315adfd44e22797bbf14f07d08155d9",
    "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a",
    "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
    "8ef7e2ff77f913773e30b1463d4657368db700e5",
    "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
    "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
    "da98becf72fbeef836dba366431be2a652e5e001",
    "911d3769224d009fb9fe08c6cb5489686bbc5713",
    "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
    "54ce20a5e04275835b40f2cd1453db778264191e",
    "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
    "5d4201d50079fc36fee21617ece1bfbbcf194120",
    "2de127ad4ad8dcb81521039749308de58ac81420",
    "bdc5b38cb12d26605a968845338bef5bad22816d",
    "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
    "c0dff3d2bb2277429f4e387d18deb75b0797a375",
    "45a88974bc9545eff6c7de07d054a2836dcbdfca",
    "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
    "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
    "cf2c1514af43bc955571ede20876d6cda1779f11",
    "8ca04b84259f1840db7e1037828f7120427eb7b1",
    "464ff1d9606a3189a41bae80e504929dec091d33",
    "f816cc6a516c324875fa409a33d288447c6996f7",
    "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
    "881db0688b5448768e1b3196fe5365a3d41d9342",
    "202825554c022e4262fe3bd20a34faf01ab9d620"
  ],
  "changeHistoryShort": {
    "db69a082d9449ecb13f615316a382c100cab1f23": "Ybodychange",
    "fafd2d20e177d56b5d08dfa630b920d7095877da": "Yfilerename",
    "101220bad1ac3b4082a08aff4e9c8254e71febaf": "Ybodychange",
    "8c7658144284f2f47124c6ac8131f53320091551": "Ybodychange",
    "dffd6d674ab9415caed1b82755634f52383cd7ba": "Ybodychange",
    "9aa6f5caacac316c74e374550a387f222e7e1921": "Ymultichange(Ybodychange,Yannotationchange)",
    "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1": "Ybodychange",
    "318b15c321963ad772ae9e4762c25b205047a463": "Ybodychange",
    "2263954ad7d760c145eeaf4b02c2e9a68f118ad1": "Ybodychange",
    "37404d081e807c1f4926590a78f1d4da266fb5c3": "Ybodychange",
    "2292e46b04c65d4f3f8193b0eab249a8058e59a8": "Ybodychange",
    "91d063899bd816cc57815ac0b2317b3ab674868e": "Ybodychange",
    "804f69c8b6e8156462449a310a1e0865eb329b61": "Ybodychange",
    "6b7360fed1741bd9f7208f993f1df0036e2137d6": "Ybodychange",
    "341f23e0e666ce0a00090fe1cad91caa7cb5e97c": "Yfilerename",
    "7f786ce4d7a8b51a02133d7db404d9f038d5a927": "Ybodychange",
    "4197f002d87c1c02455cc640e20f89b28b10d271": "Ybodychange",
    "e92174c772c0d787be7721ae00c7189f16b05fb5": "Ybodychange",
    "381855aaf315adfd44e22797bbf14f07d08155d9": "Yparameterchange",
    "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a": "Ybodychange",
    "4f614fa0fd74ce29c5822e70f4815cc40745a2be": "Ymultichange(Yparameterchange,Ybodychange)",
    "8ef7e2ff77f913773e30b1463d4657368db700e5": "Ymultichange(Yreturntypechange,Ybodychange)",
    "9789db23d2973d8f0156d2b6c6027d9fb67ab844": "Ybodychange",
    "a0018d13e19f7fe7ef7a98979476d9cd2851a10c": "Ybodychange",
    "da98becf72fbeef836dba366431be2a652e5e001": "Yparameterchange",
    "911d3769224d009fb9fe08c6cb5489686bbc5713": "Ybodychange",
    "81867fa4237643ca3eae24a8f085bc4b5f9443b3": "Yfilerename",
    "54ce20a5e04275835b40f2cd1453db778264191e": "Ybodychange",
    "c6713c23e327961d021706e5b1e4d5ebe8e2f458": "Ybodychange",
    "5d4201d50079fc36fee21617ece1bfbbcf194120": "Ybodychange",
    "2de127ad4ad8dcb81521039749308de58ac81420": "Ybodychange",
    "bdc5b38cb12d26605a968845338bef5bad22816d": "Ybodychange",
    "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b": "Ybodychange",
    "c0dff3d2bb2277429f4e387d18deb75b0797a375": "Ybodychange",
    "45a88974bc9545eff6c7de07d054a2836dcbdfca": "Ybodychange",
    "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033": "Ymultichange(Yparameterchange,Ybodychange)",
    "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa": "Ymultichange(Ybodychange,Yannotationchange)",
    "cf2c1514af43bc955571ede20876d6cda1779f11": "Ybodychange",
    "8ca04b84259f1840db7e1037828f7120427eb7b1": "Ybodychange",
    "464ff1d9606a3189a41bae80e504929dec091d33": "Ybodychange",
    "f816cc6a516c324875fa409a33d288447c6996f7": "Ybodychange",
    "110d9d7cd906c524af5053329a65ef4e1bd9f7eb": "Ybodychange",
    "881db0688b5448768e1b3196fe5365a3d41d9342": "Ybodychange",
    "202825554c022e4262fe3bd20a34faf01ab9d620": "Yintroduced"
  },
  "changeHistoryDetails": {
    "db69a082d9449ecb13f615316a382c100cab1f23": {
      "type": "Ybodychange",
      "commitMessage": "Avoid java.util.Optional signatures for simple field access\n\nIssue: SPR-15576\n",
      "commitDate": "2017/5/24 上午4:05",
      "commitName": "db69a082d9449ecb13f615316a382c100cab1f23",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/3/25 上午5:48",
      "commitNameOld": "5414cd0cf8228d4cd1a3873ae18b4fcb91b6e556",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 59.93,
      "commitsBetweenForRepo": 333,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue();\n    MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n    return writeBody(body, bodyTypeParameter, exchange);\n}",
      "path": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 85,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,6 +1,6 @@\n @Override\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-    Object body \u003d result.getReturnValue().orElse(null);\n+    Object body \u003d result.getReturnValue();\n     MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n     return writeBody(body, bodyTypeParameter, exchange);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fafd2d20e177d56b5d08dfa630b920d7095877da": {
      "type": "Yfilerename",
      "commitMessage": "Rename spring-web-reactive to spring-webflux\n\nIssue: SPR-15190\n",
      "commitDate": "2017/2/2 上午6:02",
      "commitName": "fafd2d20e177d56b5d08dfa630b920d7095877da",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2017/2/2 上午4:29",
      "commitNameOld": "81d121797645c65cbfc5a85b73b3540e1ab0ea92",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue().orElse(null);\n    MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n    return writeBody(body, bodyTypeParameter, exchange);\n}",
      "path": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 117,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
        "newPath": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java"
      }
    },
    "101220bad1ac3b4082a08aff4e9c8254e71febaf": {
      "type": "Ybodychange",
      "commitMessage": "Add ReactiveAdapterRegistry\n\nIssue: SPR-14159\n",
      "commitDate": "2016/7/23 上午12:21",
      "commitName": "101220bad1ac3b4082a08aff4e9c8254e71febaf",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/7/19 上午10:16",
      "commitNameOld": "4b92bf2af121075eae7ee55399841aff91984294",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 3.59,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue().orElse(null);\n    MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n    return writeBody(body, bodyTypeParameter, exchange);\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 115,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,7 +1,6 @@\n @Override\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Object body \u003d result.getReturnValue().orElse(null);\n-    ResolvableType bodyType \u003d result.getReturnType();\n     MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n-    return writeBody(exchange, body, bodyType, bodyTypeParameter);\n+    return writeBody(body, bodyTypeParameter, exchange);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c7658144284f2f47124c6ac8131f53320091551": {
      "type": "Ybodychange",
      "commitMessage": "Provide rich type information to ConversionService\n\nWhen using the ConversionService to check and bridge to and from\nreactive types we now generallly provide the full type information\navailable from method signatures. However that full type information\nis not always necessary such as when we perform additional checks on\nthe generics of the reactive type (e.g. Mono\u003cResponseEntity\u003e).\n\nThis allows us to switch to use DefaultFormattingConversionService\ninstead of GenericConversionService while also ensuring that the\nCollectionToObjectConverter doesn\u0027t think it can convert List\u003c?\u003e to\nany reactive type.\n\nThe ObjectToObjectConverter can also interfere because it is smart\nenough to find the \"from(Publisher\u003c?\u003e)\" method on Flux and Mono.\nTo make up for that on the response side we now check if a type\nis assignable to Publisher first in which case it is a simple cast.\n\nIn turn that means we don\u0027t need a PublisherToFluxConverter which can\nbe problematic in its own right because it can convert from Mono to\nFlux which technically doesn\u0027t lose data but switches stream semantics.\n\nIssue: #124, #128\n",
      "commitDate": "2016/7/4 上午9:55",
      "commitName": "8c7658144284f2f47124c6ac8131f53320091551",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/7/4 上午9:54",
      "commitNameOld": "fb2e79604859a5b6fbc9b1c491caee8c3a9dbdcc",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue().orElse(null);\n    ResolvableType bodyType \u003d result.getReturnType();\n    MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n    return writeBody(exchange, body, bodyType, bodyTypeParameter);\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 114,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,6 +1,7 @@\n @Override\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Object body \u003d result.getReturnValue().orElse(null);\n     ResolvableType bodyType \u003d result.getReturnType();\n-    return writeBody(exchange, body, bodyType);\n+    MethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n+    return writeBody(exchange, body, bodyType, bodyTypeParameter);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dffd6d674ab9415caed1b82755634f52383cd7ba": {
      "type": "Ybodychange",
      "commitMessage": "Shorten returnValueType name in HandlerResult\n",
      "commitDate": "2016/7/2 上午6:00",
      "commitName": "dffd6d674ab9415caed1b82755634f52383cd7ba",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/6/27 下午9:00",
      "commitNameOld": "699b0571267e5a27897f6d6d6304d18006ceed85",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue().orElse(null);\n    ResolvableType bodyType \u003d result.getReturnType();\n    return writeBody(exchange, body, bodyType);\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 119,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,6 +1,6 @@\n @Override\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Object body \u003d result.getReturnValue().orElse(null);\n-    ResolvableType bodyType \u003d result.getReturnValueType();\n+    ResolvableType bodyType \u003d result.getReturnType();\n     return writeBody(exchange, body, bodyType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9aa6f5caacac316c74e374550a387f222e7e1921": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Add support for ResponseEntity result handling\n",
      "commitDate": "2016/6/22 上午5:27",
      "commitName": "9aa6f5caacac316c74e374550a387f222e7e1921",
      "commitAuthor": "Rossen Stoyanchev",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Add support for ResponseEntity result handling\n",
          "commitDate": "2016/6/22 上午5:27",
          "commitName": "9aa6f5caacac316c74e374550a387f222e7e1921",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/6/7 上午5:43",
          "commitNameOld": "0a88d5983aedfaa7165d332d415df5e0341c4128",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 14.99,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue().orElse(null);\n    ResolvableType bodyType \u003d result.getReturnValueType();\n    return writeBody(exchange, body, bodyType);\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 99,
          "functionName": "handleResult",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,33 +1,6 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-    Publisher\u003c?\u003e publisher;\n-    ResolvableType elementType;\n-    ResolvableType returnType \u003d result.getReturnValueType();\n-    if (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n-        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n-        if (optionalValue.isPresent()) {\n-            publisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n-        } else {\n-            publisher \u003d Mono.empty();\n-        }\n-        elementType \u003d returnType.getGeneric(0);\n-        if (Void.class.equals(elementType.getRawClass())) {\n-            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n-        }\n-    } else {\n-        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n-        elementType \u003d returnType;\n-    }\n-    List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n-    MediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n-    if (bestMediaType !\u003d null) {\n-        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n-            if (converter.canWrite(elementType, bestMediaType)) {\n-                ServerHttpResponse response \u003d exchange.getResponse();\n-                return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n-            }\n-        }\n-    }\n-    return Mono.error(new NotAcceptableStatusException(producibleTypes));\n+    Object body \u003d result.getReturnValue().orElse(null);\n+    ResolvableType bodyType \u003d result.getReturnValueType();\n+    return writeBody(exchange, body, bodyType);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Add support for ResponseEntity result handling\n",
          "commitDate": "2016/6/22 上午5:27",
          "commitName": "9aa6f5caacac316c74e374550a387f222e7e1921",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/6/7 上午5:43",
          "commitNameOld": "0a88d5983aedfaa7165d332d415df5e0341c4128",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 14.99,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object body \u003d result.getReturnValue().orElse(null);\n    ResolvableType bodyType \u003d result.getReturnValueType();\n    return writeBody(exchange, body, bodyType);\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 99,
          "functionName": "handleResult",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,33 +1,6 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-    Publisher\u003c?\u003e publisher;\n-    ResolvableType elementType;\n-    ResolvableType returnType \u003d result.getReturnValueType();\n-    if (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n-        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n-        if (optionalValue.isPresent()) {\n-            publisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n-        } else {\n-            publisher \u003d Mono.empty();\n-        }\n-        elementType \u003d returnType.getGeneric(0);\n-        if (Void.class.equals(elementType.getRawClass())) {\n-            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n-        }\n-    } else {\n-        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n-        elementType \u003d returnType;\n-    }\n-    List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n-    MediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n-    if (bestMediaType !\u003d null) {\n-        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n-            if (converter.canWrite(elementType, bestMediaType)) {\n-                ServerHttpResponse response \u003d exchange.getResponse();\n-                return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n-            }\n-        }\n-    }\n-    return Mono.error(new NotAcceptableStatusException(producibleTypes));\n+    Object body \u003d result.getReturnValue().orElse(null);\n+    ResolvableType bodyType \u003d result.getReturnValueType();\n+    return writeBody(exchange, body, bodyType);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override,@SuppressWarnings(\"unchecked\")",
            "newValue": "@Override"
          }
        }
      ]
    },
    "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1": {
      "type": "Ybodychange",
      "commitMessage": "Introduce base class for ResponseBodyResultHandler\n\nThe ContentNegotiatingResultHandlerSupport base class encapsulates the\nlogic for content negotiation needed for both @ResponseBody and view\nresolution result handling.\n",
      "commitDate": "2016/6/1 上午4:33",
      "commitName": "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/5/27 上午5:48",
      "commitNameOld": "793638e610fa01cfffa53e1edcab56c98b2d5751",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n        if (optionalValue.isPresent()) {\n            publisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n        } else {\n            publisher \u003d Mono.empty();\n        }\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n    MediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n    if (bestMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            if (converter.canWrite(elementType, bestMediaType)) {\n                ServerHttpResponse response \u003d exchange.getResponse();\n                return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n            }\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(producibleTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 114,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,33 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n-    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+    if (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n         Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n         if (optionalValue.isPresent()) {\n-            publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n+            publisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n         } else {\n             publisher \u003d Mono.empty();\n         }\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n         elementType \u003d returnType;\n     }\n-    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n-    if (compatibleMediaTypes.isEmpty()) {\n-        if (result.getReturnValue().isPresent()) {\n-            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n-            return Mono.error(new NotAcceptableStatusException(mediaTypes));\n-        }\n-        return Mono.empty();\n-    }\n-    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n+    List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n+    MediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n     if (bestMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             if (converter.canWrite(elementType, bestMediaType)) {\n                 ServerHttpResponse response \u003d exchange.getResponse();\n                 return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n             }\n         }\n     }\n-    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n+    return Mono.error(new NotAcceptableStatusException(producibleTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "318b15c321963ad772ae9e4762c25b205047a463": {
      "type": "Ybodychange",
      "commitMessage": "Polish\n",
      "commitDate": "2016/5/27 上午1:39",
      "commitName": "318b15c321963ad772ae9e4762c25b205047a463",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/5/27 上午1:34",
      "commitNameOld": "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n        if (optionalValue.isPresent()) {\n            publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n        } else {\n            publisher \u003d Mono.empty();\n        }\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n    if (compatibleMediaTypes.isEmpty()) {\n        if (result.getReturnValue().isPresent()) {\n            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n            return Mono.error(new NotAcceptableStatusException(mediaTypes));\n        }\n        return Mono.empty();\n    }\n    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n    if (bestMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            if (converter.canWrite(elementType, bestMediaType)) {\n                ServerHttpResponse response \u003d exchange.getResponse();\n                return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n            }\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 150,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,40 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n         if (optionalValue.isPresent()) {\n             publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n         } else {\n             publisher \u003d Mono.empty();\n         }\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n     if (compatibleMediaTypes.isEmpty()) {\n         if (result.getReturnValue().isPresent()) {\n             List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n             return Mono.error(new NotAcceptableStatusException(mediaTypes));\n         }\n         return Mono.empty();\n     }\n     MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n     if (bestMediaType !\u003d null) {\n-        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n-        if (converter !\u003d null) {\n-            ServerHttpResponse response \u003d exchange.getResponse();\n-            return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n+        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n+            if (converter.canWrite(elementType, bestMediaType)) {\n+                ServerHttpResponse response \u003d exchange.getResponse();\n+                return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n+            }\n         }\n     }\n     return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2263954ad7d760c145eeaf4b02c2e9a68f118ad1": {
      "type": "Ybodychange",
      "commitMessage": "Respect produces condition in @ResponseBody algorithm\n",
      "commitDate": "2016/5/27 上午1:34",
      "commitName": "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/5/26 下午11:05",
      "commitNameOld": "a017e2848a792038b10eec635ab10e4809a2883b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n        if (optionalValue.isPresent()) {\n            publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n        } else {\n            publisher \u003d Mono.empty();\n        }\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n    if (compatibleMediaTypes.isEmpty()) {\n        if (result.getReturnValue().isPresent()) {\n            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n            return Mono.error(new NotAcceptableStatusException(mediaTypes));\n        }\n        return Mono.empty();\n    }\n    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n    if (bestMediaType !\u003d null) {\n        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n        if (converter !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 150,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,39 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n         if (optionalValue.isPresent()) {\n             publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n         } else {\n             publisher \u003d Mono.empty();\n         }\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n         elementType \u003d returnType;\n     }\n-    ServerHttpRequest request \u003d exchange.getRequest();\n     List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n     if (compatibleMediaTypes.isEmpty()) {\n         if (result.getReturnValue().isPresent()) {\n-            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(elementType);\n+            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n             return Mono.error(new NotAcceptableStatusException(mediaTypes));\n         }\n         return Mono.empty();\n     }\n     MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n     if (bestMediaType !\u003d null) {\n         HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n         if (converter !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n         }\n     }\n     return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37404d081e807c1f4926590a78f1d4da266fb5c3": {
      "type": "Ybodychange",
      "commitMessage": "Use ContentTypeResolver for content negotiation\n",
      "commitDate": "2016/5/26 下午10:52",
      "commitName": "37404d081e807c1f4926590a78f1d4da266fb5c3",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/5/26 上午5:35",
      "commitNameOld": "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n        if (optionalValue.isPresent()) {\n            publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n        } else {\n            publisher \u003d Mono.empty();\n        }\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n        elementType \u003d returnType;\n    }\n    ServerHttpRequest request \u003d exchange.getRequest();\n    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n    if (compatibleMediaTypes.isEmpty()) {\n        if (result.getReturnValue().isPresent()) {\n            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(elementType);\n            return Mono.error(new NotAcceptableStatusException(mediaTypes));\n        }\n        return Mono.empty();\n    }\n    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n    if (bestMediaType !\u003d null) {\n        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n        if (converter !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 150,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,40 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n         if (optionalValue.isPresent()) {\n             publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n         } else {\n             publisher \u003d Mono.empty();\n         }\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n         elementType \u003d returnType;\n     }\n     ServerHttpRequest request \u003d exchange.getRequest();\n-    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n+    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n     if (compatibleMediaTypes.isEmpty()) {\n-        List\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n-        return Mono.error(new NotAcceptableStatusException(supported));\n+        if (result.getReturnValue().isPresent()) {\n+            List\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(elementType);\n+            return Mono.error(new NotAcceptableStatusException(mediaTypes));\n+        }\n+        return Mono.empty();\n     }\n     MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n     if (bestMediaType !\u003d null) {\n         HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n         if (converter !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n         }\n     }\n     return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2292e46b04c65d4f3f8193b0eab249a8058e59a8": {
      "type": "Ybodychange",
      "commitMessage": "Update empty return value ResponseBody handling\n\nWhen a null is returned from an @ResponseBody method, rather than\nreturning Mono.empty() immediately, convert it to Mono.empty() and\napply the same processing.\n\nCurrently that doesn\u0027t make a practical difference but it\u0027s more\naccurate to do it this way. Eventually it may mean the possibility\nto turn empty values into something through an extension point\nas we do with ResponseBodyAdvice in Spring MVC today.\n",
      "commitDate": "2016/5/26 上午5:35",
      "commitName": "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/5/26 上午5:34",
      "commitNameOld": "91d063899bd816cc57815ac0b2317b3ab674868e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n        if (optionalValue.isPresent()) {\n            publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n        } else {\n            publisher \u003d Mono.empty();\n        }\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n        elementType \u003d returnType;\n    }\n    ServerHttpRequest request \u003d exchange.getRequest();\n    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n    if (compatibleMediaTypes.isEmpty()) {\n        List\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n        return Mono.error(new NotAcceptableStatusException(supported));\n    }\n    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n    if (bestMediaType !\u003d null) {\n        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n        if (converter !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 127,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,36 +1,37 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n-    if (!value.isPresent()) {\n-        return Mono.empty();\n-    }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n+        Optional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n+        if (optionalValue.isPresent()) {\n+            publisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n+        } else {\n+            publisher \u003d Mono.empty();\n+        }\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n-        publisher \u003d Mono.just(value.get());\n+        publisher \u003d Mono.justOrEmpty(result.getReturnValue());\n         elementType \u003d returnType;\n     }\n     ServerHttpRequest request \u003d exchange.getRequest();\n     List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n     if (compatibleMediaTypes.isEmpty()) {\n         List\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n         return Mono.error(new NotAcceptableStatusException(supported));\n     }\n     MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n     if (bestMediaType !\u003d null) {\n         HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n         if (converter !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n         }\n     }\n     return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "91d063899bd816cc57815ac0b2317b3ab674868e": {
      "type": "Ybodychange",
      "commitMessage": "Polish ResponseBody result handling\n",
      "commitDate": "2016/5/26 上午5:34",
      "commitName": "91d063899bd816cc57815ac0b2317b3ab674868e",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/4/20 下午10:27",
      "commitNameOld": "804f69c8b6e8156462449a310a1e0865eb329b61",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 35.3,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    ServerHttpRequest request \u003d exchange.getRequest();\n    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n    if (compatibleMediaTypes.isEmpty()) {\n        List\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n        return Mono.error(new NotAcceptableStatusException(supported));\n    }\n    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n    if (bestMediaType !\u003d null) {\n        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n        if (converter !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 127,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,36 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Optional\u003cObject\u003e value \u003d result.getReturnValue();\n     if (!value.isPresent()) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.just(value.get());\n         elementType \u003d returnType;\n     }\n-    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange.getRequest(), elementType);\n+    ServerHttpRequest request \u003d exchange.getRequest();\n+    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n     if (compatibleMediaTypes.isEmpty()) {\n-        return Mono.error(new NotAcceptableStatusException(getProducibleMediaTypes(elementType)));\n+        List\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n+        return Mono.error(new NotAcceptableStatusException(supported));\n     }\n-    Optional\u003cMediaType\u003e selectedMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n-    if (selectedMediaType.isPresent()) {\n-        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, selectedMediaType.get());\n+    MediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n+    if (bestMediaType !\u003d null) {\n+        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n         if (converter !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n-            return converter.write((Publisher) publisher, elementType, selectedMediaType.get(), response);\n+            return converter.write((Publisher) publisher, elementType, bestMediaType, response);\n         }\n     }\n-    return Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n+    return Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "804f69c8b6e8156462449a310a1e0865eb329b61": {
      "type": "Ybodychange",
      "commitMessage": "Wrapping up zero-copy support\n\nThis commit wraps up the previous commits:\n\n - It uses HttpMessageConverter in the web.reactive.server package instead of Encoder/Decoder.\n - It introduces tests for the Resource @ResponseBodies.\n",
      "commitDate": "2016/4/20 下午10:27",
      "commitName": "804f69c8b6e8156462449a310a1e0865eb329b61",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2016/4/20 上午4:02",
      "commitNameOld": "6b7360fed1741bd9f7208f993f1df0036e2137d6",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange.getRequest(), elementType);\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new NotAcceptableStatusException(getProducibleMediaTypes(elementType)));\n    }\n    Optional\u003cMediaType\u003e selectedMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n    if (selectedMediaType.isPresent()) {\n        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, selectedMediaType.get());\n        if (converter !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            return converter.write((Publisher) publisher, elementType, selectedMediaType.get(), response);\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 125,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,34 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Optional\u003cObject\u003e value \u003d result.getReturnValue();\n     if (!value.isPresent()) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.just(value.get());\n         elementType \u003d returnType;\n     }\n-    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n-    if (producibleMediaTypes.isEmpty()) {\n-        producibleMediaTypes.add(MediaType.ALL);\n-    }\n-    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n-    for (MediaType requestedType : requestedMediaTypes) {\n-        for (MediaType producibleType : producibleMediaTypes) {\n-            if (requestedType.isCompatibleWith(producibleType)) {\n-                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n-            }\n-        }\n-    }\n+    List\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange.getRequest(), elementType);\n     if (compatibleMediaTypes.isEmpty()) {\n-        return Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n+        return Mono.error(new NotAcceptableStatusException(getProducibleMediaTypes(elementType)));\n     }\n-    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n-    MediaType.sortBySpecificityAndQuality(mediaTypes);\n-    MediaType selectedMediaType \u003d null;\n-    for (MediaType mediaType : mediaTypes) {\n-        if (mediaType.isConcrete()) {\n-            selectedMediaType \u003d mediaType;\n-            break;\n-        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n-            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n-            break;\n-        }\n-    }\n-    if (selectedMediaType !\u003d null) {\n-        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n-        if (encoder !\u003d null) {\n+    Optional\u003cMediaType\u003e selectedMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n+    if (selectedMediaType.isPresent()) {\n+        HttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, selectedMediaType.get());\n+        if (converter !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n-            response.getHeaders().setContentType(selectedMediaType);\n-            DataBufferAllocator allocator \u003d response.allocator();\n-            return response.setBody(encoder.encode((Publisher) publisher, allocator, elementType, selectedMediaType));\n+            return converter.write((Publisher) publisher, elementType, selectedMediaType.get(), response);\n         }\n     }\n     return Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b7360fed1741bd9f7208f993f1df0036e2137d6": {
      "type": "Ybodychange",
      "commitMessage": "Apply new ResponseStatusException hierarchy\n\nThis commit replaces use of the existing ServletException-based\nexceptions with the new ones from ~.web.server.\n",
      "commitDate": "2016/4/20 上午4:02",
      "commitName": "6b7360fed1741bd9f7208f993f1df0036e2137d6",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/4/15 上午4:15",
      "commitNameOld": "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            DataBufferAllocator allocator \u003d response.allocator();\n            return response.setBody(encoder.encode((Publisher) publisher, allocator, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Optional\u003cObject\u003e value \u003d result.getReturnValue();\n     if (!value.isPresent()) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.just(value.get());\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+        return Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             DataBufferAllocator allocator \u003d response.allocator();\n             return response.setBody(encoder.encode((Publisher) publisher, allocator, elementType, selectedMediaType));\n         }\n     }\n-    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+    return Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341f23e0e666ce0a00090fe1cad91caa7cb5e97c": {
      "type": "Yfilerename",
      "commitMessage": "Add \"result\" package under ~.web.reactive\n\nThe new package is parallel to the \"mvc\" package under spring-webmvc\nand a place to hold the various programming model styles.\n",
      "commitDate": "2016/4/15 上午4:15",
      "commitName": "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/4/15 上午3:17",
      "commitNameOld": "3460e577ad86c6d660bab066e751911b16182f73",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            DataBufferAllocator allocator \u003d response.allocator();\n            return response.setBody(encoder.encode((Publisher) publisher, allocator, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
        "newPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java"
      }
    },
    "7f786ce4d7a8b51a02133d7db404d9f038d5a927": {
      "type": "Ybodychange",
      "commitMessage": "Added DataBufferAllocator property to ReactiveHttpOutputMessage, and use that to pass on to Encoder.encode().\n",
      "commitDate": "2016/3/18 下午11:14",
      "commitName": "7f786ce4d7a8b51a02133d7db404d9f038d5a927",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2016/2/28 下午7:49",
      "commitNameOld": "4197f002d87c1c02455cc640e20f89b28b10d271",
      "commitAuthorOld": "Stephane Maldini",
      "daysBetweenCommits": 19.14,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            DataBufferAllocator allocator \u003d response.allocator();\n            return response.setBody(encoder.encode((Publisher) publisher, allocator, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,59 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Optional\u003cObject\u003e value \u003d result.getReturnValue();\n     if (!value.isPresent()) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.just(value.get());\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n-            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n+            DataBufferAllocator allocator \u003d response.allocator();\n+            return response.setBody(encoder.encode((Publisher) publisher, allocator, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4197f002d87c1c02455cc640e20f89b28b10d271": {
      "type": "Ybodychange",
      "commitMessage": "Arrange WriteWithOperator to save some allocation cost with the same technique used by RSC and Reactor\n",
      "commitDate": "2016/2/28 下午7:49",
      "commitName": "4197f002d87c1c02455cc640e20f89b28b10d271",
      "commitAuthor": "Stephane Maldini",
      "commitDateOld": "2016/2/9 上午7:13",
      "commitNameOld": "29db80c3e8f1d61ef97129ff9e139b24d9de93ba",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 19.52,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 134,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,58 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Optional\u003cObject\u003e value \u003d result.getReturnValue();\n     if (!value.isPresent()) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n-            return (Mono\u003cVoid\u003e) Mono.from(publisher);\n+            return Mono.from((Publisher\u003cVoid\u003e) publisher);\n         }\n     } else {\n         publisher \u003d Mono.just(value.get());\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e92174c772c0d787be7721ae00c7189f16b05fb5": {
      "type": "Ybodychange",
      "commitMessage": "Update HandlerResult\n\nRename result to returnValue and resultType to returnValueType to\nreflect what they represent.\n\nThe returnValue getter is also wrapped as Optional since the value\nreturned from a handler may be null (e.g. void method, null value).\n",
      "commitDate": "2016/2/8 上午10:50",
      "commitName": "e92174c772c0d787be7721ae00c7189f16b05fb5",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/1/28 上午6:05",
      "commitNameOld": "381855aaf315adfd44e22797bbf14f07d08155d9",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 11.2,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n    if (!value.isPresent()) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getReturnValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return (Mono\u003cVoid\u003e) Mono.from(publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value.get());\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 134,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,58 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-    Object value \u003d result.getResult();\n-    if (value \u003d\u003d null) {\n+    Optional\u003cObject\u003e value \u003d result.getReturnValue();\n+    if (!value.isPresent()) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n-    ResolvableType returnType \u003d result.getResultType();\n+    ResolvableType returnType \u003d result.getReturnValueType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-        publisher \u003d this.conversionService.convert(value, Publisher.class);\n+        publisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return (Mono\u003cVoid\u003e) Mono.from(publisher);\n         }\n     } else {\n-        publisher \u003d Mono.just(value);\n+        publisher \u003d Mono.just(value.get());\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "381855aaf315adfd44e22797bbf14f07d08155d9": {
      "type": "Yparameterchange",
      "commitMessage": "Refine names in web.server and polish Javadoc\n\nWebServerExchange -\u003e ServerWebExchange\n\nFollows the same convention as in the http package also better allowing\nthe possibility for a client equivalent in the future.\n\nWebToHttpHandlerBuilder -\u003e WebHttpHandlerBuilder\nWebToHttpHandlerAdapter -\u003e WebHttpHandlerAdapter\n\nMore consistent with Spring conventions.\n",
      "commitDate": "2016/1/28 上午6:05",
      "commitName": "381855aaf315adfd44e22797bbf14f07d08155d9",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016/1/20 上午4:18",
      "commitNameOld": "198e31641247061d0e02f8103b6d5b4583b1c619",
      "commitAuthorOld": "Stephane Maldini",
      "daysBetweenCommits": 8.07,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return (Mono\u003cVoid\u003e) Mono.from(publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 133,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,58 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n+public Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n     Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n         if (Void.class.equals(elementType.getRawClass())) {\n             return (Mono\u003cVoid\u003e) Mono.from(publisher);\n         }\n     } else {\n         publisher \u003d Mono.just(value);\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[exchange-WebServerExchange, result-HandlerResult]",
        "newValue": "[exchange-ServerWebExchange, result-HandlerResult]"
      }
    },
    "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a": {
      "type": "Ybodychange",
      "commitMessage": "Polish @RestController support\n",
      "commitDate": "2016/1/14 下午6:06",
      "commitName": "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2016/1/14 上午7:12",
      "commitNameOld": "da90f03f4c7e192a23aaf64680cccf1c51c2b0f5",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n        if (Void.class.equals(elementType.getRawClass())) {\n            return (Mono\u003cVoid\u003e) Mono.from(publisher);\n        }\n    } else {\n        publisher \u003d Mono.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,58 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n     Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n+        if (Void.class.equals(elementType.getRawClass())) {\n+            return (Mono\u003cVoid\u003e) Mono.from(publisher);\n+        }\n     } else {\n         publisher \u003d Mono.just(value);\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f614fa0fd74ce29c5822e70f4815cc40745a2be": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
      "commitDate": "2016/1/9 上午1:30",
      "commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
      "commitAuthor": "Rossen Stoyanchev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
          "commitDate": "2016/1/9 上午1:30",
          "commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/1/7 下午6:14",
          "commitNameOld": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        publisher \u003d Mono.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 131,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,55 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Mono\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+public Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n     Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n     } else {\n         publisher \u003d Mono.just(value);\n         elementType \u003d returnType;\n     }\n-    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n+            ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]",
            "newValue": "[exchange-WebServerExchange, result-HandlerResult]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
          "commitDate": "2016/1/9 上午1:30",
          "commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/1/7 下午6:14",
          "commitNameOld": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        publisher \u003d Mono.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            ServerHttpResponse response \u003d exchange.getResponse();\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 131,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,55 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Mono\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+public Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n     Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n         return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n     } else {\n         publisher \u003d Mono.just(value);\n         elementType \u003d returnType;\n     }\n-    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n+            ServerHttpResponse response \u003d exchange.getResponse();\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8ef7e2ff77f913773e30b1463d4657368db700e5": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux\u003cT\u003e for multiple values Publisher (issue #48)\n- Mono\u003cT\u003e for single value Publisher (issue #50)\n- Mono\u003cVoid\u003e for Publisher with no value (issue #49)\n",
      "commitDate": "2016/1/7 下午6:14",
      "commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
      "commitAuthor": "Sebastien Deleuze",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux\u003cT\u003e for multiple values Publisher (issue #48)\n- Mono\u003cT\u003e for single value Publisher (issue #50)\n- Mono\u003cVoid\u003e for Publisher with no value (issue #49)\n",
          "commitDate": "2016/1/7 下午6:14",
          "commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2015/12/30 下午12:13",
          "commitNameOld": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 8.25,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        publisher \u003d Mono.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 130,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+public Mono\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n-        return Publishers.empty();\n+        return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n     } else {\n-        publisher \u003d Publishers.just(value);\n+        publisher \u003d Mono.just(value);\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n-    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Publisher\u003cVoid\u003e",
            "newValue": "Mono\u003cVoid\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux\u003cT\u003e for multiple values Publisher (issue #48)\n- Mono\u003cT\u003e for single value Publisher (issue #50)\n- Mono\u003cVoid\u003e for Publisher with no value (issue #49)\n",
          "commitDate": "2016/1/7 下午6:14",
          "commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2015/12/30 下午12:13",
          "commitNameOld": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 8.25,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Mono.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        publisher \u003d Mono.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 130,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+public Mono\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n-        return Publishers.empty();\n+        return Mono.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n     ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n     } else {\n-        publisher \u003d Publishers.just(value);\n+        publisher \u003d Mono.just(value);\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+        return Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n-    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+    return Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9789db23d2973d8f0156d2b6c6027d9fb67ab844": {
      "type": "Ybodychange",
      "commitMessage": "Rename HandlerResult fields from value to result\n",
      "commitDate": "2015/12/30 下午12:13",
      "commitName": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/12/11 上午5:35",
      "commitNameOld": "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 19.28,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getResult();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getResultType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        publisher \u003d Publishers.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n-    Object value \u003d result.getValue();\n+    Object value \u003d result.getResult();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     Publisher\u003c?\u003e publisher;\n     ResolvableType elementType;\n-    ResolvableType returnType \u003d result.getValueType();\n+    ResolvableType returnType \u003d result.getResultType();\n     if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n         publisher \u003d this.conversionService.convert(value, Publisher.class);\n         elementType \u003d returnType.getGeneric(0);\n     } else {\n         publisher \u003d Publishers.just(value);\n         elementType \u003d returnType;\n     }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a0018d13e19f7fe7ef7a98979476d9cd2851a10c": {
      "type": "Ybodychange",
      "commitMessage": "Add DispatcherHandlerErrorTests\n\nThe tests demonstrate failures at various phases of request processing\nand the resulting error signals.\n",
      "commitDate": "2015/12/11 上午5:35",
      "commitName": "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/12/3 上午6:46",
      "commitNameOld": "da98becf72fbeef836dba366431be2a652e5e001",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    Publisher\u003c?\u003e publisher;\n    ResolvableType elementType;\n    ResolvableType returnType \u003d result.getValueType();\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        publisher \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        publisher \u003d Publishers.just(value);\n        elementType \u003d returnType;\n    }\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n+    Publisher\u003c?\u003e publisher;\n+    ResolvableType elementType;\n     ResolvableType returnType \u003d result.getValueType();\n+    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+        publisher \u003d this.conversionService.convert(value, Publisher.class);\n+        elementType \u003d returnType.getGeneric(0);\n+    } else {\n+        publisher \u003d Publishers.just(value);\n+        elementType \u003d returnType;\n+    }\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n-        Publisher\u003c?\u003e publisher;\n-        ResolvableType elementType;\n-        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-            publisher \u003d this.conversionService.convert(value, Publisher.class);\n-            elementType \u003d returnType.getGeneric(0);\n-        } else {\n-            publisher \u003d Publishers.just(value);\n-            elementType \u003d returnType;\n-        }\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da98becf72fbeef836dba366431be2a652e5e001": {
      "type": "Yparameterchange",
      "commitMessage": "Move http.server to http.server.reactive\n",
      "commitDate": "2015/12/3 上午6:46",
      "commitName": "da98becf72fbeef836dba366431be2a652e5e001",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/23 上午4:02",
      "commitNameOld": "4a3c0bc3b615df84afd7deb18bc102f5d363076e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 10.11,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType returnType \u003d result.getValueType();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Publisher\u003c?\u003e publisher;\n        ResolvableType elementType;\n        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n            publisher \u003d this.conversionService.convert(value, Publisher.class);\n            elementType \u003d returnType.getGeneric(0);\n        } else {\n            publisher \u003d Publishers.just(value);\n            elementType \u003d returnType;\n        }\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n+public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType returnType \u003d result.getValueType();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n     if (producibleMediaTypes.isEmpty()) {\n         producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Publisher\u003c?\u003e publisher;\n         ResolvableType elementType;\n         if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n             publisher \u003d this.conversionService.convert(value, Publisher.class);\n             elementType \u003d returnType.getGeneric(0);\n         } else {\n             publisher \u003d Publishers.just(value);\n             elementType \u003d returnType;\n         }\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[request-ReactiveServerHttpRequest, response-ReactiveServerHttpResponse, result-HandlerResult]",
        "newValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]"
      }
    },
    "911d3769224d009fb9fe08c6cb5489686bbc5713": {
      "type": "Ybodychange",
      "commitMessage": "Improve MimeType -\u003e MediaType handling\n\nThis change adds an Encoder-to-MediaType lookup in\nResponseBodyResultHandler to avoid MimeType to MediaType creation at\nruntime.\n",
      "commitDate": "2015/11/23 上午3:41",
      "commitName": "911d3769224d009fb9fe08c6cb5489686bbc5713",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/14 上午6:49",
      "commitNameOld": "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 8.87,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType returnType \u003d result.getValueType();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n    if (producibleMediaTypes.isEmpty()) {\n        producibleMediaTypes.add(MediaType.ALL);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Publisher\u003c?\u003e publisher;\n        ResolvableType elementType;\n        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n            publisher \u003d this.conversionService.convert(value, Publisher.class);\n            elementType \u003d returnType.getGeneric(0);\n        } else {\n            publisher \u003d Publishers.just(value);\n            elementType \u003d returnType;\n        }\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType returnType \u003d result.getValueType();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n     if (producibleMediaTypes.isEmpty()) {\n-        Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n+        producibleMediaTypes.add(MediaType.ALL);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Publisher\u003c?\u003e publisher;\n         ResolvableType elementType;\n         if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n             publisher \u003d this.conversionService.convert(value, Publisher.class);\n             elementType \u003d returnType.getGeneric(0);\n         } else {\n             publisher \u003d Publishers.just(value);\n             elementType \u003d returnType;\n         }\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n-    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n+    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "81867fa4237643ca3eae24a8f085bc4b5f9443b3": {
      "type": "Yfilerename",
      "commitMessage": "Refactor package structure for web\n\nThe web related code is now under org.springframework.web.reactive.\nThis is parallel to org.springframework.web (the top-level package of\nspring-webmvc).\n",
      "commitDate": "2015/11/14 上午6:49",
      "commitName": "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/14 上午6:23",
      "commitNameOld": "54ce20a5e04275835b40f2cd1453db778264191e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType returnType \u003d result.getValueType();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n    if (producibleMediaTypes.isEmpty()) {\n        Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Publisher\u003c?\u003e publisher;\n        ResolvableType elementType;\n        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n            publisher \u003d this.conversionService.convert(value, Publisher.class);\n            elementType \u003d returnType.getGeneric(0);\n        } else {\n            publisher \u003d Publishers.just(value);\n            elementType \u003d returnType;\n        }\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
        "newPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java"
      }
    },
    "54ce20a5e04275835b40f2cd1453db778264191e": {
      "type": "Ybodychange",
      "commitMessage": "Rename field in HandlerResult\n",
      "commitDate": "2015/11/14 上午6:23",
      "commitName": "54ce20a5e04275835b40f2cd1453db778264191e",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/14 上午6:09",
      "commitNameOld": "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType returnType \u003d result.getValueType();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n    if (producibleMediaTypes.isEmpty()) {\n        Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Publisher\u003c?\u003e publisher;\n        ResolvableType elementType;\n        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n            publisher \u003d this.conversionService.convert(value, Publisher.class);\n            elementType \u003d returnType.getGeneric(0);\n        } else {\n            publisher \u003d Publishers.just(value);\n            elementType \u003d returnType;\n        }\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n-    ResolvableType returnType \u003d result.getType();\n+    ResolvableType returnType \u003d result.getValueType();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n     if (producibleMediaTypes.isEmpty()) {\n         Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Publisher\u003c?\u003e publisher;\n         ResolvableType elementType;\n         if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n             publisher \u003d this.conversionService.convert(value, Publisher.class);\n             elementType \u003d returnType.getGeneric(0);\n         } else {\n             publisher \u003d Publishers.just(value);\n             elementType \u003d returnType;\n         }\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6713c23e327961d021706e5b1e4d5ebe8e2f458": {
      "type": "Ybodychange",
      "commitMessage": "Add a ResolvableType field to HandlerResult\n\nThis change allows to be able to check generic type on the return value\nat HandlerAdapter and ResultHandler level. For example, it allows to do\na Publisher\u003cVoid\u003e check in SimpleHandlerResultHandler.\n",
      "commitDate": "2015/11/14 上午6:09",
      "commitName": "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/11/14 上午5:47",
      "commitNameOld": "5d4201d50079fc36fee21617ece1bfbbcf194120",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType returnType \u003d result.getType();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n    if (producibleMediaTypes.isEmpty()) {\n        Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Publisher\u003c?\u003e publisher;\n        ResolvableType elementType;\n        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n            publisher \u003d this.conversionService.convert(value, Publisher.class);\n            elementType \u003d returnType.getGeneric(0);\n        } else {\n            publisher \u003d Publishers.just(value);\n            elementType \u003d returnType;\n        }\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,54 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n-    HandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n-    ResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n+    ResolvableType returnType \u003d result.getType();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n     if (producibleMediaTypes.isEmpty()) {\n         Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         Publisher\u003c?\u003e publisher;\n         ResolvableType elementType;\n         if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n             publisher \u003d this.conversionService.convert(value, Publisher.class);\n             elementType \u003d returnType.getGeneric(0);\n         } else {\n             publisher \u003d Publishers.just(value);\n             elementType \u003d returnType;\n         }\n         Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n         if (encoder !\u003d null) {\n             response.getHeaders().setContentType(selectedMediaType);\n             return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n         }\n     }\n     return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d4201d50079fc36fee21617ece1bfbbcf194120": {
      "type": "Ybodychange",
      "commitMessage": "Fix \"Content-Type\" and \"Accept\" header processing\n\n\"Content-Type\" is just a single MediaType.\n\nFor the response, the MediaType must be fully selected before\nselecting and encoder.\n\nThe ResponseBodyResultHandler now includes actual content negotiation\nwith a potential 406 response.\n",
      "commitDate": "2015/11/14 上午5:47",
      "commitName": "5d4201d50079fc36fee21617ece1bfbbcf194120",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/14 上午4:55",
      "commitNameOld": "2de127ad4ad8dcb81521039749308de58ac81420",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    HandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n    ResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n    if (producibleMediaTypes.isEmpty()) {\n        Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        Publisher\u003c?\u003e publisher;\n        ResolvableType elementType;\n        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n            publisher \u003d this.conversionService.convert(value, Publisher.class);\n            elementType \u003d returnType.getGeneric(0);\n        } else {\n            publisher \u003d Publishers.just(value);\n            elementType \u003d returnType;\n        }\n        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n        if (encoder !\u003d null) {\n            response.getHeaders().setContentType(selectedMediaType);\n            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n        }\n    }\n    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,36 +1,55 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     HandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n     ResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n-    Publisher\u003c?\u003e elementStream;\n-    ResolvableType elementType;\n-    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-        elementStream \u003d this.conversionService.convert(value, Publisher.class);\n-        elementType \u003d returnType.getGeneric(0);\n-    } else {\n-        elementStream \u003d Publishers.just(value);\n-        elementType \u003d returnType;\n+    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n+    if (producibleMediaTypes.isEmpty()) {\n+        Publishers.error(new IllegalArgumentException(\"No encoder found for return value of type: \" + returnType));\n     }\n-    MediaType mediaType \u003d resolveMediaType(request);\n-    Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, mediaType);\n-    if (encoder \u003d\u003d null) {\n-        return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n-    }\n-    Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode((Publisher) elementStream, returnType, mediaType);\n-    if (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n-        List\u003cMimeType\u003e mimeTypes \u003d encoder.getSupportedMimeTypes();\n-        if (!mimeTypes.isEmpty()) {\n-            MimeType mimeType \u003d mimeTypes.get(0);\n-            mediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n+    for (MediaType requestedType : requestedMediaTypes) {\n+        for (MediaType producibleType : producibleMediaTypes) {\n+            if (requestedType.isCompatibleWith(producibleType)) {\n+                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n+            }\n         }\n     }\n-    if (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n-        response.getHeaders().setContentType(mediaType);\n+    if (compatibleMediaTypes.isEmpty()) {\n+        return Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n     }\n-    return response.setBody(outputStream);\n+    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n+    MediaType.sortBySpecificityAndQuality(mediaTypes);\n+    MediaType selectedMediaType \u003d null;\n+    for (MediaType mediaType : mediaTypes) {\n+        if (mediaType.isConcrete()) {\n+            selectedMediaType \u003d mediaType;\n+            break;\n+        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n+            break;\n+        }\n+    }\n+    if (selectedMediaType !\u003d null) {\n+        Publisher\u003c?\u003e publisher;\n+        ResolvableType elementType;\n+        if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+            publisher \u003d this.conversionService.convert(value, Publisher.class);\n+            elementType \u003d returnType.getGeneric(0);\n+        } else {\n+            publisher \u003d Publishers.just(value);\n+            elementType \u003d returnType;\n+        }\n+        Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n+        if (encoder !\u003d null) {\n+            response.getHeaders().setContentType(selectedMediaType);\n+            return response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n+        }\n+    }\n+    return Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2de127ad4ad8dcb81521039749308de58ac81420": {
      "type": "Ybodychange",
      "commitMessage": "Polish\n",
      "commitDate": "2015/11/14 上午4:55",
      "commitName": "2de127ad4ad8dcb81521039749308de58ac81420",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/14 上午4:01",
      "commitNameOld": "bdc5b38cb12d26605a968845338bef5bad22816d",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    HandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n    ResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n    Publisher\u003c?\u003e elementStream;\n    ResolvableType elementType;\n    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n        elementStream \u003d this.conversionService.convert(value, Publisher.class);\n        elementType \u003d returnType.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d returnType;\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, mediaType);\n    if (encoder \u003d\u003d null) {\n        return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n    }\n    Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode((Publisher) elementStream, returnType, mediaType);\n    if (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n        List\u003cMimeType\u003e mimeTypes \u003d encoder.getSupportedMimeTypes();\n        if (!mimeTypes.isEmpty()) {\n            MimeType mimeType \u003d mimeTypes.get(0);\n            mediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n        }\n    }\n    if (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n        response.getHeaders().setContentType(mediaType);\n    }\n    return response.setBody(outputStream);\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 88,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,36 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n-    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n-    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n-    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n-    MediaType mediaType \u003d resolveMediaType(request);\n+    HandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n+    ResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n     Publisher\u003c?\u003e elementStream;\n     ResolvableType elementType;\n-    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n-        elementStream \u003d conversionService.convert(value, Publisher.class);\n-        elementType \u003d type.getGeneric(0);\n+    if (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+        elementStream \u003d this.conversionService.convert(value, Publisher.class);\n+        elementType \u003d returnType.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n-        elementType \u003d type;\n+        elementType \u003d returnType;\n     }\n-    Encoder\u003c?\u003e serializer \u003d resolveSerializer(elementType, mediaType);\n-    if (serializer !\u003d null) {\n-        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode((Publisher) elementStream, type, mediaType);\n-        if (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n-            List\u003cMimeType\u003e mimeTypes \u003d serializer.getSupportedMimeTypes();\n-            if (!mimeTypes.isEmpty()) {\n-                MimeType mimeType \u003d mimeTypes.get(0);\n-                mediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n-            }\n-        }\n-        if (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n-            response.getHeaders().setContentType(mediaType);\n-        }\n-        return response.setBody(outputStream);\n+    MediaType mediaType \u003d resolveMediaType(request);\n+    Encoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, mediaType);\n+    if (encoder \u003d\u003d null) {\n+        return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n     }\n-    String returnTypeName \u003d returnType.getParameterType().getName();\n-    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n+    Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode((Publisher) elementStream, returnType, mediaType);\n+    if (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n+        List\u003cMimeType\u003e mimeTypes \u003d encoder.getSupportedMimeTypes();\n+        if (!mimeTypes.isEmpty()) {\n+            MimeType mimeType \u003d mimeTypes.get(0);\n+            mediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+        }\n+    }\n+    if (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n+        response.getHeaders().setContentType(mediaType);\n+    }\n+    return response.setBody(outputStream);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bdc5b38cb12d26605a968845338bef5bad22816d": {
      "type": "Ybodychange",
      "commitMessage": "Refactor codecs\n\nThis commit introduces the following changes:\n - MessageToByteEncoder/Decoder renamed to Encoder/Decoder\n - JsonObjectEncoder/Decoder are now used directly in\n   JacksonJsonEncoder/Decoder\n - Codec uses MimeType instead of MediaType since they\n   are not specific to HTTP\n - Default MimeType are now managed thanks to\n   Encoder/Decoder#getSupportedMimeTypes()\n - AbstractEncoder/Decoder takes care of generic MimeType related behavior\n",
      "commitDate": "2015/11/14 上午4:01",
      "commitName": "bdc5b38cb12d26605a968845338bef5bad22816d",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/10/31 上午5:58",
      "commitNameOld": "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 13.92,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    Publisher\u003c?\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    Encoder\u003c?\u003e serializer \u003d resolveSerializer(elementType, mediaType);\n    if (serializer !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode((Publisher) elementStream, type, mediaType);\n        if (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n            List\u003cMimeType\u003e mimeTypes \u003d serializer.getSupportedMimeTypes();\n            if (!mimeTypes.isEmpty()) {\n                MimeType mimeType \u003d mimeTypes.get(0);\n                mediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n            }\n        }\n        if (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n            response.getHeaders().setContentType(mediaType);\n        }\n        return response.setBody(outputStream);\n    }\n    String returnTypeName \u003d returnType.getParameterType().getName();\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 88,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,38 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     MediaType mediaType \u003d resolveMediaType(request);\n-    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n-    hints.add(UTF_8);\n-    Publisher\u003cObject\u003e elementStream;\n+    Publisher\u003c?\u003e elementStream;\n     ResolvableType elementType;\n     if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n         elementStream \u003d conversionService.convert(value, Publisher.class);\n         elementType \u003d type.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n         elementType \u003d type;\n     }\n-    MessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(elementType, mediaType, hints.toArray());\n-    if (encoder !\u003d null) {\n-        Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n-        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(elementType, mediaType, hints.toArray());\n-        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n-            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n+    Encoder\u003c?\u003e serializer \u003d resolveSerializer(elementType, mediaType);\n+    if (serializer !\u003d null) {\n+        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode((Publisher) elementStream, type, mediaType);\n+        if (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n+            List\u003cMimeType\u003e mimeTypes \u003d serializer.getSupportedMimeTypes();\n+            if (!mimeTypes.isEmpty()) {\n+                MimeType mimeType \u003d mimeTypes.get(0);\n+                mediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+            }\n         }\n-        response.getHeaders().setContentType(mediaType);\n+        if (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n+            response.getHeaders().setContentType(mediaType);\n+        }\n         return response.setBody(outputStream);\n     }\n     String returnTypeName \u003d returnType.getParameterType().getName();\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b": {
      "type": "Ybodychange",
      "commitMessage": "Replace DefaultConversionService in spring-reactive\n",
      "commitDate": "2015/10/31 上午5:58",
      "commitName": "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/10/31 上午5:22",
      "commitNameOld": "c0dff3d2bb2277429f4e387d18deb75b0797a375",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(elementType, mediaType, hints.toArray());\n    if (encoder !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.setBody(outputStream);\n    }\n    String returnTypeName \u003d returnType.getParameterType().getName();\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 100,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     Publisher\u003cObject\u003e elementStream;\n     ResolvableType elementType;\n     if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n         elementStream \u003d conversionService.convert(value, Publisher.class);\n         elementType \u003d type.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n         elementType \u003d type;\n     }\n-    MessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(request, elementType, mediaType, hints.toArray());\n+    MessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(elementType, mediaType, hints.toArray());\n     if (encoder !\u003d null) {\n         Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n-        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n+        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.setBody(outputStream);\n     }\n     String returnTypeName \u003d returnType.getParameterType().getName();\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c0dff3d2bb2277429f4e387d18deb75b0797a375": {
      "type": "Ybodychange",
      "commitMessage": "Comply with Spring Framework code style\n\nhttps://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Code-Style\n",
      "commitDate": "2015/10/31 上午5:22",
      "commitName": "c0dff3d2bb2277429f4e387d18deb75b0797a375",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/10/30 下午6:03",
      "commitNameOld": "01ae961820768bfe9c1f948a74a37104dcdef992",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 0.47,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(request, elementType, mediaType, hints.toArray());\n    if (encoder !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.setBody(outputStream);\n    }\n    String returnTypeName \u003d returnType.getParameterType().getName();\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 107,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,35 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     Publisher\u003cObject\u003e elementStream;\n     ResolvableType elementType;\n     if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n         elementStream \u003d conversionService.convert(value, Publisher.class);\n         elementType \u003d type.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n         elementType \u003d type;\n     }\n-    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n-    if (serializer !\u003d null) {\n-        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n+    MessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(request, elementType, mediaType, hints.toArray());\n+    if (encoder !\u003d null) {\n+        Publisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.setBody(outputStream);\n     }\n-    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n+    String returnTypeName \u003d returnType.getParameterType().getName();\n+    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a88974bc9545eff6c7de07d054a2836dcbdfca": {
      "type": "Ybodychange",
      "commitMessage": "Changed addBody() to setBody()\n",
      "commitDate": "2015/10/29 下午11:28",
      "commitName": "45a88974bc9545eff6c7de07d054a2836dcbdfca",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2015/10/29 下午10:45",
      "commitNameOld": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.setBody(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 108,
      "functionName": "handleResult",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     Publisher\u003cObject\u003e elementStream;\n     ResolvableType elementType;\n     if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n         elementStream \u003d conversionService.convert(value, Publisher.class);\n         elementType \u003d type.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n         elementType \u003d type;\n     }\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n-        return response.addBody(outputStream);\n+        return response.setBody(outputStream);\n     }\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
      "commitDate": "2015/10/29 下午10:45",
      "commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
      "commitAuthor": "Arjen Poutsma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
          "commitDate": "2015/10/29 下午10:45",
          "commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2015/10/29 下午5:50",
          "commitNameOld": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 0.21,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.addBody(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 108,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,34 +1,34 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     Publisher\u003cObject\u003e elementStream;\n     ResolvableType elementType;\n     if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n         elementStream \u003d conversionService.convert(value, Publisher.class);\n         elementType \u003d type.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n         elementType \u003d type;\n     }\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n-        return response.writeWith(outputStream);\n+        return response.addBody(outputStream);\n     }\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]",
            "newValue": "[request-ReactiveServerHttpRequest, response-ReactiveServerHttpResponse, result-HandlerResult]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
          "commitDate": "2015/10/29 下午10:45",
          "commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2015/10/29 下午5:50",
          "commitNameOld": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 0.21,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.addBody(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 108,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,34 +1,34 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+public Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     Publisher\u003cObject\u003e elementStream;\n     ResolvableType elementType;\n     if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n         elementStream \u003d conversionService.convert(value, Publisher.class);\n         elementType \u003d type.getGeneric(0);\n     } else {\n         elementStream \u003d Publishers.just(value);\n         elementType \u003d type;\n     }\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n-        return response.writeWith(outputStream);\n+        return response.addBody(outputStream);\n     }\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Add handler method parameter and result converters\n\nThis commit introduces the following changes:\n - Publisher -\u003e Observable/Stream/etc. conversion is now managed\n    in a dedicated ConversionService instead of directly in\n    RequestBodyArgumentResolver and ResponseBodyResultHandler\n - More isolated logic that decides if the stream should be\n    serialized as a JSON array or not\n - Publisher\u003cByteBuffer\u003e are now handled by regular\n   ByteBufferEncoder and ByteBufferDecoder\n - Handle Publisher\u003cVoid\u003e return value properly\n - Ensure that the headers are properly written even for response\n   without body\n - Improve JsonObjectEncoder to autodetect JSON arrays\n",
      "commitDate": "2015/10/29 下午5:50",
      "commitName": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
      "commitAuthor": "Sebastien Deleuze",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Add handler method parameter and result converters\n\nThis commit introduces the following changes:\n - Publisher -\u003e Observable/Stream/etc. conversion is now managed\n    in a dedicated ConversionService instead of directly in\n    RequestBodyArgumentResolver and ResponseBodyResultHandler\n - More isolated logic that decides if the stream should be\n    serialized as a JSON array or not\n - Publisher\u003cByteBuffer\u003e are now handled by regular\n   ByteBufferEncoder and ByteBufferDecoder\n - Handle Publisher\u003cVoid\u003e return value properly\n - Ensure that the headers are properly written even for response\n   without body\n - Improve JsonObjectEncoder to autodetect JSON arrays\n",
          "commitDate": "2015/10/29 下午5:50",
          "commitName": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2015/10/19 下午5:15",
          "commitNameOld": "cf2c1514af43bc955571ede20876d6cda1779f11",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 10.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 98,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,38 +1,34 @@\n @Override\n+@SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n-    MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n+    MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n-    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n+    Publisher\u003cObject\u003e elementStream;\n+    ResolvableType elementType;\n+    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n+        elementStream \u003d conversionService.convert(value, Publisher.class);\n+        elementType \u003d type.getGeneric(0);\n+    } else {\n+        elementStream \u003d Publishers.just(value);\n+        elementType \u003d type;\n+    }\n+    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n-        Publisher\u003cObject\u003e elementStream;\n-        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d ((Promise) value).stream();\n-        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d RxJava1Converter.from((Observable) value);\n-        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d RxJava1SingleConverter.from((Single) value);\n-        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n-        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d (Publisher) value;\n-        } else {\n-            elementStream \u003d Publishers.just(value);\n-        }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n-        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n+        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n-            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.writeWith(outputStream);\n     }\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Add handler method parameter and result converters\n\nThis commit introduces the following changes:\n - Publisher -\u003e Observable/Stream/etc. conversion is now managed\n    in a dedicated ConversionService instead of directly in\n    RequestBodyArgumentResolver and ResponseBodyResultHandler\n - More isolated logic that decides if the stream should be\n    serialized as a JSON array or not\n - Publisher\u003cByteBuffer\u003e are now handled by regular\n   ByteBufferEncoder and ByteBufferDecoder\n - Handle Publisher\u003cVoid\u003e return value properly\n - Ensure that the headers are properly written even for response\n   without body\n - Improve JsonObjectEncoder to autodetect JSON arrays\n",
          "commitDate": "2015/10/29 下午5:50",
          "commitName": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2015/10/19 下午5:15",
          "commitNameOld": "cf2c1514af43bc955571ede20876d6cda1779f11",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 10.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    MediaType mediaType \u003d resolveMediaType(request);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    Publisher\u003cObject\u003e elementStream;\n    ResolvableType elementType;\n    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n        elementStream \u003d conversionService.convert(value, Publisher.class);\n        elementType \u003d type.getGeneric(0);\n    } else {\n        elementStream \u003d Publishers.just(value);\n        elementType \u003d type;\n    }\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
          "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 98,
          "functionName": "handleResult",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,38 +1,34 @@\n @Override\n+@SuppressWarnings(\"unchecked\")\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n-    MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n+    MediaType mediaType \u003d resolveMediaType(request);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n-    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n+    Publisher\u003cObject\u003e elementStream;\n+    ResolvableType elementType;\n+    if (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n+        elementStream \u003d conversionService.convert(value, Publisher.class);\n+        elementType \u003d type.getGeneric(0);\n+    } else {\n+        elementStream \u003d Publishers.just(value);\n+        elementType \u003d type;\n+    }\n+    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n-        Publisher\u003cObject\u003e elementStream;\n-        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d ((Promise) value).stream();\n-        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d RxJava1Converter.from((Observable) value);\n-        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d RxJava1SingleConverter.from((Single) value);\n-        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n-        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d (Publisher) value;\n-        } else {\n-            elementStream \u003d Publishers.just(value);\n-        }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n-        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n+        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n-            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+            outputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.writeWith(outputStream);\n     }\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": "@Override,@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "cf2c1514af43bc955571ede20876d6cda1779f11": {
      "type": "Ybodychange",
      "commitMessage": "Use latest Reactor core capabilities\n\n No need for rxjava-reactive-streams dependency and\n CompletableFutureUtils anymore.\n",
      "commitDate": "2015/10/19 下午5:15",
      "commitName": "cf2c1514af43bc955571ede20876d6cda1779f11",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/10/16 下午3:13",
      "commitNameOld": "8ca04b84259f1840db7e1037828f7120427eb7b1",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 3.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cObject\u003e elementStream;\n        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d ((Promise) value).stream();\n        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxJava1Converter.from((Observable) value);\n        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxJava1SingleConverter.from((Single) value);\n        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d (Publisher) value;\n        } else {\n            elementStream \u003d Publishers.just(value);\n        }\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 98,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cObject\u003e elementStream;\n         if (Promise.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d ((Promise) value).stream();\n         } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n+            elementStream \u003d RxJava1Converter.from((Observable) value);\n         } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n+            elementStream \u003d RxJava1SingleConverter.from((Single) value);\n         } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-            elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n+            elementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n         } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d (Publisher) value;\n         } else {\n             elementStream \u003d Publishers.just(value);\n         }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.writeWith(outputStream);\n     }\n     return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8ca04b84259f1840db7e1037828f7120427eb7b1": {
      "type": "Ybodychange",
      "commitMessage": "More accurate ResponseBodyResultHandler error message\n",
      "commitDate": "2015/10/16 下午3:13",
      "commitName": "8ca04b84259f1840db7e1037828f7120427eb7b1",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/10/7 下午7:24",
      "commitNameOld": "464ff1d9606a3189a41bae80e504929dec091d33",
      "commitAuthorOld": "Stephane Maldini",
      "daysBetweenCommits": 8.83,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cObject\u003e elementStream;\n        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d ((Promise) value).stream();\n        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d (Publisher) value;\n        } else {\n            elementStream \u003d Publishers.just(value);\n        }\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 97,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Publishers.empty();\n     }\n     MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cObject\u003e elementStream;\n         if (Promise.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d ((Promise) value).stream();\n         } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n         } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n         } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n         } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d (Publisher) value;\n         } else {\n             elementStream \u003d Publishers.just(value);\n         }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.writeWith(outputStream);\n     }\n-    return Publishers.error(new IllegalStateException(\"Return value type not supported: \" + returnType));\n+    return Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "464ff1d9606a3189a41bae80e504929dec091d33": {
      "type": "Ybodychange",
      "commitMessage": "Progress #24\nReplace Streams fail, empty and Stream map with Publishers.error, empty and map.\nReplace Streams calls by Publishers.flatMap, just and Publishers.from\nPrecise cancel and size to toReadQueue to simulate Promise\nUpdate build\n",
      "commitDate": "2015/10/7 下午7:24",
      "commitName": "464ff1d9606a3189a41bae80e504929dec091d33",
      "commitAuthor": "Stephane Maldini",
      "commitDateOld": "2015/10/3 上午2:09",
      "commitNameOld": "9516c9992f4ed53bbb0be801bed31b6280eaff8c",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 4.72,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Publishers.empty();\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cObject\u003e elementStream;\n        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d ((Promise) value).stream();\n        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d (Publisher) value;\n        } else {\n            elementStream \u003d Publishers.just(value);\n        }\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(outputStream);\n    }\n    return Publishers.error(new IllegalStateException(\"Return value type not supported: \" + returnType));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 97,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n-        return Streams.empty();\n+        return Publishers.empty();\n     }\n     MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cObject\u003e elementStream;\n         if (Promise.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d ((Promise) value).stream();\n         } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n         } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n         } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n         } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d (Publisher) value;\n         } else {\n-            elementStream \u003d Streams.just(value);\n+            elementStream \u003d Publishers.just(value);\n         }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n-        return response.writeWith(Streams.wrap(outputStream));\n+        return response.writeWith(outputStream);\n     }\n-    return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n+    return Publishers.error(new IllegalStateException(\"Return value type not supported: \" + returnType));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f816cc6a516c324875fa409a33d288447c6996f7": {
      "type": "Ybodychange",
      "commitMessage": "Add CompletableFuture/Single/Promise support\n",
      "commitDate": "2015/9/25 上午5:02",
      "commitName": "f816cc6a516c324875fa409a33d288447c6996f7",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/9/22 下午2:02",
      "commitNameOld": "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 2.62,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Streams.empty();\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cObject\u003e elementStream;\n        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d ((Promise) value).stream();\n        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d (Publisher) value;\n        } else {\n            elementStream \u003d Streams.just(value);\n        }\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(Streams.wrap(outputStream));\n    }\n    return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 96,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,38 @@\n @Override\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Streams.empty();\n     }\n     MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cObject\u003e elementStream;\n-        if (Observable.class.isAssignableFrom(type.getRawClass())) {\n+        if (Promise.class.isAssignableFrom(type.getRawClass())) {\n+            elementStream \u003d ((Promise) value).stream();\n+        } else if (Observable.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n+        } else if (Single.class.isAssignableFrom(type.getRawClass())) {\n+            elementStream \u003d RxReactiveStreams.toPublisher(((Single) value).toObservable());\n+        } else if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n+            elementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n         } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d (Publisher) value;\n         } else {\n             elementStream \u003d Streams.just(value);\n         }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n         return response.writeWith(Streams.wrap(outputStream));\n     }\n     return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "110d9d7cd906c524af5053329a65ef4e1bd9f7eb": {
      "type": "Ybodychange",
      "commitMessage": "Use ByteBuffer instead of byte[]\n",
      "commitDate": "2015/9/22 下午2:02",
      "commitName": "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/9/10 下午7:47",
      "commitNameOld": "881db0688b5448768e1b3196fe5365a3d41d9342",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 11.76,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Streams.empty();\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cObject\u003e elementStream;\n        if (Observable.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d (Publisher) value;\n        } else {\n            elementStream \u003d Streams.just(value);\n        }\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(Streams.wrap(outputStream));\n    }\n    return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 91,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n @Override\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Streams.empty();\n     }\n     MediaType mediaType \u003d resolveMediaType(request);\n     ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n     List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n     hints.add(UTF_8);\n     MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n     if (serializer !\u003d null) {\n         Publisher\u003cObject\u003e elementStream;\n         if (Observable.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n         } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n             elementStream \u003d (Publisher) value;\n         } else {\n             elementStream \u003d Streams.just(value);\n         }\n         Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n         List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n         for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n             outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n         }\n         response.getHeaders().setContentType(mediaType);\n-        return response.writeWith(Streams.wrap(outputStream).map(buffer -\u003e new Buffer(buffer).asBytes()));\n+        return response.writeWith(Streams.wrap(outputStream));\n     }\n     return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "881db0688b5448768e1b3196fe5365a3d41d9342": {
      "type": "Ybodychange",
      "commitMessage": "Add Codec support\n\nThis commit adds support for Publisher based codecs that allows to convert\nbyte stream to object stream and vice \u0026 versa.\n\nJackson, JAXB2 and String codec implementations are provided.\n",
      "commitDate": "2015/9/10 下午7:47",
      "commitName": "881db0688b5448768e1b3196fe5365a3d41d9342",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/8/26 上午12:45",
      "commitNameOld": "202825554c022e4262fe3bd20a34faf01ab9d620",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 15.79,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Streams.empty();\n    }\n    MediaType mediaType \u003d resolveMediaType(request);\n    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n    hints.add(UTF_8);\n    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n    if (serializer !\u003d null) {\n        Publisher\u003cObject\u003e elementStream;\n        if (Observable.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n            elementStream \u003d (Publisher) value;\n        } else {\n            elementStream \u003d Streams.just(value);\n        }\n        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n        }\n        response.getHeaders().setContentType(mediaType);\n        return response.writeWith(Streams.wrap(outputStream).map(buffer -\u003e new Buffer(buffer).asBytes()));\n    }\n    return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 92,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,32 @@\n @Override\n public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n     Object value \u003d result.getValue();\n     HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n     MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n     if (value \u003d\u003d null) {\n         return Streams.empty();\n     }\n-    if (value instanceof String) {\n-        response.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n-        return response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n-    } else if (value instanceof Publisher) {\n-        Class\u003c?\u003e type \u003d ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n-        if (String.class.equals(type)) {\n-            @SuppressWarnings(\"unchecked\") Publisher\u003cString\u003e content \u003d (Publisher\u003cString\u003e) value;\n-            return response.writeWith(Streams.wrap(content).map(value1 -\u003e value1.getBytes(UTF_8)));\n+    MediaType mediaType \u003d resolveMediaType(request);\n+    ResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n+    List\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n+    hints.add(UTF_8);\n+    MessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, type, mediaType, hints.toArray());\n+    if (serializer !\u003d null) {\n+        Publisher\u003cObject\u003e elementStream;\n+        if (Observable.class.isAssignableFrom(type.getRawClass())) {\n+            elementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n+        } else if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n+            elementStream \u003d (Publisher) value;\n+        } else {\n+            elementStream \u003d Streams.just(value);\n         }\n+        Publisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n+        List\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n+        for (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n+            outputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+        }\n+        response.getHeaders().setContentType(mediaType);\n+        return response.writeWith(Streams.wrap(outputStream).map(buffer -\u003e new Buffer(buffer).asBytes()));\n     }\n     return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "202825554c022e4262fe3bd20a34faf01ab9d620": {
      "type": "Yintroduced",
      "commitMessage": "Add basic support for @RequestMapping\n\nJust enough for a test with an @ResponseBody method that accepts an\n@RequestParam String arg and returning Publisher\u003cString\u003e or String.\n\nSee RequestMappingIntegrationTests.\n",
      "commitDate": "2015/8/26 上午12:45",
      "commitName": "202825554c022e4262fe3bd20a34faf01ab9d620",
      "commitAuthor": "Rossen Stoyanchev",
      "diff": "@@ -0,0 +1,20 @@\n+@Override\n+public Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n+    Object value \u003d result.getValue();\n+    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n+    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n+    if (value \u003d\u003d null) {\n+        return Streams.empty();\n+    }\n+    if (value instanceof String) {\n+        response.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n+        return response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n+    } else if (value instanceof Publisher) {\n+        Class\u003c?\u003e type \u003d ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n+        if (String.class.equals(type)) {\n+            @SuppressWarnings(\"unchecked\") Publisher\u003cString\u003e content \u003d (Publisher\u003cString\u003e) value;\n+            return response.writeWith(Streams.wrap(content).map(value1 -\u003e value1.getBytes(UTF_8)));\n+        }\n+    }\n+    return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response, HandlerResult result) {\n    Object value \u003d result.getValue();\n    HandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n    MethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n    if (value \u003d\u003d null) {\n        return Streams.empty();\n    }\n    if (value instanceof String) {\n        response.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n        return response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n    } else if (value instanceof Publisher) {\n        Class\u003c?\u003e type \u003d ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n        if (String.class.equals(type)) {\n            @SuppressWarnings(\"unchecked\") Publisher\u003cString\u003e content \u003d (Publisher\u003cString\u003e) value;\n            return response.writeWith(Streams.wrap(content).map(value1 -\u003e value1.getBytes(UTF_8)));\n        }\n    }\n    return Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 72,
      "functionName": "handleResult",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}