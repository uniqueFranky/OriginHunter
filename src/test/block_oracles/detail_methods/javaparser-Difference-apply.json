{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "Difference.java",
  "functionName": "apply",
  "functionId": "apply",
  "sourceFilePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
  "functionAnnotation": "",
  "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
  "functionStartLine": 115,
  "functionEndLine": 144,
  "numCommitsSeen": 180,
  "timeTaken": 4020,
  "changeHistory": [
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
    "996b78486d0db86dece4457a7faa9b314dc3b847",
    "0a54807d59a9f39be0d222ae45697413d6765516",
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38",
    "c35fbac21da07f996f017169288b748764488c20",
    "a25f53f8871fd178b6791d1194d7358b55d1ba37",
    "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
    "04f28d4024daa5798f3c627170bfe2a96bce8e55",
    "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
    "40f6fef078275d3ca43f02918200a2d6076fef9d",
    "7f177dcaadbccb2076a2a41aa1000696a9a8a10e",
    "2ae6f779cc175b3cd82d915419f378e53ff4b056",
    "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
    "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
    "5123e075b8411953473b23c82e64d8d23edb9181",
    "478b82aa16242a7324a16ffc9df8811309228234",
    "3a31705ba43ab2968ab2f113272b2462c91027bb",
    "6149218487aac50fad2256c8723639671747d7bb",
    "516947a3d4eda478d20dcbb4216d6c52cf11d169",
    "6a1ee724c337694ee28b2a09af41c236b880ba66",
    "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
    "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
    "a3359354bf46a3459c2262ba520c95ba4bf02a58",
    "cbf3d3d09837a5648602ac7ececc3322144e68f0",
    "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
    "7c051d8316c3c9270f191bae4a5323b92f283420",
    "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
    "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1",
    "1a6665bb95b0e46cafdb19202274e6d6725ea464",
    "1555adc99a08f09e7f7ec40db7bd2535062e55af",
    "10508ce2a362ca01c7f29c39c7f98469233fce04",
    "ad402162f98243c84e4f7c9693012633347a4829",
    "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
    "488ccb1191c3b71644bdc9176712394220b9252b",
    "87b56cb1f18252c95d88b979a449f06d55def290",
    "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
    "9192b9d17903947058b755b987d1c57a05821e58",
    "b1cd1afb0aaa19f370a169350318496ca7e541bb",
    "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
    "0be8bb2b4275456c18bee064c5de2ccb12a33080",
    "bd0af28e7b81048d9bda153b908c727304ca8a04",
    "15cb49e74025eb4011187f31735aa4772993fb5d",
    "4b87b2b6b407077eb064ac949baaa2fbd0487986",
    "a55cd517deae99d6bb32717af632cd9dc9f01928",
    "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
    "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
    "e71e376b9542dd7fea6e973301d8d426f340d65b",
    "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
    "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
    "f21322dd131f30bfcd809d2748a2366df7dc27d3",
    "882790065271126fc4b17a71bebb078b60ffe00c",
    "572ea89397e9b3b35dc616d48176ab0d296612dd",
    "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
    "5d76ede0db52033984e3d7908105c6f2f4380725",
    "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
    "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
    "f0f313058c4389cd48052112e3fb906c060be30f",
    "6c2c1abbfcee5a8874d805a58f08d7d21c20482c",
    "566e84eb47ec36af0964ae8a3584460737917d73",
    "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
    "ecefb777275fd26b37f10709f97810a3e6a69bb2",
    "01e9c90792e879eca937a12b6bb30b31e51aee53",
    "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
    "6f102302a83146e02d13ff476f39fc8a86710e38",
    "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
    "c73ae5d79b62de91209477538b45ab5216fb108e"
  ],
  "changeHistoryShort": {
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632": "Ybodychange",
    "996b78486d0db86dece4457a7faa9b314dc3b847": "Ybodychange",
    "0a54807d59a9f39be0d222ae45697413d6765516": "Ybodychange",
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38": "Ybodychange",
    "c35fbac21da07f996f017169288b748764488c20": "Ybodychange",
    "a25f53f8871fd178b6791d1194d7358b55d1ba37": "Ybodychange",
    "29a9b8bcb552dc691cc57c85b8eb017092c960ad": "Ybodychange",
    "04f28d4024daa5798f3c627170bfe2a96bce8e55": "Ybodychange",
    "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c": "Ymultichange(Yparameterchange,Ybodychange)",
    "40f6fef078275d3ca43f02918200a2d6076fef9d": "Ybodychange",
    "7f177dcaadbccb2076a2a41aa1000696a9a8a10e": "Ybodychange",
    "2ae6f779cc175b3cd82d915419f378e53ff4b056": "Ybodychange",
    "de5c17c37f15a1c134f518ed2754974cc4b9aa15": "Ybodychange",
    "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc": "Ybodychange",
    "5123e075b8411953473b23c82e64d8d23edb9181": "Ybodychange",
    "478b82aa16242a7324a16ffc9df8811309228234": "Ybodychange",
    "3a31705ba43ab2968ab2f113272b2462c91027bb": "Ybodychange",
    "6149218487aac50fad2256c8723639671747d7bb": "Ybodychange",
    "516947a3d4eda478d20dcbb4216d6c52cf11d169": "Ybodychange",
    "6a1ee724c337694ee28b2a09af41c236b880ba66": "Ybodychange",
    "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889": "Ybodychange",
    "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2": "Ybodychange",
    "a3359354bf46a3459c2262ba520c95ba4bf02a58": "Ybodychange",
    "cbf3d3d09837a5648602ac7ececc3322144e68f0": "Ybodychange",
    "74dc0e58a9a6aa10a2c41bf121af592df43c30fe": "Ybodychange",
    "7c051d8316c3c9270f191bae4a5323b92f283420": "Ybodychange",
    "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e": "Ybodychange",
    "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1": "Ybodychange",
    "1a6665bb95b0e46cafdb19202274e6d6725ea464": "Ybodychange",
    "1555adc99a08f09e7f7ec40db7bd2535062e55af": "Ybodychange",
    "10508ce2a362ca01c7f29c39c7f98469233fce04": "Ybodychange",
    "ad402162f98243c84e4f7c9693012633347a4829": "Ybodychange",
    "a31908d22bc52d1bf24e00d3bc1bc709224156fd": "Ybodychange",
    "488ccb1191c3b71644bdc9176712394220b9252b": "Ybodychange",
    "87b56cb1f18252c95d88b979a449f06d55def290": "Ybodychange",
    "b29a465257afcf2cc720c9423c2ddedd1edd31a3": "Ybodychange",
    "9192b9d17903947058b755b987d1c57a05821e58": "Ybodychange",
    "b1cd1afb0aaa19f370a169350318496ca7e541bb": "Ybodychange",
    "adb78b277512189cc5f8ecb076d9bf8106f9e1e0": "Ybodychange",
    "0be8bb2b4275456c18bee064c5de2ccb12a33080": "Ybodychange",
    "bd0af28e7b81048d9bda153b908c727304ca8a04": "Ybodychange",
    "15cb49e74025eb4011187f31735aa4772993fb5d": "Ymultichange(Ymodifierchange,Ybodychange,Ydocchange)",
    "4b87b2b6b407077eb064ac949baaa2fbd0487986": "Ybodychange",
    "a55cd517deae99d6bb32717af632cd9dc9f01928": "Ybodychange",
    "7121d100d536b7b3df76c22ad3acc4c507be7bfe": "Ybodychange",
    "152592f7c8110f04ea6ca6e6c6d57360fd40ee16": "Ybodychange",
    "e71e376b9542dd7fea6e973301d8d426f340d65b": "Ybodychange",
    "ed7f4a6532043b5ac8c8da55923fbd91f72ec574": "Ybodychange",
    "548fb9c5a72776ec009c5f2f92b1a4c480a05030": "Ybodychange",
    "f21322dd131f30bfcd809d2748a2366df7dc27d3": "Ybodychange",
    "882790065271126fc4b17a71bebb078b60ffe00c": "Ybodychange",
    "572ea89397e9b3b35dc616d48176ab0d296612dd": "Ybodychange",
    "48ac9477b3997592001fa0f44f98eb7481f7b9ea": "Ybodychange",
    "5d76ede0db52033984e3d7908105c6f2f4380725": "Ymultichange(Yparameterchange,Ybodychange)",
    "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f": "Ybodychange",
    "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa": "Ybodychange",
    "f0f313058c4389cd48052112e3fb906c060be30f": "Ybodychange",
    "6c2c1abbfcee5a8874d805a58f08d7d21c20482c": "Ybodychange",
    "566e84eb47ec36af0964ae8a3584460737917d73": "Ybodychange",
    "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16": "Ymultichange(Ymovefromfile,Ybodychange)",
    "ecefb777275fd26b37f10709f97810a3e6a69bb2": "Ybodychange",
    "01e9c90792e879eca937a12b6bb30b31e51aee53": "Ybodychange",
    "f4ce6ce924ffbd03518c64cea9b830d04f75b849": "Ybodychange",
    "6f102302a83146e02d13ff476f39fc8a86710e38": "Ybodychange",
    "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee": "Ybodychange",
    "c73ae5d79b62de91209477538b45ab5216fb108e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632": {
      "type": "Ybodychange",
      "commitMessage": "built RemovedGroup into Difference class to be able to handle indentations better for removed elements\n",
      "commitDate": "2018/6/8 上午4:54",
      "commitName": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/6/8 上午4:54",
      "commitNameOld": "996b78486d0db86dece4457a7faa9b314dc3b847",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    extractReshuffledDiffElements(diffElements);\n    Map\u003cRemoved, RemovedGroup\u003e removedGroups \u003d combineRemovedElementsToRemovedGroups();\n    do {\n        boolean isLeftOverDiffElement \u003d applyLeftOverDiffElements();\n        boolean isLeftOverOriginalElement \u003d applyLeftOverOriginalElements();\n        if (!isLeftOverDiffElement \u0026\u0026 !isLeftOverOriginalElement) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                applyAddedDiffElement((Added) diffElement);\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed) diffElement;\n                    applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 123,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,46 +1,26 @@\n void apply() {\n     extractReshuffledDiffElements(diffElements);\n+    Map\u003cRemoved, RemovedGroup\u003e removedGroups \u003d combineRemovedElementsToRemovedGroups();\n     do {\n-        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n-            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-            if (diffElement instanceof Kept) {\n-                Kept kept \u003d (Kept) diffElement;\n-                if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n-                    diffIndex++;\n-                } else {\n-                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n-                }\n-            } else if (diffElement instanceof Added) {\n-                Added addedElement \u003d (Added) diffElement;\n-                nodeText.addElement(originalIndex, addedElement.toTextElement());\n-                originalIndex++;\n-                diffIndex++;\n-            } else {\n-                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n-            }\n-        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n-            TextElement originalElement \u003d originalElements.get(originalIndex);\n-            if (originalElement.isWhiteSpaceOrComment()) {\n-                originalIndex++;\n-            } else {\n-                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n-            }\n-        } else {\n+        boolean isLeftOverDiffElement \u003d applyLeftOverDiffElements();\n+        boolean isLeftOverOriginalElement \u003d applyLeftOverOriginalElements();\n+        if (!isLeftOverDiffElement \u0026\u0026 !isLeftOverOriginalElement) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n                 applyAddedDiffElement((Added) diffElement);\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n                     applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else if (diffElement instanceof Removed) {\n-                    applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n+                    Removed removed \u003d (Removed) diffElement;\n+                    applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "996b78486d0db86dece4457a7faa9b314dc3b847": {
      "type": "Ybodychange",
      "commitMessage": "moved extraction of reshuffled diffElements out of the loop with the rest\n",
      "commitDate": "2018/6/8 上午4:54",
      "commitName": "996b78486d0db86dece4457a7faa9b314dc3b847",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/29 下午2:28",
      "commitNameOld": "0a54807d59a9f39be0d222ae45697413d6765516",
      "commitAuthorOld": "Jooyung Han",
      "daysBetweenCommits": 9.6,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    extractReshuffledDiffElements(diffElements);\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                applyAddedDiffElement((Added) diffElement);\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else if (diffElement instanceof Removed) {\n                    applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 123,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,47 +1,46 @@\n void apply() {\n+    extractReshuffledDiffElements(diffElements);\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n                 applyAddedDiffElement((Added) diffElement);\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n                     applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else if (diffElement instanceof Removed) {\n                     applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n-                } else if (diffElement instanceof Reshuffled) {\n-                    applyReshuffledDiffElement((Reshuffled) diffElement);\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a54807d59a9f39be0d222ae45697413d6765516": {
      "type": "Ybodychange",
      "commitMessage": "Fix Difference.apply() with redundant Unindent\n\nRedundant unindent may be discarded just like other whitespaces\n",
      "commitDate": "2018/5/29 下午2:28",
      "commitName": "0a54807d59a9f39be0d222ae45697413d6765516",
      "commitAuthor": "Jooyung Han",
      "commitDateOld": "2018/5/20 上午12:42",
      "commitNameOld": "8718d4a587fe7951b4767c6bcc52d7979d9b8795",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 9.57,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                applyAddedDiffElement((Added) diffElement);\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else if (diffElement instanceof Removed) {\n                    applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else if (diffElement instanceof Reshuffled) {\n                    applyReshuffledDiffElement((Reshuffled) diffElement);\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 123,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,47 +1,47 @@\n void apply() {\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n-                if (kept.isWhiteSpaceOrComment()) {\n+                if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n                 applyAddedDiffElement((Added) diffElement);\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n                     applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else if (diffElement instanceof Removed) {\n                     applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else if (diffElement instanceof Reshuffled) {\n                     applyReshuffledDiffElement((Reshuffled) diffElement);\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38": {
      "type": "Ybodychange",
      "commitMessage": "Reduced cognitive complexity by extracting some methods\n",
      "commitDate": "2018/5/19 上午9:34",
      "commitName": "b7bd15d12e107c85e29912960f7b4e48aac4dc38",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午9:23",
      "commitNameOld": "c35fbac21da07f996f017169288b748764488c20",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                applyAddedDiffElement((Added) diffElement);\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else if (diffElement instanceof Removed) {\n                    applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                } else if (diffElement instanceof Reshuffled) {\n                    applyReshuffledDiffElement((Reshuffled) diffElement);\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 124,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,237 +1,47 @@\n void apply() {\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n-                Added addedElement \u003d (Added) diffElement;\n-                if (addedElement.isIndent()) {\n-                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n-                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n-                    }\n-                    addedIndentation \u003d true;\n-                    diffIndex++;\n-                    continue;\n-                }\n-                if (addedElement.isUnindent()) {\n-                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n-                        indentation.remove(indentation.size() - 1);\n-                    }\n-                    addedIndentation \u003d false;\n-                    diffIndex++;\n-                    continue;\n-                }\n-                TextElement addedTextElement \u003d addedElement.toTextElement();\n-                boolean used \u003d false;\n-                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n-                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n-                        nodeText.addElement(originalIndex++, e);\n-                    }\n-                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                    if (addedTextElement.isNewline()) {\n-                        used \u003d true;\n-                    }\n-                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n-                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n-                        originalElements.remove(originalIndex);\n-                    }\n-                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n-                        nodeText.addElement(originalIndex++, e);\n-                    }\n-                    if (!addedIndentation) {\n-                        for (TextElement e : indentationBlock()) {\n-                            nodeText.addElement(originalIndex++, e);\n-                        }\n-                    }\n-                }\n-                if (!used) {\n-                    nodeText.addElement(originalIndex, addedTextElement);\n-                    originalIndex++;\n-                }\n-                if (addedTextElement.isNewline()) {\n-                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n-                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n-                }\n-                diffIndex++;\n+                applyAddedDiffElement((Added) diffElement);\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n-                    Kept kept \u003d (Kept) diffElement;\n-                    if (originalElement.isComment()) {\n-                        originalIndex++;\n-                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n-                        diffIndex++;\n-                        originalIndex++;\n-                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n-                        if (originalElement.isWhiteSpaceOrComment()) {\n-                            originalIndex++;\n-                        } else {\n-                            if (kept.isPrimitiveType()) {\n-                                originalIndex++;\n-                                diffIndex++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n-                            }\n-                        }\n-                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n-                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n-                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n-                            originalIndex++;\n-                            diffIndex++;\n-                        } else if (kept.isWhiteSpaceOrComment()) {\n-                            diffIndex++;\n-                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n-                            originalIndex++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n-                        }\n-                    } else if (kept.isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (kept.isIndent()) {\n-                        diffIndex++;\n-                    } else if (kept.isUnindent()) {\n-                        diffIndex++;\n-                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n-                            nodeText.removeElement(--originalIndex);\n-                        }\n-                    } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n-                    }\n+                    applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else if (diffElement instanceof Removed) {\n-                    Removed removed \u003d (Removed) diffElement;\n-                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n-                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n-                        if (originalElementChild.isComment()) {\n-                            Comment comment \u003d (Comment) originalElementChild.getChild();\n-                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n-                                nodeText.removeElement(originalIndex);\n-                            } else {\n-                                originalIndex++;\n-                            }\n-                        } else {\n-                            nodeText.removeElement(originalIndex);\n-                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n-                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n-                            } else {\n-                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n-                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n-                                }\n-                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n-                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                            originalElements.remove(originalIndex--);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            diffIndex++;\n-                        }\n-                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n-                        nodeText.removeElement(originalIndex);\n-                        diffIndex++;\n-                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n-                        originalIndex++;\n-                    } else if (removed.isPrimitiveType()) {\n-                        if (isPrimitiveType(originalElement)) {\n-                            nodeText.removeElement(originalIndex);\n-                            diffIndex++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n-                        }\n-                    } else if (removed.isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (originalElement.isWhiteSpace()) {\n-                        originalIndex++;\n-                    } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n-                    }\n+                    applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                 } else if (diffElement instanceof Reshuffled) {\n-                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n-                    CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n-                    CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n-                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n-                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n-                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n-                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n-                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n-                        if (value !\u003d -1) {\n-                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n-                        }\n-                    }\n-                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n-                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n-                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n-                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n-                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n-                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n-                            int originalCsmIndex \u003d -1;\n-                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n-                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n-                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n-                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n-                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n-                                    }\n-                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n-                                }\n-                            }\n-                            if (originalCsmIndex \u003d\u003d -1) {\n-                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n-                            }\n-                        }\n-                    }\n-                    diffElements.remove(diffIndex);\n-                    int diffElIterator \u003d diffIndex;\n-                    if (lastNodeTextIndex !\u003d -1) {\n-                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n-                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n-                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n-                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n-                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                                    }\n-                                }\n-                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n-                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n-                                if (toBeKept) {\n-                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n-                                } else {\n-                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n-                                }\n-                            }\n-                        }\n-                    }\n-                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                    }\n+                    applyReshuffledDiffElement((Reshuffled) diffElement);\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c35fbac21da07f996f017169288b748764488c20": {
      "type": "Ybodychange",
      "commitMessage": "Changed local indentaton variables to fields\n",
      "commitDate": "2018/5/19 上午9:23",
      "commitName": "c35fbac21da07f996f017169288b748764488c20",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午9:15",
      "commitNameOld": "a25f53f8871fd178b6791d1194d7358b55d1ba37",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Reshuffled) {\n                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n                    CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 124,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,239 +1,237 @@\n void apply() {\n-    boolean addedIndentation \u003d false;\n-    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof Removed) {\n                     Removed removed \u003d (Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof Reshuffled) {\n                     Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n                     CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a25f53f8871fd178b6791d1194d7358b55d1ba37": {
      "type": "Ybodychange",
      "commitMessage": "Moved DifferenceElement classes to their own files\n",
      "commitDate": "2018/5/19 上午9:15",
      "commitName": "a25f53f8871fd178b6791d1194d7358b55d1ba37",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午8:49",
      "commitNameOld": "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Reshuffled) {\n                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n                    CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 121,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,239 +1,239 @@\n void apply() {\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n-            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n-                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n+            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+            if (diffElement instanceof Kept) {\n+                Kept kept \u003d (Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n-            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n-                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n+            } else if (diffElement instanceof Added) {\n+                Added addedElement \u003d (Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n-            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-            if (diffElement instanceof DifferenceElementCalculator.Added) {\n-                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n+            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+            if (diffElement instanceof Added) {\n+                Added addedElement \u003d (Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n-                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n-                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n+                if (diffElement instanceof Kept) {\n+                    Kept kept \u003d (Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n+                            throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                     }\n-                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n-                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n+                } else if (diffElement instanceof Removed) {\n+                    Removed removed \u003d (Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n-                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n+                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n+                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n+                        throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                     }\n-                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n-                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n-                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n-                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n+                } else if (diffElement instanceof Reshuffled) {\n+                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n+                    CsmMix elementsFromPreviousOrder \u003d reshuffled.getPreviousOrder();\n+                    CsmMix elementsFromNextOrder \u003d reshuffled.getNextOrder();\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n+                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n-                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n-                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n+                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29a9b8bcb552dc691cc57c85b8eb017092c960ad": {
      "type": "Ybodychange",
      "commitMessage": "Changed some local variables to instance variables\n",
      "commitDate": "2018/5/19 上午8:49",
      "commitName": "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午8:42",
      "commitNameOld": "04f28d4024daa5798f3c627170bfe2a96bce8e55",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 120,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,245 +1,239 @@\n void apply() {\n-    if (nodeText \u003d\u003d null) {\n-        throw new NullPointerException();\n-    }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n-    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n-    int originalIndex \u003d 0;\n-    int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                 DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                     DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                     DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "04f28d4024daa5798f3c627170bfe2a96bce8e55": {
      "type": "Ybodychange",
      "commitMessage": "Removed getElements method\n",
      "commitDate": "2018/5/19 上午8:42",
      "commitName": "04f28d4024daa5798f3c627170bfe2a96bce8e55",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午8:36",
      "commitNameOld": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply() {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n    int originalIndex \u003d 0;\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 109,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,246 +1,245 @@\n void apply() {\n-    if (this.nodeText \u003d\u003d null) {\n+    if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n-    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n+    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n     int originalIndex \u003d 0;\n-    List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n     int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                 DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                     DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n-                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n+                                if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                     DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
      "commitDate": "2018/5/19 上午8:36",
      "commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
      "commitAuthor": "Thomas Leu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
          "commitDate": "2018/5/19 上午8:36",
          "commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
          "commitAuthor": "Thomas Leu",
          "commitDateOld": "2018/5/19 上午7:51",
          "commitNameOld": "40f6fef078275d3ca43f02918200a2d6076fef9d",
          "commitAuthorOld": "Thomas Leu",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "void apply() {\n    if (this.nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n    int originalIndex \u003d 0;\n    List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 109,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
          "diff": "@@ -1,246 +1,246 @@\n-void apply(NodeText nodeText, Node node) {\n-    if (nodeText \u003d\u003d null) {\n+void apply() {\n+    if (this.nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n-    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n+    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n     List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n     int originalIndex \u003d 0;\n     List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n     int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                 DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                     DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                     DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[nodeText-NodeText, node-Node]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
          "commitDate": "2018/5/19 上午8:36",
          "commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
          "commitAuthor": "Thomas Leu",
          "commitDateOld": "2018/5/19 上午7:51",
          "commitNameOld": "40f6fef078275d3ca43f02918200a2d6076fef9d",
          "commitAuthorOld": "Thomas Leu",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "void apply() {\n    if (this.nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n    int originalIndex \u003d 0;\n    List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 109,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
          "diff": "@@ -1,246 +1,246 @@\n-void apply(NodeText nodeText, Node node) {\n-    if (nodeText \u003d\u003d null) {\n+void apply() {\n+    if (this.nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n-    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n+    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(this.node);\n     List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n     int originalIndex \u003d 0;\n     List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n     int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                 DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof DifferenceElementCalculator.Added) {\n                 DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                     DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                     DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "40f6fef078275d3ca43f02918200a2d6076fef9d": {
      "type": "Ybodychange",
      "commitMessage": "Moved DifferenceElement classes and static methods to new class DifferenceElementCalculator\n",
      "commitDate": "2018/5/19 上午7:51",
      "commitName": "40f6fef078275d3ca43f02918200a2d6076fef9d",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午7:26",
      "commitNameOld": "c4bbfa7060e136038d49a7ecfc35ec960153ac06",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n    int originalIndex \u003d 0;\n    List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof DifferenceElementCalculator.Added) {\n                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 105,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,246 +1,246 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n     int originalIndex \u003d 0;\n-    List\u003cDifferenceElement\u003e diffElements \u003d getElements();\n+    List\u003cDifferenceElementCalculator.DifferenceElement\u003e diffElements \u003d getElements();\n     int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n-            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-            if (diffElement instanceof Kept) {\n-                Kept kept \u003d (Kept) diffElement;\n+            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+            if (diffElement instanceof DifferenceElementCalculator.Kept) {\n+                DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n-            } else if (diffElement instanceof Added) {\n-                Added addedElement \u003d (Added) diffElement;\n+            } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n+                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n-            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-            if (diffElement instanceof Added) {\n-                Added addedElement \u003d (Added) diffElement;\n+            DifferenceElementCalculator.DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+            if (diffElement instanceof DifferenceElementCalculator.Added) {\n+                DifferenceElementCalculator.Added addedElement \u003d (DifferenceElementCalculator.Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n                 if (addedTextElement.isNewline()) {\n                     boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n-                if (diffElement instanceof Kept) {\n-                    Kept kept \u003d (Kept) diffElement;\n+                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n+                    DifferenceElementCalculator.Kept kept \u003d (DifferenceElementCalculator.Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                         if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                         }\n                     } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n-                } else if (diffElement instanceof Removed) {\n-                    Removed removed \u003d (Removed) diffElement;\n+                } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n+                    DifferenceElementCalculator.Removed removed \u003d (DifferenceElementCalculator.Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                         ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                         if (originalElementChild.isComment()) {\n                             Comment comment \u003d (Comment) originalElementChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n-                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n-                } else if (diffElement instanceof Reshuffled) {\n-                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n+                } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n+                    DifferenceElementCalculator.Reshuffled reshuffled \u003d (DifferenceElementCalculator.Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n                     diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n-                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                 } else {\n-                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7f177dcaadbccb2076a2a41aa1000696a9a8a10e": {
      "type": "Ybodychange",
      "commitMessage": "Extracted some methods and renamed some variables\n",
      "commitDate": "2018/5/19 上午5:48",
      "commitName": "7f177dcaadbccb2076a2a41aa1000696a9a8a10e",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/19 上午4:05",
      "commitNameOld": "2ae6f779cc175b3cd82d915419f378e53ff4b056",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n    int originalIndex \u003d 0;\n    List\u003cDifferenceElement\u003e diffElements \u003d getElements();\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement addedTextElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (addedTextElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, addedTextElement);\n                    originalIndex++;\n                }\n                if (addedTextElement.isNewline()) {\n                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                        }\n                    } else if (kept.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n                        if (originalElementChild.isComment()) {\n                            Comment comment \u003d (Comment) originalElementChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Reshuffled) {\n                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                            }\n                        }\n                    }\n                    diffElements.remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 570,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,258 +1,246 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n     int originalIndex \u003d 0;\n-    List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n+    List\u003cDifferenceElement\u003e diffElements \u003d getElements();\n     int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 nodeText.addElement(originalIndex, addedElement.toTextElement());\n                 originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n             TextElement originalElement \u003d originalElements.get(originalIndex);\n             if (originalElement.isWhiteSpaceOrComment()) {\n                 originalIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n-                TextElement textElement \u003d addedElement.toTextElement();\n+                TextElement addedTextElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                    if (textElement.isNewline()) {\n+                    if (addedTextElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                         originalElements.remove(originalIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                         nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n-                    nodeText.addElement(originalIndex, textElement);\n+                    nodeText.addElement(originalIndex, addedTextElement);\n                     originalIndex++;\n                 }\n-                if (textElement.isNewline()) {\n-                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                if (addedTextElement.isNewline()) {\n+                    boolean followedByUnindent \u003d isFollowedByUnindent(diffElements, diffIndex);\n                     originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n                 TextElement originalElement \u003d originalElements.get(originalIndex);\n                 boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                 boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n                     if (originalElement.isComment()) {\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n                         originalIndex++;\n                     } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                         if (originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n                     } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n-                        CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        TokenTextElement nodeTextToken \u003d (TokenTextElement) originalElement;\n-                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n+                        TokenTextElement originalTextToken \u003d (TokenTextElement) originalElement;\n+                        if (kept.getTokenType() \u003d\u003d originalTextToken.getTokenKind()) {\n                             originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n-                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n+                        } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                            throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                         }\n-                    } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n+                    } else if (kept.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n                         for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof Removed) {\n                     Removed removed \u003d (Removed) diffElement;\n                     if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n-                        ChildTextElement actualChild \u003d (ChildTextElement) originalElement;\n-                        if (actualChild.isComment()) {\n-                            CsmChild csmChild \u003d (CsmChild) removed.element;\n-                            Comment comment \u003d (Comment) actualChild.getChild();\n-                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                        ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n+                        if (originalElementChild.isComment()) {\n+                            Comment comment \u003d (Comment) originalElementChild.getChild();\n+                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                                 nodeText.removeElement(originalIndex);\n                             } else {\n                                 originalIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(originalIndex);\n                             if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                 originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n                                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                     if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                             originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n-                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind()) {\n+                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n                         nodeText.removeElement(originalIndex);\n                         diffIndex++;\n                     } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                         originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n                         if (isPrimitiveType(originalElement)) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (originalElement.isWhiteSpace()) {\n                         originalIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof Reshuffled) {\n                     Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n-                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n-                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n-                        boolean found \u003d false;\n-                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n-                        for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n-                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n-                                found \u003d true;\n-                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n-                            }\n-                        }\n-                    }\n+                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                     List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                    List\u003cCsmElement\u003e nextOrderElements \u003d elementsFromNextOrder.getElements();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n-                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n+                    for (int ni \u003d 0; ni \u003c nextOrderElements.size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n-                            for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n+                            for (int nj \u003d ni + 1; nj \u003c nextOrderElements.size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n-                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n-                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                                elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                             }\n                         }\n                     }\n-                    this.getElements().remove(diffIndex);\n+                    diffElements.remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n                         for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ae6f779cc175b3cd82d915419f378e53ff4b056": {
      "type": "Ybodychange",
      "commitMessage": "Renamed given to original\n",
      "commitDate": "2018/5/19 上午4:05",
      "commitName": "2ae6f779cc175b3cd82d915419f378e53ff4b056",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/18 上午6:47",
      "commitNameOld": "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n    int originalIndex \u003d 0;\n    List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n            TextElement originalElement \u003d originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        originalElements.remove(originalIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                        nodeText.addElement(originalIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(originalIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(originalIndex, textElement);\n                    originalIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement originalElement \u003d originalElements.get(originalIndex);\n                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n                    if (originalElement.isComment()) {\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                        diffIndex++;\n                        originalIndex++;\n                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n                        if (originalElement.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                originalIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) originalElement;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            originalIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            originalIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--originalIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n                        ChildTextElement actualChild \u003d (ChildTextElement) originalElement;\n                        if (actualChild.isComment()) {\n                            CsmChild csmChild \u003d (CsmChild) removed.element;\n                            Comment comment \u003d (Comment) actualChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                nodeText.removeElement(originalIndex);\n                            } else {\n                                originalIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(originalIndex);\n                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                }\n                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                            originalElements.remove(originalIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind()) {\n                        nodeText.removeElement(originalIndex);\n                        diffIndex++;\n                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n                        originalIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(originalElement)) {\n                            nodeText.removeElement(originalIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (originalElement.isWhiteSpace()) {\n                        originalIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                    }\n                } else if (diffElement instanceof Reshuffled) {\n                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 534,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,258 +1,258 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n-    List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n-    int givenIndex \u003d 0;\n+    List\u003cTextElement\u003e originalElements \u003d nodeText.getElements();\n+    int originalIndex \u003d 0;\n     List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n     int diffIndex \u003d 0;\n     do {\n-        if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n+        if (diffIndex \u003c diffElements.size() \u0026\u0026 originalIndex \u003e\u003d originalElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n                 if (kept.isWhiteSpaceOrComment()) {\n                     diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n-                nodeText.addElement(givenIndex, addedElement.toTextElement());\n-                givenIndex++;\n+                nodeText.addElement(originalIndex, addedElement.toTextElement());\n+                originalIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n-        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n-            TextElement givenElement \u003d givenElements.get(givenIndex);\n-            if (givenElement.isWhiteSpaceOrComment()) {\n-                givenIndex++;\n+        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 originalIndex \u003c originalElements.size()) {\n+            TextElement originalElement \u003d originalElements.get(originalIndex);\n+            if (originalElement.isWhiteSpaceOrComment()) {\n+                originalIndex++;\n             } else {\n-                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + givenElement);\n+                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Added) {\n                 Added addedElement \u003d (Added) diffElement;\n                 if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n-                if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n-                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n-                        nodeText.addElement(givenIndex++, e);\n+                if (originalIndex \u003e 0 \u0026\u0026 originalElements.get(originalIndex - 1).isNewline()) {\n+                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n+                        nodeText.addElement(originalIndex++, e);\n                     }\n-                } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n+                } else if (isAfterLBrace(nodeText, originalIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n-                    while (givenElements.get(givenIndex).isSpaceOrTab()) {\n-                        givenElements.remove(givenIndex);\n+                    nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n+                    while (originalElements.get(originalIndex).isSpaceOrTab()) {\n+                        originalElements.remove(originalIndex);\n                     }\n-                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n-                        nodeText.addElement(givenIndex++, e);\n+                    for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n+                        nodeText.addElement(originalIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n-                            nodeText.addElement(givenIndex++, e);\n+                            nodeText.addElement(originalIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n-                    nodeText.addElement(givenIndex, textElement);\n-                    givenIndex++;\n+                    nodeText.addElement(originalIndex, textElement);\n+                    originalIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                    givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent);\n+                    originalIndex \u003d adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else {\n-                TextElement givenElement \u003d givenElements.get(givenIndex);\n-                boolean givenElementIsChild \u003d givenElement instanceof ChildTextElement;\n-                boolean givenElementIsToken \u003d givenElement instanceof TokenTextElement;\n+                TextElement originalElement \u003d originalElements.get(originalIndex);\n+                boolean originalElementIsChild \u003d originalElement instanceof ChildTextElement;\n+                boolean originalElementIsToken \u003d originalElement instanceof TokenTextElement;\n                 if (diffElement instanceof Kept) {\n                     Kept kept \u003d (Kept) diffElement;\n-                    if (givenElement.isComment()) {\n-                        givenIndex++;\n-                    } else if (kept.isChild() \u0026\u0026 givenElementIsChild) {\n+                    if (originalElement.isComment()) {\n+                        originalIndex++;\n+                    } else if (kept.isChild() \u0026\u0026 originalElementIsChild) {\n                         diffIndex++;\n-                        givenIndex++;\n-                    } else if (kept.isChild() \u0026\u0026 givenElementIsToken) {\n-                        if (givenElement.isWhiteSpaceOrComment()) {\n-                            givenIndex++;\n+                        originalIndex++;\n+                    } else if (kept.isChild() \u0026\u0026 originalElementIsToken) {\n+                        if (originalElement.isWhiteSpaceOrComment()) {\n+                            originalIndex++;\n                         } else {\n                             if (kept.isPrimitiveType()) {\n-                                givenIndex++;\n+                                originalIndex++;\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                             }\n                         }\n-                    } else if (kept.isToken() \u0026\u0026 givenElementIsToken) {\n+                    } else if (kept.isToken() \u0026\u0026 originalElementIsToken) {\n                         CsmToken csmToken \u003d (CsmToken) kept.element;\n-                        TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n+                        TokenTextElement nodeTextToken \u003d (TokenTextElement) originalElement;\n                         if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                            givenIndex++;\n+                            originalIndex++;\n                             diffIndex++;\n                         } else if (kept.isWhiteSpaceOrComment()) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                            givenIndex++;\n+                            originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.isIndent()) {\n                         diffIndex++;\n                     } else if (kept.isUnindent()) {\n                         diffIndex++;\n-                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n-                            nodeText.removeElement(--givenIndex);\n+                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 originalIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n+                            nodeText.removeElement(--originalIndex);\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof Removed) {\n                     Removed removed \u003d (Removed) diffElement;\n-                    if (removed.isChild() \u0026\u0026 givenElementIsChild) {\n-                        ChildTextElement actualChild \u003d (ChildTextElement) givenElement;\n+                    if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n+                        ChildTextElement actualChild \u003d (ChildTextElement) originalElement;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild \u003d (CsmChild) removed.element;\n                             Comment comment \u003d (Comment) actualChild.getChild();\n                             if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                nodeText.removeElement(givenIndex);\n+                                nodeText.removeElement(originalIndex);\n                             } else {\n-                                givenIndex++;\n+                                originalIndex++;\n                             }\n                         } else {\n-                            nodeText.removeElement(givenIndex);\n-                            if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n-                                givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n+                            nodeText.removeElement(originalIndex);\n+                            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n+                                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                             } else {\n                                 if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                    givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n+                                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                                 }\n-                                if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n-                                    if (givenElements.get(givenIndex).isWhiteSpace() \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n+                                    if (originalElements.get(originalIndex).isWhiteSpace() \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                            givenElements.remove(givenIndex--);\n+                                            originalElements.remove(originalIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n-                    } else if (removed.isToken() \u0026\u0026 givenElementIsToken \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) givenElement).getTokenKind()) {\n-                        nodeText.removeElement(givenIndex);\n+                    } else if (removed.isToken() \u0026\u0026 originalElementIsToken \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind()) {\n+                        nodeText.removeElement(originalIndex);\n                         diffIndex++;\n-                    } else if (givenElementIsToken \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n-                        givenIndex++;\n+                    } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n+                        originalIndex++;\n                     } else if (removed.isPrimitiveType()) {\n-                        if (isPrimitiveType(givenElement)) {\n-                            nodeText.removeElement(givenIndex);\n+                        if (isPrimitiveType(originalElement)) {\n+                            nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (removed.isWhiteSpace()) {\n                         diffIndex++;\n-                    } else if (givenElement.isWhiteSpace()) {\n-                        givenIndex++;\n+                    } else if (originalElement.isWhiteSpace()) {\n+                        originalIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                     }\n                 } else if (diffElement instanceof Reshuffled) {\n                     Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                     CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                     Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                         boolean found \u003d false;\n                         CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                         for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                             CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                                 found \u003d true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n-                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n+                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                     Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                     for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                         int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                         if (value !\u003d -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                     List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                     Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                     for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             int originalCsmIndex \u003d -1;\n                             for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             if (originalCsmIndex \u003d\u003d -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n                     this.getElements().remove(diffIndex);\n                     int diffElIterator \u003d diffIndex;\n                     if (lastNodeTextIndex !\u003d -1) {\n-                        for (int ntIndex \u003d givenIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n+                        for (int ntIndex \u003d originalIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n                                 CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                         }\n                     }\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         diffElements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n-                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n+                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                 }\n             }\n         }\n-    } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n+    } while (diffIndex \u003c diffElements.size() || originalIndex \u003c originalElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de5c17c37f15a1c134f518ed2754974cc4b9aa15": {
      "type": "Ybodychange",
      "commitMessage": "Moved some logic to DifferenceElement objects and some renamings etc.\n",
      "commitDate": "2018/5/18 上午6:47",
      "commitName": "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/18 上午5:24",
      "commitNameOld": "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n    int givenIndex \u003d 0;\n    List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.isWhiteSpaceOrComment()) {\n                    diffIndex++;\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                nodeText.addElement(givenIndex, addedElement.toTextElement());\n                givenIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n            TextElement givenElement \u003d givenElements.get(givenIndex);\n            if (givenElement.isWhiteSpaceOrComment()) {\n                givenIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + givenElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Added) {\n                Added addedElement \u003d (Added) diffElement;\n                if (addedElement.isIndent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement.isUnindent()) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d addedElement.toTextElement();\n                boolean used \u003d false;\n                if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                        nodeText.addElement(givenIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                        givenElements.remove(givenIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                        nodeText.addElement(givenIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(givenIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(givenIndex, textElement);\n                    givenIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else {\n                TextElement givenElement \u003d givenElements.get(givenIndex);\n                boolean givenElementIsChild \u003d givenElement instanceof ChildTextElement;\n                boolean givenElementIsToken \u003d givenElement instanceof TokenTextElement;\n                if (diffElement instanceof Kept) {\n                    Kept kept \u003d (Kept) diffElement;\n                    if (givenElement.isComment()) {\n                        givenIndex++;\n                    } else if (kept.isChild() \u0026\u0026 givenElementIsChild) {\n                        diffIndex++;\n                        givenIndex++;\n                    } else if (kept.isChild() \u0026\u0026 givenElementIsToken) {\n                        if (givenElement.isWhiteSpaceOrComment()) {\n                            givenIndex++;\n                        } else {\n                            if (kept.isPrimitiveType()) {\n                                givenIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                            }\n                        }\n                    } else if (kept.isToken() \u0026\u0026 givenElementIsToken) {\n                        CsmToken csmToken \u003d (CsmToken) kept.element;\n                        TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                            givenIndex++;\n                            diffIndex++;\n                        } else if (kept.isWhiteSpaceOrComment()) {\n                            diffIndex++;\n                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                            givenIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                        }\n                    } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (kept.isIndent()) {\n                        diffIndex++;\n                    } else if (kept.isUnindent()) {\n                        diffIndex++;\n                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n                            nodeText.removeElement(--givenIndex);\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                    }\n                } else if (diffElement instanceof Removed) {\n                    Removed removed \u003d (Removed) diffElement;\n                    if (removed.isChild() \u0026\u0026 givenElementIsChild) {\n                        ChildTextElement actualChild \u003d (ChildTextElement) givenElement;\n                        if (actualChild.isComment()) {\n                            CsmChild csmChild \u003d (CsmChild) removed.element;\n                            Comment comment \u003d (Comment) actualChild.getChild();\n                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                nodeText.removeElement(givenIndex);\n                            } else {\n                                givenIndex++;\n                            }\n                        } else {\n                            nodeText.removeElement(givenIndex);\n                            if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n                                givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n                            } else {\n                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                    givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n                                }\n                                if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n                                    if (givenElements.get(givenIndex).isWhiteSpace() \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                            givenElements.remove(givenIndex--);\n                                        }\n                                    }\n                                }\n                            }\n                            diffIndex++;\n                        }\n                    } else if (removed.isToken() \u0026\u0026 givenElementIsToken \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) givenElement).getTokenKind()) {\n                        nodeText.removeElement(givenIndex);\n                        diffIndex++;\n                    } else if (givenElementIsToken \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n                        givenIndex++;\n                    } else if (removed.isPrimitiveType()) {\n                        if (isPrimitiveType(givenElement)) {\n                            nodeText.removeElement(givenIndex);\n                            diffIndex++;\n                        } else {\n                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                        }\n                    } else if (removed.isWhiteSpace()) {\n                        diffIndex++;\n                    } else if (givenElement.isWhiteSpace()) {\n                        givenIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                    }\n                } else if (diffElement instanceof Reshuffled) {\n                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                        boolean found \u003d false;\n                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                        for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                                found \u003d true;\n                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                            }\n                        }\n                    }\n                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                        if (value !\u003d -1) {\n                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n                        }\n                    }\n                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                            int originalCsmIndex \u003d -1;\n                            for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                    }\n                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                }\n                            }\n                            if (originalCsmIndex \u003d\u003d -1) {\n                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                    }\n                    this.getElements().remove(diffIndex);\n                    int diffElIterator \u003d diffIndex;\n                    if (lastNodeTextIndex !\u003d -1) {\n                        for (int ntIndex \u003d givenIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                    }\n                                }\n                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                if (toBeKept) {\n                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                } else {\n                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                }\n                            }\n                        }\n                    }\n                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                }\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 534,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,264 +1,258 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n     int givenIndex \u003d 0;\n     List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n     int diffIndex \u003d 0;\n     do {\n         if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n             if (diffElement instanceof Kept) {\n                 Kept kept \u003d (Kept) diffElement;\n-                if (kept.element instanceof CsmToken) {\n-                    CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n-                        diffIndex++;\n-                    } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n-                    }\n+                if (kept.isWhiteSpaceOrComment()) {\n+                    diffIndex++;\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffElement instanceof Added) {\n-                nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n+                Added addedElement \u003d (Added) diffElement;\n+                nodeText.addElement(givenIndex, addedElement.toTextElement());\n                 givenIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n             TextElement givenElement \u003d givenElements.get(givenIndex);\n             if (givenElement.isWhiteSpaceOrComment()) {\n                 givenIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + givenElement);\n             }\n         } else {\n             DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n-            TextElement givenElement \u003d givenElements.get(givenIndex);\n             if (diffElement instanceof Added) {\n-                CsmElement addedElement \u003d ((Added) diffElement).element;\n-                if (addedElement instanceof CsmIndent) {\n+                Added addedElement \u003d (Added) diffElement;\n+                if (addedElement.isIndent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n-                if (addedElement instanceof CsmUnindent) {\n+                if (addedElement.isUnindent()) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n-                TextElement textElement \u003d toTextElement(addedElement);\n+                TextElement textElement \u003d addedElement.toTextElement();\n                 boolean used \u003d false;\n                 if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                         nodeText.addElement(givenIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                         givenElements.remove(givenIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                         nodeText.addElement(givenIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(givenIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(givenIndex, textElement);\n                     givenIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n-            } else if (diffElement instanceof Kept) {\n-                Kept kept \u003d (Kept) diffElement;\n-                if (givenElement.isComment()) {\n-                    givenIndex++;\n-                } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n-                    diffIndex++;\n-                    givenIndex++;\n-                } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof TokenTextElement) {\n-                    if (givenElement.isWhiteSpaceOrComment()) {\n+            } else {\n+                TextElement givenElement \u003d givenElements.get(givenIndex);\n+                boolean givenElementIsChild \u003d givenElement instanceof ChildTextElement;\n+                boolean givenElementIsToken \u003d givenElement instanceof TokenTextElement;\n+                if (diffElement instanceof Kept) {\n+                    Kept kept \u003d (Kept) diffElement;\n+                    if (givenElement.isComment()) {\n                         givenIndex++;\n-                    } else {\n-                        if (kept.element instanceof CsmChild) {\n-                            CsmChild keptChild \u003d (CsmChild) kept.element;\n-                            if (keptChild.getChild() instanceof PrimitiveType) {\n+                    } else if (kept.isChild() \u0026\u0026 givenElementIsChild) {\n+                        diffIndex++;\n+                        givenIndex++;\n+                    } else if (kept.isChild() \u0026\u0026 givenElementIsToken) {\n+                        if (givenElement.isWhiteSpaceOrComment()) {\n+                            givenIndex++;\n+                        } else {\n+                            if (kept.isPrimitiveType()) {\n                                 givenIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                             }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                         }\n-                    }\n-                } else if ((kept.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement) {\n-                    CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n-                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                        givenIndex++;\n-                        diffIndex++;\n-                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n-                        diffIndex++;\n-                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                        givenIndex++;\n-                    } else {\n-                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n-                    }\n-                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n-                    diffIndex++;\n-                } else if (kept.element instanceof CsmIndent) {\n-                    diffIndex++;\n-                } else if (kept.element instanceof CsmUnindent) {\n-                    diffIndex++;\n-                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n-                        nodeText.removeElement(--givenIndex);\n-                    }\n-                } else {\n-                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n-                }\n-            } else if (diffElement instanceof Removed) {\n-                Removed removed \u003d (Removed) diffElement;\n-                if ((removed.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n-                    ChildTextElement actualChild \u003d (ChildTextElement) givenElement;\n-                    if (actualChild.isComment()) {\n-                        CsmChild csmChild \u003d (CsmChild) removed.element;\n-                        Comment comment \u003d (Comment) actualChild.getChild();\n-                        if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                            nodeText.removeElement(givenIndex);\n-                        } else {\n+                    } else if (kept.isToken() \u0026\u0026 givenElementIsToken) {\n+                        CsmToken csmToken \u003d (CsmToken) kept.element;\n+                        TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n+                        if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                             givenIndex++;\n+                            diffIndex++;\n+                        } else if (kept.isWhiteSpaceOrComment()) {\n+                            diffIndex++;\n+                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n+                            givenIndex++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                        }\n+                    } else if (kept.isToken() \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n+                        diffIndex++;\n+                    } else if (kept.isIndent()) {\n+                        diffIndex++;\n+                    } else if (kept.isUnindent()) {\n+                        diffIndex++;\n+                        for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n+                            nodeText.removeElement(--givenIndex);\n                         }\n                     } else {\n-                        nodeText.removeElement(givenIndex);\n-                        if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n-                            givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n-                        } else {\n-                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                    }\n+                } else if (diffElement instanceof Removed) {\n+                    Removed removed \u003d (Removed) diffElement;\n+                    if (removed.isChild() \u0026\u0026 givenElementIsChild) {\n+                        ChildTextElement actualChild \u003d (ChildTextElement) givenElement;\n+                        if (actualChild.isComment()) {\n+                            CsmChild csmChild \u003d (CsmChild) removed.element;\n+                            Comment comment \u003d (Comment) actualChild.getChild();\n+                            if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                nodeText.removeElement(givenIndex);\n+                            } else {\n+                                givenIndex++;\n                             }\n-                            if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n-                                if (givenElements.get(givenIndex).isWhiteSpace() \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n-                                    if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                        givenElements.remove(givenIndex--);\n+                        } else {\n+                            nodeText.removeElement(givenIndex);\n+                            if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n+                                givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n+                            } else {\n+                                if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                    givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n+                                }\n+                                if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n+                                    if (givenElements.get(givenIndex).isWhiteSpace() \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                            givenElements.remove(givenIndex--);\n+                                        }\n                                     }\n                                 }\n                             }\n+                            diffIndex++;\n                         }\n-                        diffIndex++;\n-                    }\n-                } else if ((removed.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) givenElement).getTokenKind()) {\n-                    nodeText.removeElement(givenIndex);\n-                    diffIndex++;\n-                } else if (givenElement instanceof TokenTextElement \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n-                    givenIndex++;\n-                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n-                    if (isPrimitiveType(givenElement)) {\n+                    } else if (removed.isToken() \u0026\u0026 givenElementIsToken \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) givenElement).getTokenKind()) {\n                         nodeText.removeElement(givenIndex);\n                         diffIndex++;\n+                    } else if (givenElementIsToken \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n+                        givenIndex++;\n+                    } else if (removed.isPrimitiveType()) {\n+                        if (isPrimitiveType(givenElement)) {\n+                            nodeText.removeElement(givenIndex);\n+                            diffIndex++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                        }\n+                    } else if (removed.isWhiteSpace()) {\n+                        diffIndex++;\n+                    } else if (givenElement.isWhiteSpace()) {\n+                        givenIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                     }\n-                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n-                    diffIndex++;\n-                } else if (givenElement.isWhiteSpace()) {\n-                    givenIndex++;\n+                } else if (diffElement instanceof Reshuffled) {\n+                    Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n+                    CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n+                    CsmMix elementsFromNextOrder \u003d reshuffled.element;\n+                    Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n+                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n+                        boolean found \u003d false;\n+                        CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n+                        for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n+                            CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n+                                found \u003d true;\n+                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n+                            }\n+                        }\n+                    }\n+                    List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n+                    Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n+                    for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n+                        int value \u003d nodeTextIndexOfPreviousElements.get(i);\n+                        if (value !\u003d -1) {\n+                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n+                        }\n+                    }\n+                    int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n+                    List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                    Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n+                    for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n+                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n+                            int originalCsmIndex \u003d -1;\n+                            for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n+                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n+                                    originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n+                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n+                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n+                                    }\n+                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                }\n+                            }\n+                            if (originalCsmIndex \u003d\u003d -1) {\n+                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                            }\n+                        }\n+                    }\n+                    this.getElements().remove(diffIndex);\n+                    int diffElIterator \u003d diffIndex;\n+                    if (lastNodeTextIndex !\u003d -1) {\n+                        for (int ntIndex \u003d givenIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n+                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n+                                int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n+                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n+                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n+                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                                    }\n+                                }\n+                                CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n+                                boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n+                                if (toBeKept) {\n+                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                } else {\n+                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                }\n+                            }\n+                        }\n+                    }\n+                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n+                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                    }\n                 } else {\n-                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                 }\n-            } else if (diffElement instanceof Reshuffled) {\n-                Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n-                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n-                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n-                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n-                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n-                    boolean found \u003d false;\n-                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n-                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n-                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n-                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n-                            found \u003d true;\n-                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n-                        }\n-                    }\n-                }\n-                final int startNodeTextIndex \u003d givenIndex;\n-                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n-                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n-                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n-                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n-                    if (value !\u003d -1) {\n-                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n-                    }\n-                }\n-                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n-                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n-                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n-                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n-                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n-                        int originalCsmIndex \u003d -1;\n-                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n-                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n-                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n-                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n-                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n-                                }\n-                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n-                            }\n-                        }\n-                        if (originalCsmIndex \u003d\u003d -1) {\n-                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n-                        }\n-                    }\n-                }\n-                this.getElements().remove(diffIndex);\n-                int diffElIterator \u003d diffIndex;\n-                if (lastNodeTextIndex !\u003d -1) {\n-                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n-                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n-                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n-                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n-                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                                }\n-                            }\n-                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n-                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n-                            if (toBeKept) {\n-                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n-                            } else {\n-                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n-                            }\n-                        }\n-                    }\n-                }\n-                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n             }\n         }\n     } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc": {
      "type": "Ybodychange",
      "commitMessage": "Renamings\n",
      "commitDate": "2018/5/18 上午5:24",
      "commitName": "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/5/12 上午12:03",
      "commitNameOld": "ae539a6fa91b4a3695df754a8f9e33180f9c466e",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 6.22,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n    int givenIndex \u003d 0;\n    List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n    int diffIndex \u003d 0;\n    do {\n        if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffElement instanceof Added) {\n                nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n                givenIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n            TextElement givenElement \u003d givenElements.get(givenIndex);\n            if (givenElement.isWhiteSpaceOrComment()) {\n                givenIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + givenElement);\n            }\n        } else {\n            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n            TextElement givenElement \u003d givenElements.get(givenIndex);\n            if (diffElement instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffElement).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(addedElement);\n                boolean used \u003d false;\n                if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                        nodeText.addElement(givenIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                        givenElements.remove(givenIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                        nodeText.addElement(givenIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(givenIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(givenIndex, textElement);\n                    givenIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffElement instanceof Kept) {\n                Kept kept \u003d (Kept) diffElement;\n                if (givenElement.isComment()) {\n                    givenIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n                    diffIndex++;\n                    givenIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof TokenTextElement) {\n                    if (givenElement.isWhiteSpaceOrComment()) {\n                        givenIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                givenIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        givenIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        givenIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--givenIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                }\n            } else if (diffElement instanceof Removed) {\n                Removed removed \u003d (Removed) diffElement;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n                    ChildTextElement actualChild \u003d (ChildTextElement) givenElement;\n                    if (actualChild.isComment()) {\n                        CsmChild csmChild \u003d (CsmChild) removed.element;\n                        Comment comment \u003d (Comment) actualChild.getChild();\n                        if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                            nodeText.removeElement(givenIndex);\n                        } else {\n                            givenIndex++;\n                        }\n                    } else {\n                        nodeText.removeElement(givenIndex);\n                        if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n                            givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n                            }\n                            if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n                                if (givenElements.get(givenIndex).isWhiteSpace() \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n                                    if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                        givenElements.remove(givenIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    }\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) givenElement).getTokenKind()) {\n                    nodeText.removeElement(givenIndex);\n                    diffIndex++;\n                } else if (givenElement instanceof TokenTextElement \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n                    givenIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(givenElement)) {\n                        nodeText.removeElement(givenIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (givenElement.isWhiteSpace()) {\n                    givenIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                }\n            } else if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d givenIndex;\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n            }\n        }\n    } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 482,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,262 +1,264 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n+    List\u003cTextElement\u003e givenElements \u003d nodeText.getElements();\n+    int givenIndex \u003d 0;\n+    List\u003cDifferenceElement\u003e diffElements \u003d this.elements;\n     int diffIndex \u003d 0;\n-    int nodeTextIndex \u003d 0;\n     do {\n-        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n-            DifferenceElement diffEl \u003d elements.get(diffIndex);\n-            if (diffEl instanceof Kept) {\n-                Kept kept \u003d (Kept) diffEl;\n+        if (diffIndex \u003c diffElements.size() \u0026\u0026 givenIndex \u003e\u003d givenElements.size()) {\n+            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+            if (diffElement instanceof Kept) {\n+                Kept kept \u003d (Kept) diffElement;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n-            } else if (diffEl instanceof Added) {\n-                nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n-                nodeTextIndex++;\n+            } else if (diffElement instanceof Added) {\n+                nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n+                givenIndex++;\n                 diffIndex++;\n             } else {\n-                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n             }\n-        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n-            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-            if (nodeTextEl.isWhiteSpaceOrComment()) {\n-                nodeTextIndex++;\n+        } else if (diffIndex \u003e\u003d diffElements.size() \u0026\u0026 givenIndex \u003c givenElements.size()) {\n+            TextElement givenElement \u003d givenElements.get(givenIndex);\n+            if (givenElement.isWhiteSpaceOrComment()) {\n+                givenIndex++;\n             } else {\n-                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + givenElement);\n             }\n         } else {\n-            DifferenceElement diffEl \u003d elements.get(diffIndex);\n-            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-            if (diffEl instanceof Added) {\n-                CsmElement addedElement \u003d ((Added) diffEl).element;\n+            DifferenceElement diffElement \u003d diffElements.get(diffIndex);\n+            TextElement givenElement \u003d givenElements.get(givenIndex);\n+            if (diffElement instanceof Added) {\n+                CsmElement addedElement \u003d ((Added) diffElement).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(addedElement);\n                 boolean used \u003d false;\n-                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n-                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n-                        nodeText.addElement(nodeTextIndex++, e);\n+                if (givenIndex \u003e 0 \u0026\u0026 givenElements.get(givenIndex - 1).isNewline()) {\n+                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n+                        nodeText.addElement(givenIndex++, e);\n                     }\n-                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n+                } else if (isAfterLBrace(nodeText, givenIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n-                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n-                        nodeText.getElements().remove(nodeTextIndex);\n+                    nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n+                    while (givenElements.get(givenIndex).isSpaceOrTab()) {\n+                        givenElements.remove(givenIndex);\n                     }\n-                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n-                        nodeText.addElement(nodeTextIndex++, e);\n+                    for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n+                        nodeText.addElement(givenIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                            nodeText.addElement(givenIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n-                    nodeText.addElement(nodeTextIndex, textElement);\n-                    nodeTextIndex++;\n+                    nodeText.addElement(givenIndex, textElement);\n+                    givenIndex++;\n                 }\n                 if (textElement.isNewline()) {\n-                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n+                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c diffElements.size() \u0026\u0026 diffElements.get(diffIndex + 1).isAdded() \u0026\u0026 diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                    givenIndex \u003d adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n-            } else if (diffEl instanceof Kept) {\n-                Kept kept \u003d (Kept) diffEl;\n-                if (nodeTextEl.isComment()) {\n-                    nodeTextIndex++;\n-                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+            } else if (diffElement instanceof Kept) {\n+                Kept kept \u003d (Kept) diffElement;\n+                if (givenElement.isComment()) {\n+                    givenIndex++;\n+                } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n                     diffIndex++;\n-                    nodeTextIndex++;\n-                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n-                        nodeTextIndex++;\n+                    givenIndex++;\n+                } else if ((kept.element instanceof CsmChild) \u0026\u0026 givenElement instanceof TokenTextElement) {\n+                    if (givenElement.isWhiteSpaceOrComment()) {\n+                        givenIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n-                                nodeTextIndex++;\n+                                givenIndex++;\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                             }\n                         } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                         }\n                     }\n-                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                } else if ((kept.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n+                    TokenTextElement nodeTextToken \u003d (TokenTextElement) givenElement;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n-                        nodeTextIndex++;\n+                        givenIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                        nodeTextIndex++;\n+                        givenIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n-                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n-                        nodeText.removeElement(--nodeTextIndex);\n+                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 givenIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n+                        nodeText.removeElement(--givenIndex);\n                     }\n                 } else {\n-                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                 }\n-            } else if (diffEl instanceof Removed) {\n-                Removed removed \u003d (Removed) diffEl;\n-                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                    ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n+            } else if (diffElement instanceof Removed) {\n+                Removed removed \u003d (Removed) diffElement;\n+                if ((removed.element instanceof CsmChild) \u0026\u0026 givenElement instanceof ChildTextElement) {\n+                    ChildTextElement actualChild \u003d (ChildTextElement) givenElement;\n                     if (actualChild.isComment()) {\n                         CsmChild csmChild \u003d (CsmChild) removed.element;\n                         Comment comment \u003d (Comment) actualChild.getChild();\n                         if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                            nodeText.removeElement(givenIndex);\n                         } else {\n-                            nodeTextIndex++;\n+                            givenIndex++;\n                         }\n                     } else {\n-                        nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n-                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                        nodeText.removeElement(givenIndex);\n+                        if (givenIndex \u003c givenElements.size() \u0026\u0026 givenElements.get(givenIndex).isNewline()) {\n+                            givenIndex \u003d considerCleaningTheLine(nodeText, givenIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                                givenIndex \u003d considerEnforcingIndentation(nodeText, givenIndex);\n                             }\n-                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n-                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                    if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n-                                        nodeText.getElements().remove(nodeTextIndex--);\n+                            if (givenElements.size() \u003e givenIndex \u0026\u0026 givenIndex \u003e 0) {\n+                                if (givenElements.get(givenIndex).isWhiteSpace() \u0026\u0026 givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                    if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                        givenElements.remove(givenIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     }\n-                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n-                    nodeText.removeElement(nodeTextIndex);\n+                } else if ((removed.element instanceof CsmToken) \u0026\u0026 givenElement instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) givenElement).getTokenKind()) {\n+                    nodeText.removeElement(givenIndex);\n                     diffIndex++;\n-                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n-                    nodeTextIndex++;\n+                } else if (givenElement instanceof TokenTextElement \u0026\u0026 givenElement.isWhiteSpaceOrComment()) {\n+                    givenIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n-                    if (isPrimitiveType(nodeTextEl)) {\n-                        nodeText.removeElement(nodeTextIndex);\n+                    if (isPrimitiveType(givenElement)) {\n+                        nodeText.removeElement(givenIndex);\n                         diffIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n-                } else if (nodeTextEl.isWhiteSpace()) {\n-                    nodeTextIndex++;\n+                } else if (givenElement.isWhiteSpace()) {\n+                    givenIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                 }\n-            } else if (diffEl instanceof Reshuffled) {\n-                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n+            } else if (diffElement instanceof Reshuffled) {\n+                Reshuffled reshuffled \u003d (Reshuffled) diffElement;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n-                final int startNodeTextIndex \u003d nodeTextIndex;\n+                final int startNodeTextIndex \u003d givenIndex;\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                    elements.add(diffElIterator++, new Added(elementToAdd));\n+                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n-                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n-                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                    elements.add(diffElIterator++, new Added(elementToAdd));\n+                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n-                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n             }\n         }\n-    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n+    } while (diffIndex \u003c diffElements.size() || givenIndex \u003c givenElements.size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5123e075b8411953473b23c82e64d8d23edb9181": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue 1461 - wrong identation when adding new annotation\n",
      "commitDate": "2018/5/11 上午9:47",
      "commitName": "5123e075b8411953473b23c82e64d8d23edb9181",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018/3/12 上午1:38",
      "commitNameOld": "98e6c2f915a109d3157bed8cc2b775b430894535",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 60.34,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n                    if (actualChild.isComment()) {\n                        CsmChild csmChild \u003d (CsmChild) removed.element;\n                        Comment comment \u003d (Comment) actualChild.getChild();\n                        if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    }\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 482,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,263 +1,262 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n                     if (actualChild.isComment()) {\n                         CsmChild csmChild \u003d (CsmChild) removed.element;\n                         Comment comment \u003d (Comment) actualChild.getChild();\n                         if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     }\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n-                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n-                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n+                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "478b82aa16242a7324a16ffc9df8811309228234": {
      "type": "Ybodychange",
      "commitMessage": "improve how comments are handled by LexicalPreservingPrinter #1297\n",
      "commitDate": "2018/1/13 下午9:14",
      "commitName": "478b82aa16242a7324a16ffc9df8811309228234",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/11/14 上午3:21",
      "commitNameOld": "3a31705ba43ab2968ab2f113272b2462c91027bb",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 60.75,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n                    if (actualChild.isComment()) {\n                        CsmChild csmChild \u003d (CsmChild) removed.element;\n                        Comment comment \u003d (Comment) actualChild.getChild();\n                        if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    }\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 483,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,263 +1,263 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n-                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n+                if (nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n                     if (actualChild.isComment()) {\n                         CsmChild csmChild \u003d (CsmChild) removed.element;\n                         Comment comment \u003d (Comment) actualChild.getChild();\n                         if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     }\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a31705ba43ab2968ab2f113272b2462c91027bb": {
      "type": "Ybodychange",
      "commitMessage": "delete comments associated to nodes to be deleted #1244\n",
      "commitDate": "2017/11/14 上午3:21",
      "commitName": "3a31705ba43ab2968ab2f113272b2462c91027bb",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/9/20 下午11:39",
      "commitNameOld": "6149218487aac50fad2256c8723639671747d7bb",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 54.15,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n                    if (actualChild.isComment()) {\n                        CsmChild csmChild \u003d (CsmChild) removed.element;\n                        Comment comment \u003d (Comment) actualChild.getChild();\n                        if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        nodeText.removeElement(nodeTextIndex);\n                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                        } else {\n                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                            }\n                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                    if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                        nodeText.getElements().remove(nodeTextIndex--);\n                                    }\n                                }\n                            }\n                        }\n                        diffIndex++;\n                    }\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 483,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,252 +1,263 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n-                    nodeText.removeElement(nodeTextIndex);\n-                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n-                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n-                    } else {\n-                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                    ChildTextElement actualChild \u003d (ChildTextElement) nodeTextEl;\n+                    if (actualChild.isComment()) {\n+                        CsmChild csmChild \u003d (CsmChild) removed.element;\n+                        Comment comment \u003d (Comment) actualChild.getChild();\n+                        if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                        } else {\n+                            nodeTextIndex++;\n                         }\n-                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n-                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n-                                    nodeText.getElements().remove(nodeTextIndex--);\n+                    } else {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n+                            nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                        } else {\n+                            if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                            }\n+                            if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n+                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                    if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n+                                        nodeText.getElements().remove(nodeTextIndex--);\n+                                    }\n                                 }\n                             }\n                         }\n+                        diffIndex++;\n                     }\n-                    diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6149218487aac50fad2256c8723639671747d7bb": {
      "type": "Ybodychange",
      "commitMessage": "Remove dependency on LPP for finding nodetext\n",
      "commitDate": "2017/9/20 下午11:39",
      "commitName": "6149218487aac50fad2256c8723639671747d7bb",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017/8/13 上午6:08",
      "commitNameOld": "23226e3befe168df74edef0272ab2a562810074b",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 38.73,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 482,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,252 +1,252 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n-    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n+    List\u003cTokenTextElement\u003e indentation \u003d LexicalPreservingPrinter.findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n-                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n-                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n+                TextElement textElement \u003d toTextElement(addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                 if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "516947a3d4eda478d20dcbb4216d6c52cf11d169": {
      "type": "Ybodychange",
      "commitMessage": "cleanup following IDEA suggestions #1001\n",
      "commitDate": "2017/7/19 下午11:34",
      "commitName": "516947a3d4eda478d20dcbb4216d6c52cf11d169",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/7/19 下午11:19",
      "commitNameOld": "b83b81211f26f9259b032b188bb2482aa390df0d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,253 +1,252 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                 if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n-                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n+                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n-                        } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a1ee724c337694ee28b2a09af41c236b880ba66": {
      "type": "Ybodychange",
      "commitMessage": "Take TokenType into consideration\n",
      "commitDate": "2017/7/19 上午3:42",
      "commitName": "6a1ee724c337694ee28b2a09af41c236b880ba66",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017/7/13 上午12:46",
      "commitNameOld": "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 6.12,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,253 +1,253 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n+                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                 if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889": {
      "type": "Ybodychange",
      "commitMessage": "A lot more intellij inspection results\n",
      "commitDate": "2017/7/13 上午12:46",
      "commitName": "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017/5/21 下午7:34",
      "commitNameOld": "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 52.22,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,253 +1,253 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                    if (nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                 if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2": {
      "type": "Ybodychange",
      "commitMessage": "cleaning up PR 932\n",
      "commitDate": "2017/5/21 下午7:34",
      "commitName": "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "a3359354bf46a3459c2262ba520c95ba4bf02a58",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 485,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,254 +1,253 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                 if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n-                int v \u003d 0;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a3359354bf46a3459c2262ba520c95ba4bf02a58": {
      "type": "Ybodychange",
      "commitMessage": "correct space merging to work only when there is a kept\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "a3359354bf46a3459c2262ba520c95ba4bf02a58",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "1a0ffde702735e1e1deda6d092e92eee2305bd14",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n                int v \u003d 0;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 481,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,254 +1,254 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || !(elements.get(diffIndex + 1) instanceof Added)) {\n+                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n                 int v \u003d 0;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cbf3d3d09837a5648602ac7ececc3322144e68f0": {
      "type": "Ybodychange",
      "commitMessage": "fix CsmMix.prettyPrint\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "cbf3d3d09837a5648602ac7ececc3322144e68f0",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || !(elements.get(diffIndex + 1) instanceof Added)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n                int v \u003d 0;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,253 +1,254 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                         if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                             if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                 if ((diffIndex + 1) \u003d\u003d this.elements.size() || !(elements.get(diffIndex + 1) instanceof Added)) {\n                                     nodeText.getElements().remove(nodeTextIndex--);\n                                 }\n                             }\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n+                int v \u003d 0;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "74dc0e58a9a6aa10a2c41bf121af592df43c30fe": {
      "type": "Ybodychange",
      "commitMessage": "working on whitespace reconciliation\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "e9796ac7c5a26db2e4a8b37b781b1c5933b8c1fd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || !(elements.get(diffIndex + 1) instanceof Added)) {\n                                    nodeText.getElements().remove(nodeTextIndex--);\n                                }\n                            }\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,246 +1,253 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof CsmChild) {\n                             CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n+                        if (nodeText.getElements().size() \u003e nodeTextIndex \u0026\u0026 nodeTextIndex \u003e 0) {\n+                            if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace() \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                if ((diffIndex + 1) \u003d\u003d this.elements.size() || !(elements.get(diffIndex + 1) instanceof Added)) {\n+                                    nodeText.getElements().remove(nodeTextIndex--);\n+                                }\n+                            }\n+                        }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Reshuffled) {\n                 Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                 CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                 CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                 Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     boolean found \u003d false;\n                     CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                     for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                         CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                             found \u003d true;\n                             correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                         }\n                     }\n                 }\n                 final int startNodeTextIndex \u003d nodeTextIndex;\n                 final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                 List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                 Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                 for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                     int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                     if (value !\u003d -1) {\n                         nodeTextIndexToPreviousCSMIndex.put(value, i);\n                     }\n                 }\n                 int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                 List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                 Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                 for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                     if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                         int originalCsmIndex \u003d -1;\n                         for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                             if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                 originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                 if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                     elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                 }\n                                 elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                         if (originalCsmIndex \u003d\u003d -1) {\n                             elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                         }\n                     }\n                 }\n                 this.getElements().remove(diffIndex);\n                 int diffElIterator \u003d diffIndex;\n                 if (lastNodeTextIndex !\u003d -1) {\n                     for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                         if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                             int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                             if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                 for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                     elements.add(diffElIterator++, new Added(elementToAdd));\n                                 }\n                             }\n                             CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                             boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                             if (toBeKept) {\n                                 elements.add(diffElIterator++, new Kept(originalCSMElement));\n                             } else {\n                                 elements.add(diffElIterator++, new Removed(originalCSMElement));\n                             }\n                         } else {\n                         }\n                     }\n                 }\n                 for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                     elements.add(diffElIterator++, new Added(elementToAdd));\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c051d8316c3c9270f191bae4a5323b92f283420": {
      "type": "Ybodychange",
      "commitMessage": "removing dead code #866\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "7c051d8316c3c9270f191bae4a5323b92f283420",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "",
      "extendedDetails": {}
    },
    "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e": {
      "type": "Ybodychange",
      "commitMessage": "new approach based on rewriting Difference based on NodeText on encountering a CsmMix #866\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "9e91a1d76dbfb28f2bc7c32028fe459b073ee861",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Reshuffled) {\n                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    boolean found \u003d false;\n                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n                            found \u003d true;\n                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                        }\n                    }\n                }\n                final int startNodeTextIndex \u003d nodeTextIndex;\n                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n                    if (value !\u003d -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        int originalCsmIndex \u003d -1;\n                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                            }\n                        }\n                        if (originalCsmIndex \u003d\u003d -1) {\n                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                        }\n                    }\n                }\n                this.getElements().remove(diffIndex);\n                int diffElIterator \u003d diffIndex;\n                if (lastNodeTextIndex !\u003d -1) {\n                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    elements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        } else {\n                        }\n                    }\n                }\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    elements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 535,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,175 +1,246 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n-                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n+                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n-                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n-                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n-                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n-                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n+                        if (kept.element instanceof CsmChild) {\n+                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                         nodeText.removeElement(--nodeTextIndex);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n-                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n-                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n+                } else if (removed.element instanceof CsmChild \u0026\u0026 ((CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n+            } else if (diffEl instanceof Reshuffled) {\n+                Reshuffled reshuffled \u003d (Reshuffled) diffEl;\n+                CsmMix elementsFromPreviousOrder \u003d reshuffled.previousOrder;\n+                CsmMix elementsFromNextOrder \u003d reshuffled.element;\n+                Map\u003cInteger, Integer\u003e correspondanceBetweenNextOrderAndPreviousOrder \u003d new HashMap\u003c\u003e();\n+                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n+                    boolean found \u003d false;\n+                    CsmElement ne \u003d elementsFromNextOrder.getElements().get(ni);\n+                    for (int pi \u003d 0; pi \u003c elementsFromPreviousOrder.getElements().size() \u0026\u0026 !found; pi++) {\n+                        CsmElement pe \u003d elementsFromPreviousOrder.getElements().get(pi);\n+                        if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe) \u0026\u0026 matching(ne, pe)) {\n+                            found \u003d true;\n+                            correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n+                        }\n+                    }\n+                }\n+                final int startNodeTextIndex \u003d nodeTextIndex;\n+                final Set\u003cInteger\u003e usedIndexes \u003d new HashSet\u003c\u003e();\n+                List\u003cInteger\u003e nodeTextIndexOfPreviousElements \u003d elementsFromPreviousOrder.getElements().stream().map(it -\u003e findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node)).collect(Collectors.toList());\n+                Map\u003cInteger, Integer\u003e nodeTextIndexToPreviousCSMIndex \u003d new HashMap\u003c\u003e();\n+                for (int i \u003d 0; i \u003c nodeTextIndexOfPreviousElements.size(); i++) {\n+                    int value \u003d nodeTextIndexOfPreviousElements.get(i);\n+                    if (value !\u003d -1) {\n+                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n+                    }\n+                }\n+                int lastNodeTextIndex \u003d nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n+                List\u003cCsmElement\u003e elementsToBeAddedAtTheEnd \u003d new LinkedList\u003c\u003e();\n+                Map\u003cInteger, List\u003cCsmElement\u003e\u003e elementsToAddBeforeGivenOriginalCSMElement \u003d new HashMap\u003c\u003e();\n+                for (int ni \u003d 0; ni \u003c elementsFromNextOrder.getElements().size(); ni++) {\n+                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n+                        int originalCsmIndex \u003d -1;\n+                        for (int nj \u003d ni + 1; nj \u003c elementsFromNextOrder.getElements().size() \u0026\u0026 originalCsmIndex \u003d\u003d -1; nj++) {\n+                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n+                                originalCsmIndex \u003d correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n+                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n+                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList\u003c\u003e());\n+                                }\n+                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                            }\n+                        }\n+                        if (originalCsmIndex \u003d\u003d -1) {\n+                            elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                        }\n+                    }\n+                }\n+                this.getElements().remove(diffIndex);\n+                int diffElIterator \u003d diffIndex;\n+                if (lastNodeTextIndex !\u003d -1) {\n+                    for (int ntIndex \u003d startNodeTextIndex; ntIndex \u003c\u003d lastNodeTextIndex; ntIndex++) {\n+                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n+                            int indexOfOriginalCSMElement \u003d nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n+                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n+                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n+                                    elements.add(diffElIterator++, new Added(elementToAdd));\n+                                }\n+                            }\n+                            CsmElement originalCSMElement \u003d elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n+                            boolean toBeKept \u003d correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n+                            if (toBeKept) {\n+                                elements.add(diffElIterator++, new Kept(originalCSMElement));\n+                            } else {\n+                                elements.add(diffElIterator++, new Removed(originalCSMElement));\n+                            }\n+                        } else {\n+                        }\n+                    }\n+                }\n+                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n+                    elements.add(diffElIterator++, new Added(elementToAdd));\n+                }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1": {
      "type": "Ybodychange",
      "commitMessage": "reconsider how CsmUnindent is handled in Difference.apply\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "1a6665bb95b0e46cafdb19202274e6d6725ea464",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                        nodeText.removeElement(--nodeTextIndex);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 430,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,172 +1,175 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n+                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 nodeTextIndex \u003e\u003d 1 \u0026\u0026 nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n+                        nodeText.removeElement(--nodeTextIndex);\n+                    }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a6665bb95b0e46cafdb19202274e6d6725ea464": {
      "type": "Ybodychange",
      "commitMessage": "cleaning Difference\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "1a6665bb95b0e46cafdb19202274e6d6725ea464",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "c624f15225df9442948dc1bb1c655e0114806ebb",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 430,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "",
      "extendedDetails": {}
    },
    "1555adc99a08f09e7f7ec40db7bd2535062e55af": {
      "type": "Ybodychange",
      "commitMessage": "progressing on unindent reconciliation\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "1555adc99a08f09e7f7ec40db7bd2535062e55af",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "10508ce2a362ca01c7f29c39c7f98469233fce04",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 447,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,172 +1,172 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent \u0026\u0026 !addedIndentation);\n+                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "10508ce2a362ca01c7f29c39c7f98469233fce04": {
      "type": "Ybodychange",
      "commitMessage": "reconciliating unindent with existing indentation\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "10508ce2a362ca01c7f29c39c7f98469233fce04",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "ad402162f98243c84e4f7c9693012633347a4829",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent \u0026\u0026 !addedIndentation);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 447,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,171 +1,172 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                         indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                     }\n                     addedIndentation \u003d true;\n                     diffIndex++;\n                     continue;\n                 }\n                 if (addedElement instanceof CsmUnindent) {\n                     for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                         indentation.remove(indentation.size() - 1);\n                     }\n                     addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     if (!addedIndentation) {\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n-                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n+                    boolean followedByUnindent \u003d (diffIndex + 1) \u003c elements.size() \u0026\u0026 elements.get(diffIndex + 1).isAdded() \u0026\u0026 elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent \u0026\u0026 !addedIndentation);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n-                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad402162f98243c84e4f7c9693012633347a4829": {
      "type": "Ybodychange",
      "commitMessage": "explaining why sometimes we force indentation\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "ad402162f98243c84e4f7c9693012633347a4829",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    boolean addedIndentation \u003d false;\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                    }\n                    addedIndentation \u003d true;\n                    diffIndex++;\n                    continue;\n                }\n                if (addedElement instanceof CsmUnindent) {\n                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n                        indentation.remove(indentation.size() - 1);\n                    }\n                    addedIndentation \u003d false;\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    if (!addedIndentation) {\n                        for (TextElement e : indentationBlock()) {\n                            nodeText.addElement(nodeTextIndex++, e);\n                        }\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 447,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,156 +1,171 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n+    boolean addedIndentation \u003d false;\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n-                if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n+                if (addedElement instanceof CsmIndent) {\n+                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE; i++) {\n+                        indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n+                    }\n+                    addedIndentation \u003d true;\n+                    diffIndex++;\n+                    continue;\n+                }\n+                if (addedElement instanceof CsmUnindent) {\n+                    for (int i \u003d 0; i \u003c STANDARD_INDENTATION_SIZE \u0026\u0026 !indentation.isEmpty(); i++) {\n+                        indentation.remove(indentation.size() - 1);\n+                    }\n+                    addedIndentation \u003d false;\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n-                    for (TextElement e : indentationBlock()) {\n-                        nodeText.addElement(nodeTextIndex++, e);\n+                    if (!addedIndentation) {\n+                        for (TextElement e : indentationBlock()) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmIndent) {\n                     diffIndex++;\n                 } else if (kept.element instanceof CsmUnindent) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a31908d22bc52d1bf24e00d3bc1bc709224156fd": {
      "type": "Ybodychange",
      "commitMessage": "initial handling of indent/unindent in Difference\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "488ccb1191c3b71644bdc9176712394220b9252b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmIndent) {\n                    diffIndex++;\n                } else if (kept.element instanceof CsmUnindent) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 446,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,152 +1,156 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 CsmElement addedElement \u003d ((Added) diffEl).element;\n                 if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                     diffIndex++;\n                     continue;\n                 }\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n+                } else if (kept.element instanceof CsmIndent) {\n+                    diffIndex++;\n+                } else if (kept.element instanceof CsmUnindent) {\n+                    diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "488ccb1191c3b71644bdc9176712394220b9252b": {
      "type": "Ybodychange",
      "commitMessage": "propagating CsmIndent and CsmUnindent\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "488ccb1191c3b71644bdc9176712394220b9252b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/5/21 下午7:26",
      "commitNameOld": "87b56cb1f18252c95d88b979a449f06d55def290",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                CsmElement addedElement \u003d ((Added) diffEl).element;\n                if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                    diffIndex++;\n                    continue;\n                }\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 408,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,147 +1,152 @@\n void apply(NodeText nodeText, Node node) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n-                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                CsmElement addedElement \u003d ((Added) diffEl).element;\n+                if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n+                    diffIndex++;\n+                    continue;\n+                }\n+                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87b56cb1f18252c95d88b979a449f06d55def290": {
      "type": "Ybodychange",
      "commitMessage": "working on propagating the indentation to NodeText generated\n",
      "commitDate": "2017/5/21 下午7:26",
      "commitName": "87b56cb1f18252c95d88b979a449f06d55def290",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/3/7 上午12:35",
      "commitNameOld": "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 75.79,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 375,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,147 +1,147 @@\n void apply(NodeText nodeText, Node node) {\n-    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n+    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b29a465257afcf2cc720c9423c2ddedd1edd31a3": {
      "type": "Ybodychange",
      "commitMessage": "Move TokenConstants around\n",
      "commitDate": "2017/3/7 上午12:35",
      "commitName": "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017/3/7 上午12:15",
      "commitNameOld": "9192b9d17903947058b755b987d1c57a05821e58",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 375,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,147 +1,147 @@\n void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n+                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9192b9d17903947058b755b987d1c57a05821e58": {
      "type": "Ybodychange",
      "commitMessage": "* explicitly match \\r\\n in the grammar\n* centralize token handling\n",
      "commitDate": "2017/3/7 上午12:15",
      "commitName": "9192b9d17903947058b755b987d1c57a05821e58",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017/3/6 下午11:40",
      "commitNameOld": "b1cd1afb0aaa19f370a169350318496ca7e541bb",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isNewline()) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 375,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,147 +1,147 @@\n void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n-                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n+                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                    if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n+                    if (textElement.isNewline()) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n+                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n-                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n+                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1cd1afb0aaa19f370a169350318496ca7e541bb": {
      "type": "Ybodychange",
      "commitMessage": "Some attempts at getting \\r\\n recognized.\n",
      "commitDate": "2017/3/6 下午11:40",
      "commitName": "b1cd1afb0aaa19f370a169350318496ca7e541bb",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2017/3/5 下午6:02",
      "commitNameOld": "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 377,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,147 +1,147 @@\n void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n-                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n+                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                    if (textElement.isToken(NEWLINE_TOKEN)) {\n+                    if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n+                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n-                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n+                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "adb78b277512189cc5f8ecb076d9bf8106f9e1e0": {
      "type": "Ybodychange",
      "commitMessage": "issue823: distinguish between spaces and comments\n",
      "commitDate": "2017/3/5 下午6:02",
      "commitName": "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/3/5 下午5:50",
      "commitNameOld": "0be8bb2b4275456c18bee064c5de2ccb12a33080",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 378,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,145 +1,147 @@\n void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n-                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl.isComment()) {\n+                    nodeTextIndex++;\n+                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0be8bb2b4275456c18bee064c5de2ccb12a33080": {
      "type": "Ybodychange",
      "commitMessage": "issue823: add TextElement.isWhiteSpaceOrComment\n",
      "commitDate": "2017/3/5 下午5:50",
      "commitName": "0be8bb2b4275456c18bee064c5de2ccb12a33080",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/28 上午3:50",
      "commitNameOld": "de2adb51f6f0465024755f034fe27de56c651ffd",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 378,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,145 +1,145 @@\n void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+            if (nodeTextEl.isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (nodeTextEl.isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bd0af28e7b81048d9bda153b908c727304ca8a04": {
      "type": "Ybodychange",
      "commitMessage": "issue124: remove Tokens\n",
      "commitDate": "2017/2/24 上午1:57",
      "commitName": "bd0af28e7b81048d9bda153b908c727304ca8a04",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午1:39",
      "commitNameOld": "15cb49e74025eb4011187f31735aa4772993fb5d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (nodeTextEl.isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 377,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
      "diff": "@@ -1,143 +1,145 @@\n void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n-                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n-                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n-                    diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n+                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n+                    diffIndex++;\n+                } else if (nodeTextEl.isWhiteSpace()) {\n+                    nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15cb49e74025eb4011187f31735aa4772993fb5d": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "issue124: final cleanup\n",
      "commitDate": "2017/2/24 上午1:39",
      "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "issue124: final cleanup\n",
          "commitDate": "2017/2/24 上午1:39",
          "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:20",
          "commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 377,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
          "diff": "@@ -1,143 +1,143 @@\n-public void apply(NodeText nodeText, Node node) {\n+void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue124: final cleanup\n",
          "commitDate": "2017/2/24 上午1:39",
          "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:20",
          "commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 377,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
          "diff": "@@ -1,143 +1,143 @@\n-public void apply(NodeText nodeText, Node node) {\n+void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "issue124: final cleanup\n",
          "commitDate": "2017/2/24 上午1:39",
          "commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:20",
          "commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 377,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n",
          "diff": "@@ -1,143 +1,143 @@\n-public void apply(NodeText nodeText, Node node) {\n+void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                    } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\nto the difference (adding and removing the elements provided).\n"
          }
        }
      ]
    },
    "4b87b2b6b407077eb064ac949baaa2fbd0487986": {
      "type": "Ybodychange",
      "commitMessage": "issue124: more cleanup\n",
      "commitDate": "2017/2/24 上午12:20",
      "commitName": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:20",
      "commitNameOld": "a55cd517deae99d6bb32717af632cd9dc9f01928",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 352,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,143 +1,143 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n-                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n-                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n-                    if (textElement.isToken(3)) {\n+                    if (textElement.isToken(NEWLINE_TOKEN)) {\n                         used \u003d true;\n                     }\n-                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                        throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a55cd517deae99d6bb32717af632cd9dc9f01928": {
      "type": "Ybodychange",
      "commitMessage": "issue124: clean up\n",
      "commitDate": "2017/2/24 上午12:20",
      "commitName": "a55cd517deae99d6bb32717af632cd9dc9f01928",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,153 +1,143 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n-    boolean comingFromRemoved \u003d false;\n-    boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n-                comingFromRemoved \u003d false;\n-                comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 if (textElement.isNewline()) {\n                     nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                 }\n                 diffIndex++;\n-                comingFromRemoved \u003d false;\n-                comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n-                comingFromRemoved \u003d false;\n-                comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n-                comingFromRemoved \u003d true;\n-                comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7121d100d536b7b3df76c22ad3acc4c507be7bfe": {
      "type": "Ybodychange",
      "commitMessage": "issue124: adjusting indentation of following line\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                if (textElement.isNewline()) {\n                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,150 +1,153 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                         nodeText.getElements().remove(nodeTextIndex);\n                     }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n+                if (textElement.isNewline()) {\n+                    nodeTextIndex \u003d adjustIndentation(indentation, nodeText, nodeTextIndex);\n+                }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "152592f7c8110f04ea6ca6e6c6d57360fd40ee16": {
      "type": "Ybodychange",
      "commitMessage": "issue124: fix findIndentation\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "e71e376b9542dd7fea6e973301d8d426f340d65b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                        nodeText.getElements().remove(nodeTextIndex);\n                    }\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,147 +1,150 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                    while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n+                        nodeText.getElements().remove(nodeTextIndex);\n+                    }\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e71e376b9542dd7fea6e973301d8d426f340d65b": {
      "type": "Ybodychange",
      "commitMessage": "issue124: specific support for replacement\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "e71e376b9542dd7fea6e973301d8d426f340d65b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 373,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,147 +1,147 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n-                } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n+                } else if (isAfterLBrace(nodeText, nodeTextIndex) \u0026\u0026 !isAReplacement(diffIndex)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     } else {\n                         if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                             nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                         }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ed7f4a6532043b5ac8c8da55923fbd91f72ec574": {
      "type": "Ybodychange",
      "commitMessage": "issue124: special handling for replacement\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    } else {\n                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n                        }\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 372,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,143 +1,147 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                    } else {\n+                        if (diffIndex + 1 \u003e\u003d this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                            nodeTextIndex \u003d considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                        }\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "548fb9c5a72776ec009c5f2f92b1a4c480a05030": {
      "type": "Ybodychange",
      "commitMessage": "issue124: correct isAfterLBrace\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "f21322dd131f30bfcd809d2748a2366df7dc27d3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 344,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,143 +1,143 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n-                } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f21322dd131f30bfcd809d2748a2366df7dc27d3": {
      "type": "Ybodychange",
      "commitMessage": "issue124: minor bug\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "f21322dd131f30bfcd809d2748a2366df7dc27d3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "882790065271126fc4b17a71bebb078b60ffe00c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 334,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,143 +1,143 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n-                    if (nodeTextIndex \u003e nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                    if (nodeTextIndex \u003c nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                         nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "882790065271126fc4b17a71bebb078b60ffe00c": {
      "type": "Ybodychange",
      "commitMessage": "issue124: removing empty lines\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "882790065271126fc4b17a71bebb078b60ffe00c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "572ea89397e9b3b35dc616d48176ab0d296612dd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    if (nodeTextIndex \u003e nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n                    }\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 334,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,144 +1,143 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n-            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                     if (textElement.isToken(3)) {\n                         used \u003d true;\n                     }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n                 if (!used) {\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                 }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n-                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                        if (comingFromRemoved) {\n-                            nodeText.removeElement(nodeTextIndex);\n-                        } else {\n-                            nodeTextIndex++;\n-                        }\n+                    if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                        nodeTextIndex++;\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n-                    } else if (nodeTextToken.isWhiteSpace()) {\n+                    } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n+                    if (nodeTextIndex \u003e nodeText.getElements().size() \u0026\u0026 nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                        nodeTextIndex \u003d considerCleaningTheLine(nodeText, nodeTextIndex);\n+                    }\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n-                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "572ea89397e9b3b35dc616d48176ab0d296612dd": {
      "type": "Ybodychange",
      "commitMessage": "issue124: more newlines processing\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "572ea89397e9b3b35dc616d48176ab0d296612dd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                boolean used \u003d false;\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                    if (textElement.isToken(3)) {\n                        used \u003d true;\n                    }\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                if (!used) {\n                    nodeText.addElement(nodeTextIndex, textElement);\n                    nodeTextIndex++;\n                }\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 326,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,138 +1,144 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                boolean used \u003d false;\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                    if (textElement.isToken(3)) {\n+                        used \u003d true;\n+                    }\n                     nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                     for (TextElement e : indentationBlock()) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n                 }\n-                nodeText.addElement(nodeTextIndex, textElement);\n-                nodeTextIndex++;\n+                if (!used) {\n+                    nodeText.addElement(nodeTextIndex, textElement);\n+                    nodeTextIndex++;\n+                }\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48ac9477b3997592001fa0f44f98eb7481f7b9ea": {
      "type": "Ybodychange",
      "commitMessage": "issue124: improvements in processing indentation\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "5d76ede0db52033984e3d7908105c6f2f4380725",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                    for (TextElement e : indentationBlock()) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                nodeText.addElement(nodeTextIndex, textElement);\n                nodeTextIndex++;\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 326,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,130 +1,138 @@\n public void apply(NodeText nodeText, Node node) {\n     List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                 if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                     for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                         nodeText.addElement(nodeTextIndex++, e);\n                     }\n+                } else if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                    nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                        nodeText.addElement(nodeTextIndex++, e);\n+                    }\n+                    for (TextElement e : indentationBlock()) {\n+                        nodeText.addElement(nodeTextIndex++, e);\n+                    }\n                 }\n                 nodeText.addElement(nodeTextIndex, textElement);\n                 nodeTextIndex++;\n                 diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d76ede0db52033984e3d7908105c6f2f4380725": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue124: consider indentation\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue124: consider indentation\n",
          "commitDate": "2017/2/24 上午12:19",
          "commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:19",
          "commitNameOld": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                nodeText.addElement(nodeTextIndex, textElement);\n                nodeTextIndex++;\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 317,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,123 +1,130 @@\n-public void apply(NodeText nodeText) {\n+public void apply(NodeText nodeText, Node node) {\n+    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n-                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                diffIndex++;\n+                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                        nodeText.addElement(nodeTextIndex++, e);\n+                    }\n+                }\n+                nodeText.addElement(nodeTextIndex, textElement);\n                 nodeTextIndex++;\n+                diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[nodeText-NodeText]",
            "newValue": "[nodeText-NodeText, node-Node]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue124: consider indentation\n",
          "commitDate": "2017/2/24 上午12:19",
          "commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:19",
          "commitNameOld": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public void apply(NodeText nodeText, Node node) {\n    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                        nodeText.addElement(nodeTextIndex++, e);\n                    }\n                }\n                nodeText.addElement(nodeTextIndex, textElement);\n                nodeTextIndex++;\n                diffIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 317,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,123 +1,130 @@\n-public void apply(NodeText nodeText) {\n+public void apply(NodeText nodeText, Node node) {\n+    List\u003cTokenTextElement\u003e indentation \u003d nodeText.getLexicalPreservingPrinter().findIndentation(node);\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                    if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n-                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                diffIndex++;\n+                TextElement textElement \u003d toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                if (nodeTextIndex \u003e 0 \u0026\u0026 nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                    for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                        nodeText.addElement(nodeTextIndex++, e);\n+                    }\n+                }\n+                nodeText.addElement(nodeTextIndex, textElement);\n                 nodeTextIndex++;\n+                diffIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                    } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                     if (isPrimitiveType(nodeTextEl)) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f": {
      "type": "Ybodychange",
      "commitMessage": "issue124: now changing the type of variable causes also the maxCommonType of the enclosing declaration to change\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n                    if (isPrimitiveType(nodeTextEl)) {\n                        nodeText.removeElement(nodeTextIndex);\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 295,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,116 +1,123 @@\n public void apply(NodeText nodeText) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n+                } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild \u0026\u0026 ((LexicalDifferenceCalculator.CsmChild) removed.element).getChild() instanceof PrimitiveType) {\n+                    if (isPrimitiveType(nodeTextEl)) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                    }\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa": {
      "type": "Ybodychange",
      "commitMessage": "issue124: added tollerance for Diff expecting to keep whitespace\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "a616b929f4a243fd5ed9097d399e7c6bbe79dfc1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 294,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,114 +1,116 @@\n public void apply(NodeText nodeText) {\n     if (nodeText \u003d\u003d null) {\n         throw new NullPointerException();\n     }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n+                } else if ((kept.element instanceof CsmToken) \u0026\u0026 ((CsmToken) kept.element).isWhiteSpace()) {\n+                    diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0f313058c4389cd48052112e3fb906c060be30f": {
      "type": "Ybodychange",
      "commitMessage": "issue124: improving how JavadocComment is handled\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "f0f313058c4389cd48052112e3fb906c060be30f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "b062cd703845b9a2d65e423e912d4e245f185ed4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    if (nodeText \u003d\u003d null) {\n        throw new NullPointerException();\n    }\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 295,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,109 +1,114 @@\n public void apply(NodeText nodeText) {\n+    if (nodeText \u003d\u003d null) {\n+        throw new NullPointerException();\n+    }\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n                 comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n+                } else if (removed.element instanceof CsmToken \u0026\u0026 ((CsmToken) removed.element).isWhiteSpace()) {\n+                    diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n                 comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c2c1abbfcee5a8874d805a58f08d7d21c20482c": {
      "type": "Ybodychange",
      "commitMessage": "issue124: difference now considering added whitespace\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "6c2c1abbfcee5a8874d805a58f08d7d21c20482c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "566e84eb47ec36af0964ae8a3584460737917d73",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    boolean comingFromAdded \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d true;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n                comingFromAdded \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n                comingFromAdded \u003d false;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 295,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,104 +1,109 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n+    boolean comingFromAdded \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n+                comingFromAdded \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n+                comingFromAdded \u003d true;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n+                comingFromAdded \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n+                comingFromAdded \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "566e84eb47ec36af0964ae8a3584460737917d73": {
      "type": "Ybodychange",
      "commitMessage": "issue124: added annotationDeclarationExampleWithModifierAdded\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "566e84eb47ec36af0964ae8a3584460737917d73",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "74000e047aaabc467031830b1d958b281cf28df9",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                    nodeTextIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 285,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,102 +1,104 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                             LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                             if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n+                } else if (nodeTextEl instanceof TokenTextElement \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                    nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "issue124: extract Difference\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "issue124: extract Difference\n",
          "commitDate": "2017/2/24 上午12:19",
          "commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:19",
          "commitNameOld": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 233,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,102 +1,102 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (isWhitespace(csmToken.getTokenType())) {\n+                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n-                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n-                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n-                        if (kept.element instanceof CsmChild) {\n-                            CsmChild keptChild \u003d (CsmChild) kept.element;\n-                            if (keptChild.child instanceof PrimitiveType) {\n+                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n+                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n+                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (isWhitespace(csmToken.getTokenType())) {\n+                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n-                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
            "newPath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
            "oldMethodName": "apply",
            "newMethodName": "apply"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue124: extract Difference\n",
          "commitDate": "2017/2/24 上午12:19",
          "commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/2/24 上午12:19",
          "commitNameOld": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 233,
          "functionName": "apply",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,102 +1,102 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n-                    if (isWhitespace(csmToken.getTokenType())) {\n+                    if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n-                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n-                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n-                        if (kept.element instanceof CsmChild) {\n-                            CsmChild keptChild \u003d (CsmChild) kept.element;\n-                            if (keptChild.child instanceof PrimitiveType) {\n+                        if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n+                            LexicalDifferenceCalculator.CsmChild keptChild \u003d (LexicalDifferenceCalculator.CsmChild) kept.element;\n+                            if (keptChild.getChild() instanceof PrimitiveType) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n-                    } else if (isWhitespace(csmToken.getTokenType())) {\n+                    } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n-                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ecefb777275fd26b37f10709f97810a3e6a69bb2": {
      "type": "Ybodychange",
      "commitMessage": "issue124: addressing a few more cases\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "670f643e671ee92ed35db80bb96e28fc5250866d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        if (kept.element instanceof CsmChild) {\n                            CsmChild keptChild \u003d (CsmChild) kept.element;\n                            if (keptChild.child instanceof PrimitiveType) {\n                                nodeTextIndex++;\n                                diffIndex++;\n                            } else {\n                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                            }\n                        } else {\n                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                        }\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 498,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,92 +1,102 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 nodeTextIndex++;\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                        if (kept.element instanceof CsmChild) {\n+                            CsmChild keptChild \u003d (CsmChild) kept.element;\n+                            if (keptChild.child instanceof PrimitiveType) {\n+                                nodeTextIndex++;\n+                                diffIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                        }\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else if (isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else if (nodeTextToken.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01e9c90792e879eca937a12b6bb30b31e51aee53": {
      "type": "Ybodychange",
      "commitMessage": "issue124: expanding the cases covered\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "01e9c90792e879eca937a12b6bb30b31e51aee53",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                nodeTextIndex++;\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else if (nodeTextToken.isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 429,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,81 +1,92 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n+            } else if (diffEl instanceof Added) {\n+                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                nodeTextIndex++;\n+                diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                 nodeTextIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n             }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                     if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                         nodeTextIndex++;\n                         diffIndex++;\n+                    } else if (isWhitespace(csmToken.getTokenType())) {\n+                        diffIndex++;\n+                    } else if (nodeTextToken.isWhiteSpace()) {\n+                        nodeTextIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException();\n+                        throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n+                } else if ((removed.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement \u0026\u0026 ((CsmToken) removed.element).getTokenType() \u003d\u003d ((TokenTextElement) nodeTextEl).getTokenKind()) {\n+                    nodeText.removeElement(nodeTextIndex);\n+                    diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4ce6ce924ffbd03518c64cea9b830d04f75b849": {
      "type": "Ybodychange",
      "commitMessage": "issue124: array creation level support using CSM\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "6f102302a83146e02d13ff476f39fc8a86710e38",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                nodeTextIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n            }\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n                        nodeTextIndex++;\n                        diffIndex++;\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 332,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,68 +1,81 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n     boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n                 comingFromRemoved \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n-            nodeTextIndex++;\n-            throw new UnsupportedOperationException(\"B\");\n+            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+            if ((nodeTextEl instanceof TokenTextElement) \u0026\u0026 ((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                nodeTextIndex++;\n+            } else {\n+                throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+            }\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                         if (comingFromRemoved) {\n                             nodeText.removeElement(nodeTextIndex);\n                         } else {\n                             nodeTextIndex++;\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n+                } else if ((kept.element instanceof CsmToken) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                    CsmToken csmToken \u003d (CsmToken) kept.element;\n+                    TokenTextElement nodeTextToken \u003d (TokenTextElement) nodeTextEl;\n+                    if (csmToken.getTokenType() \u003d\u003d nodeTextToken.getTokenKind()) {\n+                        nodeTextIndex++;\n+                        diffIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n                 comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f102302a83146e02d13ff476f39fc8a86710e38": {
      "type": "Ybodychange",
      "commitMessage": "issue124: lexical preservation based on CSM implemented for CompilationUnit\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "6f102302a83146e02d13ff476f39fc8a86710e38",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    boolean comingFromRemoved \u003d false;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n                comingFromRemoved \u003d false;\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            nodeTextIndex++;\n            throw new UnsupportedOperationException(\"B\");\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        if (comingFromRemoved) {\n                            nodeText.removeElement(nodeTextIndex);\n                        } else {\n                            nodeTextIndex++;\n                        }\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d false;\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n                comingFromRemoved \u003d true;\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 332,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,68 @@\n public void apply(NodeText nodeText) {\n     int diffIndex \u003d 0;\n     int nodeTextIndex \u003d 0;\n+    boolean comingFromRemoved \u003d false;\n     do {\n         if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if (kept.element instanceof CsmToken) {\n                     CsmToken csmToken \u003d (CsmToken) kept.element;\n                     if (isWhitespace(csmToken.getTokenType())) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else {\n                     throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                 }\n+                comingFromRemoved \u003d false;\n             } else {\n                 throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n             }\n         } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n             nodeTextIndex++;\n             throw new UnsupportedOperationException(\"B\");\n         } else {\n             DifferenceElement diffEl \u003d elements.get(diffIndex);\n             TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n             if (diffEl instanceof Added) {\n                 nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                 diffIndex++;\n                 nodeTextIndex++;\n+                comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Kept) {\n                 Kept kept \u003d (Kept) diffEl;\n                 if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     diffIndex++;\n                     nodeTextIndex++;\n                 } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                     if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                        nodeTextIndex++;\n+                        if (comingFromRemoved) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                        } else {\n+                            nodeTextIndex++;\n+                        }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                 }\n+                comingFromRemoved \u003d false;\n             } else if (diffEl instanceof Removed) {\n                 Removed removed \u003d (Removed) diffEl;\n                 if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                     nodeText.removeElement(nodeTextIndex);\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                 }\n+                comingFromRemoved \u003d true;\n             } else {\n                 throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n             }\n         }\n     } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee": {
      "type": "Ybodychange",
      "commitMessage": "issue124: applying differences\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/2/24 上午12:19",
      "commitNameOld": "c73ae5d79b62de91209477538b45ab5216fb108e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void apply(NodeText nodeText) {\n    int diffIndex \u003d 0;\n    int nodeTextIndex \u003d 0;\n    do {\n        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if (kept.element instanceof CsmToken) {\n                    CsmToken csmToken \u003d (CsmToken) kept.element;\n                    if (isWhitespace(csmToken.getTokenType())) {\n                        diffIndex++;\n                    } else {\n                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                    }\n                } else {\n                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                }\n            } else {\n                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n            }\n        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n            nodeTextIndex++;\n            throw new UnsupportedOperationException(\"B\");\n        } else {\n            DifferenceElement diffEl \u003d elements.get(diffIndex);\n            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n            if (diffEl instanceof Added) {\n                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                diffIndex++;\n                nodeTextIndex++;\n            } else if (diffEl instanceof Kept) {\n                Kept kept \u003d (Kept) diffEl;\n                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    diffIndex++;\n                    nodeTextIndex++;\n                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                        nodeTextIndex++;\n                    } else {\n                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                }\n            } else if (diffEl instanceof Removed) {\n                Removed removed \u003d (Removed) diffEl;\n                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n                    nodeText.removeElement(nodeTextIndex);\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                }\n            } else {\n                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n            }\n        }\n    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 332,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,2 +1,59 @@\n public void apply(NodeText nodeText) {\n+    int diffIndex \u003d 0;\n+    int nodeTextIndex \u003d 0;\n+    do {\n+        if (diffIndex \u003c this.elements.size() \u0026\u0026 nodeTextIndex \u003e\u003d nodeText.getElements().size()) {\n+            DifferenceElement diffEl \u003d elements.get(diffIndex);\n+            if (diffEl instanceof Kept) {\n+                Kept kept \u003d (Kept) diffEl;\n+                if (kept.element instanceof CsmToken) {\n+                    CsmToken csmToken \u003d (CsmToken) kept.element;\n+                    if (isWhitespace(csmToken.getTokenType())) {\n+                        diffIndex++;\n+                    } else {\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+            }\n+        } else if (diffIndex \u003e\u003d this.elements.size() \u0026\u0026 nodeTextIndex \u003c nodeText.getElements().size()) {\n+            nodeTextIndex++;\n+            throw new UnsupportedOperationException(\"B\");\n+        } else {\n+            DifferenceElement diffEl \u003d elements.get(diffIndex);\n+            TextElement nodeTextEl \u003d nodeText.getElements().get(nodeTextIndex);\n+            if (diffEl instanceof Added) {\n+                nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                diffIndex++;\n+                nodeTextIndex++;\n+            } else if (diffEl instanceof Kept) {\n+                Kept kept \u003d (Kept) diffEl;\n+                if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                    diffIndex++;\n+                    nodeTextIndex++;\n+                } else if ((kept.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof TokenTextElement) {\n+                    if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                        nodeTextIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                    }\n+                } else {\n+                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                }\n+            } else if (diffEl instanceof Removed) {\n+                Removed removed \u003d (Removed) diffEl;\n+                if ((removed.element instanceof CsmChild) \u0026\u0026 nodeTextEl instanceof ChildTextElement) {\n+                    nodeText.removeElement(nodeTextIndex);\n+                    diffIndex++;\n+                } else {\n+                    throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+            }\n+        }\n+    } while (diffIndex \u003c this.elements.size() || nodeTextIndex \u003c nodeText.getElements().size());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c73ae5d79b62de91209477538b45ab5216fb108e": {
      "type": "Yintroduced",
      "commitMessage": "issue124: working on calculate the CSM difference before and after a property change\n",
      "commitDate": "2017/2/24 上午12:19",
      "commitName": "c73ae5d79b62de91209477538b45ab5216fb108e",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,2 @@\n+public void apply(NodeText nodeText) {\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void apply(NodeText nodeText) {\n}",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
      "functionStartLine": 206,
      "functionName": "apply",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}