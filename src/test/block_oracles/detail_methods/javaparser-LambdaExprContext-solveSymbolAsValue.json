{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "LambdaExprContext.java",
  "functionName": "solveSymbolAsValue",
  "functionId": "solveSymbolAsValue___name-String__typeSolver-TypeSolver",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 56,
  "functionEndLine": 138,
  "numCommitsSeen": 60,
  "timeTaken": 932,
  "changeHistory": [
    "b54617e765d73b3ce0d187cf12ad8da382bce439",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
    "0aaa5e5b086a557801d54f8a3ac236e08513e774",
    "acdac6790f4424f8097b3aa6c888e825cac485f9",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518",
    "631896a1d2f34eed89c41cc717f463ebbd69e401",
    "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
    "6fcf6356a95a250db103245c1c5f2d596f9493d6",
    "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
    "03e407957d600a18ef0a4a83224c17d155ef8645",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
    "70f3e66c944670a818922f101162226ef604b263",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "8d234965b572759181da7787fead07b225e9e5ca",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
    "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f"
  ],
  "changeHistoryShort": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ybodychange",
    "5da7835cd514233e05ff8ceb07b4f82063b0d08e": "Ybodychange",
    "0aaa5e5b086a557801d54f8a3ac236e08513e774": "Ybodychange",
    "acdac6790f4424f8097b3aa6c888e825cac485f9": "Ybodychange",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": "Ybodychange",
    "631896a1d2f34eed89c41cc717f463ebbd69e401": "Ybodychange",
    "dc093e9ac9ae3239375c654c4cfff92ee0fb3927": "Ybodychange",
    "6fcf6356a95a250db103245c1c5f2d596f9493d6": "Ybodychange",
    "ecc1af475857cf3c62b3a07eb35ad080ed435dea": "Ybodychange",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": "Ybodychange",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": "Ybodychange",
    "03e407957d600a18ef0a4a83224c17d155ef8645": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": "Ybodychange",
    "70f3e66c944670a818922f101162226ef604b263": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "8d234965b572759181da7787fead07b225e9e5ca": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ybodychange",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": "Ybodychange",
    "e529ad59cb7c1766706162cbc3a4fca49cd88e3e": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ybodychange",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": {
      "type": "Ybodychange",
      "commitMessage": "Cleaning up JSS code\n",
      "commitDate": "2018/2/4 上午2:46",
      "commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018/1/10 下午8:52",
      "commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 24.25,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (requireParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) requireParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found \u003d false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found \u003d true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        ResolvedLambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                        }\n                        Value value \u003d new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (requireParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) requireParentNode(wrappedNode);\n                    ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                    ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 56,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,71 +1,71 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n-                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n-                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n+                if (requireParentNode(wrappedNode) instanceof MethodCallExpr) {\n+                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) requireParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                     if (functionalMethodOpt.isPresent()) {\n                         MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                         boolean found \u003d false;\n                         int lambdaParamIndex;\n                         for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                             if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                 found \u003d true;\n                                 break;\n                             }\n                         }\n                         if (!found) {\n                             return Optional.empty();\n                         }\n                         ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                         ResolvedLambdaConstraintType conType;\n                         if (argType.isWildcard()) {\n                             conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                         } else {\n                             conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                         }\n                         Value value \u003d new Value(conType, name);\n                         return Optional.of(value);\n                     } else {\n                         return Optional.empty();\n                     }\n-                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n-                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n+                } else if (requireParentNode(wrappedNode) instanceof VariableDeclarator) {\n+                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) requireParentNode(wrappedNode);\n                     ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n                         Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                         if (lambdaType.isReferenceType()) {\n                             for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                     ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                     lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018/1/10 下午8:52",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/1/10 下午4:01",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found \u003d false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found \u003d true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        ResolvedLambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                        }\n                        Value value \u003d new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                    ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
      }
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ybodychange",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017/9/29 上午4:36",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/3/11 上午5:50",
      "commitNameOld": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 201.95,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found \u003d false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found \u003d true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        ResolvedLambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                        }\n                        Value value \u003d new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                    ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,71 +1,71 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n-        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n+        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n-                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                    ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                     if (functionalMethodOpt.isPresent()) {\n                         MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                         boolean found \u003d false;\n                         int lambdaParamIndex;\n                         for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                             if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                 found \u003d true;\n                                 break;\n                             }\n                         }\n                         if (!found) {\n                             return Optional.empty();\n                         }\n-                        Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n-                        LambdaConstraintType conType;\n+                        ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n+                        ResolvedLambdaConstraintType conType;\n                         if (argType.isWildcard()) {\n-                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                            conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                         } else {\n-                            conType \u003d LambdaConstraintType.bound(argType);\n+                            conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                         }\n                         Value value \u003d new Value(conType, name);\n                         return Optional.of(value);\n                     } else {\n                         return Optional.empty();\n                     }\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n-                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n+                    ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n-                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n-                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n+                        ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n+                        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                         if (lambdaType.isReferenceType()) {\n-                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n-                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n-                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n+                            for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n+                                if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n+                                    ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n+                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5da7835cd514233e05ff8ceb07b4f82063b0d08e": {
      "type": "Ybodychange",
      "commitMessage": "Small readability changes\n",
      "commitDate": "2017/3/11 上午5:50",
      "commitName": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/3/11 上午3:11",
      "commitNameOld": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found \u003d false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found \u003d true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        LambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType \u003d LambdaConstraintType.bound(argType);\n                        }\n                        Value value \u003d new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,71 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                     if (functionalMethodOpt.isPresent()) {\n                         MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                         boolean found \u003d false;\n                         int lambdaParamIndex;\n                         for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                             if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                 found \u003d true;\n                                 break;\n                             }\n                         }\n-                        if (!found)\n+                        if (!found) {\n                             return Optional.empty();\n+                        }\n                         Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                         LambdaConstraintType conType;\n                         if (argType.isWildcard()) {\n                             conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                         } else {\n                             conType \u003d LambdaConstraintType.bound(argType);\n                         }\n                         Value value \u003d new Value(conType, name);\n                         return Optional.of(value);\n                     } else {\n                         return Optional.empty();\n                     }\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                     lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0aaa5e5b086a557801d54f8a3ac236e08513e774": {
      "type": "Ybodychange",
      "commitMessage": "Fix some issues with recovering types of lambda arguments\n",
      "commitDate": "2017/3/11 上午3:11",
      "commitName": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/3/10 上午9:22",
      "commitNameOld": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found \u003d false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found \u003d true;\n                                break;\n                            }\n                        }\n                        if (!found)\n                            return Optional.empty();\n                        Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        LambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType \u003d LambdaConstraintType.bound(argType);\n                        }\n                        Value value \u003d new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,70 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                    Type argType \u003d lambdaType.asReferenceType().typeParametersValues().get(0);\n-                    LambdaConstraintType conType;\n-                    if (argType.isWildcard()) {\n-                        conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                    Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n+                    if (functionalMethodOpt.isPresent()) {\n+                        MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n+                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n+                        boolean found \u003d false;\n+                        int lambdaParamIndex;\n+                        for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++) {\n+                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n+                                found \u003d true;\n+                                break;\n+                            }\n+                        }\n+                        if (!found)\n+                            return Optional.empty();\n+                        Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n+                        LambdaConstraintType conType;\n+                        if (argType.isWildcard()) {\n+                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                        } else {\n+                            conType \u003d LambdaConstraintType.bound(argType);\n+                        }\n+                        Value value \u003d new Value(conType, name);\n+                        return Optional.of(value);\n                     } else {\n-                        conType \u003d LambdaConstraintType.bound(argType);\n+                        return Optional.empty();\n                     }\n-                    Value value \u003d new Value(conType, name);\n-                    return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                     lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "acdac6790f4424f8097b3aa6c888e825cac485f9": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for type inference\n",
      "commitDate": "2017/3/10 上午9:22",
      "commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/3/9 上午11:31",
      "commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Type argType \u003d lambdaType.asReferenceType().typeParametersValues().get(0);\n                    LambdaConstraintType conType;\n                    if (argType.isWildcard()) {\n                        conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                    } else {\n                        conType \u003d LambdaConstraintType.bound(argType);\n                    }\n                    Value value \u003d new Value(conType, name);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,52 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n+                    Type argType \u003d lambdaType.asReferenceType().typeParametersValues().get(0);\n+                    LambdaConstraintType conType;\n+                    if (argType.isWildcard()) {\n+                        conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                    } else {\n+                        conType \u003d LambdaConstraintType.bound(argType);\n+                    }\n+                    Value value \u003d new Value(conType, name);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                     lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": {
      "type": "Ybodychange",
      "commitMessage": "type inference\n",
      "commitDate": "2016/10/25 上午1:19",
      "commitName": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/23 下午5:26",
      "commitNameOld": "631896a1d2f34eed89c41cc717f463ebbd69e401",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.33,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 52,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,45 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n+                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot);\n+                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "631896a1d2f34eed89c41cc717f463ebbd69e401": {
      "type": "Ybodychange",
      "commitMessage": "commenting classes in model\n",
      "commitDate": "2016/10/23 下午5:26",
      "commitName": "631896a1d2f34eed89c41cc717f463ebbd69e401",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/22 下午8:39",
      "commitNameOld": "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,44 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                    lambdaType \u003d lambdaType.replaceParam(entry._1, ot);\n+                                    lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc093e9ac9ae3239375c654c4cfff92ee0fb3927": {
      "type": "Ybodychange",
      "commitMessage": "more usages of TypeParameterDeclaration instead of just the name\n",
      "commitDate": "2016/10/22 下午8:39",
      "commitName": "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/22 下午8:36",
      "commitNameOld": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceParam(entry._1, ot);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,44 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                    lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot);\n+                                    lambdaType \u003d lambdaType.replaceParam(entry._1, ot);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6fcf6356a95a250db103245c1c5f2d596f9493d6": {
      "type": "Ybodychange",
      "commitMessage": "model: refactoring\n",
      "commitDate": "2016/10/22 下午5:18",
      "commitName": "6fcf6356a95a250db103245c1c5f2d596f9493d6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/21 下午7:23",
      "commitNameOld": "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,44 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n-                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n-                                    if (ot.isPresent()) {\n-                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n-                                    }\n+                                    Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n+                                    lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot);\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n-                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n-                            if (ot.isPresent()) {\n-                                lambdaType \u003d ot.get();\n-                            }\n+                            lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                         }\n                         Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc1af475857cf3c62b3a07eb35ad080ed435dea": {
      "type": "Ybodychange",
      "commitMessage": "more comments on model\n",
      "commitDate": "2016/10/21 下午7:23",
      "commitName": "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/21 下午2:55",
      "commitNameOld": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n+                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n-                        Value value \u003d new Value(lambdaType, name, false);\n+                        Value value \u003d new Value(lambdaType, name);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
      "type": "Ybodychange",
      "commitMessage": "adding more comments in model declarations\n",
      "commitDate": "2016/10/21 下午2:55",
      "commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/21 上午4:06",
      "commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                     Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n-                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n+                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n-                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n+                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016/10/20 下午2:39",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 下午2:32",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 56,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
      }
    },
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": {
      "type": "Ybodychange",
      "commitMessage": "use VariableDeclarator.getType\n",
      "commitDate": "2016/10/20 上午1:36",
      "commitName": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:35",
      "commitNameOld": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 54,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,49 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n-                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n-                    if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n-                        declaratorType \u003d ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n-                    } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n-                        declaratorType \u003d ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n-                    } else {\n-                        throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n-                    }\n-                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                    Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
      "type": "Ybodychange",
      "commitMessage": "revision of modified code to use Navigator.getParentNode\n",
      "commitDate": "2016/10/20 上午1:35",
      "commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:34",
      "commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                    if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n                    } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n                    } else {\n                        throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 56,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n-                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n+                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n+                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n-                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n+                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n-                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n-                    if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n-                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n-                    } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n-                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n+                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n+                    if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n+                        declaratorType \u003d ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n+                    } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n+                        declaratorType \u003d ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n                     } else {\n-                        throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n+                        throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03e407957d600a18ef0a4a83224c17d155ef8645": {
      "type": "Ybodychange",
      "commitMessage": "fixing a few more tests\n",
      "commitDate": "2016/10/20 上午1:34",
      "commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:33",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                    } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                    } else {\n                        throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n-                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n-                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n-                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n-                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n+                    if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n+                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n+                    } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n+                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                     } else {\n-                        throw new UnsupportedOperationException();\n+                        throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/19 下午11:04",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n-                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n+                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n-                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n+                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
      "type": "Ybodychange",
      "commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
      "commitDate": "2016/10/15 上午4:57",
      "commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午1:24",
      "commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n+                    Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                         declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                         declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n-                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n-                                    Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                    Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n-                            Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                            Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f3e66c944670a818922f101162226ef604b263": {
      "type": "Ybodychange",
      "commitMessage": "deprecating some methods involving type parameters\n",
      "commitDate": "2016/10/15 上午1:24",
      "commitName": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午12:51",
      "commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n+                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                         declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                         declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016/10/15 上午12:51",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 下午2:36",
      "commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                         declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                         declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n                         Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n-                            for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                            for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d234965b572759181da7787fead07b225e9e5ca": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeSolver from MethodUsage\n",
      "commitDate": "2016/10/14 下午2:36",
      "commitName": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 上午4:11",
      "commitNameOld": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                         declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                         declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                     Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n-                        Type lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n+                        Type lambdaType \u003d functionalMethod.get().getParamType(index);\n                         if (lambdaType.isReferenceType()) {\n                             for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                     Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                             Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ybodychange",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016/10/14 上午4:11",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/13 上午5:43",
      "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n-                    TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                    Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n-                    Type declaratorType \u003d null;\n+                    com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                         declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                         declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n-                    TypeUsage t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                    Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                     Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                     if (functionalMethod.isPresent()) {\n-                        TypeUsage lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n+                        Type lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n                         if (lambdaType.isReferenceType()) {\n-                            for (Tuple2\u003cTypeParameter, TypeUsage\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                            for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                 if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n-                                    Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                    Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                     if (ot.isPresent()) {\n                                         lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                     }\n                                 }\n                             }\n                         } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n-                            Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                            Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                             if (ot.isPresent()) {\n                                 lambdaType \u003d ot.get();\n                             }\n                         }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n             index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": {
      "type": "Ybodychange",
      "commitMessage": "issue80: working on lambdas assigned to variables\n",
      "commitDate": "2016/10/13 上午5:43",
      "commitName": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/9/23 下午10:49",
      "commitNameOld": "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 19.29,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index \u003d 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    TypeUsage t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        TypeUsage lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2\u003cTypeParameter, TypeUsage\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                    Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                    if (ot.isPresent()) {\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                    }\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                            Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                            if (ot.isPresent()) {\n                                lambdaType \u003d ot.get();\n                            }\n                        }\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 40,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,57 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n+        int index \u003d 0;\n         for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n             if (decl.getName().equals(name)) {\n                 if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                     MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                     MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                     int i \u003d pos(methodCallExpr, wrappedNode);\n                     TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                     Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                     return Optional.of(value);\n                 } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                     Type declaratorType \u003d null;\n                     VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                     if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                         declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                     } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                         declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n-                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n-                    if (functionalMethod.isPresent() \u0026\u0026 functionalMethod.get().getNoParams() \u003d\u003d 1) {\n-                        TypeUsage lambdaType \u003d functionalMethod.get().getParamType(0, typeSolver);\n+                    TypeUsage t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n+                    if (functionalMethod.isPresent()) {\n+                        TypeUsage lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n+                        if (lambdaType.isReferenceType()) {\n+                            for (Tuple2\u003cTypeParameter, TypeUsage\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n+                                    Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                    if (ot.isPresent()) {\n+                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n+                                    }\n+                                }\n+                            }\n+                        } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n+                            Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                            if (ot.isPresent()) {\n+                                lambdaType \u003d ot.get();\n+                            }\n+                        }\n                         Value value \u003d new Value(lambdaType, name, false);\n                         return Optional.of(value);\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n                 }\n             }\n+            index++;\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e529ad59cb7c1766706162cbc3a4fca49cd88e3e": {
      "type": "Ybodychange",
      "commitMessage": "expanded LambdaExprContext to solve lambda parameter types in contexts other than method calls and implemented tests for newly supported cases.\n",
      "commitDate": "2016/9/23 下午10:49",
      "commitName": "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2015/12/4 上午4:36",
      "commitNameOld": "45898d6dbf0eab3b7258bd74125c70f498fca373",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 294.76,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i \u003d pos(methodCallExpr, wrappedNode);\n                    TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                    return Optional.of(value);\n                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                    Type declaratorType \u003d null;\n                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n                    if (functionalMethod.isPresent() \u0026\u0026 functionalMethod.get().getNoParams() \u003d\u003d 1) {\n                        TypeUsage lambdaType \u003d functionalMethod.get().getParamType(0, typeSolver);\n                        Value value \u003d new Value(lambdaType, name, false);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,39 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n-        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n-            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n-            int i \u003d pos(methodCallExpr, wrappedNode);\n-            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n-            Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n-            return Optional.of(value);\n-        } else {\n-            throw new UnsupportedOperationException();\n+        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n+            if (decl.getName().equals(name)) {\n+                if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+                    MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n+                    MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                    int i \u003d pos(methodCallExpr, wrappedNode);\n+                    TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                    Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n+                    return Optional.of(value);\n+                } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n+                    Type declaratorType \u003d null;\n+                    VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n+                    if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n+                        declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n+                    } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n+                        declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                    Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n+                    if (functionalMethod.isPresent() \u0026\u0026 functionalMethod.get().getNoParams() \u003d\u003d 1) {\n+                        TypeUsage lambdaType \u003d functionalMethod.get().getParamType(0, typeSolver);\n+                        Value value \u003d new Value(lambdaType, name, false);\n+                        return Optional.of(value);\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                } else {\n+                    throw new UnsupportedOperationException();\n+                }\n+            }\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015/11/22 下午6:45",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/22 下午6:03",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n            int i \u003d pos(methodCallExpr, wrappedNode);\n            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n            Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n            return Optional.of(value);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 33,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
      }
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015/11/13 下午5:12",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午4:53",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n            int i \u003d pos(methodCallExpr, wrappedNode);\n            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n            Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n            return Optional.of(value);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 29,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java"
      }
    },
    "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeUsage.typeParameters\n",
      "commitDate": "2015/10/30 下午11:48",
      "commitName": "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午5:53",
      "commitNameOld": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n            int i \u003d pos(methodCallExpr, wrappedNode);\n            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n            Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n            return Optional.of(value);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 25,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,17 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n             int i \u003d pos(methodCallExpr, wrappedNode);\n             TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n-            Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n+            Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n             return Optional.of(value);\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015/10/30 下午5:53",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午5:29",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n            int i \u003d pos(methodCallExpr, wrappedNode);\n            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n            Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n            return Optional.of(value);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 25,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java"
      }
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ybodychange",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015/8/5 下午10:25",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/5 下午10:08",
      "commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n            int i \u003d pos(methodCallExpr, wrappedNode);\n            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n            Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n            return Optional.of(value);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 24,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,17 @@\n @Override\n public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n     for (Parameter parameter : wrappedNode.getParameters()) {\n         SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n-            MethodUsage methodUsage \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n+            MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n             int i \u003d pos(methodCallExpr, wrappedNode);\n             TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n             Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n             return Optional.of(value);\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     }\n     return getParent().solveSymbolAsValue(name, typeSolver);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": {
      "type": "Yintroduced",
      "commitMessage": "add resolveReferenceToLambdaParamBase\n",
      "commitDate": "2015/8/5 下午10:08",
      "commitName": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,17 @@\n+@Override\n+public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n+    for (Parameter parameter : wrappedNode.getParameters()) {\n+        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n+        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n+            MethodUsage methodUsage \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n+            int i \u003d pos(methodCallExpr, wrappedNode);\n+            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n+            Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n+            return Optional.of(value);\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    return getParent().solveSymbolAsValue(name, typeSolver);\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            MethodUsage methodUsage \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n            int i \u003d pos(methodCallExpr, wrappedNode);\n            TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n            Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n            return Optional.of(value);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 24,
      "functionName": "solveSymbolAsValue",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}