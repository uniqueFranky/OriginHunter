{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "TreeWalker.java",
  "functionName": "processFiltered",
  "functionId": "processFiltered___file-File__fileText-FileText",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 176,
  "functionEndLine": 199,
  "numCommitsSeen": 522,
  "timeTaken": 7759,
  "changeHistory": [
    "58327e1dd9707b09f82ae2d4d4ce14c253247154",
    "f994512712c08a16def4a3c5a0426b7ab1590cc9",
    "6d9e8ece85007117e048fef55469623b830f9446",
    "82979737c4201b4913ea30b9c9431e71783d1c02",
    "d72e6f7d0b9f339feef4309a9dada7fd381ba242",
    "27e1e94244b6bb369c2ea7502c235260f49f78b0",
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
    "d46c2cf0e9df06bb5f424dbd7645574f082f7609",
    "be3e035ce39a610881cd2c1bfdce3eef101c2e3c",
    "5922d5a6730d7582d7d66121eb911ef9426f9e24",
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
    "4d2e6647f9e8385749c382bcab5e64965a943178",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
    "c4928f486c67afa62e7e8fbd5d8f731be7186985",
    "82d8e91024a57a96fbb6410dacb29d6a3f582903",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
    "a2da840df3bcb4e251695f7fbf1a5d341142459d",
    "ea9ff3965d9c657b5b7bd2d969e075f430635c47",
    "56743942d548686fb90ebd8b7a17fed5977e49dc",
    "aeef83ee58cce5b5bf0f10a8793fc37514751ef5",
    "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66",
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
    "1dacd5303bfe94b9d5476059b6a5676146d96708",
    "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
    "204c073294cdca6756bcd546d6af85a797ad7d79",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "a8b8375b1db65b131938111ff283baed771161ed",
    "a24df47cafeab03fd65cf72b460aad3d2fafce3d",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "3cd6646941eca3da7d3b9a221c88e4c1d214876e",
    "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
    "17754d363645285e49bf4323a1af5762af47a8ea",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "788b41973d5747c7b4699a853b62168cf0001df6",
    "76374876692534687016dba762a465bf93039402",
    "748df52c1317e298203bf28e48545d3e50db59f1",
    "915c6568cf2cde57c3e92ee9786acb4808562671",
    "44e3d33fc25d44157486288d5c77de75156984cb",
    "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0",
    "6db0b3effd48f02d741b2202338d710b1b254910",
    "5ace399de6c8963584b1fbe08007721433c4bad3",
    "d216ec75255a120ce7c24e51da7df63a2b9864de",
    "784b3270054dd61d8c6dbe413bcedfc628063171",
    "2149a9c42dce7a3913cca83755c8f562b0442929",
    "9f6a98ac725727519c43f6496f020c2e595dac57",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
    "abff1a2489ea8af10e1bc0a335551262d22f44e7",
    "54a09706ec1db32435b09e6b6910813325558f8d",
    "82b2ba526976588d550cac698e512f8de6c1ffc6",
    "93390fbc8a6952bbb20571ac1b18a705814fc219",
    "822384a711290170148b43b5ae390dd4e8cfaf4f",
    "4cbd709c019cf1b69796858506d673f7b66d37c7",
    "51941dcf2475545cee7b754acd5e2494c53acf9c",
    "03f8352479400cd2c80511bfe0242932a4f00f11",
    "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
    "751257987b2ef5f301e2deb3b55302196e5015af",
    "c682b5725d22afc38bf19d9667b23a7deab6d8c3",
    "7521f1897b007e3acc06ea3330df5124f4206589",
    "bbe51f6884ac0a961f55310e15ec90411709d970",
    "8f8879df46592e6e35658026c354b804ef328097",
    "190c0e5ca6cff056a136bc2c17f7678eb10686c7",
    "b671e6bb1c0652cfc1ccd07355cac99df584eb2f",
    "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
    "f8ea4c69a2228c5aca6c0b6e08a39a613d157708",
    "030798a11d2d21330cbdddd159cdc1824492157a",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3"
  ],
  "changeHistoryShort": {
    "58327e1dd9707b09f82ae2d4d4ce14c253247154": "Ybodychange",
    "f994512712c08a16def4a3c5a0426b7ab1590cc9": "Ybodychange",
    "6d9e8ece85007117e048fef55469623b830f9446": "Ybodychange",
    "82979737c4201b4913ea30b9c9431e71783d1c02": "Ymultichange(Yparameterchange,Ybodychange)",
    "d72e6f7d0b9f339feef4309a9dada7fd381ba242": "Ybodychange",
    "27e1e94244b6bb369c2ea7502c235260f49f78b0": "Ybodychange",
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": "Ybodychange",
    "d46c2cf0e9df06bb5f424dbd7645574f082f7609": "Ybodychange",
    "be3e035ce39a610881cd2c1bfdce3eef101c2e3c": "Ybodychange",
    "5922d5a6730d7582d7d66121eb911ef9426f9e24": "Ymultichange(Yexceptionschange,Ybodychange)",
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7": "Ybodychange",
    "4d2e6647f9e8385749c382bcab5e64965a943178": "Ybodychange",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": "Ybodychange",
    "c4928f486c67afa62e7e8fbd5d8f731be7186985": "Ybodychange",
    "82d8e91024a57a96fbb6410dacb29d6a3f582903": "Ybodychange",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": "Ybodychange",
    "a2da840df3bcb4e251695f7fbf1a5d341142459d": "Ybodychange",
    "ea9ff3965d9c657b5b7bd2d969e075f430635c47": "Ybodychange",
    "56743942d548686fb90ebd8b7a17fed5977e49dc": "Ybodychange",
    "aeef83ee58cce5b5bf0f10a8793fc37514751ef5": "Ybodychange",
    "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66": "Ybodychange",
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": "Ybodychange",
    "1dacd5303bfe94b9d5476059b6a5676146d96708": "Ybodychange",
    "14e0b0ea52977de4a8d8ceb6bab1420e84093a21": "Ybodychange",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": "Ybodychange",
    "204c073294cdca6756bcd546d6af85a797ad7d79": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "a8b8375b1db65b131938111ff283baed771161ed": "Ybodychange",
    "a24df47cafeab03fd65cf72b460aad3d2fafce3d": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "3cd6646941eca3da7d3b9a221c88e4c1d214876e": "Ybodychange",
    "13b7c634337e38d20daa92ca9d5e069a2e72ec55": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
    "17754d363645285e49bf4323a1af5762af47a8ea": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "788b41973d5747c7b4699a853b62168cf0001df6": "Ybodychange",
    "76374876692534687016dba762a465bf93039402": "Ybodychange",
    "748df52c1317e298203bf28e48545d3e50db59f1": "Ybodychange",
    "915c6568cf2cde57c3e92ee9786acb4808562671": "Ybodychange",
    "44e3d33fc25d44157486288d5c77de75156984cb": "Ybodychange",
    "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0": "Ybodychange",
    "6db0b3effd48f02d741b2202338d710b1b254910": "Ybodychange",
    "5ace399de6c8963584b1fbe08007721433c4bad3": "Ybodychange",
    "d216ec75255a120ce7c24e51da7df63a2b9864de": "Ybodychange",
    "784b3270054dd61d8c6dbe413bcedfc628063171": "Ybodychange",
    "2149a9c42dce7a3913cca83755c8f562b0442929": "Ybodychange",
    "9f6a98ac725727519c43f6496f020c2e595dac57": "Ybodychange",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": "Ybodychange",
    "abff1a2489ea8af10e1bc0a335551262d22f44e7": "Ymultichange(Ymovefromfile,Ybodychange)",
    "54a09706ec1db32435b09e6b6910813325558f8d": "Ymultichange(Yreturntypechange,Ybodychange,Ydocchange)",
    "82b2ba526976588d550cac698e512f8de6c1ffc6": "Ybodychange",
    "93390fbc8a6952bbb20571ac1b18a705814fc219": "Ybodychange",
    "822384a711290170148b43b5ae390dd4e8cfaf4f": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "4cbd709c019cf1b69796858506d673f7b66d37c7": "Ybodychange",
    "51941dcf2475545cee7b754acd5e2494c53acf9c": "Ybodychange",
    "03f8352479400cd2c80511bfe0242932a4f00f11": "Ybodychange",
    "4880b50a3a89db93e7e7c1b8bae8036ec06e186b": "Ybodychange",
    "751257987b2ef5f301e2deb3b55302196e5015af": "Ybodychange",
    "c682b5725d22afc38bf19d9667b23a7deab6d8c3": "Ybodychange",
    "7521f1897b007e3acc06ea3330df5124f4206589": "Ybodychange",
    "bbe51f6884ac0a961f55310e15ec90411709d970": "Ybodychange",
    "8f8879df46592e6e35658026c354b804ef328097": "Ybodychange",
    "190c0e5ca6cff056a136bc2c17f7678eb10686c7": "Ybodychange",
    "b671e6bb1c0652cfc1ccd07355cac99df584eb2f": "Ybodychange",
    "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24": "Ybodychange",
    "f8ea4c69a2228c5aca6c0b6e08a39a613d157708": "Ybodychange",
    "030798a11d2d21330cbdddd159cdc1824492157a": "Ybodychange",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": "Ymultichange(Ymodifierchange,Ybodychange)",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": "Ybodychange",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "58327e1dd9707b09f82ae2d4d4ce14c253247154": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5436: Split TreeWalker to TreeWalker and JavaParser\n",
      "commitDate": "2018/1/24 下午2:39",
      "commitName": "58327e1dd9707b09f82ae2d4d4ce14c253247154",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "2018/1/4 下午11:20",
      "commitNameOld": "0847a10b9430d9fb0a3f44df03e891da906bea47",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 19.64,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions()) \u0026\u0026 (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty())) {\n        final FileContents contents \u003d new FileContents(fileText);\n        final DetailAST rootAST \u003d JavaParser.parse(contents);\n        if (!ordinaryChecks.isEmpty()) {\n            walk(rootAST, contents, AstState.ORDINARY);\n        }\n        if (!commentChecks.isEmpty()) {\n            final DetailAST astWithComments \u003d JavaParser.appendHiddenCommentNodes(rootAST);\n            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n        }\n        if (filters.isEmpty()) {\n            addMessages(messages);\n        } else {\n            final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(file.getPath(), contents, rootAST);\n            addMessages(filteredMessages);\n        }\n        messages.clear();\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 176,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,21 @@\n @Override\n protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n-    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n-        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n-        final String fileName \u003d file.getPath();\n-        try {\n-            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n-                final FileContents contents \u003d new FileContents(fileText);\n-                final DetailAST rootAST \u003d parse(contents);\n-                if (!ordinaryChecks.isEmpty()) {\n-                    walk(rootAST, contents, AstState.ORDINARY);\n-                }\n-                if (!commentChecks.isEmpty()) {\n-                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n-                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-                }\n-                if (filters.isEmpty()) {\n-                    addMessages(messages);\n-                } else {\n-                    final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(fileName, contents, rootAST);\n-                    addMessages(filteredMessages);\n-                }\n-                messages.clear();\n-            }\n-        } catch (final TokenStreamRecognitionException tre) {\n-            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n-            throw new CheckstyleException(exceptionMsg, tre);\n-        } catch (RecognitionException | TokenStreamException ex) {\n-            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n-            throw new CheckstyleException(exceptionMsg, ex);\n+    if (CommonUtils.matchesFileExtension(file, getFileExtensions()) \u0026\u0026 (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty())) {\n+        final FileContents contents \u003d new FileContents(fileText);\n+        final DetailAST rootAST \u003d JavaParser.parse(contents);\n+        if (!ordinaryChecks.isEmpty()) {\n+            walk(rootAST, contents, AstState.ORDINARY);\n         }\n+        if (!commentChecks.isEmpty()) {\n+            final DetailAST astWithComments \u003d JavaParser.appendHiddenCommentNodes(rootAST);\n+            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+        }\n+        if (filters.isEmpty()) {\n+            addMessages(messages);\n+        } else {\n+            final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(file.getPath(), contents, rootAST);\n+            addMessages(filteredMessages);\n+        }\n+        messages.clear();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f994512712c08a16def4a3c5a0426b7ab1590cc9": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4422: Implement XpathFilter\n",
      "commitDate": "2017/8/23 下午11:11",
      "commitName": "f994512712c08a16def4a3c5a0426b7ab1590cc9",
      "commitAuthor": "Timur",
      "commitDateOld": "2017/8/22 下午4:05",
      "commitNameOld": "2f5115bce66f153ddfa02306505c1e81af942ff5",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 1.3,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                final FileContents contents \u003d new FileContents(fileText);\n                final DetailAST rootAST \u003d parse(contents);\n                if (!ordinaryChecks.isEmpty()) {\n                    walk(rootAST, contents, AstState.ORDINARY);\n                }\n                if (!commentChecks.isEmpty()) {\n                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                }\n                if (filters.isEmpty()) {\n                    addMessages(messages);\n                } else {\n                    final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(fileName, contents, rootAST);\n                    addMessages(filteredMessages);\n                }\n                messages.clear();\n            }\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 192,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,29 +1,33 @@\n @Override\n protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n     if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n         final String fileName \u003d file.getPath();\n         try {\n             if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                 final FileContents contents \u003d new FileContents(fileText);\n                 final DetailAST rootAST \u003d parse(contents);\n                 if (!ordinaryChecks.isEmpty()) {\n                     walk(rootAST, contents, AstState.ORDINARY);\n                 }\n                 if (!commentChecks.isEmpty()) {\n                     final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                     walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                 }\n-                final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(fileName, contents);\n-                addMessages(filteredMessages);\n+                if (filters.isEmpty()) {\n+                    addMessages(messages);\n+                } else {\n+                    final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(fileName, contents, rootAST);\n+                    addMessages(filteredMessages);\n+                }\n                 messages.clear();\n             }\n         } catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         } catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d9e8ece85007117e048fef55469623b830f9446": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4714: Make SuppressionCommentFilter and SuppressWithNearbyCommentFilter children of TreeWalker\n",
      "commitDate": "2017/7/25 上午4:38",
      "commitName": "6d9e8ece85007117e048fef55469623b830f9446",
      "commitAuthor": "Timur",
      "commitDateOld": "2017/7/7 下午8:59",
      "commitNameOld": "7fb0cf6870124032136b06eb7572a1de1b92e87a",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 17.32,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                final FileContents contents \u003d new FileContents(fileText);\n                final DetailAST rootAST \u003d parse(contents);\n                if (!ordinaryChecks.isEmpty()) {\n                    walk(rootAST, contents, AstState.ORDINARY);\n                }\n                if (!commentChecks.isEmpty()) {\n                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                }\n                final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(fileName, contents);\n                addMessages(filteredMessages);\n                messages.clear();\n            }\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 192,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,29 @@\n @Override\n protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n     if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n         final String fileName \u003d file.getPath();\n         try {\n             if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                 final FileContents contents \u003d new FileContents(fileText);\n                 final DetailAST rootAST \u003d parse(contents);\n                 if (!ordinaryChecks.isEmpty()) {\n                     walk(rootAST, contents, AstState.ORDINARY);\n                 }\n                 if (!commentChecks.isEmpty()) {\n                     final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                     walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                 }\n+                final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d getFilteredMessages(fileName, contents);\n+                addMessages(filteredMessages);\n+                messages.clear();\n             }\n         } catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         } catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82979737c4201b4913ea30b9c9431e71783d1c02": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
      "commitDate": "2017/7/7 上午4:22",
      "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
      "commitAuthor": "Timur",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
          "commitDate": "2017/7/7 上午4:22",
          "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
          "commitAuthor": "Timur",
          "commitDateOld": "2017/7/4 上午9:56",
          "commitNameOld": "ab548244eda102c5dc39cf0fc34e6803be192ba7",
          "commitAuthorOld": "Andrei Selkin",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                final FileContents contents \u003d new FileContents(fileText);\n                final DetailAST rootAST \u003d parse(contents);\n                if (!ordinaryChecks.isEmpty()) {\n                    walk(rootAST, contents, AstState.ORDINARY);\n                }\n                if (!commentChecks.isEmpty()) {\n                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                }\n            }\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 167,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,26 @@\n @Override\n-protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n+protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n     if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n         final String fileName \u003d file.getPath();\n         try {\n             if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n-                final FileText text \u003d FileText.fromLines(file, lines);\n-                final FileContents contents \u003d new FileContents(text);\n+                final FileContents contents \u003d new FileContents(fileText);\n                 final DetailAST rootAST \u003d parse(contents);\n                 if (!ordinaryChecks.isEmpty()) {\n                     walk(rootAST, contents, AstState.ORDINARY);\n                 }\n                 if (!commentChecks.isEmpty()) {\n                     final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                     walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                 }\n             }\n         } catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         } catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[file-File, lines-List\u003cString\u003e]",
            "newValue": "[file-File, fileText-FileText]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
          "commitDate": "2017/7/7 上午4:22",
          "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
          "commitAuthor": "Timur",
          "commitDateOld": "2017/7/4 上午9:56",
          "commitNameOld": "ab548244eda102c5dc39cf0fc34e6803be192ba7",
          "commitAuthorOld": "Andrei Selkin",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                final FileContents contents \u003d new FileContents(fileText);\n                final DetailAST rootAST \u003d parse(contents);\n                if (!ordinaryChecks.isEmpty()) {\n                    walk(rootAST, contents, AstState.ORDINARY);\n                }\n                if (!commentChecks.isEmpty()) {\n                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                }\n            }\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 167,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,26 @@\n @Override\n-protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n+protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n     if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n         final String fileName \u003d file.getPath();\n         try {\n             if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n-                final FileText text \u003d FileText.fromLines(file, lines);\n-                final FileContents contents \u003d new FileContents(text);\n+                final FileContents contents \u003d new FileContents(fileText);\n                 final DetailAST rootAST \u003d parse(contents);\n                 if (!ordinaryChecks.isEmpty()) {\n                     walk(rootAST, contents, AstState.ORDINARY);\n                 }\n                 if (!commentChecks.isEmpty()) {\n                     final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                     walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                 }\n             }\n         } catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         } catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d72e6f7d0b9f339feef4309a9dada7fd381ba242": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4398: increase coverage of pitest-checkstyle-tree-walker profile to 89%\n",
      "commitDate": "2017/6/22 下午10:22",
      "commitName": "d72e6f7d0b9f339feef4309a9dada7fd381ba242",
      "commitAuthor": "vasilyeva",
      "commitDateOld": "2017/6/13 上午1:11",
      "commitNameOld": "4a087c020c2b97130e94f9292b94cb4bc1f6ed93",
      "commitAuthorOld": "sagar-shah94",
      "daysBetweenCommits": 9.88,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                final FileText text \u003d FileText.fromLines(file, lines);\n                final FileContents contents \u003d new FileContents(text);\n                final DetailAST rootAST \u003d parse(contents);\n                if (!ordinaryChecks.isEmpty()) {\n                    walk(rootAST, contents, AstState.ORDINARY);\n                }\n                if (!commentChecks.isEmpty()) {\n                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                }\n            }\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 169,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,28 +1,27 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n     if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n         final String fileName \u003d file.getPath();\n         try {\n             if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                 final FileText text \u003d FileText.fromLines(file, lines);\n                 final FileContents contents \u003d new FileContents(text);\n                 final DetailAST rootAST \u003d parse(contents);\n-                getMessageCollector().reset();\n                 if (!ordinaryChecks.isEmpty()) {\n                     walk(rootAST, contents, AstState.ORDINARY);\n                 }\n                 if (!commentChecks.isEmpty()) {\n                     final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                     walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                 }\n             }\n         } catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         } catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "27e1e94244b6bb369c2ea7502c235260f49f78b0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4393: ASTs to be generated and walked only when there are corresponding type of checks. No parsing if no checks are specified\n",
      "commitDate": "2017/6/7 下午9:02",
      "commitName": "27e1e94244b6bb369c2ea7502c235260f49f78b0",
      "commitAuthor": "Piyush Sharma",
      "commitDateOld": "2017/4/22 上午10:14",
      "commitNameOld": "de50d3465849b83d25910590e1f5f39a25fe6e2c",
      "commitAuthorOld": "Vladislav Lisetskii",
      "daysBetweenCommits": 46.45,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n                final FileText text \u003d FileText.fromLines(file, lines);\n                final FileContents contents \u003d new FileContents(text);\n                final DetailAST rootAST \u003d parse(contents);\n                getMessageCollector().reset();\n                if (!ordinaryChecks.isEmpty()) {\n                    walk(rootAST, contents, AstState.ORDINARY);\n                }\n                if (!commentChecks.isEmpty()) {\n                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                }\n            }\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 168,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,28 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n     if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n         final String fileName \u003d file.getPath();\n         try {\n-            final FileText text \u003d FileText.fromLines(file, lines);\n-            final FileContents contents \u003d new FileContents(text);\n-            final DetailAST rootAST \u003d parse(contents);\n-            getMessageCollector().reset();\n-            walk(rootAST, contents, AstState.ORDINARY);\n-            final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n-            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+            if (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty()) {\n+                final FileText text \u003d FileText.fromLines(file, lines);\n+                final FileContents contents \u003d new FileContents(text);\n+                final DetailAST rootAST \u003d parse(contents);\n+                getMessageCollector().reset();\n+                if (!ordinaryChecks.isEmpty()) {\n+                    walk(rootAST, contents, AstState.ORDINARY);\n+                }\n+                if (!commentChecks.isEmpty()) {\n+                    final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n+                    walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+                }\n+            }\n         } catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         } catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3143: forbid empty return statements and fixed violations",
      "commitDate": "2016/5/27 下午9:42",
      "commitName": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
      "commitAuthor": "rnveach",
      "commitDateOld": "2016/5/17 上午4:53",
      "commitNameOld": "ecbeaa6e1df7cb021745e111b04395b9fbd509c7",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 10.7,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n        final String fileName \u003d file.getPath();\n        try {\n            final FileText text \u003d FileText.fromLines(file, lines);\n            final FileContents contents \u003d new FileContents(text);\n            final DetailAST rootAST \u003d parse(contents);\n            getMessageCollector().reset();\n            walk(rootAST, contents, AstState.ORDINARY);\n            final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n        } catch (final TokenStreamRecognitionException tre) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n            throw new CheckstyleException(exceptionMsg, tre);\n        } catch (RecognitionException | TokenStreamException ex) {\n            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n            throw new CheckstyleException(exceptionMsg, ex);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 167,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,22 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n-    if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n-        return;\n-    }\n-    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n-    final String fileName \u003d file.getPath();\n-    try {\n-        final FileText text \u003d FileText.fromLines(file, lines);\n-        final FileContents contents \u003d new FileContents(text);\n-        final DetailAST rootAST \u003d parse(contents);\n-        getMessageCollector().reset();\n-        walk(rootAST, contents, AstState.ORDINARY);\n-        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n-        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-    } catch (final TokenStreamRecognitionException tre) {\n-        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n-        throw new CheckstyleException(exceptionMsg, tre);\n-    } catch (RecognitionException | TokenStreamException ex) {\n-        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n-        throw new CheckstyleException(exceptionMsg, ex);\n+    if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n+        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n+        final String fileName \u003d file.getPath();\n+        try {\n+            final FileText text \u003d FileText.fromLines(file, lines);\n+            final FileContents contents \u003d new FileContents(text);\n+            final DetailAST rootAST \u003d parse(contents);\n+            getMessageCollector().reset();\n+            walk(rootAST, contents, AstState.ORDINARY);\n+            final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n+            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+        } catch (final TokenStreamRecognitionException tre) {\n+            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n+            throw new CheckstyleException(exceptionMsg, tre);\n+        } catch (RecognitionException | TokenStreamException ex) {\n+            final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n+            throw new CheckstyleException(exceptionMsg, ex);\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d46c2cf0e9df06bb5f424dbd7645574f082f7609": {
      "type": "Ybodychange",
      "commitMessage": "Issue #569: Move TreeWalker cache to Checker\n",
      "commitDate": "2016/2/10 上午1:50",
      "commitName": "d46c2cf0e9df06bb5f424dbd7645574f082f7609",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": "2016/2/5 下午10:01",
      "commitNameOld": "cf96dd9adcf0c3c8f8f05a9ffdcb765cafe17479",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 4.16,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    final String fileName \u003d file.getPath();\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n        throw new CheckstyleException(exceptionMsg, tre);\n    } catch (RecognitionException | TokenStreamException ex) {\n        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n        throw new CheckstyleException(exceptionMsg, ex);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 166,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,23 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n-    final String fileName \u003d file.getPath();\n-    final long timestamp \u003d file.lastModified();\n-    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n+    if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n+    final String fileName \u003d file.getPath();\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n         throw new CheckstyleException(exceptionMsg, tre);\n     } catch (RecognitionException | TokenStreamException ex) {\n         final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n         throw new CheckstyleException(exceptionMsg, ex);\n     }\n-    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n-        cache.put(fileName, timestamp);\n-    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be3e035ce39a610881cd2c1bfdce3eef101c2e3c": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1217: fixes for violations from \u0027forbiddenapis\u0027 verification tool\n",
      "commitDate": "2015/10/14 上午7:37",
      "commitName": "be3e035ce39a610881cd2c1bfdce3eef101c2e3c",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "2015/10/7 上午8:46",
      "commitNameOld": "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 6.95,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n        throw new CheckstyleException(exceptionMsg, tre);\n    } catch (RecognitionException | TokenStreamException ex) {\n        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n        throw new CheckstyleException(exceptionMsg, ex);\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 185,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,27 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n-        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n+        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, \"TokenStreamRecognitionException\", fileName);\n         throw new CheckstyleException(exceptionMsg, tre);\n     } catch (RecognitionException | TokenStreamException ex) {\n-        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n+        final String exceptionMsg \u003d String.format(Locale.ROOT, msg, ex.getClass().getSimpleName(), fileName);\n         throw new CheckstyleException(exceptionMsg, ex);\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5922d5a6730d7582d7d66121eb911ef9426f9e24": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
      "commitDate": "2015/8/31 下午1:06",
      "commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
      "commitAuthor": "Ruslan Diachenko",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
          "commitDate": "2015/8/31 下午1:06",
          "commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
          "commitAuthor": "Ruslan Diachenko",
          "commitDateOld": "2015/8/29 下午1:50",
          "commitNameOld": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        throw new CheckstyleException(exceptionMsg, tre);\n    } catch (RecognitionException | TokenStreamException ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        throw new CheckstyleException(exceptionMsg, ex);\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 183,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,31 +1,27 @@\n @Override\n-protected void processFiltered(File file, List\u003cString\u003e lines) {\n+protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n-        LOG.error(exceptionMsg);\n-        final RecognitionException re \u003d tre.recog;\n-        final String message \u003d re.getMessage();\n-        getMessageCollector().add(createLocalizedMessage(message));\n-    } catch (Throwable ex) {\n+        throw new CheckstyleException(exceptionMsg, tre);\n+    } catch (RecognitionException | TokenStreamException ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n-        LOG.error(exceptionMsg, ex);\n-        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n+        throw new CheckstyleException(exceptionMsg, ex);\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[CheckstyleException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
          "commitDate": "2015/8/31 下午1:06",
          "commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
          "commitAuthor": "Ruslan Diachenko",
          "commitDateOld": "2015/8/29 下午1:50",
          "commitNameOld": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        throw new CheckstyleException(exceptionMsg, tre);\n    } catch (RecognitionException | TokenStreamException ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        throw new CheckstyleException(exceptionMsg, ex);\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 183,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,31 +1,27 @@\n @Override\n-protected void processFiltered(File file, List\u003cString\u003e lines) {\n+protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n-        LOG.error(exceptionMsg);\n-        final RecognitionException re \u003d tre.recog;\n-        final String message \u003d re.getMessage();\n-        getMessageCollector().add(createLocalizedMessage(message));\n-    } catch (Throwable ex) {\n+        throw new CheckstyleException(exceptionMsg, tre);\n+    } catch (RecognitionException | TokenStreamException ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n-        LOG.error(exceptionMsg, ex);\n-        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n+        throw new CheckstyleException(exceptionMsg, ex);\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Rename methods returning boolean to use question word\n\nFixes some `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n\u003eReports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
      "commitDate": "2015/8/29 下午1:50",
      "commitName": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/28 上午3:53",
      "commitNameOld": "4d2e6647f9e8385749c382bcab5e64965a943178",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.41,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        final String message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 184,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,31 +1,31 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n+    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         final String message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4d2e6647f9e8385749c382bcab5e64965a943178": {
      "type": "Ybodychange",
      "commitMessage": "Rename boolean methods to start with question word. #1555\n\nFixes `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n\u003eReports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
      "commitDate": "2015/8/28 上午3:53",
      "commitName": "4d2e6647f9e8385749c382bcab5e64965a943178",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/27 下午8:41",
      "commitNameOld": "60ae95a6219d0e0765040ece0c3a8d439e1375ad",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        final String message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 184,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,31 +1,31 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n+    if (cache !\u003d null \u0026\u0026 (cache.isInCache(fileName, timestamp) || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         final String message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": {
      "type": "Ybodychange",
      "commitMessage": "Utils class has been splitted to CommonUtils and TokenUtils. Issue #1898\n",
      "commitDate": "2015/8/27 下午8:17",
      "commitName": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": "2015/8/27 下午8:17",
      "commitNameOld": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        final String message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 184,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,31 +1,31 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n+    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         final String message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4928f486c67afa62e7e8fbd5d8f731be7186985": {
      "type": "Ybodychange",
      "commitMessage": "Decrease scope of variables. #1555\n\nFixes `TooBroadScope` inspection violations.\n\nDescription:\n\u003eReports any variable declarations of which the scope can be narrowed. Especially useful for \"Pascal style\" declarations at the start of a method, but variables with too broad a scope are also often left over after refactorings.\n",
      "commitDate": "2015/8/12 下午12:54",
      "commitName": "c4928f486c67afa62e7e8fbd5d8f731be7186985",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/12 上午4:14",
      "commitNameOld": "82d8e91024a57a96fbb6410dacb29d6a3f582903",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        final String message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 182,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,31 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n-        String message;\n-        message \u003d re.getMessage();\n+        final String message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82d8e91024a57a96fbb6410dacb29d6a3f582903": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary qualifiers. #1555\n\nFixes `UnnecessarilyQualifiedStaticUsage` inspection violations.\n\nDescription:\n\u003eReports calls to static methods or accesses of static fields on the current class which are qualified with the class name. Such qualification is unnecessary, and may be safely removed.\n",
      "commitDate": "2015/8/12 上午4:14",
      "commitName": "82d8e91024a57a96fbb6410dacb29d6a3f582903",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/11 下午8:18",
      "commitNameOld": "1935bed5772c0a939b9168b81acd2ab5aa800538",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message;\n        message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 182,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n-        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n+        final DetailAST rootAST \u003d parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message;\n         message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": {
      "type": "Ybodychange",
      "commitMessage": "Remove unused assignments. #1555\n\nFixes UnusedAssignment inspection violations.\n\nDescription:\n\u003eThis inspection points out the cases where a variable value is never used after its assignment, i.e.:\n- the variable never gets read after assignment OR\n- the value is always overwritten with another assignment before the next variable read OR\n - the variable initializer is redundant (for one of the above two reasons) OR\n - the variable is never used.\n",
      "commitDate": "2015/8/8 下午12:12",
      "commitName": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/5 下午8:39",
      "commitNameOld": "a2da840df3bcb4e251695f7fbf1a5d341142459d",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 2.65,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message;\n        message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 182,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n-        String message \u003d \"TokenStreamRecognitionException occured\";\n+        String message;\n         message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2da840df3bcb4e251695f7fbf1a5d341142459d": {
      "type": "Ybodychange",
      "commitMessage": "100% UTs coverage for TreeWalker. #1294\n",
      "commitDate": "2015/8/5 下午8:39",
      "commitName": "a2da840df3bcb4e251695f7fbf1a5d341142459d",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "2015/8/3 上午9:48",
      "commitNameOld": "6fd60de0a4363b806d37d4129d9a430f8f3dee6b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.45,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        message \u003d re.getMessage();\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 182,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,32 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message \u003d \"TokenStreamRecognitionException occured\";\n-        if (re !\u003d null) {\n-            message \u003d re.getMessage();\n-        }\n+        message \u003d re.getMessage();\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n         cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea9ff3965d9c657b5b7bd2d969e075f430635c47": {
      "type": "Ybodychange",
      "commitMessage": "100% UTs coverage for PropertyCacheFile. Refactoring of PropertyCacheFile. #1294\n",
      "commitDate": "2015/7/29 上午1:12",
      "commitName": "ea9ff3965d9c657b5b7bd2d969e075f430635c47",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "2015/7/13 上午12:32",
      "commitNameOld": "8da777a68ad936f1a4e07d59cee17ecab2fc293e",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 16.03,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        if (re !\u003d null) {\n            message \u003d re.getMessage();\n        }\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n        cache.put(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 185,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n+    if (cache !\u003d null \u0026\u0026 (cache.inCache(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message \u003d \"TokenStreamRecognitionException occured\";\n         if (re !\u003d null) {\n             message \u003d re.getMessage();\n         }\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n-    if (getMessageCollector().size() \u003d\u003d 0) {\n-        cache.checkedOk(fileName, timestamp);\n+    if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n+        cache.put(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "56743942d548686fb90ebd8b7a17fed5977e49dc": {
      "type": "Ybodychange",
      "commitMessage": "Extend ReturnCount Check to treat lambdas  separately. #1068\n",
      "commitDate": "2015/5/17 下午1:19",
      "commitName": "56743942d548686fb90ebd8b7a17fed5977e49dc",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/5/16 上午6:31",
      "commitNameOld": "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        if (re !\u003d null) {\n            message \u003d re.getMessage();\n        }\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg, ex);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 185,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message \u003d \"TokenStreamRecognitionException occured\";\n         if (re !\u003d null) {\n             message \u003d re.getMessage();\n         }\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n-        LOG.error(exceptionMsg);\n+        LOG.error(exceptionMsg, ex);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aeef83ee58cce5b5bf0f10a8793fc37514751ef5": {
      "type": "Ybodychange",
      "commitMessage": "Remove obsolete space from error message",
      "commitDate": "2015/5/1 上午7:21",
      "commitName": "aeef83ee58cce5b5bf0f10a8793fc37514751ef5",
      "commitAuthor": "Michał Kordas",
      "commitDateOld": "2015/4/30 上午8:21",
      "commitNameOld": "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        if (re !\u003d null) {\n            message \u003d re.getMessage();\n        }\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 184,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n         return;\n     }\n-    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n+    final String msg \u003d \"%s occurred during the analysis of file %s.\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message \u003d \"TokenStreamRecognitionException occured\";\n         if (re !\u003d null) {\n             message \u003d re.getMessage();\n         }\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66": {
      "type": "Ybodychange",
      "commitMessage": "Fix AvoidStaticImport check violations in codebase, issue #979\n",
      "commitDate": "2015/4/27 上午12:13",
      "commitName": "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/4/26 上午8:30",
      "commitNameOld": "55b266cd92adf7b5e18f84ddee839d63f9330c5b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        if (re !\u003d null) {\n            message \u003d re.getMessage();\n        }\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 184,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n+    if (cache.alreadyChecked(fileName, timestamp) || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message \u003d \"TokenStreamRecognitionException occured\";\n         if (re !\u003d null) {\n             message \u003d re.getMessage();\n         }\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         LOG.error(exceptionMsg);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations from \u0027logging-jakarta\u0027 ruleset, issue #871\n",
      "commitDate": "2015/4/14 上午5:43",
      "commitName": "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/4/12 上午6:41",
      "commitNameOld": "7dd24c8c35572b5db3e5c905d440e813cfe2538c",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        LOG.error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        if (re !\u003d null) {\n            message \u003d re.getMessage();\n        }\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        LOG.error(exceptionMsg);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 190,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n-        Utils.getExceptionLogger().error(exceptionMsg);\n+        LOG.error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         String message \u003d \"TokenStreamRecognitionException occured\";\n         if (re !\u003d null) {\n             message \u003d re.getMessage();\n         }\n         getMessageCollector().add(createLocalizedMessage(message));\n     } catch (Throwable ex) {\n         final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n-        Utils.getExceptionLogger().error(exceptionMsg);\n+        LOG.error(exceptionMsg);\n         getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1dacd5303bfe94b9d5476059b6a5676146d96708": {
      "type": "Ybodychange",
      "commitMessage": "Merged catch blocks into one where possible\n\nPull #825\n",
      "commitDate": "2015/3/25 上午5:48",
      "commitName": "1dacd5303bfe94b9d5476059b6a5676146d96708",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": "2015/3/24 上午7:00",
      "commitNameOld": "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        String message \u003d \"TokenStreamRecognitionException occured\";\n        if (re !\u003d null) {\n            message \u003d re.getMessage();\n        }\n        getMessageCollector().add(createLocalizedMessage(message));\n    } catch (Throwable ex) {\n        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 191,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,34 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-    } catch (final RecognitionException re) {\n-        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n-        Utils.getExceptionLogger().error(exceptionMsg);\n-        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n+        String message \u003d \"TokenStreamRecognitionException occured\";\n         if (re !\u003d null) {\n-            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n-        } else {\n-            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n+            message \u003d re.getMessage();\n         }\n-    } catch (final TokenStreamException te) {\n-        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n+        getMessageCollector().add(createLocalizedMessage(message));\n+    } catch (Throwable ex) {\n+        final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n-    } catch (final Throwable err) {\n-        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n-        Utils.getExceptionLogger().error(exceptionMsg);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n+        getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14e0b0ea52977de4a8d8ceb6bab1420e84093a21": {
      "type": "Ybodychange",
      "commitMessage": "Remove unwritten field, issue #778\n\nAll violations of Findbugs rule [UwF: Unwritten field](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_UNWRITTEN_FIELD) are fixed.\n",
      "commitDate": "2015/3/24 上午7:00",
      "commitName": "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/3/17 下午1:46",
      "commitNameOld": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 6.72,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 191,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,42 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, fileExtensions)) {\n+    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, getFileExtensions())) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n         final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": {
      "type": "Ybodychange",
      "commitMessage": "Removed printStackTrace(...) from whole code, issue #660\n",
      "commitDate": "2015/3/17 下午1:46",
      "commitName": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
      "commitAuthor": "alexkravin",
      "commitDateOld": "2015/3/16 上午5:22",
      "commitNameOld": "1c15b6a36baa68dc3f2ebdf9baac131e98bb9e04",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 1.35,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, fileExtensions)) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 194,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,43 +1,42 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n     if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, fileExtensions)) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n         final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n-        err.printStackTrace();\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "204c073294cdca6756bcd546d6af85a797ad7d79": {
      "type": "Ybodychange",
      "commitMessage": "Added file extensions property to Checker \u0026 TreeWalker, issue #25\n",
      "commitDate": "2015/1/25 下午5:30",
      "commitName": "204c073294cdca6756bcd546d6af85a797ad7d79",
      "commitAuthor": "alexkravin",
      "commitDateOld": "2015/1/22 下午8:26",
      "commitNameOld": "95c1a081e0868fc3ac9faf05d09ca8b2bb06a5cc",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 2.88,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, fileExtensions)) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        err.printStackTrace();\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 196,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,43 +1,43 @@\n @Override\n protected void processFiltered(File file, List\u003cString\u003e lines) {\n     final String fileName \u003d file.getPath();\n     final long timestamp \u003d file.lastModified();\n-    if (cache.alreadyChecked(fileName, timestamp)) {\n+    if (cache.alreadyChecked(fileName, timestamp) || !fileExtensionMatches(file, fileExtensions)) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n         final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         err.printStackTrace();\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": "2015/1/19 下午10:38",
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "2015/1/19 下午10:38",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "2015/1/14 上午3:20",
          "commitNameOld": "501b7c5240705c6db756608618fdcf58189e807e",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 5.8,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        err.printStackTrace();\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 191,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,43 @@\n @Override\n-protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n-    final String fileName \u003d aFile.getPath();\n-    final long timestamp \u003d aFile.lastModified();\n-    if (mCache.alreadyChecked(fileName, timestamp)) {\n+protected void processFiltered(File file, List\u003cString\u003e lines) {\n+    final String fileName \u003d file.getPath();\n+    final long timestamp \u003d file.lastModified();\n+    if (cache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n-        final FileText text \u003d FileText.fromLines(aFile, aLines);\n+        final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n         final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         err.printStackTrace();\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n-        mCache.checkedOk(fileName, timestamp);\n+        cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[aFile-File, aLines-List\u003cString\u003e]",
            "newValue": "[file-File, lines-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "2015/1/19 下午10:38",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "2015/1/14 上午3:20",
          "commitNameOld": "501b7c5240705c6db756608618fdcf58189e807e",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 5.8,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File file, List\u003cString\u003e lines) {\n    final String fileName \u003d file.getPath();\n    final long timestamp \u003d file.lastModified();\n    if (cache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(file, lines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        err.printStackTrace();\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        cache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 191,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,43 @@\n @Override\n-protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n-    final String fileName \u003d aFile.getPath();\n-    final long timestamp \u003d aFile.lastModified();\n-    if (mCache.alreadyChecked(fileName, timestamp)) {\n+protected void processFiltered(File file, List\u003cString\u003e lines) {\n+    final String fileName \u003d file.getPath();\n+    final long timestamp \u003d file.lastModified();\n+    if (cache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n-        final FileText text \u003d FileText.fromLines(aFile, aLines);\n+        final FileText text \u003d FileText.fromLines(file, lines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n         final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n         Utils.getExceptionLogger().error(exceptionMsg);\n         err.printStackTrace();\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n-        mCache.checkedOk(fileName, timestamp);\n+        cache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a8b8375b1db65b131938111ff283baed771161ed": {
      "type": "Ybodychange",
      "commitMessage": "Logging of exceptions to console, issue #546\n",
      "commitDate": "2015/1/10 上午12:42",
      "commitName": "a8b8375b1db65b131938111ff283baed771161ed",
      "commitAuthor": "alexkravin",
      "commitDateOld": "2014/11/5 上午9:30",
      "commitNameOld": "f2b19f10806dc89807888a772de34177c36c602b",
      "commitAuthorOld": "Vladimir Sitnikov",
      "daysBetweenCommits": 65.63,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n    try {\n        final FileText text \u003d FileText.fromLines(aFile, aLines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n        Utils.getExceptionLogger().error(exceptionMsg);\n        err.printStackTrace();\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 191,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,43 @@\n @Override\n protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n+    final String msg \u003d \"%s occurred during the analysis of file %s .\";\n     try {\n         final FileText text \u003d FileText.fromLines(aFile, aLines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         getMessageCollector().reset();\n         walk(rootAST, contents, AstState.ORDINARY);\n         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n-        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n+        final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n+        Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n-        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n+        final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\", fileName);\n+        Utils.getExceptionLogger().error(exceptionMsg);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n-        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n+        final String exceptionMsg \u003d String.format(msg, \"TokenStreamException\", fileName);\n+        Utils.getExceptionLogger().error(exceptionMsg);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n+        final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n+        Utils.getExceptionLogger().error(exceptionMsg);\n         err.printStackTrace();\n-        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a24df47cafeab03fd65cf72b460aad3d2fafce3d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #49. Added support of single-line and block comments\n",
      "commitDate": "2014/10/18 下午1:19",
      "commitName": "a24df47cafeab03fd65cf72b460aad3d2fafce3d",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "2014/10/18 下午1:19",
      "commitNameOld": "59014fa7539bdbaacda4325454964492db0c6109",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileText text \u003d FileText.fromLines(aFile, aLines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        getMessageCollector().reset();\n        walk(rootAST, contents, AstState.ORDINARY);\n        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        err.printStackTrace();\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 191,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,38 @@\n @Override\n protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         final FileText text \u003d FileText.fromLines(aFile, aLines);\n         final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n-        walk(rootAST, contents);\n+        getMessageCollector().reset();\n+        walk(rootAST, contents, AstState.ORDINARY);\n+        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n+        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n+        err.printStackTrace();\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "2014/3/5 上午1:18",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "2014/2/27 下午2:35",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileText text \u003d FileText.fromLines(aFile, aLines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 175,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java"
      }
    },
    "3cd6646941eca3da7d3b9a221c88e4c1d214876e": {
      "type": "Ybodychange",
      "commitMessage": "Apply patch #2783226 that uses FileText as an implementation for\nList\u003cString\u003e to pass lines around\n",
      "commitDate": "2010/6/28 下午9:02",
      "commitName": "3cd6646941eca3da7d3b9a221c88e4c1d214876e",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2010/2/13 上午10:57",
      "commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 135.42,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileText text \u003d FileText.fromLines(aFile, aLines);\n        final FileContents contents \u003d new FileContents(text);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 175,
      "functionName": "processFiltered",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,34 @@\n @Override\n protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n+        final FileText text \u003d FileText.fromLines(aFile, aLines);\n+        final FileContents contents \u003d new FileContents(text);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13b7c634337e38d20daa92ca9d5e069a2e72ec55": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
      "commitDate": "2008/11/9 下午5:37",
      "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
          "commitDate": "2008/11/9 下午5:37",
          "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2008/9/18 下午7:34",
          "commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 51.92,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 173,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,33 @@\n-private void process(File aFile) {\n+@Override\n+protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n-        final FileContents contents \u003d new FileContents(fileName, lines);\n+        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (final FileNotFoundException fnfe) {\n-        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n-    } catch (final IOException ioe) {\n-        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n-    } else {\n-        fireErrors(fileName);\n     }\n-    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "process",
            "newValue": "processFiltered"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
          "commitDate": "2008/11/9 下午5:37",
          "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2008/9/18 下午7:34",
          "commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 51.92,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 173,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,33 @@\n-private void process(File aFile) {\n+@Override\n+protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n-        final FileContents contents \u003d new FileContents(fileName, lines);\n+        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (final FileNotFoundException fnfe) {\n-        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n-    } catch (final IOException ioe) {\n-        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n-    } else {\n-        fireErrors(fileName);\n     }\n-    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[aFile-File]",
            "newValue": "[aFile-File, aLines-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
          "commitDate": "2008/11/9 下午5:37",
          "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2008/9/18 下午7:34",
          "commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 51.92,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 173,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,33 @@\n-private void process(File aFile) {\n+@Override\n+protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n-        final FileContents contents \u003d new FileContents(fileName, lines);\n+        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (final FileNotFoundException fnfe) {\n-        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n-    } catch (final IOException ioe) {\n-        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n-    } else {\n-        fireErrors(fileName);\n     }\n-    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
          "commitDate": "2008/11/9 下午5:37",
          "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2008/9/18 下午7:34",
          "commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 51.92,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 173,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,33 @@\n-private void process(File aFile) {\n+@Override\n+protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n-        final FileContents contents \u003d new FileContents(fileName, lines);\n+        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (final FileNotFoundException fnfe) {\n-        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n-    } catch (final IOException ioe) {\n-        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n-    } else {\n-        fireErrors(fileName);\n     }\n-    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
          "commitDate": "2008/11/9 下午5:37",
          "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2008/9/18 下午7:34",
          "commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 51.92,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 173,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,33 @@\n-private void process(File aFile) {\n+@Override\n+protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n-        final FileContents contents \u003d new FileContents(fileName, lines);\n+        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (final FileNotFoundException fnfe) {\n-        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n-    } catch (final IOException ioe) {\n-        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n-    } else {\n-        fireErrors(fileName);\n     }\n-    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
          "commitDate": "2008/11/9 下午5:37",
          "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2008/9/18 下午7:34",
          "commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 51.92,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    }\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 173,
          "functionName": "processFiltered",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,43 +1,33 @@\n-private void process(File aFile) {\n+@Override\n+protected void processFiltered(File aFile, List\u003cString\u003e aLines) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n-        getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n-        final FileContents contents \u003d new FileContents(fileName, lines);\n+        final FileContents contents \u003d new FileContents(fileName, aLines.toArray(new String[aLines.size()]));\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (final FileNotFoundException fnfe) {\n-        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n-    } catch (final IOException ioe) {\n-        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n-    } else {\n-        fireErrors(fileName);\n     }\n-    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
            "newValue": ""
          }
        }
      ]
    },
    "17754d363645285e49bf4323a1af5762af47a8ea": {
      "type": "Ybodychange",
      "commitMessage": "snapshot of changes - need to refactor\n",
      "commitDate": "2008/7/16 上午6:27",
      "commitName": "17754d363645285e49bf4323a1af5762af47a8ea",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2008/4/26 上午11:45",
      "commitNameOld": "911065320fb39299f442ea08f775cfe08ba2a2ed",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 80.78,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n    } catch (final IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 178,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,43 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName, getCharset());\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (final FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass(), null));\n     } catch (final IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass(), null));\n     } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n-        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n     } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n-            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n+            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass(), null));\n         } else {\n-            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass()));\n+            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass(), null));\n         }\n     } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass(), null));\n     } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass(), null));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": "2006/7/7 上午11:44",
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2006/7/7 上午11:33",
      "commitNameOld": "f4a92dad02a3a36b5e2e988bba04debb1e2c9db9",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (final FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass()));\n    } catch (final IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass()));\n    } catch (final RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n    } catch (final TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass()));\n        }\n    } catch (final TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass()));\n    } catch (final Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 230,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,43 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName, getCharset());\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n-    } catch (FileNotFoundException fnfe) {\n+    } catch (final FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass()));\n-    } catch (IOException ioe) {\n+    } catch (final IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass()));\n-    } catch (RecognitionException re) {\n+    } catch (final RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n-    } catch (TokenStreamRecognitionException tre) {\n+    } catch (final TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass()));\n         }\n-    } catch (TokenStreamException te) {\n+    } catch (final TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass()));\n-    } catch (Throwable err) {\n+    } catch (final Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "788b41973d5747c7b4699a853b62168cf0001df6": {
      "type": "Ybodychange",
      "commitMessage": "Changes to make it possible to identify a module by an id, and then to\nsuppress messages based on the id. The motivation is to allow for finer\ngrained suppressions. For example, can enable multiple instances of the\nRegexp check, and suppress on the individual instance.\n",
      "commitDate": "2005/12/29 下午8:35",
      "commitName": "788b41973d5747c7b4699a853b62168cf0001df6",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2005/12/18 上午3:03",
      "commitNameOld": "78e9ce870170ca3ef88fd78f8e0af0681c958eb3",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 11.73,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass()));\n    } catch (IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass()));\n    } catch (RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n    } catch (TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass()));\n        }\n    } catch (TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass()));\n    } catch (Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 230,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,43 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName, getCharset());\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, getId(), this.getClass()));\n     } catch (IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, getId(), this.getClass()));\n     } catch (RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n-        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n     } catch (TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n-            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, getId(), this.getClass()));\n         } else {\n-            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, this.getClass()));\n+            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, getId(), this.getClass()));\n         }\n     } catch (TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, getId(), this.getClass()));\n     } catch (Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, getId(), this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76374876692534687016dba762a465bf93039402": {
      "type": "Ybodychange",
      "commitMessage": "Accept Oleg\u0027s comments about NPEs, http://sourceforge.net/mailarchive/forum.php?thread_id\u003d5251578\u0026forum_id\u003d2864\n",
      "commitDate": "2004/8/3 下午9:45",
      "commitName": "76374876692534687016dba762a465bf93039402",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2004/7/30 下午10:59",
      "commitNameOld": "748df52c1317e298203bf28e48545d3e50db59f1",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 3.95,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n    } catch (IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n    } catch (RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n    } catch (TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, this.getClass()));\n        }\n    } catch (TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n    } catch (Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 207,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,43 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName, getCharset());\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n     } catch (IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n     } catch (RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n     } catch (TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n         } else {\n-            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" }, this.getClass()));\n+            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"TokenStreamRecognitionException occured.\" }, this.getClass()));\n         }\n     } catch (TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n     } catch (Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "748df52c1317e298203bf28e48545d3e50db59f1": {
      "type": "Ybodychange",
      "commitMessage": "fixes possible null pointer exceptions, bad string compares\n",
      "commitDate": "2004/7/30 下午10:59",
      "commitName": "748df52c1317e298203bf28e48545d3e50db59f1",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2004/7/21 下午8:02",
      "commitNameOld": "3b5e5d728bf1b8d222c538f7cfc92cab0805eb1f",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 9.12,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n    } catch (IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n    } catch (RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n    } catch (TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" }, this.getClass()));\n        }\n    } catch (TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n    } catch (Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 207,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,43 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName, getCharset());\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n     } catch (IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n     } catch (RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n     } catch (TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n         } else {\n-            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" }, this.getClass()));\n         }\n     } catch (TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n     } catch (Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "915c6568cf2cde57c3e92ee9786acb4808562671": {
      "type": "Ybodychange",
      "commitMessage": "Added charset property to TreeWalker and StrictDuplicateCode check (addresses bug 975346)\n",
      "commitDate": "2004/6/22 下午7:42",
      "commitName": "915c6568cf2cde57c3e92ee9786acb4808562671",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2004/6/22 上午6:30",
      "commitNameOld": "44e3d33fc25d44157486288d5c77de75156984cb",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n    } catch (IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n    } catch (RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n    } catch (TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n        }\n    } catch (TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n    } catch (Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 207,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,43 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n-        final String[] lines \u003d Utils.getLines(fileName);\n+        final String[] lines \u003d Utils.getLines(fileName, getCharset());\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n     } catch (IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n     } catch (RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n     } catch (TokenStreamRecognitionException tre) {\n         Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n         final RecognitionException re \u003d tre.recog;\n         if (re !\u003d null) {\n             getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n         } else {\n             getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n         }\n     } catch (TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n     } catch (Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "44e3d33fc25d44157486288d5c77de75156984cb": {
      "type": "Ybodychange",
      "commitMessage": "Better information for unexpected char, RFE 666188\n",
      "commitDate": "2004/6/22 上午6:30",
      "commitName": "44e3d33fc25d44157486288d5c77de75156984cb",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2004/1/15 上午5:10",
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 159.06,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n    } catch (IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n    } catch (RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n    } catch (TokenStreamRecognitionException tre) {\n        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n        final RecognitionException re \u003d tre.recog;\n        if (re !\u003d null) {\n            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n        } else {\n            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n        }\n    } catch (TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n    } catch (Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 207,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,35 +1,43 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n     } catch (IOException ioe) {\n         Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n     } catch (RecognitionException re) {\n         Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+        getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+    } catch (TokenStreamRecognitionException tre) {\n+        Utils.getExceptionLogger().debug(\"TokenStreamRecognitionException occured.\", tre);\n+        final RecognitionException re \u003d tre.recog;\n+        if (re !\u003d null) {\n+            getMessageCollector().add(new LocalizedMessage(re.getLine(), re.getColumn(), Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+        } else {\n+            getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n+        }\n     } catch (TokenStreamException te) {\n         Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n     } catch (Throwable err) {\n         Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0": {
      "type": "Ybodychange",
      "commitMessage": "Added exception logging (see request 753883)\n",
      "commitDate": "2003/9/3 下午12:35",
      "commitName": "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "2003/7/5 下午6:47",
      "commitNameOld": "6db0b3effd48f02d741b2202338d710b1b254910",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 59.74,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n    } catch (IOException ioe) {\n        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n    } catch (RecognitionException re) {\n        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n    } catch (TokenStreamException te) {\n        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n    } catch (Throwable err) {\n        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 201,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,30 +1,35 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n+        Utils.getExceptionLogger().debug(\"FileNotFoundException occured.\", fnfe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n     } catch (IOException ioe) {\n+        Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n     } catch (RecognitionException re) {\n+        Utils.getExceptionLogger().debug(\"RecognitionException occured.\", re);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n     } catch (TokenStreamException te) {\n+        Utils.getExceptionLogger().debug(\"TokenStreamException occured.\", te);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n     } catch (Throwable err) {\n+        Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6db0b3effd48f02d741b2202338d710b1b254910": {
      "type": "Ybodychange",
      "commitMessage": "Code cleanup to force the class name for the cause of the message to be\nlogged. Required as part of changes I am making for RFE 756416.\n",
      "commitDate": "2003/7/5 下午6:47",
      "commitName": "6db0b3effd48f02d741b2202338d710b1b254910",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2003/6/27 下午7:04",
      "commitNameOld": "768256c32a3e397f837ce27602bda49e3c5e0062",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 7.99,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n    } catch (IOException ioe) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n    } catch (RecognitionException re) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n    } catch (TokenStreamException te) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n    } catch (Throwable err) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 201,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,30 +1,30 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null, this.getClass()));\n     } catch (IOException ioe) {\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }, this.getClass()));\n     } catch (RecognitionException re) {\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }, this.getClass()));\n     } catch (TokenStreamException te) {\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }, this.getClass()));\n     } catch (Throwable err) {\n-        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }, this.getClass()));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5ace399de6c8963584b1fbe08007721433c4bad3": {
      "type": "Ybodychange",
      "commitMessage": "Another quality patch from Oleg Sukhodolsky to fix TranslationCheck Test\nbug. (bug 720925).\n",
      "commitDate": "2003/4/24 下午4:18",
      "commitName": "5ace399de6c8963584b1fbe08007721433c4bad3",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2003/4/18 下午4:50",
      "commitNameOld": "55fcf189eb1c1c4d776ce3b3ad7835fb404b21d8",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.98,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    } catch (Throwable err) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName);\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 220,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,31 +1,30 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n-    getMessageCollector().reset();\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     } catch (Throwable err) {\n         getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n     }\n     if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n-        getMessageDispatcher().fireErrors(fileName, getMessageCollector().getMessages());\n+        fireErrors(fileName);\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d216ec75255a120ce7c24e51da7df63a2b9864de": {
      "type": "Ybodychange",
      "commitMessage": "Major refactorings to allow the use of SeverityLevels in FileSetChecks\nas well as in Checks and to simplify logging of messages in FileSetChecks.\n\nIntroduction of a new class called AbstractViolationReporter, from which\nboth Check and FileSetCheck are derived.\n\nSeverity is passed to submodules by means of the Contextualizable\nmechanism. This means that the user can f.ex. set severity to INFO\nin a TreeWalker and all Checks below that TreeWalker will use severity INFO.\n",
      "commitDate": "2003/3/27 上午3:52",
      "commitName": "d216ec75255a120ce7c24e51da7df63a2b9864de",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2003/3/1 上午2:24",
      "commitNameOld": "784b3270054dd61d8c6dbe413bcedfc628063171",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 26.06,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    getMessageCollector().reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    } catch (Throwable err) {\n        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n    }\n    if (getMessageCollector().size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, getMessageCollector().getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 220,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,31 +1,31 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n-    mMessages.reset();\n+    getMessageCollector().reset();\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n-        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n-        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n-        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n-        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     } catch (Throwable err) {\n-        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n+        getMessageCollector().add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n     }\n-    if (mMessages.size() \u003d\u003d 0) {\n+    if (getMessageCollector().size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n-        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n+        getMessageDispatcher().fireErrors(fileName, getMessageCollector().getMessages());\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "784b3270054dd61d8c6dbe413bcedfc628063171": {
      "type": "Ybodychange",
      "commitMessage": "Handle all parse errors,esp.those throws by the ANTLR parser on a\nsyntax error (see bug request id 694111).\n",
      "commitDate": "2003/3/1 上午2:24",
      "commitName": "784b3270054dd61d8c6dbe413bcedfc628063171",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2003/2/16 上午10:50",
      "commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 12.65,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    } catch (Throwable err) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 223,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,29 +1,31 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     mMessages.reset();\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n+    } catch (Throwable err) {\n+        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { \"\" + err }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2149a9c42dce7a3913cca83755c8f562b0442929": {
      "type": "Ybodychange",
      "commitMessage": "removed todo items that have already been resolved\n",
      "commitDate": "2002/12/27 下午5:58",
      "commitName": "2149a9c42dce7a3913cca83755c8f562b0442929",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/12/27 上午1:21",
      "commitNameOld": "2a71cac7e02c012add5e75f35aaf6aca7c561401",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 228,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "",
      "extendedDetails": {}
    },
    "9f6a98ac725727519c43f6496f020c2e595dac57": {
      "type": "Ybodychange",
      "commitMessage": "Added a flag - something needs to be done about\ndependencies\n",
      "commitDate": "2002/12/7 下午7:12",
      "commitName": "9f6a98ac725727519c43f6496f020c2e595dac57",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/12/6 下午9:40",
      "commitNameOld": "53e4d78c1934b2681c70d560c8805b1e83199fa5",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 186,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "",
      "extendedDetails": {}
    },
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": {
      "type": "Ybodychange",
      "commitMessage": "avalonization\n",
      "commitDate": "2002/12/1 上午2:29",
      "commitName": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/11/20 下午1:56",
      "commitNameOld": "6568a9b88220366da3fc9e58fc9de93af9a6520d",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents);\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
      "functionStartLine": 181,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
      "diff": "@@ -1,29 +1,29 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     mMessages.reset();\n     try {\n         getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n-        walk(rootAST, contents, mConfig.getClassLoader());\n+        walk(rootAST, contents);\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n     }\n     getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abff1a2489ea8af10e1bc0a335551262d22f44e7": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
      "commitDate": "2002/11/20 上午4:21",
      "commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
          "commitDate": "2002/11/20 上午4:21",
          "commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/20 上午3:17",
          "commitNameOld": "54a09706ec1db32435b09e6b6910813325558f8d",
          "commitAuthorOld": "Lars Kühne",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 132,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
          "diff": "@@ -1,29 +1,29 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     mMessages.reset();\n     try {\n-        fireFileStarted(fileName);\n+        getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n-        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n+        walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n-        fireErrors(fileName, mMessages.getMessages());\n+        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n     }\n-    fireFileFinished(fileName);\n+    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
            "newPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
            "oldMethodName": "process",
            "newMethodName": "process"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
          "commitDate": "2002/11/20 上午4:21",
          "commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/20 上午3:17",
          "commitNameOld": "54a09706ec1db32435b09e6b6910813325558f8d",
          "commitAuthorOld": "Lars Kühne",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        getMessageDispatcher().fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n    }\n    getMessageDispatcher().fireFileFinished(fileName);\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
          "functionStartLine": 132,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
          "diff": "@@ -1,29 +1,29 @@\n private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return;\n     }\n     mMessages.reset();\n     try {\n-        fireFileStarted(fileName);\n+        getMessageDispatcher().fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n-        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n+        walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n-        fireErrors(fileName, mMessages.getMessages());\n+        getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n     }\n-    fireFileFinished(fileName);\n+    getMessageDispatcher().fireFileFinished(fileName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "54a09706ec1db32435b09e6b6910813325558f8d": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange,Ydocchange)",
      "commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
      "commitDate": "2002/11/20 上午3:17",
      "commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
          "commitDate": "2002/11/20 上午3:17",
          "commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/17 下午4:24",
          "commitNameOld": "82b2ba526976588d550cac698e512f8de6c1ffc6",
          "commitAuthorOld": "Lars Kühne",
          "daysBetweenCommits": 2.45,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName, mMessages.getMessages());\n    }\n    fireFileFinished(fileName);\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 192,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
          "diff": "@@ -1,30 +1,29 @@\n-private int process(File aFile) {\n+private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n-        return 0;\n+        return;\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName, mMessages.getMessages());\n     }\n     fireFileFinished(fileName);\n-    return mMessages.size();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "int",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
          "commitDate": "2002/11/20 上午3:17",
          "commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/17 下午4:24",
          "commitNameOld": "82b2ba526976588d550cac698e512f8de6c1ffc6",
          "commitAuthorOld": "Lars Kühne",
          "daysBetweenCommits": 2.45,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName, mMessages.getMessages());\n    }\n    fireFileFinished(fileName);\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 192,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
          "diff": "@@ -1,30 +1,29 @@\n-private int process(File aFile) {\n+private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n-        return 0;\n+        return;\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName, mMessages.getMessages());\n     }\n     fireFileFinished(fileName);\n-    return mMessages.size();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
          "commitDate": "2002/11/20 上午3:17",
          "commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/17 下午4:24",
          "commitNameOld": "82b2ba526976588d550cac698e512f8de6c1ffc6",
          "commitAuthorOld": "Lars Kühne",
          "daysBetweenCommits": 2.45,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "private void process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return;\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName, mMessages.getMessages());\n    }\n    fireFileFinished(fileName);\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 192,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n",
          "diff": "@@ -1,30 +1,29 @@\n-private int process(File aFile) {\n+private void process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n-        return 0;\n+        return;\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(fileName, mMessages.getMessages());\n     }\n     fireFileFinished(fileName);\n-    return mMessages.size();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n",
            "newValue": "Processes a specified file and reports all errors found.\n\n@param aFile the file to process\n"
          }
        }
      ]
    },
    "82b2ba526976588d550cac698e512f8de6c1ffc6": {
      "type": "Ybodychange",
      "commitMessage": "Moved stripping of basedir to the event handling routines.\nThis separates concerns in parse(File) as a preparation for moving that method to TreeWalker.\nIt also fixes bug #622290 (package name reported incorrectly) once I integrate PackageHtmlCheck.\n",
      "commitDate": "2002/11/17 下午4:24",
      "commitName": "82b2ba526976588d550cac698e512f8de6c1ffc6",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/11/17 下午4:05",
      "commitNameOld": "93390fbc8a6952bbb20571ac1b18a705814fc219",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return 0;\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(fileName);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(fileName, mMessages.getMessages());\n    }\n    fireFileFinished(fileName);\n    return mMessages.size();\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 138,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n",
      "diff": "@@ -1,38 +1,30 @@\n private int process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return 0;\n     }\n-    final String stripped;\n-    final String basedir \u003d mConfig.getBasedir();\n-    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n-        stripped \u003d fileName;\n-    } else {\n-        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n-        stripped \u003d fileName.substring(basedir.length() + skipSep);\n-    }\n     mMessages.reset();\n     try {\n-        fireFileStarted(stripped);\n+        fireFileStarted(fileName);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n-        fireErrors(stripped, mMessages.getMessages());\n+        fireErrors(fileName, mMessages.getMessages());\n     }\n-    fireFileFinished(stripped);\n+    fireFileFinished(fileName);\n     return mMessages.size();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "93390fbc8a6952bbb20571ac1b18a705814fc219": {
      "type": "Ybodychange",
      "commitMessage": "moved parse() from Checker to TreeWalker\n",
      "commitDate": "2002/11/17 下午4:05",
      "commitName": "93390fbc8a6952bbb20571ac1b18a705814fc219",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/11/17 下午2:48",
      "commitNameOld": "822384a711290170148b43b5ae390dd4e8cfaf4f",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n        stripped \u003d fileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d fileName.substring(basedir.length() + skipSep);\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(stripped, mMessages.getMessages());\n    }\n    fireFileFinished(stripped);\n    return mMessages.size();\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 138,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n",
      "diff": "@@ -1,38 +1,38 @@\n private int process(File aFile) {\n     final String fileName \u003d aFile.getPath();\n     final long timestamp \u003d aFile.lastModified();\n     if (mCache.alreadyChecked(fileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n         stripped \u003d fileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d fileName.substring(basedir.length() + skipSep);\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d Utils.getLines(fileName);\n         final FileContents contents \u003d new FileContents(fileName, lines);\n-        final DetailAST rootAST \u003d parse(contents);\n+        final DetailAST rootAST \u003d TreeWalker.parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(stripped, mMessages.getMessages());\n     }\n     fireFileFinished(stripped);\n     return mMessages.size();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "822384a711290170148b43b5ae390dd4e8cfaf4f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
      "commitDate": "2002/11/17 下午2:48",
      "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
          "commitDate": "2002/11/17 下午2:48",
          "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/16 上午2:18",
          "commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
          "commitAuthorOld": "Rick Giles",
          "daysBetweenCommits": 1.52,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private int process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n        stripped \u003d fileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d fileName.substring(basedir.length() + skipSep);\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(stripped, mMessages.getMessages());\n    }\n    fireFileFinished(stripped);\n    return mMessages.size();\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 184,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n",
          "diff": "@@ -1,38 +1,38 @@\n-private int process(String aFileName) {\n-    final File f \u003d new File(aFileName);\n-    final long timestamp \u003d f.lastModified();\n-    if (mCache.alreadyChecked(aFileName, timestamp)) {\n+private int process(File aFile) {\n+    final String fileName \u003d aFile.getPath();\n+    final long timestamp \u003d aFile.lastModified();\n+    if (mCache.alreadyChecked(fileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n-    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n-        stripped \u003d aFileName;\n+    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n+        stripped \u003d fileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n-        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n+        stripped \u003d fileName.substring(basedir.length() + skipSep);\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(stripped);\n-        final String[] lines \u003d Utils.getLines(aFileName);\n-        final FileContents contents \u003d new FileContents(aFileName, lines);\n+        final String[] lines \u003d Utils.getLines(fileName);\n+        final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n-        mCache.checkedOk(aFileName, timestamp);\n+        mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(stripped, mMessages.getMessages());\n     }\n     fireFileFinished(stripped);\n     return mMessages.size();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[aFileName-String]",
            "newValue": "[aFile-File]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
          "commitDate": "2002/11/17 下午2:48",
          "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/16 上午2:18",
          "commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
          "commitAuthorOld": "Rick Giles",
          "daysBetweenCommits": 1.52,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private int process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n        stripped \u003d fileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d fileName.substring(basedir.length() + skipSep);\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(stripped, mMessages.getMessages());\n    }\n    fireFileFinished(stripped);\n    return mMessages.size();\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 184,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n",
          "diff": "@@ -1,38 +1,38 @@\n-private int process(String aFileName) {\n-    final File f \u003d new File(aFileName);\n-    final long timestamp \u003d f.lastModified();\n-    if (mCache.alreadyChecked(aFileName, timestamp)) {\n+private int process(File aFile) {\n+    final String fileName \u003d aFile.getPath();\n+    final long timestamp \u003d aFile.lastModified();\n+    if (mCache.alreadyChecked(fileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n-    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n-        stripped \u003d aFileName;\n+    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n+        stripped \u003d fileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n-        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n+        stripped \u003d fileName.substring(basedir.length() + skipSep);\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(stripped);\n-        final String[] lines \u003d Utils.getLines(aFileName);\n-        final FileContents contents \u003d new FileContents(aFileName, lines);\n+        final String[] lines \u003d Utils.getLines(fileName);\n+        final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n-        mCache.checkedOk(aFileName, timestamp);\n+        mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(stripped, mMessages.getMessages());\n     }\n     fireFileFinished(stripped);\n     return mMessages.size();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
          "commitDate": "2002/11/17 下午2:48",
          "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
          "commitAuthor": "Lars Kühne",
          "commitDateOld": "2002/11/16 上午2:18",
          "commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
          "commitAuthorOld": "Rick Giles",
          "daysBetweenCommits": 1.52,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private int process(File aFile) {\n    final String fileName \u003d aFile.getPath();\n    final long timestamp \u003d aFile.lastModified();\n    if (mCache.alreadyChecked(fileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n        stripped \u003d fileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d fileName.substring(basedir.length() + skipSep);\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d Utils.getLines(fileName);\n        final FileContents contents \u003d new FileContents(fileName, lines);\n        final DetailAST rootAST \u003d parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(fileName, timestamp);\n    } else {\n        fireErrors(stripped, mMessages.getMessages());\n    }\n    fireFileFinished(stripped);\n    return mMessages.size();\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 184,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n",
          "diff": "@@ -1,38 +1,38 @@\n-private int process(String aFileName) {\n-    final File f \u003d new File(aFileName);\n-    final long timestamp \u003d f.lastModified();\n-    if (mCache.alreadyChecked(aFileName, timestamp)) {\n+private int process(File aFile) {\n+    final String fileName \u003d aFile.getPath();\n+    final long timestamp \u003d aFile.lastModified();\n+    if (mCache.alreadyChecked(fileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n-    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n-        stripped \u003d aFileName;\n+    if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n+        stripped \u003d fileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n-        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n+        stripped \u003d fileName.substring(basedir.length() + skipSep);\n     }\n     mMessages.reset();\n     try {\n         fireFileStarted(stripped);\n-        final String[] lines \u003d Utils.getLines(aFileName);\n-        final FileContents contents \u003d new FileContents(aFileName, lines);\n+        final String[] lines \u003d Utils.getLines(fileName);\n+        final FileContents contents \u003d new FileContents(fileName, lines);\n         final DetailAST rootAST \u003d parse(contents);\n         mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n         mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n     if (mMessages.size() \u003d\u003d 0) {\n-        mCache.checkedOk(aFileName, timestamp);\n+        mCache.checkedOk(fileName, timestamp);\n     } else {\n         fireErrors(stripped, mMessages.getMessages());\n     }\n     fireFileFinished(stripped);\n     return mMessages.size();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
            "newValue": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFile the file to process\n"
          }
        }
      ]
    },
    "4cbd709c019cf1b69796858506d673f7b66d37c7": {
      "type": "Ybodychange",
      "commitMessage": "This is a really enjoyable commit to make. I have finally got to remove the\nugly Verifier class. The only remaining check are based on the new fileset\ncheck that Lars putting together. Magic. :-)\n",
      "commitDate": "2002/11/13 下午12:21",
      "commitName": "4cbd709c019cf1b69796858506d673f7b66d37c7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/11/6 上午11:57",
      "commitNameOld": "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 7.02,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    mMessages.reset();\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d Utils.getLines(aFileName);\n        final FileContents contents \u003d new FileContents(aFileName, lines);\n        final DetailAST rootAST \u003d parse(contents);\n        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n    } catch (FileNotFoundException fnfe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n    } catch (IOException ioe) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n    } catch (RecognitionException re) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n    } catch (TokenStreamException te) {\n        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n    }\n    if (mMessages.size() \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, mMessages.getMessages());\n    }\n    fireFileFinished(stripped);\n    return mMessages.size();\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 184,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,57 +1,38 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n-    LocalizedMessage[] errors;\n+    mMessages.reset();\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d Utils.getLines(aFileName);\n-        try {\n-            VerifierSingleton.getInstance().reset();\n-            VerifierSingleton.getInstance().setLines(lines);\n-            final Reader sar \u003d new StringArrayReader(lines);\n-            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n-            jl.setFilename(aFileName);\n-            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n-            jr.setFilename(aFileName);\n-            jr.setASTNodeClass(MyCommonAST.class.getName());\n-            jr.compilationUnit();\n-        } catch (RecognitionException re) {\n-            VerifierSingleton.getInstance().reset();\n-            VerifierSingleton.getInstance().setLines(lines);\n-            final Reader sar \u003d new StringArrayReader(lines);\n-            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n-            jl.setFilename(aFileName);\n-            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n-            jr.setFilename(aFileName);\n-            jr.setASTNodeClass(MyCommonAST.class.getName());\n-            jr.compilationUnit();\n-        }\n-        errors \u003d VerifierSingleton.getInstance().getMessages();\n+        final FileContents contents \u003d new FileContents(aFileName, lines);\n+        final DetailAST rootAST \u003d parse(contents);\n+        mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n     } catch (FileNotFoundException fnfe) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null) };\n+        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null));\n     } catch (IOException ioe) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }) };\n+        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }));\n     } catch (RecognitionException re) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }) };\n+        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }));\n     } catch (TokenStreamException te) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }) };\n+        mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }));\n     }\n-    if (errors.length \u003d\u003d 0) {\n+    if (mMessages.size() \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n-        fireErrors(stripped, errors);\n+        fireErrors(stripped, mMessages.getMessages());\n     }\n     fireFileFinished(stripped);\n-    return errors.length;\n+    return mMessages.size();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51941dcf2475545cee7b754acd5e2494c53acf9c": {
      "type": "Ybodychange",
      "commitMessage": "added TreeViewer to help with development.\n",
      "commitDate": "2002/10/7 上午7:52",
      "commitName": "51941dcf2475545cee7b754acd5e2494c53acf9c",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/10/1 下午4:47",
      "commitNameOld": "eb7b7bfd3e63a926c3f3b2801d519caa0e1fffc3",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.63,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    LocalizedMessage[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d Utils.getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null) };\n    } catch (IOException ioe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }) };\n    } catch (RecognitionException re) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 290,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,57 +1,57 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n     LocalizedMessage[] errors;\n     try {\n         fireFileStarted(stripped);\n-        final String[] lines \u003d getLines(aFileName);\n+        final String[] lines \u003d Utils.getLines(aFileName);\n         try {\n             VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n             VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null) };\n     } catch (IOException ioe) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }) };\n     } catch (RecognitionException re) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(stripped, errors);\n     }\n     fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03f8352479400cd2c80511bfe0242932a4f00f11": {
      "type": "Ybodychange",
      "commitMessage": "Got the unit tests to pass again. They highlighted a bug in the recent\nchanges, and once again prove they are worth the effort. ;-)\n",
      "commitDate": "2002/9/19 下午5:07",
      "commitName": "03f8352479400cd2c80511bfe0242932a4f00f11",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/9/18 下午1:08",
      "commitNameOld": "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    LocalizedMessage[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null) };\n    } catch (IOException ioe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }) };\n    } catch (RecognitionException re) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 165,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,57 +1,57 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n     LocalizedMessage[] errors;\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d getLines(aFileName);\n         try {\n             VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n             VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null, null) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.fileNotFound\", null) };\n     } catch (IOException ioe) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { ioe.getMessage() }) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { ioe.getMessage() }) };\n     } catch (RecognitionException re) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { re.getMessage() }) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { re.getMessage() }) };\n     } catch (TokenStreamException te) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { te.getMessage() }) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE, \"general.exception\", new String[] { te.getMessage() }) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(stripped, errors);\n     }\n     fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4880b50a3a89db93e7e7c1b8bae8036ec06e186b": {
      "type": "Ybodychange",
      "commitMessage": "improved resource bundle handling:\n- plugins can use their own bundle (location determined automatically)\n- return the message key if ResourceBundle is not available\n- added log helper methods in Check.java\n",
      "commitDate": "2002/9/18 下午1:08",
      "commitName": "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/9/17 下午8:33",
      "commitNameOld": "672b27dd5551de63a1fb08d8ea80376d70f2aa60",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    LocalizedMessage[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null, null) };\n    } catch (IOException ioe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { ioe.getMessage() }) };\n    } catch (RecognitionException re) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { re.getMessage() }) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { te.getMessage() }) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 165,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,57 +1,57 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n     LocalizedMessage[] errors;\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d getLines(aFileName);\n         try {\n             VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n             VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null, null) };\n     } catch (IOException ioe) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { ioe.getMessage() }) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { ioe.getMessage() }) };\n     } catch (RecognitionException re) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { re.getMessage() }) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { re.getMessage() }) };\n     } catch (TokenStreamException te) {\n-        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { te.getMessage() }) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", null, new String[] { te.getMessage() }) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(stripped, errors);\n     }\n     fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "751257987b2ef5f301e2deb3b55302196e5015af": {
      "type": "Ybodychange",
      "commitMessage": "Refactored the logging out of Verifier. Also fixed all gump errors.\n",
      "commitDate": "2002/8/12 下午9:18",
      "commitName": "751257987b2ef5f301e2deb3b55302196e5015af",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/8/12 下午8:10",
      "commitNameOld": "ecc852d48b9d26398926b255e3cd68572119c106",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    LocalizedMessage[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().reset();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null) };\n    } catch (IOException ioe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { ioe.getMessage() }) };\n    } catch (RecognitionException re) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { re.getMessage() }) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { te.getMessage() }) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 164,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,57 +1,57 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n     LocalizedMessage[] errors;\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d getLines(aFileName);\n         try {\n-            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n-            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().reset();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null) };\n     } catch (IOException ioe) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { ioe.getMessage() }) };\n     } catch (RecognitionException re) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { re.getMessage() }) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { te.getMessage() }) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(stripped, errors);\n     }\n     fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c682b5725d22afc38bf19d9667b23a7deab6d8c3": {
      "type": "Ybodychange",
      "commitMessage": "Major rework to support localized error messages. Inspired by patch 580410. At\nthe moment it is not possible to override the system locale, this probably\nshould be added.\n",
      "commitDate": "2002/8/10 下午10:15",
      "commitName": "c682b5725d22afc38bf19d9667b23a7deab6d8c3",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/7/6 下午2:35",
      "commitNameOld": "7521f1897b007e3acc06ea3330df5124f4206589",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 35.32,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    LocalizedMessage[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null) };\n    } catch (IOException ioe) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { ioe.getMessage() }) };\n    } catch (RecognitionException re) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { re.getMessage() }) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { te.getMessage() }) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 160,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,57 +1,57 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n     final String basedir \u003d mConfig.getBasedir();\n     if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n         final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n         stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n-    LineText[] errors;\n+    LocalizedMessage[] errors;\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d getLines(aFileName);\n         try {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n-        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.fileNotFound\", null) };\n     } catch (IOException ioe) {\n-        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { ioe.getMessage() }) };\n     } catch (RecognitionException re) {\n-        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { re.getMessage() }) };\n     } catch (TokenStreamException te) {\n-        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n+        errors \u003d new LocalizedMessage[] { new LocalizedMessage(0, \"general.exception\", new String[] { te.getMessage() }) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(stripped, errors);\n     }\n     fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7521f1897b007e3acc06ea3330df5124f4206589": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug where reported file names were not correct when checkstyle.basedir ended with File.separator\n",
      "commitDate": "2002/7/6 下午2:35",
      "commitName": "7521f1897b007e3acc06ea3330df5124f4206589",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/7/3 上午4:08",
      "commitNameOld": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 3.44,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    final String basedir \u003d mConfig.getBasedir();\n    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n        stripped \u003d aFileName;\n    } else {\n        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 160,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,55 +1,57 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     final String stripped;\n-    if ((mConfig.getBasedir() \u003d\u003d null) || !aFileName.startsWith(mConfig.getBasedir())) {\n+    final String basedir \u003d mConfig.getBasedir();\n+    if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n         stripped \u003d aFileName;\n     } else {\n-        stripped \u003d aFileName.substring(mConfig.getBasedir().length() + 1);\n+        final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n+        stripped \u003d aFileName.substring(basedir.length() + skipSep);\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(stripped);\n         final String[] lines \u003d getLines(aFileName);\n         try {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(stripped, errors);\n     }\n     fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbe51f6884ac0a961f55310e15ec90411709d970": {
      "type": "Ybodychange",
      "commitMessage": "571161: Added support for basedir attribute.\n",
      "commitDate": "2002/7/1 上午9:57",
      "commitName": "bbe51f6884ac0a961f55310e15ec90411709d970",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/5/15 下午1:02",
      "commitNameOld": "032b3801aa80bff181235ddd05244d07cc5f43f8",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 46.87,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    final String stripped;\n    if ((mConfig.getBasedir() \u003d\u003d null) || !aFileName.startsWith(mConfig.getBasedir())) {\n        stripped \u003d aFileName;\n    } else {\n        stripped \u003d aFileName.substring(mConfig.getBasedir().length() + 1);\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(stripped);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(stripped, errors);\n    }\n    fireFileFinished(stripped);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 178,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,49 +1,55 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n+    final String stripped;\n+    if ((mConfig.getBasedir() \u003d\u003d null) || !aFileName.startsWith(mConfig.getBasedir())) {\n+        stripped \u003d aFileName;\n+    } else {\n+        stripped \u003d aFileName.substring(mConfig.getBasedir().length() + 1);\n+    }\n     LineText[] errors;\n     try {\n-        fireFileStarted(aFileName);\n+        fireFileStarted(stripped);\n         final String[] lines \u003d getLines(aFileName);\n         try {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n-        fireErrors(aFileName, errors);\n+        fireErrors(stripped, errors);\n     }\n-    fireFileFinished(aFileName);\n+    fireFileFinished(stripped);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f8879df46592e6e35658026c354b804ef328097": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bug with the parser falling back when failing on assert\nstatements. Found with problems with imports.\n",
      "commitDate": "2002/4/30 下午6:56",
      "commitName": "8f8879df46592e6e35658026c354b804ef328097",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/4/25 下午3:03",
      "commitNameOld": "6970485b88600343de72af03a6bf87cf78e6cf55",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.16,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 177,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,47 +1,49 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(aFileName);\n         final String[] lines \u003d getLines(aFileName);\n-        VerifierSingleton.getInstance().clearMessages();\n-        VerifierSingleton.getInstance().setLines(lines);\n         try {\n+            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n+            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(aFileName, errors);\n     }\n     fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "190c0e5ca6cff056a136bc2c17f7678eb10686c7": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bug introduced during cleanup of duplicate code:\nReader cannot be reused by fallback lexer, it would\nnever see the characters that have been consumed before\nthe RecognitionException in the first parsing attempt.\n\nAlso added comment why the JDK 1.4 grammar is tried first.\n",
      "commitDate": "2002/3/20 上午4:26",
      "commitName": "190c0e5ca6cff056a136bc2c17f7678eb10686c7",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/3/20 上午3:35",
      "commitNameOld": "dd476d336818a95e58163cd1c4f8cb00be239eae",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        final String[] lines \u003d getLines(aFileName);\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(lines);\n        try {\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 220,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,46 +1,47 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(aFileName);\n         final String[] lines \u003d getLines(aFileName);\n-        final Reader sar \u003d new StringArrayReader(lines);\n         VerifierSingleton.getInstance().clearMessages();\n         VerifierSingleton.getInstance().setLines(lines);\n         try {\n+            final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n+            final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(aFileName, errors);\n     }\n     fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b671e6bb1c0652cfc1ccd07355cac99df584eb2f": {
      "type": "Ybodychange",
      "commitMessage": "Removed some duplicate code, as I also feel the pain. I like the patch, but\nI question using the Java14 lexer/recognizer first. Is this because most of\nthe time it will succeed (especially with 1.4 source:-). Be great if a\ncomment could be added to the code.\n",
      "commitDate": "2002/3/14 下午6:20",
      "commitName": "b671e6bb1c0652cfc1ccd07355cac99df584eb2f",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/3/14 下午2:19",
      "commitNameOld": "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        final String[] lines \u003d getLines(aFileName);\n        final Reader sar \u003d new StringArrayReader(lines);\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(lines);\n        try {\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 220,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,49 +1,46 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(aFileName);\n         final String[] lines \u003d getLines(aFileName);\n+        final Reader sar \u003d new StringArrayReader(lines);\n+        VerifierSingleton.getInstance().clearMessages();\n+        VerifierSingleton.getInstance().setLines(lines);\n         try {\n-            VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(lines);\n-            final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         } catch (RecognitionException re) {\n-            VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(lines);\n-            final Reader sar \u003d new StringArrayReader(lines);\n             final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n             jl.setFilename(aFileName);\n             final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n             jr.setFilename(aFileName);\n             jr.setASTNodeClass(MyCommonAST.class.getName());\n             jr.compilationUnit();\n         }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(aFileName, errors);\n     }\n     fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24": {
      "type": "Ybodychange",
      "commitMessage": "added support for jdk 1.4 assert statements\n\ngrammar changes inspired by John Pybus on the antlr-interest mailing list,\nsee http://groups.yahoo.com/group/antlr-interest/message/4968\n\nthe changes to Checker.java are not very clean, but I don\u0027t see a better\nsolution unless the ANTLR api is improved (compilationUnit() should be an\nabstract member of Parser, error reporting should be pluggable)\n",
      "commitDate": "2002/3/14 下午2:19",
      "commitName": "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/3/6 上午4:53",
      "commitNameOld": "ec1e3e834918a32d63025d60175189b3437769d7",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 8.39,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        final String[] lines \u003d getLines(aFileName);\n        try {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        } catch (RecognitionException re) {\n            VerifierSingleton.getInstance().clearMessages();\n            VerifierSingleton.getInstance().setLines(lines);\n            final Reader sar \u003d new StringArrayReader(lines);\n            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n            jl.setFilename(aFileName);\n            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n            jr.setFilename(aFileName);\n            jr.setASTNodeClass(MyCommonAST.class.getName());\n            jr.compilationUnit();\n        }\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 220,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,37 +1,49 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(aFileName);\n         final String[] lines \u003d getLines(aFileName);\n-        VerifierSingleton.getInstance().clearMessages();\n-        VerifierSingleton.getInstance().setLines(lines);\n-        final Reader sar \u003d new StringArrayReader(lines);\n-        final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n-        jl.setFilename(aFileName);\n-        final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n-        jr.setFilename(aFileName);\n-        jr.setASTNodeClass(MyCommonAST.class.getName());\n-        jr.compilationUnit();\n+        try {\n+            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().setLines(lines);\n+            final Reader sar \u003d new StringArrayReader(lines);\n+            final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n+            jl.setFilename(aFileName);\n+            final GeneratedJava14Recognizer jr \u003d new SilentJava14Recognizer(jl);\n+            jr.setFilename(aFileName);\n+            jr.setASTNodeClass(MyCommonAST.class.getName());\n+            jr.compilationUnit();\n+        } catch (RecognitionException re) {\n+            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().setLines(lines);\n+            final Reader sar \u003d new StringArrayReader(lines);\n+            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n+            jl.setFilename(aFileName);\n+            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n+            jr.setFilename(aFileName);\n+            jr.setASTNodeClass(MyCommonAST.class.getName());\n+            jr.compilationUnit();\n+        }\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(aFileName, errors);\n     }\n     fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f8ea4c69a2228c5aca6c0b6e08a39a613d157708": {
      "type": "Ybodychange",
      "commitMessage": "Removed all evidence of the java.tree.g file.\n",
      "commitDate": "2002/1/14 上午9:33",
      "commitName": "f8ea4c69a2228c5aca6c0b6e08a39a613d157708",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/1/6 下午3:40",
      "commitNameOld": "edf2c95634cd0c657465723eb0dc2e6f1834eeba",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 7.75,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        final String[] lines \u003d getLines(aFileName);\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(lines);\n        final Reader sar \u003d new StringArrayReader(lines);\n        final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n        jl.setFilename(aFileName);\n        final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n        jr.setFilename(aFileName);\n        jr.setASTNodeClass(MyCommonAST.class.getName());\n        jr.compilationUnit();\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 122,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,33 +1,37 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(aFileName);\n         final String[] lines \u003d getLines(aFileName);\n         VerifierSingleton.getInstance().clearMessages();\n         VerifierSingleton.getInstance().setLines(lines);\n         final Reader sar \u003d new StringArrayReader(lines);\n-        final AST ast \u003d getAST(aFileName, sar);\n-        processAST(ast);\n+        final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n+        jl.setFilename(aFileName);\n+        final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n+        jr.setFilename(aFileName);\n+        jr.setASTNodeClass(MyCommonAST.class.getName());\n+        jr.compilationUnit();\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(aFileName, errors);\n     }\n     fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "030798a11d2d21330cbdddd159cdc1824492157a": {
      "type": "Ybodychange",
      "commitMessage": "incorporate performance patch\n",
      "commitDate": "2001/10/31 下午8:42",
      "commitName": "030798a11d2d21330cbdddd159cdc1824492157a",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/8/31 上午12:13",
      "commitNameOld": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 61.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        final String[] lines \u003d getLines(aFileName);\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(lines);\n        final Reader sar \u003d new StringArrayReader(lines);\n        final AST ast \u003d getAST(aFileName, sar);\n        processAST(ast);\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 128,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,31 +1,33 @@\n private int process(String aFileName) {\n     final File f \u003d new File(aFileName);\n     final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n         fireFileStarted(aFileName);\n+        final String[] lines \u003d getLines(aFileName);\n         VerifierSingleton.getInstance().clearMessages();\n-        VerifierSingleton.getInstance().setLines(getLines(aFileName));\n-        final AST ast \u003d getAST(aFileName);\n+        VerifierSingleton.getInstance().setLines(lines);\n+        final Reader sar \u003d new StringArrayReader(lines);\n+        final AST ast \u003d getAST(aFileName, sar);\n         processAST(ast);\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n         fireErrors(aFileName, errors);\n     }\n     fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "started to incorporate logging events\n",
      "commitDate": "2001/8/31 上午12:13",
      "commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "started to incorporate logging events\n",
          "commitDate": "2001/8/31 上午12:13",
          "commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2001/8/5 下午10:12",
          "commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 25.08,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(getLines(aFileName));\n        final AST ast \u003d getAST(aFileName);\n        processAST(ast);\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 127,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
          "diff": "@@ -1,28 +1,31 @@\n-int process(String aFileName) {\n-    final long timestamp \u003d new File(aFileName).lastModified();\n+private int process(String aFileName) {\n+    final File f \u003d new File(aFileName);\n+    final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n+        fireFileStarted(aFileName);\n         VerifierSingleton.getInstance().clearMessages();\n         VerifierSingleton.getInstance().setLines(getLines(aFileName));\n         final AST ast \u003d getAST(aFileName);\n         processAST(ast);\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n-        displayErrors(aFileName, errors);\n+        fireErrors(aFileName, errors);\n     }\n+    fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "started to incorporate logging events\n",
          "commitDate": "2001/8/31 上午12:13",
          "commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "2001/8/5 下午10:12",
          "commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 25.08,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private int process(String aFileName) {\n    final File f \u003d new File(aFileName);\n    final long timestamp \u003d f.lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        fireFileStarted(aFileName);\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(getLines(aFileName));\n        final AST ast \u003d getAST(aFileName);\n        processAST(ast);\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        fireErrors(aFileName, errors);\n    }\n    fireFileFinished(aFileName);\n    return errors.length;\n}",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
          "functionStartLine": 127,
          "functionName": "process",
          "functionAnnotation": "",
          "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
          "diff": "@@ -1,28 +1,31 @@\n-int process(String aFileName) {\n-    final long timestamp \u003d new File(aFileName).lastModified();\n+private int process(String aFileName) {\n+    final File f \u003d new File(aFileName);\n+    final long timestamp \u003d f.lastModified();\n     if (mCache.alreadyChecked(aFileName, timestamp)) {\n         return 0;\n     }\n     LineText[] errors;\n     try {\n+        fireFileStarted(aFileName);\n         VerifierSingleton.getInstance().clearMessages();\n         VerifierSingleton.getInstance().setLines(getLines(aFileName));\n         final AST ast \u003d getAST(aFileName);\n         processAST(ast);\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n     if (errors.length \u003d\u003d 0) {\n         mCache.checkedOk(aFileName, timestamp);\n     } else {\n-        displayErrors(aFileName, errors);\n+        fireErrors(aFileName, errors);\n     }\n+    fireFileFinished(aFileName);\n     return errors.length;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": {
      "type": "Ybodychange",
      "commitMessage": "added support for caching\n",
      "commitDate": "2001/8/5 下午10:12",
      "commitName": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/6/29 下午3:21",
      "commitNameOld": "69138e40225407ef560fd9d06d2903de37c83c2c",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 37.29,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "int process(String aFileName) {\n    final long timestamp \u003d new File(aFileName).lastModified();\n    if (mCache.alreadyChecked(aFileName, timestamp)) {\n        return 0;\n    }\n    LineText[] errors;\n    try {\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(getLines(aFileName));\n        final AST ast \u003d getAST(aFileName);\n        processAST(ast);\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    if (errors.length \u003d\u003d 0) {\n        mCache.checkedOk(aFileName, timestamp);\n    } else {\n        displayErrors(aFileName, errors);\n    }\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 73,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n",
      "diff": "@@ -1,20 +1,28 @@\n int process(String aFileName) {\n+    final long timestamp \u003d new File(aFileName).lastModified();\n+    if (mCache.alreadyChecked(aFileName, timestamp)) {\n+        return 0;\n+    }\n     LineText[] errors;\n     try {\n         VerifierSingleton.getInstance().clearMessages();\n         VerifierSingleton.getInstance().setLines(getLines(aFileName));\n         final AST ast \u003d getAST(aFileName);\n         processAST(ast);\n         errors \u003d VerifierSingleton.getInstance().getMessages();\n     } catch (FileNotFoundException fnfe) {\n         errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n     } catch (IOException ioe) {\n         errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n     } catch (RecognitionException re) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n     } catch (TokenStreamException te) {\n         errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n     }\n-    displayErrors(aFileName, errors);\n+    if (errors.length \u003d\u003d 0) {\n+        mCache.checkedOk(aFileName, timestamp);\n+    } else {\n+        displayErrors(aFileName, errors);\n+    }\n     return errors.length;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": {
      "type": "Yintroduced",
      "commitMessage": "first cut\n",
      "commitDate": "2001/6/22 下午9:24",
      "commitName": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
      "commitAuthor": "Oliver Burn",
      "diff": "@@ -0,0 +1,20 @@\n+int process(String aFileName) {\n+    LineText[] errors;\n+    try {\n+        VerifierSingleton.getInstance().clearMessages();\n+        VerifierSingleton.getInstance().setLines(getLines(aFileName));\n+        final AST ast \u003d getAST(aFileName);\n+        processAST(ast);\n+        errors \u003d VerifierSingleton.getInstance().getMessages();\n+    } catch (FileNotFoundException fnfe) {\n+        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n+    } catch (IOException ioe) {\n+        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n+    } catch (RecognitionException re) {\n+        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n+    } catch (TokenStreamException te) {\n+        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n+    }\n+    displayErrors(aFileName, errors);\n+    return errors.length;\n+}\n\\ No newline at end of file\n",
      "actualSource": "int process(String aFileName) {\n    LineText[] errors;\n    try {\n        VerifierSingleton.getInstance().clearMessages();\n        VerifierSingleton.getInstance().setLines(getLines(aFileName));\n        final AST ast \u003d getAST(aFileName);\n        processAST(ast);\n        errors \u003d VerifierSingleton.getInstance().getMessages();\n    } catch (FileNotFoundException fnfe) {\n        errors \u003d new LineText[] { new LineText(0, \"File not found!\") };\n    } catch (IOException ioe) {\n        errors \u003d new LineText[] { new LineText(0, \"Got an IOException -\" + ioe.getMessage()) };\n    } catch (RecognitionException re) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a RecognitionException -\" + re.getMessage()) };\n    } catch (TokenStreamException te) {\n        errors \u003d new LineText[] { new LineText(0, \"Got a TokenStreamException -\" + te.getMessage()) };\n    }\n    displayErrors(aFileName, errors);\n    return errors.length;\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
      "functionStartLine": 94,
      "functionName": "process",
      "functionAnnotation": "",
      "functionDoc": "Processes a specified file and prints out all errors found.\n\n@return the number of errors found\n@param aFileName the name of the file to process\n"
    }
  }
}