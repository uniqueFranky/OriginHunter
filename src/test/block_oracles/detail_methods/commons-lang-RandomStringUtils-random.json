{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "RandomStringUtils.java",
  "functionName": "random",
  "functionId": "random___count-int__start-int__end-int__letters-boolean(modifiers-final)__numbers-boolean(modifiers-final)__chars-char[](modifiers-final)__random-Random(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single\n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
  "functionStartLine": 348,
  "functionEndLine": 425,
  "numCommitsSeen": 95,
  "timeTaken": 2348,
  "changeHistory": [
    "88654b79c92386b7c411f064cc373e7698a49449",
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
    "c82b1f062af2a1a376e514020707597f6ed1f82d",
    "30c85ad05363767deeefee577063c2c432b971d4",
    "f643b4fa939e89348618ddffae20a804f4461363",
    "695342cb1cef42f30fd1a8496f181c92b21ae82d",
    "15b80753a6e8f481ea5029bc278e362994cb7bee",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "4a65cb8da23d6667ac6f91775309b4da9b315d95",
    "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441",
    "371e866442f46131cc38a9a5018e1703f52f9b60",
    "0ca84735ad3df33dfb48e9e165db5cb689783869",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "b01434196523fc67daa5d9379c4465b68961fd53",
    "c79adcc3f0b99cb838155909a989fbd7bd71e600",
    "fac4f8d2d6c980440cbf582f3e0bfff3055aab3b",
    "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e",
    "7edd55554a03d7cdaefd12e4a319a0059414fb99",
    "e81e45f27fb6b3b4d82baa473e90e49d0317b77a",
    "0dd253a756b2cf808ea9c534f323a9a7d590cc74",
    "8f45918465c1c992d55fe08f2d7e49689b722b38",
    "3ac32dd142df1d1e0a5a36f224dcc73b1fa066e5",
    "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242",
    "7477a1e08fae75215763db8a837b8ca2a2bc9e6b",
    "031ff96cd3a9e319689e7df5a0b6272c16202256",
    "6627f7ad8fb08d6c23b83d6c9f0a6830e9e7085a"
  ],
  "changeHistoryShort": {
    "88654b79c92386b7c411f064cc373e7698a49449": "Ybodychange",
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec": "Ydocchange",
    "c82b1f062af2a1a376e514020707597f6ed1f82d": "Ybodychange",
    "30c85ad05363767deeefee577063c2c432b971d4": "Ybodychange",
    "f643b4fa939e89348618ddffae20a804f4461363": "Ymultichange(Ybodychange,Ydocchange)",
    "695342cb1cef42f30fd1a8496f181c92b21ae82d": "Ymultichange(Ybodychange,Ydocchange)",
    "15b80753a6e8f481ea5029bc278e362994cb7bee": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "4a65cb8da23d6667ac6f91775309b4da9b315d95": "Ybodychange",
    "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441": "Ymultichange(Ybodychange,Ydocchange)",
    "371e866442f46131cc38a9a5018e1703f52f9b60": "Ybodychange",
    "0ca84735ad3df33dfb48e9e165db5cb689783869": "Ydocchange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "b01434196523fc67daa5d9379c4465b68961fd53": "Ybodychange",
    "c79adcc3f0b99cb838155909a989fbd7bd71e600": "Ybodychange",
    "fac4f8d2d6c980440cbf582f3e0bfff3055aab3b": "Ydocchange",
    "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "7edd55554a03d7cdaefd12e4a319a0059414fb99": "Ydocchange",
    "e81e45f27fb6b3b4d82baa473e90e49d0317b77a": "Ybodychange",
    "0dd253a756b2cf808ea9c534f323a9a7d590cc74": "Ydocchange",
    "8f45918465c1c992d55fe08f2d7e49689b722b38": "Ybodychange",
    "3ac32dd142df1d1e0a5a36f224dcc73b1fa066e5": "Ymultichange(Ybodychange,Ydocchange)",
    "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "7477a1e08fae75215763db8a837b8ca2a2bc9e6b": "Ydocchange",
    "031ff96cd3a9e319689e7df5a0b6272c16202256": "Ydocchange",
    "6627f7ad8fb08d6c23b83d6c9f0a6830e9e7085a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "88654b79c92386b7c411f064cc373e7698a49449": {
      "type": "Ybodychange",
      "commitMessage": "Use final.",
      "commitDate": "2017/10/21 上午3:02",
      "commitName": "88654b79c92386b7c411f064cc373e7698a49449",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2017/7/29 上午12:26",
      "commitNameOld": "daeed97201c060563c9509e7d63b23094cb31664",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 84.11,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Character.MAX_CODE_POINT;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null \u0026\u0026 (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii)) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n    }\n    final StringBuilder builder \u003d new StringBuilder(count);\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        int codePoint;\n        if (chars \u003d\u003d null) {\n            codePoint \u003d random.nextInt(gap) + start;\n            switch(Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n        } else {\n            codePoint \u003d chars[random.nextInt(gap) + start];\n        }\n        final int numberOfChars \u003d Character.charCount(codePoint);\n        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n            count++;\n            continue;\n        }\n        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n            builder.appendCodePoint(codePoint);\n            if (numberOfChars \u003d\u003d 2) {\n                count--;\n            }\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 348,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single\n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,62 +1,62 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Character.MAX_CODE_POINT;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     final int zero_digit_ascii \u003d 48;\n     final int first_letter_ascii \u003d 65;\n     if (chars \u003d\u003d null \u0026\u0026 (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii)) {\n         throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n     }\n-    StringBuilder builder \u003d new StringBuilder(count);\n+    final StringBuilder builder \u003d new StringBuilder(count);\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         int codePoint;\n         if (chars \u003d\u003d null) {\n             codePoint \u003d random.nextInt(gap) + start;\n             switch(Character.getType(codePoint)) {\n                 case Character.UNASSIGNED:\n                 case Character.PRIVATE_USE:\n                 case Character.SURROGATE:\n                     count++;\n                     continue;\n             }\n         } else {\n             codePoint \u003d chars[random.nextInt(gap) + start];\n         }\n         final int numberOfChars \u003d Character.charCount(codePoint);\n         if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n             count++;\n             continue;\n         }\n         if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n             builder.appendCodePoint(codePoint);\n             if (numberOfChars \u003d\u003d 2) {\n                 count--;\n             }\n         } else {\n             count++;\n         }\n     }\n     return builder.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec": {
      "type": "Ydocchange",
      "commitMessage": "Make sure lines in files don\u0027t have trailing white spaces and remove all trailing white spaces\n",
      "commitDate": "2017/6/6 下午9:12",
      "commitName": "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2017/5/25 下午8:49",
      "commitNameOld": "ebe7bb58a541bf397333f466d412e617266ee5aa",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 12.02,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Character.MAX_CODE_POINT;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null \u0026\u0026 (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii)) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n    }\n    StringBuilder builder \u003d new StringBuilder(count);\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        int codePoint;\n        if (chars \u003d\u003d null) {\n            codePoint \u003d random.nextInt(gap) + start;\n            switch(Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n        } else {\n            codePoint \u003d chars[random.nextInt(gap) + start];\n        }\n        final int numberOfChars \u003d Character.charCount(codePoint);\n        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n            count++;\n            continue;\n        }\n        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n            builder.appendCodePoint(codePoint);\n            if (numberOfChars \u003d\u003d 2) {\n                count--;\n            }\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 348,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single\n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
        "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single\n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n"
      }
    },
    "c82b1f062af2a1a376e514020707597f6ed1f82d": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Nested if statements can be combined\n",
      "commitDate": "2017/4/17 下午7:02",
      "commitName": "c82b1f062af2a1a376e514020707597f6ed1f82d",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2017/2/17 上午2:59",
      "commitNameOld": "30c85ad05363767deeefee577063c2c432b971d4",
      "commitAuthorOld": "Sebb",
      "daysBetweenCommits": 59.67,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Character.MAX_CODE_POINT;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null \u0026\u0026 (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii)) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n    }\n    StringBuilder builder \u003d new StringBuilder(count);\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        int codePoint;\n        if (chars \u003d\u003d null) {\n            codePoint \u003d random.nextInt(gap) + start;\n            switch(Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n        } else {\n            codePoint \u003d chars[random.nextInt(gap) + start];\n        }\n        final int numberOfChars \u003d Character.charCount(codePoint);\n        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n            count++;\n            continue;\n        }\n        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n            builder.appendCodePoint(codePoint);\n            if (numberOfChars \u003d\u003d 2) {\n                count--;\n            }\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 344,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,64 +1,62 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Character.MAX_CODE_POINT;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     final int zero_digit_ascii \u003d 48;\n     final int first_letter_ascii \u003d 65;\n-    if (chars \u003d\u003d null) {\n-        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n-            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n-        }\n+    if (chars \u003d\u003d null \u0026\u0026 (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii)) {\n+        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n     }\n     StringBuilder builder \u003d new StringBuilder(count);\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         int codePoint;\n         if (chars \u003d\u003d null) {\n             codePoint \u003d random.nextInt(gap) + start;\n             switch(Character.getType(codePoint)) {\n                 case Character.UNASSIGNED:\n                 case Character.PRIVATE_USE:\n                 case Character.SURROGATE:\n                     count++;\n                     continue;\n             }\n         } else {\n             codePoint \u003d chars[random.nextInt(gap) + start];\n         }\n         final int numberOfChars \u003d Character.charCount(codePoint);\n         if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n             count++;\n             continue;\n         }\n         if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n             builder.appendCodePoint(codePoint);\n             if (numberOfChars \u003d\u003d 2) {\n                 count--;\n             }\n         } else {\n             count++;\n         }\n     }\n     return builder.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "30c85ad05363767deeefee577063c2c432b971d4": {
      "type": "Ybodychange",
      "commitMessage": "Use StringBuilders instead of StringBuffers\n\n(A couple of instances were overlooked)\nThis fixes #236",
      "commitDate": "2017/2/17 上午2:59",
      "commitName": "30c85ad05363767deeefee577063c2c432b971d4",
      "commitAuthor": "Sebb",
      "commitDateOld": "2016/12/15 上午4:46",
      "commitNameOld": "cdfb2aa1e1ae3029e5d73cb3b5ca90c7df222c8a",
      "commitAuthorOld": "duncan",
      "daysBetweenCommits": 63.93,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Character.MAX_CODE_POINT;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null) {\n        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n        }\n    }\n    StringBuilder builder \u003d new StringBuilder(count);\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        int codePoint;\n        if (chars \u003d\u003d null) {\n            codePoint \u003d random.nextInt(gap) + start;\n            switch(Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n        } else {\n            codePoint \u003d chars[random.nextInt(gap) + start];\n        }\n        final int numberOfChars \u003d Character.charCount(codePoint);\n        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n            count++;\n            continue;\n        }\n        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n            builder.appendCodePoint(codePoint);\n            if (numberOfChars \u003d\u003d 2) {\n                count--;\n            }\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 344,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,64 +1,64 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Character.MAX_CODE_POINT;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     final int zero_digit_ascii \u003d 48;\n     final int first_letter_ascii \u003d 65;\n     if (chars \u003d\u003d null) {\n         if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n         }\n     }\n-    StringBuffer buffer \u003d new StringBuffer(count);\n+    StringBuilder builder \u003d new StringBuilder(count);\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         int codePoint;\n         if (chars \u003d\u003d null) {\n             codePoint \u003d random.nextInt(gap) + start;\n             switch(Character.getType(codePoint)) {\n                 case Character.UNASSIGNED:\n                 case Character.PRIVATE_USE:\n                 case Character.SURROGATE:\n                     count++;\n                     continue;\n             }\n         } else {\n             codePoint \u003d chars[random.nextInt(gap) + start];\n         }\n         final int numberOfChars \u003d Character.charCount(codePoint);\n         if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n             count++;\n             continue;\n         }\n         if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n-            buffer.appendCodePoint(codePoint);\n+            builder.appendCodePoint(codePoint);\n             if (numberOfChars \u003d\u003d 2) {\n                 count--;\n             }\n         } else {\n             count++;\n         }\n     }\n-    return buffer.toString();\n+    return builder.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f643b4fa939e89348618ddffae20a804f4461363": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Fix for LANG-1286: RandomStringUtils random method can overflow...",
      "commitDate": "2016/12/14 下午2:27",
      "commitName": "f643b4fa939e89348618ddffae20a804f4461363",
      "commitAuthor": "duncan",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fix for LANG-1286: RandomStringUtils random method can overflow...",
          "commitDate": "2016/12/14 下午2:27",
          "commitName": "f643b4fa939e89348618ddffae20a804f4461363",
          "commitAuthor": "duncan",
          "commitDateOld": "2016/11/18 下午11:51",
          "commitNameOld": "695342cb1cef42f30fd1a8496f181c92b21ae82d",
          "commitAuthorOld": "Ivan Morozov",
          "daysBetweenCommits": 25.61,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Character.MAX_CODE_POINT;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null) {\n        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer(count);\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        int codePoint;\n        if (chars \u003d\u003d null) {\n            codePoint \u003d random.nextInt(gap) + start;\n            switch(Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n        } else {\n            codePoint \u003d chars[random.nextInt(gap) + start];\n        }\n        final int numberOfChars \u003d Character.charCount(codePoint);\n        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n            count++;\n            continue;\n        }\n        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n            buffer.appendCodePoint(codePoint);\n            if (numberOfChars \u003d\u003d 2) {\n                count--;\n            }\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
          "functionStartLine": 343,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
          "diff": "@@ -1,69 +1,64 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n-                end \u003d Integer.MAX_VALUE;\n+                end \u003d Character.MAX_CODE_POINT;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     final int zero_digit_ascii \u003d 48;\n     final int first_letter_ascii \u003d 65;\n     if (chars \u003d\u003d null) {\n         if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n         }\n     }\n-    final char[] buffer \u003d new char[count];\n+    StringBuffer buffer \u003d new StringBuffer(count);\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n-        char ch;\n+        int codePoint;\n         if (chars \u003d\u003d null) {\n-            ch \u003d (char) (random.nextInt(gap) + start);\n+            codePoint \u003d random.nextInt(gap) + start;\n+            switch(Character.getType(codePoint)) {\n+                case Character.UNASSIGNED:\n+                case Character.PRIVATE_USE:\n+                case Character.SURROGATE:\n+                    count++;\n+                    continue;\n+            }\n         } else {\n-            ch \u003d chars[random.nextInt(gap) + start];\n+            codePoint \u003d chars[random.nextInt(gap) + start];\n         }\n-        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n-            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n-                if (count \u003d\u003d 0) {\n-                    count++;\n-                } else {\n-                    buffer[count] \u003d ch;\n-                    count--;\n-                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n-                }\n-            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n-                if (count \u003d\u003d 0) {\n-                    count++;\n-                } else {\n-                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n-                    count--;\n-                    buffer[count] \u003d ch;\n-                }\n-            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n-                count++;\n-            } else {\n-                buffer[count] \u003d ch;\n+        final int numberOfChars \u003d Character.charCount(codePoint);\n+        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n+            count++;\n+            continue;\n+        }\n+        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n+            buffer.appendCodePoint(codePoint);\n+            if (numberOfChars \u003d\u003d 2) {\n+                count--;\n             }\n         } else {\n             count++;\n         }\n     }\n-    return new String(buffer);\n+    return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fix for LANG-1286: RandomStringUtils random method can overflow...",
          "commitDate": "2016/12/14 下午2:27",
          "commitName": "f643b4fa939e89348618ddffae20a804f4461363",
          "commitAuthor": "duncan",
          "commitDateOld": "2016/11/18 下午11:51",
          "commitNameOld": "695342cb1cef42f30fd1a8496f181c92b21ae82d",
          "commitAuthorOld": "Ivan Morozov",
          "daysBetweenCommits": 25.61,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Character.MAX_CODE_POINT;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null) {\n        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer(count);\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        int codePoint;\n        if (chars \u003d\u003d null) {\n            codePoint \u003d random.nextInt(gap) + start;\n            switch(Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n        } else {\n            codePoint \u003d chars[random.nextInt(gap) + start];\n        }\n        final int numberOfChars \u003d Character.charCount(codePoint);\n        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n            count++;\n            continue;\n        }\n        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n            buffer.appendCodePoint(codePoint);\n            if (numberOfChars \u003d\u003d 2) {\n                count--;\n            }\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
          "functionStartLine": 343,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
          "diff": "@@ -1,69 +1,64 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n-                end \u003d Integer.MAX_VALUE;\n+                end \u003d Character.MAX_CODE_POINT;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     final int zero_digit_ascii \u003d 48;\n     final int first_letter_ascii \u003d 65;\n     if (chars \u003d\u003d null) {\n         if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n         }\n     }\n-    final char[] buffer \u003d new char[count];\n+    StringBuffer buffer \u003d new StringBuffer(count);\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n-        char ch;\n+        int codePoint;\n         if (chars \u003d\u003d null) {\n-            ch \u003d (char) (random.nextInt(gap) + start);\n+            codePoint \u003d random.nextInt(gap) + start;\n+            switch(Character.getType(codePoint)) {\n+                case Character.UNASSIGNED:\n+                case Character.PRIVATE_USE:\n+                case Character.SURROGATE:\n+                    count++;\n+                    continue;\n+            }\n         } else {\n-            ch \u003d chars[random.nextInt(gap) + start];\n+            codePoint \u003d chars[random.nextInt(gap) + start];\n         }\n-        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n-            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n-                if (count \u003d\u003d 0) {\n-                    count++;\n-                } else {\n-                    buffer[count] \u003d ch;\n-                    count--;\n-                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n-                }\n-            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n-                if (count \u003d\u003d 0) {\n-                    count++;\n-                } else {\n-                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n-                    count--;\n-                    buffer[count] \u003d ch;\n-                }\n-            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n-                count++;\n-            } else {\n-                buffer[count] \u003d ch;\n+        final int numberOfChars \u003d Character.charCount(codePoint);\n+        if (count \u003d\u003d 0 \u0026\u0026 numberOfChars \u003e 1) {\n+            count++;\n+            continue;\n+        }\n+        if (letters \u0026\u0026 Character.isLetter(codePoint) || numbers \u0026\u0026 Character.isDigit(codePoint) || !letters \u0026\u0026 !numbers) {\n+            buffer.appendCodePoint(codePoint);\n+            if (numberOfChars \u003d\u003d 2) {\n+                count--;\n             }\n         } else {\n             count++;\n         }\n     }\n-    return new String(buffer);\n+    return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
            "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@link Character#MAX_CODE_POINT}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n"
          }
        }
      ]
    },
    "695342cb1cef42f30fd1a8496f181c92b21ae82d": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-1287: RandomStringUtils#random can enter infinite loop if end parameter is to small (closes #211)\n\n1.) Fixed possible infinite loop that can be caused by generating either digits or letters by calling with a to low end param.\n\n2.) Added (inclusive) and (exclusive) terms to javadoc of random method\n",
      "commitDate": "2016/11/18 下午11:51",
      "commitName": "695342cb1cef42f30fd1a8496f181c92b21ae82d",
      "commitAuthor": "Ivan Morozov",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1287: RandomStringUtils#random can enter infinite loop if end parameter is to small (closes #211)\n\n1.) Fixed possible infinite loop that can be caused by generating either digits or letters by calling with a to low end param.\n\n2.) Added (inclusive) and (exclusive) terms to javadoc of random method\n",
          "commitDate": "2016/11/18 下午11:51",
          "commitName": "695342cb1cef42f30fd1a8496f181c92b21ae82d",
          "commitAuthor": "Ivan Morozov",
          "commitDateOld": "2016/8/21 下午9:50",
          "commitNameOld": "a06c99b9c094d66f0d33bd69e15fe01ba52a8b05",
          "commitAuthorOld": "pascalschumacher",
          "daysBetweenCommits": 89.08,
          "commitsBetweenForRepo": 177,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null) {\n        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n        }\n    }\n    final char[] buffer \u003d new char[count];\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
          "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
          "functionStartLine": 343,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
          "diff": "@@ -1,62 +1,69 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Integer.MAX_VALUE;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n+    final int zero_digit_ascii \u003d 48;\n+    final int first_letter_ascii \u003d 65;\n+    if (chars \u003d\u003d null) {\n+        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n+            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n+        }\n+    }\n     final char[] buffer \u003d new char[count];\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-1287: RandomStringUtils#random can enter infinite loop if end parameter is to small (closes #211)\n\n1.) Fixed possible infinite loop that can be caused by generating either digits or letters by calling with a to low end param.\n\n2.) Added (inclusive) and (exclusive) terms to javadoc of random method\n",
          "commitDate": "2016/11/18 下午11:51",
          "commitName": "695342cb1cef42f30fd1a8496f181c92b21ae82d",
          "commitAuthor": "Ivan Morozov",
          "commitDateOld": "2016/8/21 下午9:50",
          "commitNameOld": "a06c99b9c094d66f0d33bd69e15fe01ba52a8b05",
          "commitAuthorOld": "pascalschumacher",
          "daysBetweenCommits": 89.08,
          "commitsBetweenForRepo": 177,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final int zero_digit_ascii \u003d 48;\n    final int first_letter_ascii \u003d 65;\n    if (chars \u003d\u003d null) {\n        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n        }\n    }\n    final char[] buffer \u003d new char[count];\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
          "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
          "functionStartLine": 343,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
          "diff": "@@ -1,62 +1,69 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Integer.MAX_VALUE;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n+    final int zero_digit_ascii \u003d 48;\n+    final int first_letter_ascii \u003d 65;\n+    if (chars \u003d\u003d null) {\n+        if (numbers \u0026\u0026 end \u003c\u003d zero_digit_ascii || letters \u0026\u0026 end \u003c\u003d first_letter_ascii) {\n+            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zero_digit_ascii + \") for generating digits \" + \"or greater then (\" + first_letter_ascii + \") for generating letters.\");\n+        }\n+    }\n     final char[] buffer \u003d new char[count];\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
            "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at (inclusive)\n@param end the position in set of chars to end before (exclusive)\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n"
          }
        }
      ]
    },
    "15b80753a6e8f481ea5029bc278e362994cb7bee": {
      "type": "Ybodychange",
      "commitMessage": "Reuse",
      "commitDate": "2016/4/14 上午4:57",
      "commitName": "15b80753a6e8f481ea5029bc278e362994cb7bee",
      "commitAuthor": "ggregory",
      "commitDateOld": "2015/5/6 上午3:12",
      "commitNameOld": "740c0f95fbd99cb7c07bcf7c54bc077c3ab27bd1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 344.07,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return StringUtils.EMPTY;\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final char[] buffer \u003d new char[count];\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 222,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,62 +1,62 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n-        return \"\";\n+        return StringUtils.EMPTY;\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Integer.MAX_VALUE;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     final char[] buffer \u003d new char[count];\n     final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:09",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/1/22 下午3:07",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    final char[] buffer \u003d new char[count];\n    final int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 223,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,62 +1,62 @@\n public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Integer.MAX_VALUE;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n-    char[] buffer \u003d new char[count];\n-    int gap \u003d end - start;\n+    final char[] buffer \u003d new char[count];\n+    final int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:07",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012/6/10 下午8:40",
      "commitNameOld": "4a65cb8da23d6667ac6f91775309b4da9b315d95",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 225.77,
      "commitsBetweenForRepo": 160,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 223,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,62 +1,62 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n+public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Integer.MAX_VALUE;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n     } else {\n         if (end \u003c\u003d start) {\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n     }\n     char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[count-int, start-int, end-int, letters-boolean, numbers-boolean, chars-char[], random-Random]",
        "newValue": "[count-int, start-int, end-int, letters-boolean(modifiers-final), numbers-boolean(modifiers-final), chars-char[](modifiers-final), random-Random(modifiers-final)]"
      }
    },
    "4a65cb8da23d6667ac6f91775309b4da9b315d95": {
      "type": "Ybodychange",
      "commitMessage": "LANG-807 RandomStringUtils throws confusing IAE when end \u003c\u003d start\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1348583 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/6/10 下午8:40",
      "commitName": "4a65cb8da23d6667ac6f91775309b4da9b315d95",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2012/6/9 下午10:58",
      "commitNameOld": "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    } else {\n        if (end \u003c\u003d start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 223,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
      "diff": "@@ -1,58 +1,62 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"The chars array must not be empty\");\n     }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         if (chars !\u003d null) {\n             end \u003d chars.length;\n         } else {\n             if (!letters \u0026\u0026 !numbers) {\n                 end \u003d Integer.MAX_VALUE;\n             } else {\n                 end \u003d \u0027z\u0027 + 1;\n                 start \u003d \u0027 \u0027;\n             }\n         }\n+    } else {\n+        if (end \u003c\u003d start) {\n+            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n+        }\n     }\n     char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-805 RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1348422 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/6/9 下午10:58",
      "commitName": "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-805 RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1348422 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2012/6/9 下午10:58",
          "commitName": "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2011/11/10 上午1:53",
          "commitNameOld": "371e866442f46131cc38a9a5018e1703f52f9b60",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 212.88,
          "commitsBetweenForRepo": 82,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
          "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
          "functionStartLine": 223,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
          "diff": "@@ -1,51 +1,58 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n+    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n+        throw new IllegalArgumentException(\"The chars array must not be empty\");\n+    }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n-        end \u003d \u0027z\u0027 + 1;\n-        start \u003d \u0027 \u0027;\n-        if (!letters \u0026\u0026 !numbers) {\n-            start \u003d 0;\n-            end \u003d Integer.MAX_VALUE;\n+        if (chars !\u003d null) {\n+            end \u003d chars.length;\n+        } else {\n+            if (!letters \u0026\u0026 !numbers) {\n+                end \u003d Integer.MAX_VALUE;\n+            } else {\n+                end \u003d \u0027z\u0027 + 1;\n+                start \u003d \u0027 \u0027;\n+            }\n         }\n     }\n     char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-805 RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1348422 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2012/6/9 下午10:58",
          "commitName": "27bcbcc728434ffb2c45e81c0e75e6a3d6da3441",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2011/11/10 上午1:53",
          "commitNameOld": "371e866442f46131cc38a9a5018e1703f52f9b60",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 212.88,
          "commitsBetweenForRepo": 82,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        if (chars !\u003d null) {\n            end \u003d chars.length;\n        } else {\n            if (!letters \u0026\u0026 !numbers) {\n                end \u003d Integer.MAX_VALUE;\n            } else {\n                end \u003d \u0027z\u0027 + 1;\n                start \u003d \u0027 \u0027;\n            }\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
          "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
          "functionStartLine": 223,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n",
          "diff": "@@ -1,51 +1,58 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n+    if (chars !\u003d null \u0026\u0026 chars.length \u003d\u003d 0) {\n+        throw new IllegalArgumentException(\"The chars array must not be empty\");\n+    }\n     if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n-        end \u003d \u0027z\u0027 + 1;\n-        start \u003d \u0027 \u0027;\n-        if (!letters \u0026\u0026 !numbers) {\n-            start \u003d 0;\n-            end \u003d Integer.MAX_VALUE;\n+        if (chars !\u003d null) {\n+            end \u003d chars.length;\n+        } else {\n+            if (!letters \u0026\u0026 !numbers) {\n+                end \u003d Integer.MAX_VALUE;\n+            } else {\n+                end \u003d \u0027z\u0027 + 1;\n+                start \u003d \u0027 \u0027;\n+            }\n         }\n     }\n     char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0.\n@since 2.0\n",
            "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from, must not be empty.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0 or the provided chars array is empty.\n@since 2.0\n"
          }
        }
      ]
    },
    "371e866442f46131cc38a9a5018e1703f52f9b60": {
      "type": "Ybodychange",
      "commitMessage": "Remove superfluous parens like:\nreturn (foo + 1);\nint len \u003d (foo + 1);\nif ((foo + 1 \u003e 2))\n((String) foo)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1199894 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/11/10 上午1:53",
      "commitName": "371e866442f46131cc38a9a5018e1703f52f9b60",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011/7/20 上午4:53",
      "commitNameOld": "2c3fa8366e133200d2a6e0c7f309a876ff9b8675",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 112.88,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 223,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0.\n@since 2.0\n",
      "diff": "@@ -1,51 +1,51 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n-    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n+    if (start \u003d\u003d 0 \u0026\u0026 end \u003d\u003d 0) {\n         end \u003d \u0027z\u0027 + 1;\n         start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n-        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n+        if (letters \u0026\u0026 Character.isLetter(ch) || numbers \u0026\u0026 Character.isDigit(ch) || !letters \u0026\u0026 !numbers) {\n             if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d ch;\n                     count--;\n                     buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                 }\n             } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                 if (count \u003d\u003d 0) {\n                     count++;\n                 } else {\n                     buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                     count--;\n                     buffer[count] \u003d ch;\n                 }\n             } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                 count++;\n             } else {\n                 buffer[count] \u003d ch;\n             }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ca84735ad3df33dfb48e9e165db5cb689783869": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1078032 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/3/5 上午12:07",
      "commitName": "0ca84735ad3df33dfb48e9e165db5cb689783869",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2011/3/4 下午8:54",
      "commitNameOld": "79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 227,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0.\n@since 2.0\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n",
        "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both {@code 0}, start and end are set\nto {@code \u0027 \u0027} and {@code \u0027z\u0027}, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n{@code false}, in which case, start and end are set to\n{@code 0} and {@code Integer.MAX_VALUE}.\n\n\u003cp\u003eIf set is not {@code null}, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If {@code null}, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n {@code (end - start) + 1} characters in the set array.\n@throws IllegalArgumentException if {@code count} \u0026lt; 0.\n@since 2.0\n"
      }
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 225,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/RandomStringUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/java/org/apache/commons/lang3/RandomStringUtils.java",
      "functionStartLine": 225,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/RandomStringUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/RandomStringUtils.java"
      }
    },
    "b01434196523fc67daa5d9379c4465b68961fd53": {
      "type": "Ybodychange",
      "commitMessage": "Adding a test and a fix for LANG-100. This is a bug in which the randomly created String can sometimes be illegal unicode; because the code does not consider when relationships exist between characters. High and low surrogates are now dealt with, but I\u0027m skipping private high surrogates because I can\u0027t find out what to do. Need to go plod very slowly through the spec. This site was very useful: http://www.alanwood.net/unicode/private_use_high_surrogates.html\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@417319 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/6/27 上午8:28",
      "commitName": "b01434196523fc67daa5d9379c4465b68961fd53",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2005/9/10 下午6:07",
      "commitNameOld": "c79adcc3f0b99cb838155909a989fbd7bd71e600",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 289.6,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d ch;\n                    count--;\n                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n                }\n            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n                if (count \u003d\u003d 0) {\n                    count++;\n                } else {\n                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] \u003d ch;\n                }\n            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n                count++;\n            } else {\n                buffer[count] \u003d ch;\n            }\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 226,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n",
      "diff": "@@ -1,31 +1,51 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d \u0027z\u0027 + 1;\n         start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n-            buffer[count] \u003d ch;\n+            if (ch \u003e\u003d 56320 \u0026\u0026 ch \u003c\u003d 57343) {\n+                if (count \u003d\u003d 0) {\n+                    count++;\n+                } else {\n+                    buffer[count] \u003d ch;\n+                    count--;\n+                    buffer[count] \u003d (char) (55296 + random.nextInt(128));\n+                }\n+            } else if (ch \u003e\u003d 55296 \u0026\u0026 ch \u003c\u003d 56191) {\n+                if (count \u003d\u003d 0) {\n+                    count++;\n+                } else {\n+                    buffer[count] \u003d (char) (56320 + random.nextInt(128));\n+                    count--;\n+                    buffer[count] \u003d ch;\n+                }\n+            } else if (ch \u003e\u003d 56192 \u0026\u0026 ch \u003c\u003d 56319) {\n+                count++;\n+            } else {\n+                buffer[count] \u003d ch;\n+            }\n         } else {\n             count++;\n         }\n     }\n     return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c79adcc3f0b99cb838155909a989fbd7bd71e600": {
      "type": "Ybodychange",
      "commitMessage": "Optimize performance of RandomStringUtils\nbug 35170, from Shaun Kalley\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@279985 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/9/10 下午6:07",
      "commitName": "c79adcc3f0b99cb838155909a989fbd7bd71e600",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2005/6/27 上午8:54",
      "commitNameOld": "ebff428ba5d133a8e37e97a03b4b2483d1f9386d",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 75.38,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    char[] buffer \u003d new char[count];\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer[count] \u003d ch;\n        } else {\n            count++;\n        }\n    }\n    return new String(buffer);\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 218,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n",
      "diff": "@@ -1,31 +1,31 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d \u0027z\u0027 + 1;\n         start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n-    StringBuffer buffer \u003d new StringBuffer();\n+    char[] buffer \u003d new char[count];\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d chars[random.nextInt(gap) + start];\n         }\n-        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n-            buffer.append(ch);\n+        if ((letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n+            buffer[count] \u003d ch;\n         } else {\n             count++;\n         }\n     }\n-    return buffer.toString();\n+    return new String(buffer);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fac4f8d2d6c980440cbf582f3e0bfff3055aab3b": {
      "type": "Ydocchange",
      "commitMessage": "Add @since 2.0 tags based on http://www.apache.org/~bayard/commons-lang-2.0/Commons-Lang-1.0.1-to-2.0/missingSinces.txt\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137644 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/8/21 下午11:52",
      "commitName": "fac4f8d2d6c980440cbf582f3e0bfff3055aab3b",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2003/8/18 上午10:22",
      "commitNameOld": "379d1bcac32d75e6c7f32661b2203f930f9989df",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 3.56,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 255,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
        "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n@since 2.0\n"
      }
    },
    "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Fix RandomStringUtils to not throw NPE all the time\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137543 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/8/1 上午7:24",
      "commitName": "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix RandomStringUtils to not throw NPE all the time\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137543 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/8/1 上午7:24",
          "commitName": "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/7/26 下午6:32",
          "commitNameOld": "7edd55554a03d7cdaefd12e4a319a0059414fb99",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 5.54,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 252,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
          "diff": "@@ -1,31 +1,31 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d \u0027z\u0027 + 1;\n         start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n-        if (set \u003d\u003d null) {\n+        if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n-            ch \u003d set[random.nextInt(gap) + start];\n+            ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[count-int, start-int, end-int, letters-boolean, numbers-boolean, set-char[], random-Random]",
            "newValue": "[count-int, start-int, end-int, letters-boolean, numbers-boolean, chars-char[], random-Random]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix RandomStringUtils to not throw NPE all the time\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137543 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/8/1 上午7:24",
          "commitName": "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/7/26 下午6:32",
          "commitNameOld": "7edd55554a03d7cdaefd12e4a319a0059414fb99",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 5.54,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 252,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
          "diff": "@@ -1,31 +1,31 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d \u0027z\u0027 + 1;\n         start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n-        if (set \u003d\u003d null) {\n+        if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n-            ch \u003d set[random.nextInt(gap) + start];\n+            ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fix RandomStringUtils to not throw NPE all the time\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137543 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/8/1 上午7:24",
          "commitName": "43db5237ab2a2dbc3a79daed10499bb4dbf92a4e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/7/26 下午6:32",
          "commitNameOld": "7edd55554a03d7cdaefd12e4a319a0059414fb99",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 5.54,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (chars \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d chars[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 252,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
          "diff": "@@ -1,31 +1,31 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d \u0027z\u0027 + 1;\n         start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n-        if (set \u003d\u003d null) {\n+        if (chars \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n-            ch \u003d set[random.nextInt(gap) + start];\n+            ch \u003d chars[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
            "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param chars the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n"
          }
        }
      ]
    },
    "7edd55554a03d7cdaefd12e4a319a0059414fb99": {
      "type": "Ydocchange",
      "commitMessage": "Fix Javadoc troubles\nfrom Phil Steitz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137506 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/26 下午6:32",
      "commitName": "7edd55554a03d7cdaefd12e4a319a0059414fb99",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003/7/26 上午8:26",
      "commitNameOld": "e81e45f27fb6b3b4d82baa473e90e49d0317b77a",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 252,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
        "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eThis method accepts a user-supplied {@link Random}\ninstance to use as a source of randomness. By seeding a single \n{@link Random} instance with a fixed seed and using it for each call,\nthe same random sequence of strings can be generated repeatedly\nand predictably.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n"
      }
    },
    "e81e45f27fb6b3b4d82baa473e90e49d0317b77a": {
      "type": "Ybodychange",
      "commitMessage": "Severity\tDescription\tResource\tIn Folder\tLocation\tCreation Time\n\tUnnecessary cast to type int for expression of type char\tRandomStringUtils.java\tApache Jakarta Commons/lang/src/java/org/apache/commons/lang\tline 259\tJuly 23, 2003 11:22:36 AM\n\tUnnecessary cast to type int for expression of type char. It is already compatible with the argument type int\tRandomStringUtils.java\tApache Jakarta Commons/lang/src/java/org/apache/commons/lang\tline 258\tJuly 23, 2003 11:22:36 AM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137500 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/26 上午8:26",
      "commitName": "e81e45f27fb6b3b4d82baa473e90e49d0317b77a",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2003/7/20 上午4:21",
      "commitNameOld": "a0aef72d875ab7d1bd2d1e6ac93e282ffbebfc89",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 6.17,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d \u0027z\u0027 + 1;\n        start \u003d \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 251,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
      "diff": "@@ -1,31 +1,31 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n-        end \u003d (int) \u0027z\u0027 + 1;\n-        start \u003d (int) \u0027 \u0027;\n+        end \u003d \u0027z\u0027 + 1;\n+        start \u003d \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0dd253a756b2cf808ea9c534f323a9a7d590cc74": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc null behaviour\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/16 上午8:39",
      "commitName": "0dd253a756b2cf808ea9c534f323a9a7d590cc74",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003/7/9 上午6:06",
      "commitNameOld": "d5c3e4d3fe44b740061fe4b0d613094fd4c01db3",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 7.11,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027 + 1;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 252,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
        "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count the length of random string to create\n@param start the position in set of chars to start at\n@param end the position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set the set of chars to choose randoms from.\n If \u003ccode\u003enull\u003c/code\u003e, then it will use the set of all chars.\n@param random a source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n"
      }
    },
    "8f45918465c1c992d55fe08f2d7e49689b722b38": {
      "type": "Ybodychange",
      "commitMessage": "Ensure that RandomStringUtils returns all expected characters\nbug 20592, reported/patched by Phil Steitz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137365 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/6/10 上午5:36",
      "commitName": "8f45918465c1c992d55fe08f2d7e49689b722b38",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003/5/21 上午5:15",
      "commitNameOld": "0cd7de5283b8c96e50638f2480a3b2743714247e",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027 + 1;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 252,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
      "diff": "@@ -1,31 +1,31 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n     if (count \u003d\u003d 0) {\n         return \"\";\n     } else if (count \u003c 0) {\n         throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n     }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n-        end \u003d (int) \u0027z\u0027;\n+        end \u003d (int) \u0027z\u0027 + 1;\n         start \u003d (int) \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ac32dd142df1d1e0a5a36f224dcc73b1fa066e5": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Patch for RandomString bug in which counts of 0 or negative counts would cause array exceptions.\n\nSubmitted by:\tville.skytta@iki.fi (Ville Skytt�)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137289 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/4/9 下午10:13",
      "commitName": "3ac32dd142df1d1e0a5a36f224dcc73b1fa066e5",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Patch for RandomString bug in which counts of 0 or negative counts would cause array exceptions.\n\nSubmitted by:\tville.skytta@iki.fi (Ville Skytt�)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137289 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/4/9 下午10:13",
          "commitName": "3ac32dd142df1d1e0a5a36f224dcc73b1fa066e5",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2003/3/24 上午2:02",
          "commitNameOld": "637d681789b12e618871140154fdc7acee7a181d",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 16.84,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 251,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
          "diff": "@@ -1,26 +1,31 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n+    if (count \u003d\u003d 0) {\n+        return \"\";\n+    } else if (count \u003c 0) {\n+        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n+    }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d (int) \u0027z\u0027;\n         start \u003d (int) \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Patch for RandomString bug in which counts of 0 or negative counts would cause array exceptions.\n\nSubmitted by:\tville.skytta@iki.fi (Ville Skytt�)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137289 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/4/9 下午10:13",
          "commitName": "3ac32dd142df1d1e0a5a36f224dcc73b1fa066e5",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2003/3/24 上午2:02",
          "commitNameOld": "637d681789b12e618871140154fdc7acee7a181d",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 16.84,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if (count \u003d\u003d 0) {\n        return \"\";\n    } else if (count \u003c 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 251,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n",
          "diff": "@@ -1,26 +1,31 @@\n public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n+    if (count \u003d\u003d 0) {\n+        return \"\";\n+    } else if (count \u003c 0) {\n+        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n+    }\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d (int) \u0027z\u0027;\n         start \u003d (int) \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n             ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n             ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n",
            "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n@throws IllegalArgumentException if \u003ccode\u003ecount\u003c/code\u003e \u0026lt; 0.\n"
          }
        }
      ]
    },
    "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Applied patch from Tomasz Skutnik which allows a Random object to be passed\nin. This means that method calls to RandomStringUtils can be predictable.\n\nSubmitted by:\tTomasz Skutnik \u003cTomasz.Skutnik@e-point.pl\u003e\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137238 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/2/2 上午11:46",
      "commitName": "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Applied patch from Tomasz Skutnik which allows a Random object to be passed\nin. This means that method calls to RandomStringUtils can be predictable.\n\nSubmitted by:\tTomasz Skutnik \u003cTomasz.Skutnik@e-point.pl\u003e\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137238 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/2/2 上午11:46",
          "commitName": "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2002/12/23 上午8:32",
          "commitNameOld": "8e3f80d77e1601a875446fa8ca01d5c10cb30170",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 41.13,
          "commitsBetweenForRepo": 28,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 250,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n",
          "diff": "@@ -1,26 +1,26 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d (int) \u0027z\u0027;\n         start \u003d (int) \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n-            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n+            ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n-            ch \u003d set[RANDOM.nextInt(gap) + start];\n+            ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[count-int, start-int, end-int, letters-boolean, numbers-boolean, set-char[]]",
            "newValue": "[count-int, start-int, end-int, letters-boolean, numbers-boolean, set-char[], random-Random]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Applied patch from Tomasz Skutnik which allows a Random object to be passed\nin. This means that method calls to RandomStringUtils can be predictable.\n\nSubmitted by:\tTomasz Skutnik \u003cTomasz.Skutnik@e-point.pl\u003e\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137238 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/2/2 上午11:46",
          "commitName": "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2002/12/23 上午8:32",
          "commitNameOld": "8e3f80d77e1601a875446fa8ca01d5c10cb30170",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 41.13,
          "commitsBetweenForRepo": 28,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 250,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n",
          "diff": "@@ -1,26 +1,26 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d (int) \u0027z\u0027;\n         start \u003d (int) \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n-            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n+            ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n-            ch \u003d set[RANDOM.nextInt(gap) + start];\n+            ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Applied patch from Tomasz Skutnik which allows a Random object to be passed\nin. This means that method calls to RandomStringUtils can be predictable.\n\nSubmitted by:\tTomasz Skutnik \u003cTomasz.Skutnik@e-point.pl\u003e\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137238 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/2/2 上午11:46",
          "commitName": "d9bc18e804bf754b8cc11c4ce61a5dc1b9cda242",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2002/12/23 上午8:32",
          "commitNameOld": "8e3f80d77e1601a875446fa8ca01d5c10cb30170",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 41.13,
          "commitsBetweenForRepo": 28,
          "commitsBetweenForFile": 1,
          "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (random.nextInt(gap) + start);\n        } else {\n            ch \u003d set[random.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
          "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
          "functionStartLine": 250,
          "functionName": "random",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n",
          "diff": "@@ -1,26 +1,26 @@\n-public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {\n     if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n         end \u003d (int) \u0027z\u0027;\n         start \u003d (int) \u0027 \u0027;\n         if (!letters \u0026\u0026 !numbers) {\n             start \u003d 0;\n             end \u003d Integer.MAX_VALUE;\n         }\n     }\n     StringBuffer buffer \u003d new StringBuffer();\n     int gap \u003d end - start;\n     while (count-- !\u003d 0) {\n         char ch;\n         if (set \u003d\u003d null) {\n-            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n+            ch \u003d (char) (random.nextInt(gap) + start);\n         } else {\n-            ch \u003d set[RANDOM.nextInt(gap) + start];\n+            ch \u003d set[random.nextInt(gap) + start];\n         }\n         if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n             buffer.append(ch);\n         } else {\n             count++;\n         }\n     }\n     return buffer.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eCreates a random string based on a variety of options.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n",
            "newValue": "\u003cp\u003eCreates a random string based on a variety of options, using\nsupplied source of randomness.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n\u003cp\u003eAs a source of randomness is used supplied {@link Random}\ninstance. This makes method behave predictively, and allows\nusage of \u003ccode\u003eRandomStringUtils\u003c/code\u003e in situations that need\nrepetitive behaviour.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@param random source of randomness.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n"
          }
        }
      ]
    },
    "7477a1e08fae75215763db8a837b8ca2a2bc9e6b": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc formatting patch, by Fredrik Westermarck\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137133 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002/11/16 下午6:41",
      "commitName": "7477a1e08fae75215763db8a837b8ca2a2bc9e6b",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2002/9/28 下午6:34",
      "commitNameOld": "031ff96cd3a9e319689e7df5a0b6272c16202256",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 49.0,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n        } else {\n            ch \u003d set[RANDOM.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 218,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eCreates a random string based on a variety of options.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Creates a random string based on a variety of options.\nIf start and end are both 0, start and end are set to \u0027 \u0027 and \u0027z\u0027, the ASCII\nprintable characters, will be used, unless letters and numbers are both \nfalse, in which case, start and end are set to 0 and Integer.MAX_VALUE.\n\u003cp\u003e\nIf set is not null, characters between start and end are chosen.\n\u003cp\u003e\n\n@param count int length of random string to create\n@param start int position in set of chars to start at\n@param end int position in set of chars to end before\n@param letters boolean only allow letters?\n@param numbers boolean only allow numbers?\n@param set char[] set of chars to choose randoms from.\n       If null, then it will use the set of all chars.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not (end - start) + 1 \ncharacters in the set array.\n",
        "newValue": "\u003cp\u003eCreates a random string based on a variety of options.\u003c/p\u003e\n\n\u003cp\u003eIf start and end are both \u003ccode\u003e0\u003c/code\u003e, start and end are set\nto \u003ccode\u003e\u0027 \u0027\u003c/code\u003e and \u003ccode\u003e\u0027z\u0027\u003c/code\u003e, the ASCII printable\ncharacters, will be used, unless letters and numbers are both\n\u003ccode\u003efalse\u003c/code\u003e, in which case, start and end are set to\n\u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eInteger.MAX_VALUE\u003c/code\u003e.\n\n\u003cp\u003eIf set is not \u003ccode\u003enull\u003c/code\u003e, characters between start and\nend are chosen.\u003c/p\u003e\n\n@param count length of random string to create\n@param start position in set of chars to start at\n@param end position in set of chars to end before\n@param letters only allow letters?\n@param numbers only allow numbers?\n@param set set of chars to choose randoms from. If \u003ccode\u003enull\u003c/code\u003e,\n then it will use the set of all chars.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not\n \u003ccode\u003e(end - start) + 1\u003c/code\u003e characters in the set array.\n"
      }
    },
    "031ff96cd3a9e319689e7df5a0b6272c16202256": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc fixes and enhancements from Steve Downey\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002/9/28 下午6:34",
      "commitName": "031ff96cd3a9e319689e7df5a0b6272c16202256",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2002/9/19 上午3:53",
      "commitNameOld": "06ad5b4b6befe82913463dc62cbf85e207e3c428",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 9.61,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n        } else {\n            ch \u003d set[RANDOM.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 199,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "Creates a random string based on a variety of options.\nIf start and end are both 0, start and end are set to \u0027 \u0027 and \u0027z\u0027, the ASCII\nprintable characters, will be used, unless letters and numbers are both \nfalse, in which case, start and end are set to 0 and Integer.MAX_VALUE.\n\u003cp\u003e\nIf set is not null, characters between start and end are chosen.\n\u003cp\u003e\n\n@param count int length of random string to create\n@param start int position in set of chars to start at\n@param end int position in set of chars to end before\n@param letters boolean only allow letters?\n@param numbers boolean only allow numbers?\n@param set char[] set of chars to choose randoms from.\n       If null, then it will use the set of all chars.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not (end - start) + 1 \ncharacters in the set array.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Creates a random string based on a variety of options.\n\n@param count int length of random string to create\n@param start int position in set of chars to start at\n@param end int position in set of chars to end before\n@param letters boolean only allow letters?\n@param numbers boolean only allow numbers?\n@param set char[] set of chars to choose randoms from.\n       If null, then it will use the set of all chars.\n@return the random string\n",
        "newValue": "Creates a random string based on a variety of options.\nIf start and end are both 0, start and end are set to \u0027 \u0027 and \u0027z\u0027, the ASCII\nprintable characters, will be used, unless letters and numbers are both \nfalse, in which case, start and end are set to 0 and Integer.MAX_VALUE.\n\u003cp\u003e\nIf set is not null, characters between start and end are chosen.\n\u003cp\u003e\n\n@param count int length of random string to create\n@param start int position in set of chars to start at\n@param end int position in set of chars to end before\n@param letters boolean only allow letters?\n@param numbers boolean only allow numbers?\n@param set char[] set of chars to choose randoms from.\n       If null, then it will use the set of all chars.\n@return the random string\n@throws ArrayIndexOutOfBoundsException if there are not (end - start) + 1 \ncharacters in the set array.\n"
      }
    },
    "6627f7ad8fb08d6c23b83d6c9f0a6830e9e7085a": {
      "type": "Yintroduced",
      "commitMessage": "Initial copy from jakarta-commons-sandbox\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@136932 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002/7/19 上午11:35",
      "commitName": "6627f7ad8fb08d6c23b83d6c9f0a6830e9e7085a",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,26 @@\n+public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n+    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n+        end \u003d (int) \u0027z\u0027;\n+        start \u003d (int) \u0027 \u0027;\n+        if (!letters \u0026\u0026 !numbers) {\n+            start \u003d 0;\n+            end \u003d Integer.MAX_VALUE;\n+        }\n+    }\n+    StringBuffer buffer \u003d new StringBuffer();\n+    int gap \u003d end - start;\n+    while (count-- !\u003d 0) {\n+        char ch;\n+        if (set \u003d\u003d null) {\n+            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n+        } else {\n+            ch \u003d set[RANDOM.nextInt(gap) + start];\n+        }\n+        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n+            buffer.append(ch);\n+        } else {\n+            count++;\n+        }\n+    }\n+    return buffer.toString();\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n    if ((start \u003d\u003d 0) \u0026\u0026 (end \u003d\u003d 0)) {\n        end \u003d (int) \u0027z\u0027;\n        start \u003d (int) \u0027 \u0027;\n        if (!letters \u0026\u0026 !numbers) {\n            start \u003d 0;\n            end \u003d Integer.MAX_VALUE;\n        }\n    }\n    StringBuffer buffer \u003d new StringBuffer();\n    int gap \u003d end - start;\n    while (count-- !\u003d 0) {\n        char ch;\n        if (set \u003d\u003d null) {\n            ch \u003d (char) (RANDOM.nextInt(gap) + start);\n        } else {\n            ch \u003d set[RANDOM.nextInt(gap) + start];\n        }\n        if ((letters \u0026\u0026 numbers \u0026\u0026 Character.isLetterOrDigit(ch)) || (letters \u0026\u0026 Character.isLetter(ch)) || (numbers \u0026\u0026 Character.isDigit(ch)) || (!letters \u0026\u0026 !numbers)) {\n            buffer.append(ch);\n        } else {\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "path": "src/java/org/apache/commons/lang/RandomStringUtils.java",
      "functionStartLine": 194,
      "functionName": "random",
      "functionAnnotation": "",
      "functionDoc": "Creates a random string based on a variety of options.\n\n@param count int length of random string to create\n@param start int position in set of chars to start at\n@param end int position in set of chars to end before\n@param letters boolean only allow letters?\n@param numbers boolean only allow numbers?\n@param set char[] set of chars to choose randoms from.\n       If null, then it will use the set of all chars.\n@return the random string\n"
    }
  }
}