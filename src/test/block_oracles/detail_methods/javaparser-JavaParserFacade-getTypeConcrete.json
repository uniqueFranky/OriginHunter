{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "JavaParserFacade.java",
  "functionName": "getTypeConcrete",
  "functionId": "getTypeConcrete___node-Node__solveLambdas-boolean",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
  "functionAnnotation": "",
  "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n",
  "functionStartLine": 465,
  "functionEndLine": 468,
  "numCommitsSeen": 205,
  "timeTaken": 1978,
  "changeHistory": [
    "b54617e765d73b3ce0d187cf12ad8da382bce439",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
    "90c22f84a61e12130a8750d235acf7ed06305796",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "a1c7c58143a592965f8378767adc69709e4c0043",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
    "e0d63587820f7e8900af0c9060a2f149cc643c6c",
    "e174058b92c209ba1d818e53db34993236592db7",
    "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
    "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00",
    "631896a1d2f34eed89c41cc717f463ebbd69e401",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1",
    "697432aaf0e6a42825e52f956bd51f0486b411d2",
    "7c43ba3c700d72a0d613bce3659af6d74bc87434",
    "15ac26bcc19e8bed431a35edd3e3c176d7d56355",
    "1e7780e554428a10c73de88ca64e5933b2291593",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "6624f3653734698f477561c8407357e2395d411c",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e",
    "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
    "0d14741fef3a17451db153cfe379e398da4b4b79",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
    "03e407957d600a18ef0a4a83224c17d155ef8645",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "70f3e66c944670a818922f101162226ef604b263",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "acf74024c2d341bf4009af7173c9b1b972f19c32",
    "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
    "2c6d213f0359d5b52a9d570323aa10505415f6ac",
    "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
    "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74",
    "cb7655f9661f11dab8ec9e2533722d649a16e715",
    "31433fc385c0fea7ead68e4c853807752e061565",
    "a541f77a5a66a911e347d294aa76d8703e72e7db",
    "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "ead147279ca0b84d2f479a714943b20cd689e7c7",
    "a6849db3884e47909d2d97fcac0b057ab13d544b",
    "94446666d149c898131d04e7fd567777258e4e1e",
    "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
    "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
    "f20bec1be7e976300ef4857e347bc735ded0f305",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
    "fb388c36c0045c50744cf215521e5c280036aa70",
    "c04083d20425a664115db6b0df3ca9632e66ecca",
    "0e81f51c40996b42cb262dc2397126cee8f60965",
    "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
    "d0348de241a6cf6be9c51500870ee1fb26172101",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
    "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
    "d6edae7874d2e78cbd401619ad53a9f9e2288597",
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
    "31b108cbfd418f43e7b568374af2e635a580e171",
    "bac18a129c45335e69d811b3872fcb938e1f0ff8",
    "46aefdd68f2f2597a19b72da36681123cb3090e6",
    "6c297529e31036058837adbaa57cee652d4cc918",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3",
    "feab46de5d87b02bf38b29962613676adf14f78a",
    "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba",
    "09ceccd596e6aeebb5eca309093ef32216291f1e",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
    "22bf613d486d43114d1547e5bc623535aa2aca2a",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
    "80f951258992f75441239c79e0f31eda7d47e107",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
    "630eb94d43670f2080c7273584d49c0b0d4162f1",
    "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3",
    "3def8748ada27ac91166941a892adfd83ca3db2a",
    "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149"
  ],
  "changeHistoryShort": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": "Ydocchange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": "Yreturntypechange",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": "Ybodychange",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": "Ybodychange",
    "90c22f84a61e12130a8750d235acf7ed06305796": "Ybodychange",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": "Ybodychange",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ybodychange",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "a1c7c58143a592965f8378767adc69709e4c0043": "Ybodychange",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": "Ybodychange",
    "e0d63587820f7e8900af0c9060a2f149cc643c6c": "Ybodychange",
    "e174058b92c209ba1d818e53db34993236592db7": "Ybodychange",
    "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552": "Ybodychange",
    "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00": "Ybodychange",
    "631896a1d2f34eed89c41cc717f463ebbd69e401": "Ybodychange",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": "Ybodychange",
    "697432aaf0e6a42825e52f956bd51f0486b411d2": "Ybodychange",
    "7c43ba3c700d72a0d613bce3659af6d74bc87434": "Ybodychange",
    "15ac26bcc19e8bed431a35edd3e3c176d7d56355": "Ybodychange",
    "1e7780e554428a10c73de88ca64e5933b2291593": "Ydocchange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Ymultichange(Yfilerename,Ybodychange)",
    "6624f3653734698f477561c8407357e2395d411c": "Ybodychange",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": "Ybodychange",
    "9dc06a758c00cc235372dbc225a7e20c1f5269d3": "Ybodychange",
    "0d14741fef3a17451db153cfe379e398da4b4b79": "Ybodychange",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": "Ybodychange",
    "03e407957d600a18ef0a4a83224c17d155ef8645": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "70f3e66c944670a818922f101162226ef604b263": "Ymultichange(Ybodychange,Ydocchange)",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yreturntypechange,Ybodychange)",
    "acf74024c2d341bf4009af7173c9b1b972f19c32": "Ybodychange",
    "7317fe7d60ad0af88e9ee692e95dd5dde832863e": "Ybodychange",
    "2c6d213f0359d5b52a9d570323aa10505415f6ac": "Ybodychange",
    "68b3e019e1216a941ff5d8dcf63aefc9b35a3787": "Ybodychange",
    "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74": "Ybodychange",
    "cb7655f9661f11dab8ec9e2533722d649a16e715": "Ybodychange",
    "31433fc385c0fea7ead68e4c853807752e061565": "Ybodychange",
    "a541f77a5a66a911e347d294aa76d8703e72e7db": "Ybodychange",
    "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "ead147279ca0b84d2f479a714943b20cd689e7c7": "Ybodychange",
    "a6849db3884e47909d2d97fcac0b057ab13d544b": "Ybodychange",
    "94446666d149c898131d04e7fd567777258e4e1e": "Ybodychange",
    "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97": "Ybodychange",
    "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e": "Ybodychange",
    "f20bec1be7e976300ef4857e347bc735ded0f305": "Ybodychange",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": "Ybodychange",
    "fb388c36c0045c50744cf215521e5c280036aa70": "Yfilerename",
    "c04083d20425a664115db6b0df3ca9632e66ecca": "Ybodychange",
    "0e81f51c40996b42cb262dc2397126cee8f60965": "Ybodychange",
    "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c": "Ybodychange",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": "Ybodychange",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": "Ybodychange",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": "Ybodychange",
    "d0348de241a6cf6be9c51500870ee1fb26172101": "Ybodychange",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": "Ybodychange",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": "Ybodychange",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": "Ybodychange",
    "00f005b38e8b83eb1d60db9070c6e9e3beffe403": "Ybodychange",
    "d6edae7874d2e78cbd401619ad53a9f9e2288597": "Ybodychange",
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451": "Ybodychange",
    "31b108cbfd418f43e7b568374af2e635a580e171": "Ybodychange",
    "bac18a129c45335e69d811b3872fcb938e1f0ff8": "Ybodychange",
    "46aefdd68f2f2597a19b72da36681123cb3090e6": "Ybodychange",
    "6c297529e31036058837adbaa57cee652d4cc918": "Ybodychange",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": "Ybodychange",
    "feab46de5d87b02bf38b29962613676adf14f78a": "Ybodychange",
    "54b73148ab5bfb5e3c2f1c2aa463265d033ac926": "Ybodychange",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": "Ybodychange",
    "09ceccd596e6aeebb5eca309093ef32216291f1e": "Ybodychange",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": "Ybodychange",
    "22bf613d486d43114d1547e5bc623535aa2aca2a": "Ybodychange",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ymultichange(Yrename,Ymodifierchange)",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": "Ybodychange",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": "Ymultichange(Yparameterchange,Ybodychange)",
    "80f951258992f75441239c79e0f31eda7d47e107": "Ybodychange",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": "Ybodychange",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": "Ybodychange",
    "630eb94d43670f2080c7273584d49c0b0d4162f1": "Ybodychange",
    "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3": "Ybodychange",
    "3def8748ada27ac91166941a892adfd83ca3db2a": "Ybodychange",
    "381c389ea62cf20d6109dac96bb5f8202ccc0b34": "Ybodychange",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": {
      "type": "Ydocchange",
      "commitMessage": "Cleaning up JSS code\n",
      "commitDate": "2018/2/4 上午2:46",
      "commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018/1/10 下午8:52",
      "commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 24.25,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    return node.accept(typeExtractor, solveLambdas);\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 375,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
        "newValue": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n"
      }
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018/1/10 下午8:52",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/1/10 下午4:01",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    return node.accept(typeExtractor, solveLambdas);\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 391,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": {
      "type": "Yreturntypechange",
      "commitMessage": "issue1154: correct most compilation errors in the jp model\n",
      "commitDate": "2017/9/29 下午2:30",
      "commitName": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/9/29 上午4:36",
      "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    return node.accept(typeExtractor, solveLambdas);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 388,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,5 +1,5 @@\n-private Type getTypeConcrete(Node node, boolean solveLambdas) {\n+private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     return node.accept(typeExtractor, solveLambdas);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "Type",
        "newValue": "ResolvedType"
      }
    },
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": {
      "type": "Ybodychange",
      "commitMessage": "Refactored out huge method from facade to visitor\n",
      "commitDate": "2017/2/14 上午7:49",
      "commitName": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/2/2 上午8:04",
      "commitNameOld": "a12a91a78591323403230d5654879a44ab4afb20",
      "commitAuthorOld": "Brandon Fergerson",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    return node.accept(typeExtractor, solveLambdas);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 357,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,277 +1,5 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n-    if (node instanceof NameExpr) {\n-        NameExpr nameExpr \u003d (NameExpr) node;\n-        logger.finest(\"getType on name expr \" + node);\n-        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n-        if (!value.isPresent()) {\n-            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n-        } else {\n-            return value.get().getType();\n-        }\n-    } else if (node instanceof MethodCallExpr) {\n-        logger.finest(\"getType on method call \" + node);\n-        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n-        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n-        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n-        return ref.returnType();\n-    } else if (node instanceof LambdaExpr) {\n-        if (getParentNode(node) instanceof MethodCallExpr) {\n-            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n-            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n-            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n-            if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n-            }\n-            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n-            if (solveLambdas) {\n-                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                if (callExpr.getScope().isPresent()) {\n-                    Expression scope \u003d callExpr.getScope().get();\n-                    boolean staticCall \u003d false;\n-                    if (scope instanceof NameExpr) {\n-                        NameExpr nameExpr \u003d (NameExpr) scope;\n-                        try {\n-                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n-                            staticCall \u003d true;\n-                        } catch (Exception e) {\n-                        }\n-                    }\n-                    if (!staticCall) {\n-                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(scope);\n-                        if (scopeType.isReferenceType()) {\n-                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n-                        }\n-                    }\n-                }\n-                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n-                result \u003d solveGenericTypes(result, ctx, typeSolver);\n-                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n-                if (functionalMethod.isPresent()) {\n-                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n-                    inferenceContext.addPair(result, functionalInterfaceType);\n-                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                        Type actualType \u003d getType(expressionStmt.getExpression());\n-                        Type formalType \u003d functionalMethod.get().returnType();\n-                        inferenceContext.addPair(formalType, actualType);\n-                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n-                    } else {\n-                        throw new UnsupportedOperationException();\n-                    }\n-                }\n-                return result;\n-            } else {\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-            }\n-        } else {\n-            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-        }\n-    } else if (node instanceof MethodReferenceExpr) {\n-        if (getParentNode(node) instanceof MethodCallExpr) {\n-            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n-            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n-            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n-            if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n-            }\n-            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n-            if (solveLambdas) {\n-                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n-                result \u003d solveGenericTypes(result, ctx, typeSolver);\n-                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n-                if (functionalMethod.isPresent()) {\n-                    if (node instanceof MethodReferenceExpr) {\n-                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n-                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n-                        Type formalType \u003d functionalMethod.get().returnType();\n-                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                        inferenceContext.addPair(formalType, actualType);\n-                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n-                    } else {\n-                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            Type actualType \u003d getType(expressionStmt.getExpression());\n-                            Type formalType \u003d functionalMethod.get().returnType();\n-                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                            inferenceContext.addPair(formalType, actualType);\n-                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n-                        } else {\n-                            throw new UnsupportedOperationException();\n-                        }\n-                    }\n-                }\n-                return result;\n-            } else {\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-            }\n-        } else {\n-            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n-        }\n-    } else if (node instanceof VariableDeclarator) {\n-        if (getParentNode(node) instanceof FieldDeclaration) {\n-            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n-        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n-            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n-        } else {\n-            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n-        }\n-    } else if (node instanceof Parameter) {\n-        Parameter parameter \u003d (Parameter) node;\n-        if (parameter.getType() instanceof UnknownType) {\n-            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n-        }\n-        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n-    } else if (node instanceof FieldAccessExpr) {\n-        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n-        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n-            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n-            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n-            if (typeAccessedStatically.isSolved()) {\n-                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n-            }\n-        } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n-            SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n-            if (sr.isSolved()) {\n-                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n-            }\n-        }\n-        Optional\u003cValue\u003e value \u003d null;\n-        try {\n-            value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n-        } catch (UnsolvedSymbolException use) {\n-            if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n-                throw use;\n-            }\n-            SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n-            if (sref.isSolved()) {\n-                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n-            }\n-        }\n-        if (value !\u003d null \u0026\u0026 value.isPresent()) {\n-            return value.get().getType();\n-        } else {\n-            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n-        }\n-    } else if (node instanceof ObjectCreationExpr) {\n-        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-        return type;\n-    } else if (node instanceof NullLiteralExpr) {\n-        return NullType.INSTANCE;\n-    } else if (node instanceof BooleanLiteralExpr) {\n-        return PrimitiveType.BOOLEAN;\n-    } else if (node instanceof IntegerLiteralExpr) {\n-        return PrimitiveType.INT;\n-    } else if (node instanceof LongLiteralExpr) {\n-        return PrimitiveType.LONG;\n-    } else if (node instanceof CharLiteralExpr) {\n-        return PrimitiveType.CHAR;\n-    } else if (node instanceof DoubleLiteralExpr) {\n-        if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n-            return PrimitiveType.FLOAT;\n-        }\n-        return PrimitiveType.DOUBLE;\n-    } else if (node instanceof StringLiteralExpr) {\n-        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n-    } else if (node instanceof UnaryExpr) {\n-        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n-        switch(unaryExpr.getOperator()) {\n-            case MINUS:\n-            case PLUS:\n-                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n-            case LOGICAL_COMPLEMENT:\n-                return PrimitiveType.BOOLEAN;\n-            case POSTFIX_DECREMENT:\n-            case PREFIX_DECREMENT:\n-            case POSTFIX_INCREMENT:\n-            case PREFIX_INCREMENT:\n-                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n-            default:\n-                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n-        }\n-    } else if (node instanceof BinaryExpr) {\n-        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n-        switch(binaryExpr.getOperator()) {\n-            case PLUS:\n-            case MINUS:\n-            case DIVIDE:\n-            case MULTIPLY:\n-                return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n-            case LESS_EQUALS:\n-            case LESS:\n-            case GREATER:\n-            case GREATER_EQUALS:\n-            case EQUALS:\n-            case NOT_EQUALS:\n-            case OR:\n-            case AND:\n-                return PrimitiveType.BOOLEAN;\n-            case BINARY_AND:\n-            case BINARY_OR:\n-            case SIGNED_RIGHT_SHIFT:\n-            case UNSIGNED_RIGHT_SHIFT:\n-            case LEFT_SHIFT:\n-            case REMAINDER:\n-            case XOR:\n-                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n-            default:\n-                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n-        }\n-    } else if (node instanceof VariableDeclarationExpr) {\n-        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-        if (expr.getVariables().size() !\u003d 1) {\n-            throw new UnsupportedOperationException();\n-        }\n-        return convertToUsageVariableType(expr.getVariables().get(0));\n-    } else if (node instanceof InstanceOfExpr) {\n-        return PrimitiveType.BOOLEAN;\n-    } else if (node instanceof EnclosedExpr) {\n-        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n-    } else if (node instanceof CastExpr) {\n-        CastExpr enclosedExpr \u003d (CastExpr) node;\n-        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-    } else if (node instanceof AssignExpr) {\n-        AssignExpr assignExpr \u003d (AssignExpr) node;\n-        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n-    } else if (node instanceof ThisExpr) {\n-        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n-    } else if (node instanceof ConditionalExpr) {\n-        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n-        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n-    } else if (node instanceof ArrayCreationExpr) {\n-        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-        Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n-        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n-            res \u003d new ArrayType(res);\n-        }\n-        return res;\n-    } else if (node instanceof ArrayAccessExpr) {\n-        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n-        Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n-        if (arrayUsageType.isArray()) {\n-            return ((ArrayType) arrayUsageType).getComponentType();\n-        }\n-        return arrayUsageType;\n-    } else if (node instanceof SuperExpr) {\n-        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n-        if (typeOfNode instanceof ClassDeclaration) {\n-            return ((ClassDeclaration) typeOfNode).getSuperClass();\n-        } else {\n-            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-        }\n-    } else if (node instanceof ClassExpr) {\n-        ClassExpr classExpr \u003d (ClassExpr) node;\n-        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n-        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n-        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n-    } else {\n-        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-    }\n+    return node.accept(typeExtractor, solveLambdas);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
      "type": "Ybodychange",
      "commitMessage": "Update for JavaParser 3.0.0\n",
      "commitDate": "2017/1/12 上午8:45",
      "commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/1/11 上午6:19",
      "commitNameOld": "dd73ec538fbacfc1a05acb6d0ac35da3b4e87bc3",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    Expression scope \u003d callExpr.getScope().get();\n                    boolean staticCall \u003d false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) scope;\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n            if (sr.isSolved()) {\n                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d null;\n        try {\n            value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n        } catch (UnsolvedSymbolException use) {\n            if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                throw use;\n            }\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value !\u003d null \u0026\u0026 value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n            return PrimitiveType.FLOAT;\n        }\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return PrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n                return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return PrimitiveType.BOOLEAN;\n            case BINARY_AND:\n            case BINARY_OR:\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n            case REMAINDER:\n            case XOR:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 356,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,276 +1,277 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                if (callExpr.getScope() !\u003d null) {\n+                if (callExpr.getScope().isPresent()) {\n+                    Expression scope \u003d callExpr.getScope().get();\n                     boolean staticCall \u003d false;\n-                    if (callExpr.getScope() instanceof NameExpr) {\n-                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n+                    if (scope instanceof NameExpr) {\n+                        NameExpr nameExpr \u003d (NameExpr) scope;\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n-                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n+                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(scope);\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n             SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n             if (sr.isSolved()) {\n                 return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d null;\n         try {\n             value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n         } catch (UnsolvedSymbolException use) {\n             if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                 throw use;\n             }\n             SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n             if (sref.isSolved()) {\n                 return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n             }\n         }\n         if (value !\u003d null \u0026\u0026 value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n             return PrimitiveType.FLOAT;\n         }\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case MINUS:\n             case PLUS:\n                 return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n             case LOGICAL_COMPLEMENT:\n                 return PrimitiveType.BOOLEAN;\n             case POSTFIX_DECREMENT:\n             case PREFIX_DECREMENT:\n             case POSTFIX_INCREMENT:\n             case PREFIX_INCREMENT:\n                 return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case PLUS:\n             case MINUS:\n             case DIVIDE:\n             case MULTIPLY:\n                 return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n             case LESS_EQUALS:\n             case LESS:\n             case GREATER:\n             case GREATER_EQUALS:\n             case EQUALS:\n             case NOT_EQUALS:\n             case OR:\n             case AND:\n                 return PrimitiveType.BOOLEAN;\n             case BINARY_AND:\n             case BINARY_OR:\n             case SIGNED_RIGHT_SHIFT:\n             case UNSIGNED_RIGHT_SHIFT:\n             case LEFT_SHIFT:\n             case REMAINDER:\n             case XOR:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         if (arrayUsageType.isArray()) {\n             return ((ArrayType) arrayUsageType).getComponentType();\n         }\n         return arrayUsageType;\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90c22f84a61e12130a8750d235acf7ed06305796": {
      "type": "Ybodychange",
      "commitMessage": "migration to JavaParser 3.0.0-RC.3\n",
      "commitDate": "2016/12/20 上午12:01",
      "commitName": "90c22f84a61e12130a8750d235acf7ed06305796",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/12/14 上午3:42",
      "commitNameOld": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope() !\u003d null) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n            if (sr.isSolved()) {\n                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d null;\n        try {\n            value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n        } catch (UnsolvedSymbolException use) {\n            if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                throw use;\n            }\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value !\u003d null \u0026\u0026 value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n            return PrimitiveType.FLOAT;\n        }\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return PrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n                return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return PrimitiveType.BOOLEAN;\n            case BINARY_AND:\n            case BINARY_OR:\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n            case REMAINDER:\n            case XOR:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 355,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,276 +1,276 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope() !\u003d null) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n             SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n             if (sr.isSolved()) {\n                 return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d null;\n         try {\n             value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n         } catch (UnsolvedSymbolException use) {\n             if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                 throw use;\n             }\n             SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n             if (sref.isSolved()) {\n                 return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n             }\n         }\n         if (value !\u003d null \u0026\u0026 value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n             return PrimitiveType.FLOAT;\n         }\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case MINUS:\n             case PLUS:\n                 return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n             case LOGICAL_COMPLEMENT:\n                 return PrimitiveType.BOOLEAN;\n             case POSTFIX_DECREMENT:\n             case PREFIX_DECREMENT:\n             case POSTFIX_INCREMENT:\n             case PREFIX_INCREMENT:\n                 return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case PLUS:\n             case MINUS:\n             case DIVIDE:\n             case MULTIPLY:\n                 return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n             case LESS_EQUALS:\n             case LESS:\n             case GREATER:\n             case GREATER_EQUALS:\n             case EQUALS:\n             case NOT_EQUALS:\n             case OR:\n             case AND:\n                 return PrimitiveType.BOOLEAN;\n             case BINARY_AND:\n             case BINARY_OR:\n             case SIGNED_RIGHT_SHIFT:\n             case UNSIGNED_RIGHT_SHIFT:\n             case LEFT_SHIFT:\n             case REMAINDER:\n             case XOR:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         if (arrayUsageType.isArray()) {\n             return ((ArrayType) arrayUsageType).getComponentType();\n         }\n         return arrayUsageType;\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n-        com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n+        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
      "type": "Ybodychange",
      "commitMessage": "porting to JavaParser 3.0.0 RC2\n",
      "commitDate": "2016/12/14 上午3:42",
      "commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/12/14 上午12:45",
      "commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope() !\u003d null) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n            if (sr.isSolved()) {\n                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d null;\n        try {\n            value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n        } catch (UnsolvedSymbolException use) {\n            if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                throw use;\n            }\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value !\u003d null \u0026\u0026 value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n            return PrimitiveType.FLOAT;\n        }\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return PrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n                return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return PrimitiveType.BOOLEAN;\n            case BINARY_AND:\n            case BINARY_OR:\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n            case REMAINDER:\n            case XOR:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 355,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,273 +1,276 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope() !\u003d null) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n             SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n             if (sr.isSolved()) {\n                 return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d null;\n         try {\n             value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n         } catch (UnsolvedSymbolException use) {\n             if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                 throw use;\n             }\n             SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n             if (sref.isSolved()) {\n                 return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n             }\n         }\n         if (value !\u003d null \u0026\u0026 value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n             return PrimitiveType.FLOAT;\n         }\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n-            case negative:\n-            case positive:\n-                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n-            case not:\n+            case MINUS:\n+            case PLUS:\n+                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n+            case LOGICAL_COMPLEMENT:\n                 return PrimitiveType.BOOLEAN;\n-            case postIncrement:\n-            case preIncrement:\n-            case preDecrement:\n-            case postDecrement:\n-                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n+            case POSTFIX_DECREMENT:\n+            case PREFIX_DECREMENT:\n+            case POSTFIX_INCREMENT:\n+            case PREFIX_INCREMENT:\n+                return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n-            case plus:\n-            case minus:\n-            case divide:\n-            case times:\n+            case PLUS:\n+            case MINUS:\n+            case DIVIDE:\n+            case MULTIPLY:\n                 return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n-            case lessEquals:\n-            case less:\n-            case greater:\n-            case greaterEquals:\n-            case equals:\n-            case notEquals:\n-            case or:\n-            case and:\n+            case LESS_EQUALS:\n+            case LESS:\n+            case GREATER:\n+            case GREATER_EQUALS:\n+            case EQUALS:\n+            case NOT_EQUALS:\n+            case OR:\n+            case AND:\n                 return PrimitiveType.BOOLEAN;\n-            case binAnd:\n-            case binOr:\n-            case rSignedShift:\n-            case rUnsignedShift:\n-            case lShift:\n-            case remainder:\n-            case xor:\n+            case BINARY_AND:\n+            case BINARY_OR:\n+            case SIGNED_RIGHT_SHIFT:\n+            case UNSIGNED_RIGHT_SHIFT:\n+            case LEFT_SHIFT:\n+            case REMAINDER:\n+            case XOR:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+        Type res \u003d convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n+        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n+            res \u003d new ArrayType(res);\n+        }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         if (arrayUsageType.isArray()) {\n             return ((ArrayType) arrayUsageType).getComponentType();\n         }\n         return arrayUsageType;\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ybodychange",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016/12/13 下午9:10",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefévère-Laoide",
      "commitDateOld": "2016/11/22 上午4:52",
      "commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 21.68,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope() !\u003d null) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n            if (sr.isSolved()) {\n                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d null;\n        try {\n            value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n        } catch (UnsolvedSymbolException use) {\n            if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                throw use;\n            }\n            SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value !\u003d null \u0026\u0026 value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n            return PrimitiveType.FLOAT;\n        }\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n            case divide:\n            case times:\n                return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n            case rSignedShift:\n            case rUnsignedShift:\n            case lShift:\n            case remainder:\n            case xor:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 407,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,245 +1,273 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope() !\u003d null) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n-            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n-            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n             }\n+        } else if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get().toString().indexOf(\u0027.\u0027) \u003e 0) {\n+            SymbolReference\u003cReferenceTypeDeclaration\u003e sr \u003d typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n+            if (sr.isSolved()) {\n+                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n+            }\n         }\n-        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n-        if (value.isPresent()) {\n+        Optional\u003cValue\u003e value \u003d null;\n+        try {\n+            value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n+        } catch (UnsolvedSymbolException use) {\n+            if (fieldAccessExpr.getParentNode().isPresent() \u0026\u0026 fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n+                throw use;\n+            }\n+            SymbolReference\u003cReferenceTypeDeclaration\u003e sref \u003d typeSolver.tryToSolveType(node.toString());\n+            if (sref.isSolved()) {\n+                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n+            }\n+        }\n+        if (value !\u003d null \u0026\u0026 value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n+        if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n+            return PrimitiveType.FLOAT;\n+        }\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n-                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+            case divide:\n+            case times:\n+                return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n+            case rSignedShift:\n+            case rUnsignedShift:\n+            case lShift:\n+            case remainder:\n+            case xor:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n-        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+        Type arrayUsageType \u003d getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+        if (arrayUsageType.isArray()) {\n+            return ((ArrayType) arrayUsageType).getComponentType();\n+        }\n+        return arrayUsageType;\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n-        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n+        com.github.javaparser.ast.type.Type\u003c?\u003e astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016/11/22 上午2:58",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/10 上午1:15",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope() !\u003d null) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,245 +1,245 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n         if (!value.isPresent()) {\n-            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n+            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n+                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope() !\u003d null) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                         try {\n-                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n+                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n+                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n-        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n-            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n+        if (fieldAccessExpr.getScope().isPresent() \u0026\u0026 fieldAccessExpr.getScope().get() instanceof NameExpr) {\n+            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope().get();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n-                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n+                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n             }\n         }\n-        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n-            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+            throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016/11/10 上午1:15",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/6 下午4:40",
      "commitNameOld": "c746c4ef7711a05c27827ab749d96155046a4f91",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.36,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope() !\u003d null) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,245 +1,245 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                if (callExpr.getScope().isPresent()) {\n+                if (callExpr.getScope() !\u003d null) {\n                     boolean staticCall \u003d false;\n-                    if (callExpr.getScope().get() instanceof NameExpr) {\n-                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n+                    if (callExpr.getScope() instanceof NameExpr) {\n+                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n-                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n+        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1c7c58143a592965f8378767adc69709e4c0043": {
      "type": "Ybodychange",
      "commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
      "commitDate": "2016/11/5 下午11:22",
      "commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 下午11:08",
      "commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,245 +1,245 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-            SymbolReference\u003cReferenceTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n-                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n+                return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
      "type": "Ybodychange",
      "commitMessage": "creating ReferenceTypeDeclaration\n",
      "commitDate": "2016/11/5 下午11:08",
      "commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 下午3:58",
      "commitNameOld": "2fde8a6409906ab1e0b5e846f2e54b82da7878b7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cReferenceTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,245 +1,245 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+            SymbolReference\u003cReferenceTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e0d63587820f7e8900af0c9060a2f149cc643c6c": {
      "type": "Ybodychange",
      "commitMessage": "use InferenceContext in more cases\n",
      "commitDate": "2016/11/5 下午3:39",
      "commitName": "e0d63587820f7e8900af0c9060a2f149cc643c6c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 下午3:19",
      "commitNameOld": "e174058b92c209ba1d818e53db34993236592db7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                            inferenceContext.addPair(formalType, actualType);\n                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 272,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,251 +1,245 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n-                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n-                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                        }\n+                        InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                        inferenceContext.addPair(formalType, actualType);\n+                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n-                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                            }\n+                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                            inferenceContext.addPair(formalType, actualType);\n+                            result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         ClassExpr classExpr \u003d (ClassExpr) node;\n         com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n         Type jssType \u003d convertToUsage(astType, classExpr.getType());\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e174058b92c209ba1d818e53db34993236592db7": {
      "type": "Ybodychange",
      "commitMessage": "derive the type parameters in ClassExpr\n",
      "commitDate": "2016/11/5 下午3:19",
      "commitName": "e174058b92c209ba1d818e53db34993236592db7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 上午7:05",
      "commitNameOld": "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        ClassExpr classExpr \u003d (ClassExpr) node;\n        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 274,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,249 +1,251 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n-                    Type parameterType \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                     inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         inferenceContext.addPair(formalType, actualType);\n                         result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n-        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+        ClassExpr classExpr \u003d (ClassExpr) node;\n+        com.github.javaparser.ast.type.Type astType \u003d classExpr.getType();\n+        Type jssType \u003d convertToUsage(astType, classExpr.getType());\n+        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552": {
      "type": "Ybodychange",
      "commitMessage": "improving inference logic\n",
      "commitDate": "2016/11/5 上午7:05",
      "commitName": "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/3 上午4:08",
      "commitNameOld": "effd4c172ad6e4d60d68a749121a0960040edd63",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n                    Type parameterType \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                    inferenceContext.addPair(result, functionalInterfaceType);\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        inferenceContext.addPair(formalType, actualType);\n                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,249 +1,249 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                    InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+                    Type parameterType \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type functionalInterfaceType \u003d ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n+                    inferenceContext.addPair(result, functionalInterfaceType);\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n-                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                        }\n+                        inferenceContext.addPair(formalType, actualType);\n+                        result \u003d inferenceContext.resolve(inferenceContext.addSingle(result));\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00": {
      "type": "Ybodychange",
      "commitMessage": "rename JreTypeSolver to ReflectionTypeSolver\n",
      "commitDate": "2016/10/27 上午12:12",
      "commitName": "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/25 上午4:41",
      "commitNameOld": "08322b4714f672bed5ec424d3ace0a40da9ccd47",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.81,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,249 +1,249 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n-        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+        return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "631896a1d2f34eed89c41cc717f463ebbd69e401": {
      "type": "Ybodychange",
      "commitMessage": "commenting classes in model\n",
      "commitDate": "2016/10/23 下午5:26",
      "commitName": "631896a1d2f34eed89c41cc717f463ebbd69e401",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/23 下午4:58",
      "commitNameOld": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,249 +1,249 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n                     boolean staticCall \u003d false;\n                     if (callExpr.getScope().get() instanceof NameExpr) {\n                         NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                         try {\n                             JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                             staticCall \u003d true;\n                         } catch (Exception e) {\n                         }\n                     }\n                     if (!staticCall) {\n                         Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                         if (scopeType.isReferenceType()) {\n                             result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                         }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                result \u003d result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         if (fieldAccessExpr.getScope() instanceof NameExpr) {\n             NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n             SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n             if (typeAccessedStatically.isSolved()) {\n                 return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getType();\n         } else {\n             throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": {
      "type": "Ybodychange",
      "commitMessage": "handling static calls\n",
      "commitDate": "2016/10/23 下午4:58",
      "commitName": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/23 下午4:27",
      "commitNameOld": "697432aaf0e6a42825e52f956bd51f0486b411d2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    boolean staticCall \u003d false;\n                    if (callExpr.getScope().get() instanceof NameExpr) {\n                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n                        try {\n                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                            staticCall \u003d true;\n                        } catch (Exception e) {\n                        }\n                    }\n                    if (!staticCall) {\n                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                        if (scopeType.isReferenceType()) {\n                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n            if (typeAccessedStatically.isSolved()) {\n                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n            }\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getType();\n        } else {\n            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,245 +1,249 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 if (callExpr.getScope().isPresent()) {\n-                    Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n-                    if (scopeType.isReferenceType()) {\n-                        result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                    boolean staticCall \u003d false;\n+                    if (callExpr.getScope().get() instanceof NameExpr) {\n+                        NameExpr nameExpr \u003d (NameExpr) callExpr.getScope().get();\n+                        try {\n+                            JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n+                            staticCall \u003d true;\n+                        } catch (Exception e) {\n+                        }\n+                    }\n+                    if (!staticCall) {\n+                        Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                        if (scopeType.isReferenceType()) {\n+                            result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                        }\n                     }\n                 }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n-        try {\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-            if (value.isPresent()) {\n-                return value.get().getType();\n-            } else {\n-                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+        if (fieldAccessExpr.getScope() instanceof NameExpr) {\n+            NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n+            SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+            if (typeAccessedStatically.isSolved()) {\n+                return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n             }\n-        } catch (UnsolvedSymbolException e) {\n-            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n-                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n-                if (!typeAccessedStatically.isSolved()) {\n-                    throw e;\n-                } else {\n-                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n-                }\n-            } else {\n-                throw e;\n-            }\n+        }\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+        if (value.isPresent()) {\n+            return value.get().getType();\n+        } else {\n+            throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "697432aaf0e6a42825e52f956bd51f0486b411d2": {
      "type": "Ybodychange",
      "commitMessage": "working on resolving type parameters\n",
      "commitDate": "2016/10/23 下午4:27",
      "commitName": "697432aaf0e6a42825e52f956bd51f0486b411d2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/22 下午8:36",
      "commitNameOld": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                if (callExpr.getScope().isPresent()) {\n                    Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                    if (scopeType.isReferenceType()) {\n                        result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                    }\n                }\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,245 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                if (callExpr.getScope().isPresent()) {\n+                    Type scopeType \u003d JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                    if (scopeType.isReferenceType()) {\n+                        result \u003d scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                    }\n+                }\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c43ba3c700d72a0d613bce3659af6d74bc87434": {
      "type": "Ybodychange",
      "commitMessage": "using full TypeParameterDeclarations instead of names\n",
      "commitDate": "2016/10/22 下午8:36",
      "commitName": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/22 下午5:34",
      "commitNameOld": "a3b7fa9a03cb172d50bf54feddaf90300a6d8d07",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 269,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                        for (String typeName : inferredTypes.keySet()) {\n+                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                        for (String typeName : inferredTypes.keySet()) {\n+                        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (String typeName : inferredTypes.keySet()) {\n+                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15ac26bcc19e8bed431a35edd3e3c176d7d56355": {
      "type": "Ybodychange",
      "commitMessage": "minor\n",
      "commitDate": "2016/10/22 上午12:08",
      "commitName": "15ac26bcc19e8bed431a35edd3e3c176d7d56355",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/21 下午2:55",
      "commitNameOld": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getType();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getType();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n-            return value.get().getUsage();\n+            return value.get().getType();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n-                return value.get().getUsage();\n+                return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e7780e554428a10c73de88ca64e5933b2291593": {
      "type": "Ydocchange",
      "commitMessage": "issue103: apply code style to core\n",
      "commitDate": "2016/10/21 上午4:06",
      "commitName": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 下午2:39",
      "commitNameOld": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
        "newValue": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\nmodifiers.\n\n@return\n"
      }
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016/10/20 下午2:39",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "renamed packages to com.github.javapaerser\n",
          "commitDate": "2016/10/20 下午2:39",
          "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/20 下午2:32",
          "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 269,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
          "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n-            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
            "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "renamed packages to com.github.javapaerser\n",
          "commitDate": "2016/10/20 下午2:39",
          "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/20 下午2:32",
          "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 269,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
          "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n-            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6624f3653734698f477561c8407357e2395d411c": {
      "type": "Ybodychange",
      "commitMessage": "fix type of ArrayCreationExpr\n",
      "commitDate": "2016/10/20 上午2:21",
      "commitName": "6624f3653734698f477561c8407357e2395d411c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:36",
      "commitNameOld": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,242 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         if (expr.getVariables().size() !\u003d 1) {\n             throw new UnsupportedOperationException();\n         }\n         return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n-            res \u003d new ArrayType(res);\n-        }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": {
      "type": "Ybodychange",
      "commitMessage": "use VariableDeclarator.getType\n",
      "commitDate": "2016/10/20 上午1:36",
      "commitName": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:36",
      "commitNameOld": "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        if (expr.getVariables().size() !\u003d 1) {\n            throw new UnsupportedOperationException();\n        }\n        return convertToUsageVariableType(expr.getVariables().get(0));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 273,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,242 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n-            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n-            return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-        return convertToUsageVariableType(expr);\n+        if (expr.getVariables().size() !\u003d 1) {\n+            throw new UnsupportedOperationException();\n+        }\n+        return convertToUsageVariableType(expr.getVariables().get(0));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dc06a758c00cc235372dbc225a7e20c1f5269d3": {
      "type": "Ybodychange",
      "commitMessage": "considering the ArrayBrackets\n",
      "commitDate": "2016/10/20 上午1:36",
      "commitName": "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:36",
      "commitNameOld": "4c6207acd87601844c87c13fb253ae8fd8a4a289",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsageVariableType(expr);\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (getParentNode(node) instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n-            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-        return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n+        return convertToUsageVariableType(expr);\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d14741fef3a17451db153cfe379e398da4b4b79": {
      "type": "Ybodychange",
      "commitMessage": "minor fix\n",
      "commitDate": "2016/10/20 上午1:35",
      "commitName": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:35",
      "commitNameOld": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (getParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 275,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n-        if (node.getParentNode() instanceof MethodCallExpr) {\n-            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+        if (getParentNode(node) instanceof MethodCallExpr) {\n+            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n-        if (node.getParentNode() instanceof MethodCallExpr) {\n-            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+        if (getParentNode(node) instanceof MethodCallExpr) {\n+            MethodCallExpr callExpr \u003d (MethodCallExpr) getParentNode(node);\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (getParentNode(node) instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else {\n             throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
      "type": "Ybodychange",
      "commitMessage": "revision of modified code to use Navigator.getParentNode\n",
      "commitDate": "2016/10/20 上午1:35",
      "commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:34",
      "commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (getParentNode(node) instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else {\n            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 275,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n-        if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n-            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode().getParentNode();\n+        if (getParentNode(node) instanceof FieldDeclaration) {\n+            FieldDeclaration parent \u003d (FieldDeclaration) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n-        } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n-            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode().getParentNode();\n+        } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n+            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) getParentNode(node);\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else {\n-            throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03e407957d600a18ef0a4a83224c17d155ef8645": {
      "type": "Ybodychange",
      "commitMessage": "fixing a few more tests\n",
      "commitDate": "2016/10/20 上午1:34",
      "commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:33",
      "commitNameOld": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode().getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode().getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n-        if (node.getParentNode() instanceof FieldDeclaration) {\n-            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n+        if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n+            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode().getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n-        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n-            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n+        } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n+            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode().getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else {\n-            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n             case postIncrement:\n             case preIncrement:\n             case preDecrement:\n             case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/19 下午11:04",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case postIncrement:\n            case preIncrement:\n            case preDecrement:\n            case postDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 271,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
      "diff": "@@ -1,239 +1,239 @@\n private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         Type actualType \u003d getType(expressionStmt.getExpression());\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                         List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType \u003d getType(expressionStmt.getExpression());\n                             Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                             Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n-            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n-            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return type;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveType.BOOLEAN;\n-            case posIncrement:\n+            case postIncrement:\n             case preIncrement:\n             case preDecrement:\n-            case posDecrement:\n+            case postDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+        return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n-        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+        return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n+        for (int i \u003d 0; i \u003c arrayCreationExpr.getLevels().size(); i++) {\n             res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f3e66c944670a818922f101162226ef604b263": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "deprecating some methods involving type parameters\n",
      "commitDate": "2016/10/15 上午1:24",
      "commitName": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "deprecating some methods involving type parameters\n",
          "commitDate": "2016/10/15 上午1:24",
          "commitName": "70f3e66c944670a818922f101162226ef604b263",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/15 上午12:51",
          "commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 256,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
          "diff": "",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "deprecating some methods involving type parameters\n",
          "commitDate": "2016/10/15 上午1:24",
          "commitName": "70f3e66c944670a818922f101162226ef604b263",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/15 上午12:51",
          "commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 256,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
            "newValue": "Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array modifiers.\n\n@return\n"
          }
        }
      ]
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016/10/14 上午4:11",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午8:20",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 254,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
          "diff": "@@ -1,239 +1,239 @@\n-private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                        Type actualType \u003d getType(expressionStmt.getExpression());\n+                        Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                        TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n-                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n+                        Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            Type actualType \u003d getType(expressionStmt.getExpression());\n+                            Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-        return typeUsage;\n+        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+        return type;\n     } else if (node instanceof NullLiteralExpr) {\n-        return NullTypeUsage.INSTANCE;\n+        return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n-        return PrimitiveTypeUsage.BOOLEAN;\n+        return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n-        return PrimitiveTypeUsage.INT;\n+        return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n-        return PrimitiveTypeUsage.LONG;\n+        return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n-        return PrimitiveTypeUsage.CHAR;\n+        return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n-        return PrimitiveTypeUsage.DOUBLE;\n+        return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n-        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n-                return PrimitiveTypeUsage.BOOLEAN;\n+                return PrimitiveType.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n-                return PrimitiveTypeUsage.BOOLEAN;\n+                return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n-        return PrimitiveTypeUsage.BOOLEAN;\n+        return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n-        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n-            res \u003d new ArrayTypeUsage(res);\n+            res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n-        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "TypeUsage",
            "newValue": "Type"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午8:20",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "private Type getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        Type actualType \u003d getType(expressionStmt.getExpression());\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        Type formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            Type actualType \u003d getType(expressionStmt.getExpression());\n                            Type formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return type;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullType.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveType.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveType.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveType.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveType.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveType.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveType.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveType.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayType(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 254,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
          "diff": "@@ -1,239 +1,239 @@\n-private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+private Type getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                    List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                        Type actualType \u003d getType(expressionStmt.getExpression());\n+                        Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                Type result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     if (node instanceof MethodReferenceExpr) {\n                         MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                        TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n-                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        Type actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n+                        Type formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        List\u003cTuple2\u003cType, Type\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            Type actualType \u003d getType(expressionStmt.getExpression());\n+                            Type formalType \u003d functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map\u003cString, Type\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-        return typeUsage;\n+        Type type \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+        return type;\n     } else if (node instanceof NullLiteralExpr) {\n-        return NullTypeUsage.INSTANCE;\n+        return NullType.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n-        return PrimitiveTypeUsage.BOOLEAN;\n+        return PrimitiveType.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n-        return PrimitiveTypeUsage.INT;\n+        return PrimitiveType.INT;\n     } else if (node instanceof LongLiteralExpr) {\n-        return PrimitiveTypeUsage.LONG;\n+        return PrimitiveType.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n-        return PrimitiveTypeUsage.CHAR;\n+        return PrimitiveType.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n-        return PrimitiveTypeUsage.DOUBLE;\n+        return PrimitiveType.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n-        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+        return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n-                return PrimitiveTypeUsage.BOOLEAN;\n+                return PrimitiveType.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n-                return PrimitiveTypeUsage.BOOLEAN;\n+                return PrimitiveType.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n-        return PrimitiveTypeUsage.BOOLEAN;\n+        return PrimitiveType.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n-        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+        return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+        Type res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n-            res \u003d new ArrayTypeUsage(res);\n+            res \u003d new ArrayType(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n-        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "acf74024c2d341bf4009af7173c9b1b972f19c32": {
      "type": "Ybodychange",
      "commitMessage": "issue80: resolving MethodRefExpr\n",
      "commitDate": "2016/10/12 上午1:37",
      "commitName": "acf74024c2d341bf4009af7173c9b1b972f19c32",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/11 上午5:28",
      "commitNameOld": "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 253,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,227 +1,239 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n-                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                    if (node instanceof MethodReferenceExpr) {\n+                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        TypeUsage actualType \u003d toMethodUsage(methodReferenceExpr).returnType();\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException();\n+                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (String typeName : inferredTypes.keySet()) {\n+                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7317fe7d60ad0af88e9ee692e95dd5dde832863e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"issue80: working on resolving methodref generic type parameters\"\n\nThis reverts commit 2c6d213f0359d5b52a9d570323aa10505415f6ac.\n",
      "commitDate": "2016/10/11 上午5:28",
      "commitName": "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/11 上午3:51",
      "commitNameOld": "2c6d213f0359d5b52a9d570323aa10505415f6ac",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 224,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,240 +1,227 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n-                    if (node instanceof MethodReferenceExpr) {\n-                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                        MethodUsage methodUsage \u003d resolveMethodRef(methodReferenceExpr);\n-                        TypeUsage actualType \u003d methodUsage.returnType();\n+                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n-                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n-                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n-                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n-                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (String typeName : inferredTypes.keySet()) {\n-                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n-                            }\n-                        } else {\n-                            throw new UnsupportedOperationException();\n-                        }\n+                        throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c6d213f0359d5b52a9d570323aa10505415f6ac": {
      "type": "Ybodychange",
      "commitMessage": "issue80: working on resolving methodref generic type parameters\n",
      "commitDate": "2016/10/11 上午3:51",
      "commitName": "2c6d213f0359d5b52a9d570323aa10505415f6ac",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/10 上午1:11",
      "commitNameOld": "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    if (node instanceof MethodReferenceExpr) {\n                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        MethodUsage methodUsage \u003d resolveMethodRef(methodReferenceExpr);\n                        TypeUsage actualType \u003d methodUsage.returnType();\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                            for (String typeName : inferredTypes.keySet()) {\n                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                            }\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 252,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,227 +1,240 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof MethodReferenceExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n-                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n-                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n-                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                    if (node instanceof MethodReferenceExpr) {\n+                        MethodReferenceExpr methodReferenceExpr \u003d (MethodReferenceExpr) node;\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        MethodUsage methodUsage \u003d resolveMethodRef(methodReferenceExpr);\n+                        TypeUsage actualType \u003d methodUsage.returnType();\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException();\n+                        LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+                        List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                            TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                            TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                            formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                            Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (String typeName : inferredTypes.keySet()) {\n+                                result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68b3e019e1216a941ff5d8dcf63aefc9b35a3787": {
      "type": "Ybodychange",
      "commitMessage": "issue80: progress in supporting Method references\n",
      "commitDate": "2016/10/10 上午1:11",
      "commitName": "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/10 上午1:00",
      "commitNameOld": "91127219c066635d47cfe8d849a2814308d14cdc",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof MethodReferenceExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 224,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,190 +1,227 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n+    } else if (node instanceof MethodReferenceExpr) {\n+        if (node.getParentNode() instanceof MethodCallExpr) {\n+            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n+            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr, false);\n+            if (!refMethod.isSolved()) {\n+                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+            }\n+            logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n+            if (solveLambdas) {\n+                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n+                result \u003d solveGenericTypes(result, ctx, typeSolver);\n+                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n+                if (functionalMethod.isPresent()) {\n+                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n+                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        for (String typeName : inferredTypes.keySet()) {\n+                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+                return result;\n+            } else {\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n+        }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74": {
      "type": "Ybodychange",
      "commitMessage": "issue80: better handling of Lambdas and FunctionInterface\n",
      "commitDate": "2016/10/9 下午4:42",
      "commitName": "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/9 上午4:17",
      "commitNameOld": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.52,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 215,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,190 +1,190 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(callExpr.getName());\n+                throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cb7655f9661f11dab8ec9e2533722d649a16e715": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving resolution of static methods\n",
      "commitDate": "2016/10/9 上午4:17",
      "commitName": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/9/29 下午11:28",
      "commitNameOld": "31433fc385c0fea7ead68e4c853807752e061565",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 9.2,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 215,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,190 +1,190 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n-            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n+            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     } else if (node instanceof ClassExpr) {\n         return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31433fc385c0fea7ead68e4c853807752e061565": {
      "type": "Ybodychange",
      "commitMessage": "Implemented solving type of a ClassExpr. This fixes issue #64.\n",
      "commitDate": "2016/9/29 下午11:28",
      "commitName": "31433fc385c0fea7ead68e4c853807752e061565",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016/9/27 下午5:57",
      "commitNameOld": "cb2a7efc0de1197ac95d22171bd861623c7e0e27",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else if (node instanceof ClassExpr) {\n        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 215,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,188 +1,190 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else if (node instanceof ArrayAccessExpr) {\n         ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n         return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n     } else if (node instanceof SuperExpr) {\n         TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n         if (typeOfNode instanceof ClassDeclaration) {\n             return ((ClassDeclaration) typeOfNode).getSuperClass();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n+    } else if (node instanceof ClassExpr) {\n+        return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a541f77a5a66a911e347d294aa76d8703e72e7db": {
      "type": "Ybodychange",
      "commitMessage": "Implemented solving method calls on ArrayAccessExpr and SuperExpr. This fixes issue #41.\n",
      "commitDate": "2016/9/22 下午8:06",
      "commitName": "a541f77a5a66a911e347d294aa76d8703e72e7db",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016/9/21 上午4:11",
      "commitNameOld": "511490972b01d148a30dce013ede4ce213b3f05e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else if (node instanceof ArrayAccessExpr) {\n        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n    } else if (node instanceof SuperExpr) {\n        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n        if (typeOfNode instanceof ClassDeclaration) {\n            return ((ClassDeclaration) typeOfNode).getSuperClass();\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 214,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,178 +1,188 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof DoubleLiteralExpr) {\n         return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n+    } else if (node instanceof ArrayAccessExpr) {\n+        ArrayAccessExpr arrayAccessExpr \u003d (ArrayAccessExpr) node;\n+        return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+    } else if (node instanceof SuperExpr) {\n+        TypeDeclaration typeOfNode \u003d getTypeDeclaration(findContainingTypeDecl(node));\n+        if (typeOfNode instanceof ClassDeclaration) {\n+            return ((ClassDeclaration) typeOfNode).getSuperClass();\n+        } else {\n+            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+        }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0": {
      "type": "Ybodychange",
      "commitMessage": "Make typesolver recognize double literals\n",
      "commitDate": "2016/1/5 上午2:59",
      "commitName": "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0",
      "commitAuthor": "Evan",
      "commitDateOld": "2015/11/22 下午6:45",
      "commitNameOld": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 43.34,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof DoubleLiteralExpr) {\n        return PrimitiveTypeUsage.DOUBLE;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,176 +1,178 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n+    } else if (node instanceof DoubleLiteralExpr) {\n+        return PrimitiveTypeUsage.DOUBLE;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n             res \u003d new ArrayTypeUsage(res);\n         }\n         return res;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015/11/22 下午6:45",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/22 下午6:03",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "ead147279ca0b84d2f479a714943b20cd689e7c7": {
      "type": "Ybodychange",
      "commitMessage": "issue7: consider type parameters and varargs combinations\n",
      "commitDate": "2015/11/21 上午12:04",
      "commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/14 下午7:41",
      "commitNameOld": "454904fe0cb3b15aa506e3f5fa8f0c9fb1313f61",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n            res \u003d new ArrayTypeUsage(res);\n        }\n        return res;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,173 +1,176 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n-        JavaParserFacade javaParserFacade \u003d JavaParserFacade.get(typeSolver);\n-        MethodUsage ref \u003d javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n+        MethodUsage ref \u003d solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+        TypeUsage res \u003d convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+        for (int i \u003d 0; i \u003c arrayCreationExpr.getArrayCount(); i++) {\n+            res \u003d new ArrayTypeUsage(res);\n+        }\n+        return res;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6849db3884e47909d2d97fcac0b057ab13d544b": {
      "type": "Ybodychange",
      "commitMessage": "fix lambda solving\n",
      "commitDate": "2015/11/14 下午6:15",
      "commitName": "a6849db3884e47909d2d97fcac0b057ab13d544b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/14 上午6:07",
      "commitNameOld": "94446666d149c898131d04e7fd567777258e4e1e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.51,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        JavaParserFacade javaParserFacade \u003d JavaParserFacade.get(typeSolver);\n        MethodUsage ref \u003d javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 206,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,172 +1,173 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n-        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+        JavaParserFacade javaParserFacade \u003d JavaParserFacade.get(typeSolver);\n+        MethodUsage ref \u003d javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n-            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n+            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d JavaParserFacade.get(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                 result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                         ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                         TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                         TypeUsage formalType \u003d functionalMethod.get().returnType();\n                         formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                         Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                         for (String typeName : inferredTypes.keySet()) {\n                             result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n-            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n-            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n-        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n+        return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n-        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+        TypeUsage typeUsage \u003d JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94446666d149c898131d04e7fd567777258e4e1e": {
      "type": "Ybodychange",
      "commitMessage": "fix LambdaTest.lambdaMapParameter\n",
      "commitDate": "2015/11/14 上午6:07",
      "commitName": "94446666d149c898131d04e7fd567777258e4e1e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/14 上午3:41",
      "commitNameOld": "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                        for (String typeName : inferredTypes.keySet()) {\n                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 156,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,159 +1,172 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n+                Context ctx \u003d JavaParserFactory.getContext(node, typeSolver);\n+                result \u003d solveGenericTypes(result, ctx, typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n-                    throw new UnsupportedOperationException();\n+                    List\u003cTuple2\u003cTypeUsage, TypeUsage\u003e\u003e formalActualTypePairs \u003d new ArrayList\u003c\u003e();\n+                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                        ExpressionStmt expressionStmt \u003d (ExpressionStmt) lambdaExpr.getBody();\n+                        TypeUsage actualType \u003d getType(expressionStmt.getExpression());\n+                        TypeUsage formalType \u003d functionalMethod.get().returnType();\n+                        formalActualTypePairs.add(new Tuple2\u003c\u003e(formalType, actualType));\n+                        Map\u003cString, TypeUsage\u003e inferredTypes \u003d GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                        for (String typeName : inferredTypes.keySet()) {\n+                            result \u003d result.replaceParam(typeName, inferredTypes.get(typeName));\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97": {
      "type": "Ybodychange",
      "commitMessage": "add GenericTypeInferenceLogic\n",
      "commitDate": "2015/11/14 上午3:41",
      "commitName": "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/14 上午3:06",
      "commitNameOld": "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                    throw new UnsupportedOperationException();\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 141,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,158 +1,159 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                 Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n+                    LambdaExpr lambdaExpr \u003d (LambdaExpr) node;\n                     throw new UnsupportedOperationException();\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e": {
      "type": "Ybodychange",
      "commitMessage": "add FunctionInterfaceLogic\n",
      "commitDate": "2015/11/14 上午3:06",
      "commitName": "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/14 上午2:19",
      "commitNameOld": "f20bec1be7e976300ef4857e347bc735ded0f305",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    throw new UnsupportedOperationException();\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 141,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,158 +1,158 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n-                Optional\u003cMethodUsage\u003e functionalMethod \u003d getFunctionalMethod(result);\n+                Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(result);\n                 if (functionalMethod.isPresent()) {\n                     throw new UnsupportedOperationException();\n                 }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f20bec1be7e976300ef4857e347bc735ded0f305": {
      "type": "Ybodychange",
      "commitMessage": "add RedlectionInterfaceDeclarationTest\n",
      "commitDate": "2015/11/14 上午2:19",
      "commitName": "f20bec1be7e976300ef4857e347bc735ded0f305",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午5:59",
      "commitNameOld": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                Optional\u003cMethodUsage\u003e functionalMethod \u003d getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    throw new UnsupportedOperationException();\n                }\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 140,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,158 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n+                Optional\u003cMethodUsage\u003e functionalMethod \u003d getFunctionalMethod(result);\n+                if (functionalMethod.isPresent()) {\n+                    throw new UnsupportedOperationException();\n+                }\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": {
      "type": "Ybodychange",
      "commitMessage": "modules: extraction of the model module\n",
      "commitDate": "2015/11/13 下午5:59",
      "commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午5:12",
      "commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 140,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+        Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n-            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            Optional\u003cme.tomassetti.symbolsolver.model.resolution.Value\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n-        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+        return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n-        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+        return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015/11/13 下午5:12",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午4:53",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 136,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": {
      "type": "Ybodychange",
      "commitMessage": "removing TypeSolver from model.declarations\n",
      "commitDate": "2015/11/3 上午3:48",
      "commitName": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 下午11:01",
      "commitNameOld": "03ec309bba14eaf50a32b05353fa9711b831de7f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.2,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 145,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n+                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                 return result;\n             } else {\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n-                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n+                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb388c36c0045c50744cf215521e5c280036aa70": {
      "type": "Yfilerename",
      "commitMessage": "move JavaParser specific code to specific package\n",
      "commitDate": "2015/10/31 下午7:11",
      "commitName": "fb388c36c0045c50744cf215521e5c280036aa70",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 下午5:57",
      "commitNameOld": "b2bf624be5d1ef59480250e66224aeaa1886df36",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 145,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "c04083d20425a664115db6b0df3ca9632e66ecca": {
      "type": "Ybodychange",
      "commitMessage": "removing TypeSolver from fields related methods of TypeDeclaration\n",
      "commitDate": "2015/10/31 下午5:52",
      "commitName": "c04083d20425a664115db6b0df3ca9632e66ecca",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 下午5:22",
      "commitNameOld": "960364fad3fc2ead6113d4c5d4b7d9ebf23e2f9a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 147,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n-                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n+                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e81f51c40996b42cb262dc2397126cee8f60965": {
      "type": "Ybodychange",
      "commitMessage": "embedding TypeSolver\n",
      "commitDate": "2015/10/31 上午6:37",
      "commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午11:43",
      "commitNameOld": "005ec580724781a825aaf08a496ad7f8f667b27f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 146,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n-                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n+                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n-                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n+                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n-        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n+        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n-        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n+        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n-        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n+        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n-        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n+        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n-        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n+        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c": {
      "type": "Ybodychange",
      "commitMessage": "simplify TypeUsage\n",
      "commitDate": "2015/10/30 下午9:13",
      "commitName": "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午5:53",
      "commitNameOld": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 144,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n-                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n+                result \u003d solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": {
      "type": "Ybodychange",
      "commitMessage": "renaming\n",
      "commitDate": "2015/10/28 下午11:18",
      "commitName": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/27 下午10:40",
      "commitNameOld": "bed91989f7354552d72b2b7f0c28fcbd24fee003",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 62.03,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n-        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n+        return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n-        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n+        return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
      "type": "Ybodychange",
      "commitMessage": "remove noise\n",
      "commitDate": "2015/8/25 上午5:05",
      "commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午3:57",
      "commitNameOld": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,157 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine() \u003d\u003d 452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n-            System.out.println(\"GOTCHA\");\n-        }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
      "type": "Ybodychange",
      "commitMessage": "consider method override\n",
      "commitDate": "2015/8/25 上午3:19",
      "commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午2:45",
      "commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine() \u003d\u003d 452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n            System.out.println(\"GOTCHA\");\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return NullTypeUsage.INSTANCE;\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,157 +1,157 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine() \u003d\u003d 452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n             System.out.println(\"GOTCHA\");\n         }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n-        return new NullTypeUsage();\n+        return NullTypeUsage.INSTANCE;\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0348de241a6cf6be9c51500870ee1fb26172101": {
      "type": "Ybodychange",
      "commitMessage": "fix switch on enums\n",
      "commitDate": "2015/8/25 上午2:45",
      "commitName": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午12:29",
      "commitNameOld": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine() \u003d\u003d 452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n            System.out.println(\"GOTCHA\");\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,157 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n+        if (nameExpr.getName().equals(\"Boolean\") \u0026\u0026 nameExpr.getBeginLine() \u003d\u003d 452 \u0026\u0026 !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n+            System.out.println(\"GOTCHA\");\n+        }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
      "type": "Ybodychange",
      "commitMessage": "add test on switch on enum value\n",
      "commitDate": "2015/8/25 上午12:29",
      "commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午10:31",
      "commitNameOld": "ee35b15a04539af508d29081ac5c7f8f6fadba4a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,154 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n-            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n+            throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case binAnd:\n             case binOr:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
      "type": "Ybodychange",
      "commitMessage": "remove JavaParserFacade.convert\n",
      "commitDate": "2015/8/24 下午10:22",
      "commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午10:06",
      "commitNameOld": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case binAnd:\n            case binOr:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,151 +1,154 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n+            case binAnd:\n+            case binOr:\n+                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": {
      "type": "Ybodychange",
      "commitMessage": "minor corrections for enums\n",
      "commitDate": "2015/8/24 下午10:06",
      "commitName": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午9:58",
      "commitNameOld": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,151 +1,151 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n-                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n+                throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else if (node instanceof ConditionalExpr) {\n         ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n         return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n     } else if (node instanceof ArrayCreationExpr) {\n         ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n         return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00f005b38e8b83eb1d60db9070c6e9e3beffe403": {
      "type": "Ybodychange",
      "commitMessage": "Consider ConditionalExpr and ArrayCreationExpr in getTypeConcrete\n",
      "commitDate": "2015/8/24 下午9:26",
      "commitName": "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午9:22",
      "commitNameOld": "d6edae7874d2e78cbd401619ad53a9f9e2288597",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else if (node instanceof ConditionalExpr) {\n        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n    } else if (node instanceof ArrayCreationExpr) {\n        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,145 +1,151 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n+    } else if (node instanceof ConditionalExpr) {\n+        ConditionalExpr conditionalExpr \u003d (ConditionalExpr) node;\n+        return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n+    } else if (node instanceof ArrayCreationExpr) {\n+        ArrayCreationExpr arrayCreationExpr \u003d (ArrayCreationExpr) node;\n+        return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n-        throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n+        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6edae7874d2e78cbd401619ad53a9f9e2288597": {
      "type": "Ybodychange",
      "commitMessage": "Testing access to field through this keyword\n",
      "commitDate": "2015/8/24 下午9:22",
      "commitName": "d6edae7874d2e78cbd401619ad53a9f9e2288597",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 上午5:28",
      "commitNameOld": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,145 +1,145 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n             case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case posIncrement:\n             case preIncrement:\n             case preDecrement:\n             case posDecrement:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else {\n-        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+        throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451": {
      "type": "Ybodychange",
      "commitMessage": "completing various missing elements\n",
      "commitDate": "2015/8/24 上午5:28",
      "commitName": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 上午3:27",
      "commitNameOld": "31b108cbfd418f43e7b568374af2e635a580e171",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n            case positive:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case posIncrement:\n            case preIncrement:\n            case preDecrement:\n            case posDecrement:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,144 +1,145 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n-            System.out.println(\"Foo\");\n-        }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n+            case positive:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n-            case inverse:\n             case posIncrement:\n+            case preIncrement:\n+            case preDecrement:\n+            case posDecrement:\n+                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31b108cbfd418f43e7b568374af2e635a580e171": {
      "type": "Ybodychange",
      "commitMessage": "add StatementContextTest\n",
      "commitDate": "2015/8/24 上午3:27",
      "commitName": "31b108cbfd418f43e7b568374af2e635a580e171",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午9:43",
      "commitNameOld": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n            System.out.println(\"Foo\");\n        }\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case inverse:\n            case posIncrement:\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,141 +1,144 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n+        if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n+            System.out.println(\"Foo\");\n+        }\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case inverse:\n             case posIncrement:\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else if (node instanceof ThisExpr) {\n         return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bac18a129c45335e69d811b3872fcb938e1f0ff8": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/23 下午9:43",
      "commitName": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午8:43",
      "commitNameOld": "5c62d5981fb47c4e1e02baa91eb8e2c6ce20c969",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case inverse:\n            case posIncrement:\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else if (node instanceof ThisExpr) {\n        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,139 +1,141 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case not:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             case inverse:\n             case posIncrement:\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n             case or:\n             case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof AssignExpr) {\n         AssignExpr assignExpr \u003d (AssignExpr) node;\n         return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n+    } else if (node instanceof ThisExpr) {\n+        return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46aefdd68f2f2597a19b72da36681123cb3090e6": {
      "type": "Ybodychange",
      "commitMessage": "improve resolution of calls to static methods\n",
      "commitDate": "2015/8/23 下午6:34",
      "commitName": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午5:38",
      "commitNameOld": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case not:\n                return PrimitiveTypeUsage.BOOLEAN;\n            case inverse:\n            case posIncrement:\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n            case or:\n            case and:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof AssignExpr) {\n        AssignExpr assignExpr \u003d (AssignExpr) node;\n        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,133 +1,139 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n-            case inverse:\n             case not:\n+                return PrimitiveTypeUsage.BOOLEAN;\n+            case inverse:\n             case posIncrement:\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n+            case or:\n+            case and:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else if (node instanceof InstanceOfExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof EnclosedExpr) {\n         EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n         return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n     } else if (node instanceof CastExpr) {\n         CastExpr enclosedExpr \u003d (CastExpr) node;\n         return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n+    } else if (node instanceof AssignExpr) {\n+        AssignExpr assignExpr \u003d (AssignExpr) node;\n+        return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c297529e31036058837adbaa57cee652d4cc918": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/23 下午5:38",
      "commitName": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午4:24",
      "commitNameOld": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case inverse:\n            case not:\n            case posIncrement:\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else if (node instanceof InstanceOfExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof EnclosedExpr) {\n        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n    } else if (node instanceof CastExpr) {\n        CastExpr enclosedExpr \u003d (CastExpr) node;\n        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,125 +1,133 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case inverse:\n             case not:\n             case posIncrement:\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n             case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n             case lessEquals:\n             case less:\n             case greater:\n             case greaterEquals:\n             case equals:\n             case notEquals:\n                 return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n     } else if (node instanceof VariableDeclarationExpr) {\n         VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n         return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n+    } else if (node instanceof InstanceOfExpr) {\n+        return PrimitiveTypeUsage.BOOLEAN;\n+    } else if (node instanceof EnclosedExpr) {\n+        EnclosedExpr enclosedExpr \u003d (EnclosedExpr) node;\n+        return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+    } else if (node instanceof CastExpr) {\n+        CastExpr enclosedExpr \u003d (CastExpr) node;\n+        return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/23 下午4:24",
      "commitName": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午3:50",
      "commitNameOld": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case inverse:\n            case not:\n            case posIncrement:\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n            case minus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            case lessEquals:\n            case less:\n            case greater:\n            case greaterEquals:\n            case equals:\n            case notEquals:\n                return PrimitiveTypeUsage.BOOLEAN;\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else if (node instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 126,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,114 +1,125 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else if (node instanceof IntegerLiteralExpr) {\n         return PrimitiveTypeUsage.INT;\n     } else if (node instanceof LongLiteralExpr) {\n         return PrimitiveTypeUsage.LONG;\n     } else if (node instanceof CharLiteralExpr) {\n         return PrimitiveTypeUsage.CHAR;\n     } else if (node instanceof StringLiteralExpr) {\n         return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n     } else if (node instanceof UnaryExpr) {\n         UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n         switch(unaryExpr.getOperator()) {\n             case negative:\n                 return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n             case inverse:\n             case not:\n             case posIncrement:\n             default:\n                 throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n         }\n     } else if (node instanceof BinaryExpr) {\n         BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n         switch(binaryExpr.getOperator()) {\n             case plus:\n+            case minus:\n                 return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+            case lessEquals:\n+            case less:\n+            case greater:\n+            case greaterEquals:\n+            case equals:\n+            case notEquals:\n+                return PrimitiveTypeUsage.BOOLEAN;\n             default:\n                 throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n         }\n+    } else if (node instanceof VariableDeclarationExpr) {\n+        VariableDeclarationExpr expr \u003d (VariableDeclarationExpr) node;\n+        return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "feab46de5d87b02bf38b29962613676adf14f78a": {
      "type": "Ybodychange",
      "commitMessage": "implementing missing bits while solving symbols on JavaParser\n",
      "commitDate": "2015/8/22 下午6:08",
      "commitName": "feab46de5d87b02bf38b29962613676adf14f78a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/22 上午5:01",
      "commitNameOld": "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else if (node instanceof IntegerLiteralExpr) {\n        return PrimitiveTypeUsage.INT;\n    } else if (node instanceof LongLiteralExpr) {\n        return PrimitiveTypeUsage.LONG;\n    } else if (node instanceof CharLiteralExpr) {\n        return PrimitiveTypeUsage.CHAR;\n    } else if (node instanceof StringLiteralExpr) {\n        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n    } else if (node instanceof UnaryExpr) {\n        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n        switch(unaryExpr.getOperator()) {\n            case negative:\n                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n            case inverse:\n            case not:\n            case posIncrement:\n            default:\n                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n        }\n    } else if (node instanceof BinaryExpr) {\n        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n        switch(binaryExpr.getOperator()) {\n            case plus:\n                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n            default:\n                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 125,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,87 +1,114 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n+    } else if (node instanceof IntegerLiteralExpr) {\n+        return PrimitiveTypeUsage.INT;\n+    } else if (node instanceof LongLiteralExpr) {\n+        return PrimitiveTypeUsage.LONG;\n+    } else if (node instanceof CharLiteralExpr) {\n+        return PrimitiveTypeUsage.CHAR;\n+    } else if (node instanceof StringLiteralExpr) {\n+        return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n+    } else if (node instanceof UnaryExpr) {\n+        UnaryExpr unaryExpr \u003d (UnaryExpr) node;\n+        switch(unaryExpr.getOperator()) {\n+            case negative:\n+                return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n+            case inverse:\n+            case not:\n+            case posIncrement:\n+            default:\n+                throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n+        }\n+    } else if (node instanceof BinaryExpr) {\n+        BinaryExpr binaryExpr \u003d (BinaryExpr) node;\n+        switch(binaryExpr.getOperator()) {\n+            case plus:\n+                return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+            default:\n+                throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n+        }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "54b73148ab5bfb5e3c2f1c2aa463265d033ac926": {
      "type": "Ybodychange",
      "commitMessage": "remove spurios log\n",
      "commitDate": "2015/8/22 上午5:01",
      "commitName": "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/22 上午5:00",
      "commitNameOld": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,88 +1,87 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n         if (!value.isPresent()) {\n             throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n         } else {\n             return value.get().getUsage();\n         }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         try {\n             Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } catch (UnsolvedSymbolException e) {\n-            System.out.println(\"FOO\");\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                 if (!typeAccessedStatically.isSolved()) {\n                     throw e;\n                 } else {\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else if (node instanceof BooleanLiteralExpr) {\n         return PrimitiveTypeUsage.BOOLEAN;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": {
      "type": "Ybodychange",
      "commitMessage": "add tests for static field access\n",
      "commitDate": "2015/8/22 上午5:00",
      "commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/22 上午2:45",
      "commitNameOld": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n        } else {\n            return value.get().getUsage();\n        }\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        try {\n            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n            }\n        } catch (UnsolvedSymbolException e) {\n            System.out.println(\"FOO\");\n            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                if (!typeAccessedStatically.isSolved()) {\n                    throw e;\n                } else {\n                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else if (node instanceof BooleanLiteralExpr) {\n        return PrimitiveTypeUsage.BOOLEAN;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,66 +1,88 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n-        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+        if (!value.isPresent()) {\n+            throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n+        } else {\n+            return value.get().getUsage();\n+        }\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n-                throw new UnsolvedSymbolException(null, callExpr.getName());\n+                throw new UnsolvedSymbolException(callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n-        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-        if (value.isPresent()) {\n-            return value.get().getUsage();\n-        } else {\n-            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n+        try {\n+            Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            if (value.isPresent()) {\n+                return value.get().getUsage();\n+            } else {\n+                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+            }\n+        } catch (UnsolvedSymbolException e) {\n+            System.out.println(\"FOO\");\n+            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n+                NameExpr staticValue \u003d (NameExpr) fieldAccessExpr.getScope();\n+                SymbolReference\u003cTypeDeclaration\u003e typeAccessedStatically \u003d JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n+                if (!typeAccessedStatically.isSolved()) {\n+                    throw e;\n+                } else {\n+                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n+                }\n+            } else {\n+                throw e;\n+            }\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n+    } else if (node instanceof BooleanLiteralExpr) {\n+        return PrimitiveTypeUsage.BOOLEAN;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09ceccd596e6aeebb5eca309093ef32216291f1e": {
      "type": "Ybodychange",
      "commitMessage": "first step\n",
      "commitDate": "2015/8/21 下午3:18",
      "commitName": "09ceccd596e6aeebb5eca309093ef32216291f1e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/18 下午5:15",
      "commitNameOld": "1d5332815b543d569be3d7ec672a65b7efc39a04",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.92,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 123,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,66 +1,66 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n-                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else if (node instanceof NullLiteralExpr) {\n         return new NullTypeUsage();\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/18 上午12:43",
      "commitName": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/18 上午12:43",
      "commitNameOld": "d393205e2ee874242b73e4fe819d1bc874587d8a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else if (node instanceof NullLiteralExpr) {\n        return new NullTypeUsage();\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 131,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,64 +1,66 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                 return result;\n             } else {\n                 return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n+    } else if (node instanceof NullLiteralExpr) {\n+        return new NullTypeUsage();\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22bf613d486d43114d1547e5bc623535aa2aca2a": {
      "type": "Ybodychange",
      "commitMessage": "add test resolveLambdaType\n",
      "commitDate": "2015/8/17 下午3:14",
      "commitName": "22bf613d486d43114d1547e5bc623535aa2aca2a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/17 下午1:55",
      "commitNameOld": "9f625af2721bfb3f764d5f4dd23eef55324c94bc",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                return result;\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 128,
      "functionName": "getTypeConcrete",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,62 +1,64 @@\n private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                TypeUsage result \u003d refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                result \u003d result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n+                return result;\n             } else {\n                 return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015/8/5 下午10:25",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "introduce cache in JavaParserFacade\n",
          "commitDate": "2015/8/5 下午10:25",
          "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/5 下午10:08",
          "commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 124,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
          "diff": "@@ -1,62 +1,62 @@\n-public TypeUsage getType(Node node, boolean solveLambdas) {\n+private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n             } else {\n                 return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getType",
            "newValue": "getTypeConcrete"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "introduce cache in JavaParserFacade\n",
          "commitDate": "2015/8/5 下午10:25",
          "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/5 下午10:08",
          "commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 124,
          "functionName": "getTypeConcrete",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
          "diff": "@@ -1,62 +1,62 @@\n-public TypeUsage getType(Node node, boolean solveLambdas) {\n+private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         logger.finest(\"getType on name expr \" + node);\n         return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n             } else {\n                 return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n         if (parameter.getType() instanceof UnknownType) {\n             throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n         }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        }
      ]
    },
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": {
      "type": "Ybodychange",
      "commitMessage": "add resolveReferenceToLambdaParamBase\n",
      "commitDate": "2015/8/5 下午10:08",
      "commitName": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/5 下午9:30",
      "commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        logger.finest(\"getType on name expr \" + node);\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        if (parameter.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n        }\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 97,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,58 +1,62 @@\n public TypeUsage getType(Node node, boolean solveLambdas) {\n     if (node \u003d\u003d null)\n         throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n+        logger.finest(\"getType on name expr \" + node);\n         return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n         logger.finest(\"getType on method call \" + node);\n         MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n         logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n         logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n         return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n             if (solveLambdas) {\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n             } else {\n                 return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n             }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n     } else if (node instanceof Parameter) {\n         Parameter parameter \u003d (Parameter) node;\n+        if (parameter.getType() instanceof UnknownType) {\n+            throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n+        }\n         return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
      "commitDate": "2015/8/5 下午9:30",
      "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
          "commitDate": "2015/8/5 下午9:30",
          "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/5 下午4:09",
          "commitNameOld": "6650e5a3818c15de2883b71cd41524b0337e26f6",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public TypeUsage getType(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 96,
          "functionName": "getType",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
          "diff": "@@ -1,51 +1,58 @@\n-public TypeUsage getType(Node node) {\n+public TypeUsage getType(Node node, boolean solveLambdas) {\n+    if (node \u003d\u003d null)\n+        throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n-        SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n-        if (!ref.isSolved()) {\n-            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n-        }\n-        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n+        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n-        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n-        if (!ref.isSolved()) {\n-            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n-        }\n-        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+        logger.finest(\"getType on method call \" + node);\n+        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+        return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n-            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n-            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-            return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+            if (solveLambdas) {\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+            } else {\n+                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+            }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n+            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n+    } else if (node instanceof Parameter) {\n+        Parameter parameter \u003d (Parameter) node;\n+        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[node-Node]",
            "newValue": "[node-Node, solveLambdas-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
          "commitDate": "2015/8/5 下午9:30",
          "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/5 下午4:09",
          "commitNameOld": "6650e5a3818c15de2883b71cd41524b0337e26f6",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public TypeUsage getType(Node node, boolean solveLambdas) {\n    if (node \u003d\u003d null)\n        throw new IllegalArgumentException();\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n    } else if (node instanceof MethodCallExpr) {\n        logger.finest(\"getType on method call \" + node);\n        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n        return ref.returnType();\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n            } else {\n                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof Parameter) {\n        Parameter parameter \u003d (Parameter) node;\n        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
          "functionStartLine": 96,
          "functionName": "getType",
          "functionAnnotation": "",
          "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
          "diff": "@@ -1,51 +1,58 @@\n-public TypeUsage getType(Node node) {\n+public TypeUsage getType(Node node, boolean solveLambdas) {\n+    if (node \u003d\u003d null)\n+        throw new IllegalArgumentException();\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n-        SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n-        if (!ref.isSolved()) {\n-            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n-        }\n-        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n+        return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n     } else if (node instanceof MethodCallExpr) {\n-        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n-        if (!ref.isSolved()) {\n-            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n-        }\n-        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+        logger.finest(\"getType on method call \" + node);\n+        MethodUsage ref \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+        logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+        logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+        return ref.returnType();\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n-            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n-            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-            return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+            logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+            if (solveLambdas) {\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+            } else {\n+                return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+            }\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+        } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+            VariableDeclarationExpr parent \u003d (VariableDeclarationExpr) node.getParentNode();\n+            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n+    } else if (node instanceof Parameter) {\n+        Parameter parameter \u003d (Parameter) node;\n+        return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n     } else if (node instanceof FieldAccessExpr) {\n         FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n         Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n         if (value.isPresent()) {\n             return value.get().getUsage();\n         } else {\n             throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n         }\n     } else if (node instanceof ObjectCreationExpr) {\n         ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n         TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n         return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "80f951258992f75441239c79e0f31eda7d47e107": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/4 下午9:54",
      "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/4 下午5:02",
      "commitNameOld": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else if (node instanceof FieldAccessExpr) {\n        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n        if (value.isPresent()) {\n            return value.get().getUsage();\n        } else {\n            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n        }\n    } else if (node instanceof ObjectCreationExpr) {\n        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n        return typeUsage;\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 69,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,39 +1,51 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n-        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n+        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n             System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-            return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n+            return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else if (node instanceof VariableDeclarator) {\n         if (node.getParentNode() instanceof FieldDeclaration) {\n             FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n             return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n         } else {\n             throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n         }\n+    } else if (node instanceof FieldAccessExpr) {\n+        FieldAccessExpr fieldAccessExpr \u003d (FieldAccessExpr) node;\n+        Optional\u003cValue\u003e value \u003d new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+        if (value.isPresent()) {\n+            return value.get().getUsage();\n+        } else {\n+            throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n+        }\n+    } else if (node instanceof ObjectCreationExpr) {\n+        ObjectCreationExpr objectCreationExpr \u003d (ObjectCreationExpr) node;\n+        TypeUsage typeUsage \u003d new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+        return typeUsage;\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": {
      "type": "Ybodychange",
      "commitMessage": "solving first case of generic type\n",
      "commitDate": "2015/8/4 下午5:02",
      "commitName": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/3 下午2:53",
      "commitNameOld": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else if (node instanceof VariableDeclarator) {\n        if (node.getParentNode() instanceof FieldDeclaration) {\n            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n        } else {\n            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 74,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,32 +1,39 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n             System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n             return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n+    } else if (node instanceof VariableDeclarator) {\n+        if (node.getParentNode() instanceof FieldDeclaration) {\n+            FieldDeclaration parent \u003d (FieldDeclaration) node.getParentNode();\n+            return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+        } else {\n+            throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+        }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/3 下午2:53",
      "commitName": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/3 下午2:37",
      "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 70,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,32 +1,32 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n-        SymbolReference\u003cValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+        SymbolReference\u003c? extends ValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n             System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n             return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "630eb94d43670f2080c7273584d49c0b0d4162f1": {
      "type": "Ybodychange",
      "commitMessage": "initial refactoring\n",
      "commitDate": "2015/8/3 下午2:37",
      "commitName": "630eb94d43670f2080c7273584d49c0b0d4162f1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/2 下午8:22",
      "commitNameOld": "241cd249688d1e7c621c495746d2603433599eb9",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003cValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 70,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,32 +1,32 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n-        SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+        SymbolReference\u003cValueDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n             int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n             System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n             System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n             return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/2 下午6:18",
      "commitName": "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/2 下午5:48",
      "commitNameOld": "3def8748ada27ac91166941a892adfd83ca3db2a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 63,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,29 +1,32 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n     } else if (node instanceof LambdaExpr) {\n         if (node.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+            int pos \u003d JavaParserSymbolDeclaration.getParamPos(node);\n             SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n             if (!refMethod.isSolved()) {\n                 throw new UnsolvedSymbolException(null, callExpr.getName());\n             }\n-            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n+            System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+            return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n         } else {\n             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3def8748ada27ac91166941a892adfd83ca3db2a": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/2 下午5:48",
      "commitName": "3def8748ada27ac91166941a892adfd83ca3db2a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/2 下午4:52",
      "commitNameOld": "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        if (node.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(null, callExpr.getName());\n            }\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 62,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,20 +1,29 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n     } else if (node instanceof LambdaExpr) {\n-        throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+        if (node.getParentNode() instanceof MethodCallExpr) {\n+            MethodCallExpr callExpr \u003d (MethodCallExpr) node.getParentNode();\n+            SymbolReference\u003cMethodDeclaration\u003e refMethod \u003d new JavaParserFacade(typeSolver).solve(callExpr);\n+            if (!refMethod.isSolved()) {\n+                throw new UnsolvedSymbolException(null, callExpr.getName());\n+            }\n+            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+        } else {\n+            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+        }\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "381c389ea62cf20d6109dac96bb5f8202ccc0b34": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/2 下午4:52",
      "commitName": "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/1 上午2:52",
      "commitNameOld": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else if (node instanceof LambdaExpr) {\n        throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 53,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n",
      "diff": "@@ -1,18 +1,20 @@\n public TypeUsage getType(Node node) {\n     if (node instanceof NameExpr) {\n         NameExpr nameExpr \u003d (NameExpr) node;\n         SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n     } else if (node instanceof MethodCallExpr) {\n         SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n         }\n         return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+    } else if (node instanceof LambdaExpr) {\n+        throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n     } else {\n         throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": {
      "type": "Yintroduced",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/1 上午2:52",
      "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,18 @@\n+public TypeUsage getType(Node node) {\n+    if (node instanceof NameExpr) {\n+        NameExpr nameExpr \u003d (NameExpr) node;\n+        SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+        if (!ref.isSolved()) {\n+            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n+        }\n+        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n+    } else if (node instanceof MethodCallExpr) {\n+        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n+        if (!ref.isSolved()) {\n+            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n+        }\n+        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+    } else {\n+        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public TypeUsage getType(Node node) {\n    if (node instanceof NameExpr) {\n        NameExpr nameExpr \u003d (NameExpr) node;\n        SymbolReference\u003cSymbolDeclaration\u003e ref \u003d new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n    } else if (node instanceof MethodCallExpr) {\n        SymbolReference\u003cMethodDeclaration\u003e ref \u003d new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr) node);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr) node).getName());\n        }\n        return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 52,
      "functionName": "getType",
      "functionAnnotation": "",
      "functionDoc": "Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n\n@return\n"
    }
  }
}