{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "CollectionBinder.java",
  "functionName": "bind",
  "functionId": "bind",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 386,
  "functionEndLine": 552,
  "numCommitsSeen": 94,
  "timeTaken": 3875,
  "changeHistory": [
    "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83",
    "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
    "1e44e7420b7af10adc9547a461f02a6d979624f1",
    "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8",
    "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050",
    "1361925bc73a539bd6bd5d4a93de162e4a5b332b",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca",
    "bcd6185809ecf9202267134d646037e8acdd0939",
    "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5",
    "05c36793730fb1b4e3d08c731998c7649c9b34ef",
    "d7d9f0dfb207cb8238ea2962fee81708942fa368",
    "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
    "fb44ad936d8d54d311ecbaea1633683a8d809d04",
    "ddfcc44d760938578771cb6ce24c809c980c8b8b",
    "4ffba763cf6645e722a2deeea552f998ec7dc22a",
    "e18799b03611ef8dc37690585de984f63b35bc34",
    "8c806d361d63764e8523006944dde52aff70532c",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "7419fc298dab9afe82fbdbb8b64854fa37f60817",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
    "8577a68e69d30d9e671024bf3330616000a3ec54",
    "b1f925458eeb636897bf8a053712ed25fff39054",
    "e44b5f197d77e1d1a847cd04eaa0d25254362483",
    "658df91a5e308fd1d97cec62acf6110143012592",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
    "c7c6981a558e35f01ff8d27938e98aa83896765c",
    "20d22941c0e07b37295704d5300a7071e48e640d",
    "11668ca67c916595d2789787e37b3ed1affc1aa8",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e",
    "7337743c93574823424ed6c399cfcf6bd75614f8"
  ],
  "changeHistoryShort": {
    "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83": "Ybodychange",
    "7c2a58861341f1404b4974f1ed9809f40c1da8f6": "Ybodychange",
    "1e44e7420b7af10adc9547a461f02a6d979624f1": "Ybodychange",
    "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8": "Ybodychange",
    "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050": "Ybodychange",
    "1361925bc73a539bd6bd5d4a93de162e4a5b332b": "Ybodychange",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": "Ybodychange",
    "bcd6185809ecf9202267134d646037e8acdd0939": "Ybodychange",
    "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5": "Ybodychange",
    "05c36793730fb1b4e3d08c731998c7649c9b34ef": "Ybodychange",
    "d7d9f0dfb207cb8238ea2962fee81708942fa368": "Ybodychange",
    "ffb14b28b72c67dc2d658bfeb89545ca16eb3399": "Ybodychange",
    "fb44ad936d8d54d311ecbaea1633683a8d809d04": "Ybodychange",
    "ddfcc44d760938578771cb6ce24c809c980c8b8b": "Ybodychange",
    "4ffba763cf6645e722a2deeea552f998ec7dc22a": "Ybodychange",
    "e18799b03611ef8dc37690585de984f63b35bc34": "Ybodychange",
    "8c806d361d63764e8523006944dde52aff70532c": "Ybodychange",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "7419fc298dab9afe82fbdbb8b64854fa37f60817": "Ybodychange",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": "Yfilerename",
    "8577a68e69d30d9e671024bf3330616000a3ec54": "Ybodychange",
    "b1f925458eeb636897bf8a053712ed25fff39054": "Ybodychange",
    "e44b5f197d77e1d1a847cd04eaa0d25254362483": "Ybodychange",
    "658df91a5e308fd1d97cec62acf6110143012592": "Ybodychange",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": "Ybodychange",
    "c7c6981a558e35f01ff8d27938e98aa83896765c": "Ybodychange",
    "20d22941c0e07b37295704d5300a7071e48e640d": "Ybodychange",
    "11668ca67c916595d2789787e37b3ed1affc1aa8": "Ybodychange",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": "Yfilerename",
    "7337743c93574823424ed6c399cfcf6bd75614f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12122 - Checking @OrderBy for special cases should perform case-insensitive checking\n",
      "commitDate": "2017/12/13 下午8:19",
      "commitName": "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2017/9/18 下午5:03",
      "commitNameOld": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
      "commitAuthorOld": "Alexey Nesterov",
      "daysBetweenCommits": 86.14,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    if (!isMappedBy \u0026\u0026 oneToMany \u0026\u0026 property.isAnnotationPresent(OnDelete.class) \u0026\u0026 !property.isAnnotationPresent(JoinColumn.class)) {\n        String message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.contains(\"delete-orphan\")) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    final LazyGroup lazyGroupAnnotation \u003d property.getAnnotation(LazyGroup.class);\n    if (lazyGroupAnnotation !\u003d null) {\n        binder.setLazyGroup(lazyGroupAnnotation.value());\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 386,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,100 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     if (!isMappedBy \u0026\u0026 oneToMany \u0026\u0026 property.isAnnotationPresent(OnDelete.class) \u0026\u0026 !property.isAnnotationPresent(JoinColumn.class)) {\n         String message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n     buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n-    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n+    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.contains(\"delete-orphan\")) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setLazy(collection.isLazy());\n     final LazyGroup lazyGroupAnnotation \u003d property.getAnnotation(LazyGroup.class);\n     if (lazyGroupAnnotation !\u003d null) {\n         binder.setLazyGroup(lazyGroupAnnotation.value());\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c2a58861341f1404b4974f1ed9809f40c1da8f6": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6382: Allow to use @OnDelete annotation on unidirectional @OneToMany associations\n",
      "commitDate": "2017/9/18 下午5:03",
      "commitName": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
      "commitAuthor": "Alexey Nesterov",
      "commitDateOld": "2017/8/1 下午4:13",
      "commitNameOld": "47f8a679907789dd68f13cfd81a6c6caf232a81b",
      "commitAuthorOld": "Bogdan Stirbat",
      "daysBetweenCommits": 48.03,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    if (!isMappedBy \u0026\u0026 oneToMany \u0026\u0026 property.isAnnotationPresent(OnDelete.class) \u0026\u0026 !property.isAnnotationPresent(JoinColumn.class)) {\n        String message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    final LazyGroup lazyGroupAnnotation \u003d property.getAnnotation(LazyGroup.class);\n    if (lazyGroupAnnotation !\u003d null) {\n        binder.setLazyGroup(lazyGroupAnnotation.value());\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 386,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,95 +1,100 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n+    if (!isMappedBy \u0026\u0026 oneToMany \u0026\u0026 property.isAnnotationPresent(OnDelete.class) \u0026\u0026 !property.isAnnotationPresent(JoinColumn.class)) {\n+        String message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n+        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n+        throw new AnnotationException(message);\n+    }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n     buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setLazy(collection.isLazy());\n     final LazyGroup lazyGroupAnnotation \u003d property.getAnnotation(LazyGroup.class);\n     if (lazyGroupAnnotation !\u003d null) {\n         binder.setLazyGroup(lazyGroupAnnotation.value());\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e44e7420b7af10adc9547a461f02a6d979624f1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10267 - Support defining lazy attribute fetch groups\n",
      "commitDate": "2015/11/17 上午5:43",
      "commitName": "1e44e7420b7af10adc9547a461f02a6d979624f1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/10/7 上午5:07",
      "commitNameOld": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 41.02,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    final LazyGroup lazyGroupAnnotation \u003d property.getAnnotation(LazyGroup.class);\n    if (lazyGroupAnnotation !\u003d null) {\n        binder.setLazyGroup(lazyGroupAnnotation.value());\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 384,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,91 +1,95 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n     buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setLazy(collection.isLazy());\n+    final LazyGroup lazyGroupAnnotation \u003d property.getAnnotation(LazyGroup.class);\n+    if (lazyGroupAnnotation !\u003d null) {\n+        binder.setLazyGroup(lazyGroupAnnotation.value());\n+    }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10073 Not propagating XML node names configured in mappings\n",
      "commitDate": "2015/9/2 上午12:34",
      "commitName": "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8",
      "commitAuthor": "Gunnar Morling",
      "commitDateOld": "2015/7/16 下午4:05",
      "commitNameOld": "e4781feb7423c1bc74f1c43d6665c9a0d1730e31",
      "commitAuthorOld": "Gunnar Morling",
      "daysBetweenCommits": 47.35,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 383,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,92 +1,91 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n-    collection.setNodeName(propertyName);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n     buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setLazy(collection.isLazy());\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8558 - Bytecode enhancer: lazy loading support\n",
      "commitDate": "2015/7/7 上午2:34",
      "commitName": "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050",
      "commitAuthor": "barreiro",
      "commitDateOld": "2015/5/19 下午12:25",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 48.59,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 383,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,91 +1,92 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n     buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n+    binder.setLazy(collection.isLazy());\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1361925bc73a539bd6bd5d4a93de162e4a5b332b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9722\n\nChanged all toLowerCase() and toUpperCase() to toLowerCase(Locale.ROOT),\ntoUpperCase(Locale.ROOT).\n",
      "commitDate": "2015/4/18 上午3:53",
      "commitName": "1361925bc73a539bd6bd5d4a93de162e4a5b332b",
      "commitAuthor": "10urshin",
      "commitDateOld": "2015/4/3 上午6:02",
      "commitNameOld": "22ca7125f74621c09f7c2eedbc399160ce2755d5",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 14.91,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 400,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,91 +1,91 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n-        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n+        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlUpdate !\u003d null) {\n-        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n+        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDelete !\u003d null) {\n-        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n+        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (sqlDeleteAll !\u003d null) {\n-        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n+        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n         buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n     buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
      "commitDate": "2015/3/11 上午5:53",
      "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2014/10/21 下午1:18",
      "commitNameOld": "1cba98022ec0ccb30f6a68547c050663daf51a96",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 140.69,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 397,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,91 +1,91 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n-        final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n+        final TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n-            collection.setTypeName(typeDef.getTypeClass());\n+            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n-        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n+        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n-    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n+    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n-        mappings.addSecondPass(sp, !isMappedBy);\n+        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     } else {\n-        mappings.addSecondPass(sp, !isMappedBy);\n+        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n     }\n-    mappings.addCollection(collection);\n+    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bcd6185809ecf9202267134d646037e8acdd0939": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4910 The collection cache is evicted if a related collection element is inserted, removed or updated\n\nHHH-4910 minor fixes\n\nHHH-4910 make this feature configurable\n",
      "commitDate": "2013/9/19 上午12:26",
      "commitName": "bcd6185809ecf9202267134d646037e8acdd0939",
      "commitAuthor": "Andy2003",
      "commitDateOld": "2013/9/7 上午2:38",
      "commitNameOld": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 11.91,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 395,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,90 +1,91 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n+    collection.setMappedByProperty(mappedBy);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeClass());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8164 - Deprecate @Sort in favor of @SortNatural and @SortComparator\n",
      "commitDate": "2013/4/11 上午5:25",
      "commitName": "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012/10/29 下午11:37",
      "commitNameOld": "eae079d283683497d50861c78d0d84b765255105",
      "commitAuthorOld": "brmeyer",
      "daysBetweenCommits": 163.24,
      "commitsBetweenForRepo": 348,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 395,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,110 +1,90 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeClass());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n-    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n-        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n-    }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n     collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n-    if (orderBy !\u003d null)\n-        collection.setOrderBy(orderBy);\n-    if (isSorted) {\n-        collection.setSorted(true);\n-        if (comparator !\u003d null) {\n-            try {\n-                collection.setComparator((Comparator) comparator.newInstance());\n-            } catch (ClassCastException e) {\n-                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n-            } catch (Exception e) {\n-                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n-            }\n-        }\n-    } else {\n-        if (hasToBeSorted) {\n-            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n-        }\n-    }\n+    applySortingAndOrdering(collection);\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "05c36793730fb1b4e3d08c731998c7649c9b34ef": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7138 - Hibernate implements JPA @OneToMany collection versioning incorrectly\n",
      "commitDate": "2012/3/8 上午10:40",
      "commitName": "05c36793730fb1b4e3d08c731998c7649c9b34ef",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012/3/6 上午12:24",
      "commitNameOld": "36c135ab6619cc56af293060c0216e924e16b187",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 399,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,110 +1,110 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     if (explicitType !\u003d null) {\n         final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n         if (typeDef \u003d\u003d null) {\n             collection.setTypeName(explicitType);\n             collection.setTypeParameters(explicitTypeParameters);\n         } else {\n             collection.setTypeName(typeDef.getTypeClass());\n             collection.setTypeParameters(typeDef.getParameters());\n         }\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n-    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n-    if (lockAnn !\u003d null)\n-        collection.setOptimisticLocked(!lockAnn.excluded());\n+    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n+    final OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n+    final boolean includeInOptimisticLockChecks \u003d (lockAnn !\u003d null) ? !lockAnn.excluded() : !isMappedBy;\n+    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n-    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d7d9f0dfb207cb8238ea2962fee81708942fa368": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4417 - Add annotation support for UserCollectionType\n",
      "commitDate": "2012/3/3 上午3:17",
      "commitName": "d7d9f0dfb207cb8238ea2962fee81708942fa368",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/10/27 上午6:24",
      "commitNameOld": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthorOld": "Sanne Grinovero",
      "daysBetweenCommits": 127.87,
      "commitsBetweenForRepo": 349,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType !\u003d null) {\n        final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n        if (typeDef \u003d\u003d null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 388,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,110 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n+    if (explicitType !\u003d null) {\n+        final TypeDef typeDef \u003d mappings.getTypeDef(explicitType);\n+        if (typeDef \u003d\u003d null) {\n+            collection.setTypeName(explicitType);\n+            collection.setTypeParameters(explicitTypeParameters);\n+        } else {\n+            collection.setTypeName(typeDef.getTypeClass());\n+            collection.setTypeParameters(typeDef.getParameters());\n+        }\n+    }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ffb14b28b72c67dc2d658bfeb89545ca16eb3399": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6368 remove deprecated hibernate annotations\n",
      "commitDate": "2011/6/28 下午4:29",
      "commitName": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2011/5/5 上午6:15",
      "commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 54.43,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 371,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,100 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n-    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n+    if (property.isAnnotationPresent(MapKeyColumn.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n-    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n+    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb44ad936d8d54d311ecbaea1633683a8d809d04": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6196 - Split org.hibernate.engine package into api/spi/internal\n",
      "commitDate": "2011/5/5 上午6:15",
      "commitName": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/4/12 下午10:07",
      "commitNameOld": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 22.34,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 372,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,100 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n-        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n+        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n-        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n+        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n-        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n+        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n-        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n+        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ddfcc44d760938578771cb6ce24c809c980c8b8b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5916 - Add support for a programmatic way to define a default EntityPersister and CollectionPersister class implementation\n",
      "commitDate": "2011/3/5 上午5:37",
      "commitName": "ddfcc44d760938578771cb6ce24c809c980c8b8b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/2/15 上午2:20",
      "commitNameOld": "e18799b03611ef8dc37690585de984f63b35bc34",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 18.14,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 374,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,107 +1,99 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n-    } else {\n-        final PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n-        if (persisterClassProvider !\u003d null) {\n-            final Class\u003c? extends CollectionPersister\u003e persister \u003d persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n-            if (persister !\u003d null) {\n-                collection.setCollectionPersisterClass(persister);\n-            }\n-        }\n     }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ffba763cf6645e722a2deeea552f998ec7dc22a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5916 Use PersisterClassProvider in Binders\n",
      "commitDate": "2011/2/24 上午5:33",
      "commitName": "4ffba763cf6645e722a2deeea552f998ec7dc22a",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2011/2/9 上午3:55",
      "commitNameOld": "8c806d361d63764e8523006944dde52aff70532c",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 15.07,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    } else {\n        final PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n        if (persisterClassProvider !\u003d null) {\n            final Class\u003c? extends CollectionPersister\u003e persister \u003d persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n            if (persister !\u003d null) {\n                collection.setCollectionPersisterClass(persister);\n            }\n        }\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 372,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,99 +1,108 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n     LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n-    if (persisterAnn !\u003d null)\n+    if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n+    } else {\n+        final PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n+        if (persisterClassProvider !\u003d null) {\n+            final Class\u003c? extends CollectionPersister\u003e persister \u003d persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n+            if (persister !\u003d null) {\n+                collection.setCollectionPersisterClass(persister);\n+            }\n+        }\n+    }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e18799b03611ef8dc37690585de984f63b35bc34": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5916 Use PersisterClassProvider in Binders\n",
      "commitDate": "2011/2/15 上午2:20",
      "commitName": "e18799b03611ef8dc37690585de984f63b35bc34",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/10/12 上午3:41",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 125.94,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    } else {\n        final PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n        if (persisterClassProvider !\u003d null) {\n            final Class\u003c? extends CollectionPersister\u003e persister \u003d persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n            if (persister !\u003d null) {\n                collection.setCollectionPersisterClass(persister);\n            }\n        }\n    }\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 375,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,107 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n-    if (persisterAnn !\u003d null)\n+    if (persisterAnn !\u003d null) {\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n+    } else {\n+        final PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n+        if (persisterClassProvider !\u003d null) {\n+            final Class\u003c? extends CollectionPersister\u003e persister \u003d persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n+            if (persister !\u003d null) {\n+                collection.setCollectionPersisterClass(persister);\n+            }\n+        }\n+    }\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c806d361d63764e8523006944dde52aff70532c": {
      "type": "Ybodychange",
      "commitMessage": "Changes from requests at Hibernate meeting: message codes, use XXXf methods for debug and trace, use @Cause\n",
      "commitDate": "2011/2/9 上午3:55",
      "commitName": "8c806d361d63764e8523006944dde52aff70532c",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011/1/19 上午6:00",
      "commitNameOld": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 20.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 370,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,99 +1,99 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n-    LOG.debug(\"Collection role: \" + role);\n+    LOG.debugf(\"Collection role: %s\", role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": {
      "type": "Ybodychange",
      "commitMessage": "Give each project a single logger\n",
      "commitDate": "2011/1/19 上午6:00",
      "commitName": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011/1/19 上午5:35",
      "commitNameOld": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debug(\"Collection role: \" + role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 371,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,99 +1,99 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n-    LOG.collectionRole(role);\n+    LOG.debug(\"Collection role: \" + role);\n     collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011/1/19 上午5:35",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010/10/12 上午3:41",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.collectionRole(role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 376,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,99 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n-    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n-    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n+    String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n+    LOG.collectionRole(role);\n+    collection.setRole(role);\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010/10/12 上午3:41",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/10/12 上午2:51",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 373,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
      }
    },
    "7419fc298dab9afe82fbdbb8b64854fa37f60817": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5205 - Renamed BinderHelper.isDefault() to BinderHelper.isEmptyAnnotationValue() , because this describes better what the function does. Also renamed VersionTest to OptimisitcLockAnnotationTest to better describe what gets tested.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20741 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/9/29 上午12:32",
      "commitName": "7419fc298dab9afe82fbdbb8b64854fa37f60817",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010/8/13 上午3:13",
      "commitNameOld": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 46.89,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 373,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n-    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n+    boolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/7/9 上午7:41",
      "commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/7/9 上午1:32",
      "commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 373,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
        "newPath": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
      }
    },
    "8577a68e69d30d9e671024bf3330616000a3ec54": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4529 clean @Id/@EmbeddedId mapping and merge with the regular basic and component mapping to open possibilities for @Id @ManyToOne support\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18600 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/22 上午1:51",
      "commitName": "8577a68e69d30d9e671024bf3330616000a3ec54",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/13 上午2:48",
      "commitNameOld": "b1f925458eeb636897bf8a053712ed25fff39054",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 8.96,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 367,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n     if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n-    Property prop \u003d binder.make();\n+    Property prop \u003d binder.makeProperty();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1f925458eeb636897bf8a053712ed25fff39054": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4782 supports @AssociationOverride.joinTable\nHHH-4679 add tests for dot notations in @AssocuiationOverride\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18518 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/13 上午2:48",
      "commitName": "b1f925458eeb636897bf8a053712ed25fff39054",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/9 上午12:58",
      "commitNameOld": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 4.08,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 367,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n-    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || property.isAnnotationPresent(JoinTable.class))) {\n+    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) !\u003d null)) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e44b5f197d77e1d1a847cd04eaa0d25254362483": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4771 @ElementCollection fk column should default to entityName_columnNameOfOwningId\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18455 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/9 上午12:58",
      "commitName": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/8 上午1:41",
      "commitNameOld": "9ef2317e28887cf48d8fb96775b24ec832386d3f",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || property.isAnnotationPresent(JoinTable.class))) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 367,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n-    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinTable.class))) {\n+    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || property.isAnnotationPresent(JoinTable.class))) {\n         String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n         message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         throw new AnnotationException(message);\n     }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "658df91a5e308fd1d97cec62acf6110143012592": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4283 fix the incorrect test case and add a proper exception when the user error occurs\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18421 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/7 上午1:28",
      "commitName": "658df91a5e308fd1d97cec62acf6110143012592",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/7 上午12:59",
      "commitNameOld": "71d9459a20c4f769a205b70537fe416bd992e76e",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinTable.class))) {\n        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 366,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,93 +1,98 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n+    if (isMappedBy \u0026\u0026 (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinTable.class))) {\n+        String message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n+        message +\u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n+        throw new AnnotationException(message);\n+    }\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/12/18 上午5:14",
      "commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009/10/29 上午2:14",
      "commitNameOld": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 50.12,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 349,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,93 +1,93 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     if (inheritanceStatePerClass \u003d\u003d null)\n         throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n-    binder.setPropertyAccessorName(propertyAccessorName);\n+    binder.setAccessType(accessType);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n     if (!declaringClassSet)\n         throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n     propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7c6981a558e35f01ff8d27938e98aa83896765c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4533 add representation for @MappedSuperclass in the Hibernate Core metamodel and properly populate this model extension in Hibernate Annotations\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17871 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/10/29 上午2:14",
      "commitName": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009/7/23 上午4:40",
      "commitNameOld": "eeb136fa719fe007158d90ba011473ea7d1fa38b",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 97.9,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    if (inheritanceStatePerClass \u003d\u003d null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 350,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,89 +1,93 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n+    if (inheritanceStatePerClass \u003d\u003d null)\n+        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setPropertyAccessorName(propertyAccessorName);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n-    propertyHolder.addProperty(prop);\n+    if (!declaringClassSet)\n+        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n+    propertyHolder.addProperty(prop, declaringClass);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "20d22941c0e07b37295704d5300a7071e48e640d": {
      "type": "Ybodychange",
      "commitMessage": "ANN-856 implement @MapKeyColumn\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17173 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/7/21 上午10:07",
      "commitName": "20d22941c0e07b37295704d5300a7071e48e640d",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009/5/8 上午5:34",
      "commitNameOld": "11668ca67c916595d2789787e37b3ed1affc1aa8",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 74.19,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    propertyHolder.addProperty(prop);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 335,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,89 +1,89 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n-    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n-        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n+    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n+        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n     if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setPropertyAccessorName(propertyAccessorName);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n     propertyHolder.addProperty(prop);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "11668ca67c916595d2789787e37b3ed1affc1aa8": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3906 EJB-436 ANN-830 Move to JPA 2 API as a dependency\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@16523 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/5/8 上午5:34",
      "commitName": "11668ca67c916595d2789787e37b3ed1affc1aa8",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2008/10/29 上午5:41",
      "commitNameOld": "513c71de5c5c6fb65bbc2a191ab7a9e565e304d5",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 190.99,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    propertyHolder.addProperty(prop);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 334,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,89 +1,89 @@\n public void bind() {\n     this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n     log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     collection.setNodeName(propertyName);\n     if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n         throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n     }\n     defineFetchingStrategy();\n     collection.setBatchSize(batchSize);\n     if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n         throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n     }\n     collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n     OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n     if (lockAnn !\u003d null)\n         collection.setOptimisticLocked(!lockAnn.excluded());\n     Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n     if (persisterAnn !\u003d null)\n         collection.setCollectionPersisterClass(persisterAnn.impl());\n     if (orderBy !\u003d null)\n         collection.setOrderBy(orderBy);\n     if (isSorted) {\n         collection.setSorted(true);\n         if (comparator !\u003d null) {\n             try {\n                 collection.setComparator((Comparator) comparator.newInstance());\n             } catch (ClassCastException e) {\n                 throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             } catch (Exception e) {\n                 throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n             }\n         }\n     } else {\n         if (hasToBeSorted) {\n             throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n         }\n     }\n     if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n         collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n         collection.setCacheRegionName(cacheRegionName);\n     }\n     SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n     SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n     SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n     SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n     Loader loader \u003d property.getAnnotation(Loader.class);\n     if (sqlInsert !\u003d null) {\n         collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n     }\n     if (sqlUpdate !\u003d null) {\n         collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n     }\n     if (sqlDelete !\u003d null) {\n         collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n     }\n     if (sqlDeleteAll !\u003d null) {\n         collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n     }\n     if (loader !\u003d null) {\n         collection.setLoaderName(loader.namedQuery());\n     }\n     boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n     collection.setInverse(isMappedBy);\n     if (!oneToMany \u0026\u0026 isMappedBy) {\n         mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n     }\n     XClass collectionType \u003d getCollectionType();\n     SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n-    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class)) {\n+    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n         mappings.addSecondPass(sp, !isMappedBy);\n     } else {\n         mappings.addSecondPass(sp, !isMappedBy);\n     }\n     mappings.addCollection(collection);\n     PropertyBinder binder \u003d new PropertyBinder();\n     binder.setName(propertyName);\n     binder.setValue(collection);\n     binder.setCascade(cascadeStrategy);\n     if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n         collection.setOrphanDelete(true);\n     }\n     binder.setPropertyAccessorName(propertyAccessorName);\n     binder.setProperty(property);\n     binder.setInsertable(insertable);\n     binder.setUpdatable(updatable);\n     Property prop \u003d binder.make();\n     propertyHolder.addProperty(prop);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/29 上午2:53",
      "commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008/10/29 上午2:52",
      "commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    propertyHolder.addProperty(prop);\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 310,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/java/org/hibernate/cfg/annotations/CollectionBinder.java",
        "newPath": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
      }
    },
    "7337743c93574823424ed6c399cfcf6bd75614f8": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/29 上午2:41",
      "commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,89 @@\n+public void bind() {\n+    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n+    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n+    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n+    collection.setNodeName(propertyName);\n+    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n+        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n+    }\n+    defineFetchingStrategy();\n+    collection.setBatchSize(batchSize);\n+    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n+        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n+    }\n+    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n+    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n+    if (lockAnn !\u003d null)\n+        collection.setOptimisticLocked(!lockAnn.excluded());\n+    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n+    if (persisterAnn !\u003d null)\n+        collection.setCollectionPersisterClass(persisterAnn.impl());\n+    if (orderBy !\u003d null)\n+        collection.setOrderBy(orderBy);\n+    if (isSorted) {\n+        collection.setSorted(true);\n+        if (comparator !\u003d null) {\n+            try {\n+                collection.setComparator((Comparator) comparator.newInstance());\n+            } catch (ClassCastException e) {\n+                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n+            } catch (Exception e) {\n+                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n+            }\n+        }\n+    } else {\n+        if (hasToBeSorted) {\n+            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n+        }\n+    }\n+    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n+        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n+        collection.setCacheRegionName(cacheRegionName);\n+    }\n+    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n+    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n+    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n+    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n+    Loader loader \u003d property.getAnnotation(Loader.class);\n+    if (sqlInsert !\u003d null) {\n+        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n+    }\n+    if (sqlUpdate !\u003d null) {\n+        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n+    }\n+    if (sqlDelete !\u003d null) {\n+        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n+    }\n+    if (sqlDeleteAll !\u003d null) {\n+        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n+    }\n+    if (loader !\u003d null) {\n+        collection.setLoaderName(loader.namedQuery());\n+    }\n+    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n+    collection.setInverse(isMappedBy);\n+    if (!oneToMany \u0026\u0026 isMappedBy) {\n+        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n+    }\n+    XClass collectionType \u003d getCollectionType();\n+    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n+    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class)) {\n+        mappings.addSecondPass(sp, !isMappedBy);\n+    } else {\n+        mappings.addSecondPass(sp, !isMappedBy);\n+    }\n+    mappings.addCollection(collection);\n+    PropertyBinder binder \u003d new PropertyBinder();\n+    binder.setName(propertyName);\n+    binder.setValue(collection);\n+    binder.setCascade(cascadeStrategy);\n+    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n+        collection.setOrphanDelete(true);\n+    }\n+    binder.setPropertyAccessorName(propertyAccessorName);\n+    binder.setProperty(property);\n+    binder.setInsertable(insertable);\n+    binder.setUpdatable(updatable);\n+    Property prop \u003d binder.make();\n+    propertyHolder.addProperty(prop);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void bind() {\n    this.collection \u003d createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) \u0026\u0026 mapKeyPropertyName !\u003d null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn \u003d property.getAnnotation(OptimisticLock.class);\n    if (lockAnn !\u003d null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn \u003d property.getAnnotation(Persister.class);\n    if (persisterAnn !\u003d null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy !\u003d null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator !\u003d null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert \u003d property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate \u003d property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete \u003d property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll \u003d property.getAnnotation(SQLDeleteAll.class);\n    Loader loader \u003d property.getAnnotation(Loader.class);\n    if (sqlInsert !\u003d null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate !\u003d null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete !\u003d null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll !\u003d null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader !\u003d null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy \u003d !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany \u0026\u0026 isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType \u003d getCollectionType();\n    SecondPass sp \u003d getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder \u003d new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf(\"delete-orphan\") \u003e\u003d 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop \u003d binder.make();\n    propertyHolder.addProperty(prop);\n}",
      "path": "annotations/src/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 310,
      "functionName": "bind",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}