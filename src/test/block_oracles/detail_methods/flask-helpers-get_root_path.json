{
  "origin": "codeshovel",
  "repositoryName": "flask",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/flask/.git",
  "startCommitName": "980168d08498c00a14ab0f687ffac8cc50edb326",
  "sourceFileName": "helpers.py",
  "functionName": "get_root_path",
  "functionId": "__get_root_path___import_name",
  "sourceFilePath": "src/flask/helpers.py",
  "functionAnnotation": "",
  "functionStartLine": 786,
  "functionEndLine": 833,
  "numCommitsSeen": 358,
  "timeTaken": 5007,
  "changeHistory": [
    "ca278a8694f42e569a6d9f7d71c669465019bf06",
    "025589ee766249652e2e097da05808fe64911ddc",
    "52fa195d459a70f8ef73e954b20a9512b2f5001b",
    "d4b3d16c142e2189c6faf8f784a195e7f827c596",
    "8071f11328ab2b767608c5c63d0bad72d9408120",
    "a3b30b7e3b026e821716be63d586e078eaa6ee7f",
    "d16491145dc553bc30aa9c71fb3647fda8d23534",
    "1d6f86bc87253c1dc1cf0c156f421214c38c3202",
    "c3844d11026f84400d5a088dd5c24c6a4a04dcd1",
    "175d43b2f9c7825b0df4c1049ab571cb1877a807",
    "d0dc89ea802130e8a3a16b4fba73fa10815c09fb"
  ],
  "changeHistoryShort": {
    "ca278a8694f42e569a6d9f7d71c669465019bf06": "Yfilerename",
    "025589ee766249652e2e097da05808fe64911ddc": "Ybodychange",
    "52fa195d459a70f8ef73e954b20a9512b2f5001b": "Ybodychange",
    "d4b3d16c142e2189c6faf8f784a195e7f827c596": "Ybodychange",
    "8071f11328ab2b767608c5c63d0bad72d9408120": "Ybodychange",
    "a3b30b7e3b026e821716be63d586e078eaa6ee7f": "Ybodychange",
    "d16491145dc553bc30aa9c71fb3647fda8d23534": "Ybodychange",
    "1d6f86bc87253c1dc1cf0c156f421214c38c3202": "Ymultichange(Yparameterchange,Ybodychange)",
    "c3844d11026f84400d5a088dd5c24c6a4a04dcd1": "Ymultichange(Yrename,Ybodychange)",
    "175d43b2f9c7825b0df4c1049ab571cb1877a807": "Yrename",
    "d0dc89ea802130e8a3a16b4fba73fa10815c09fb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ca278a8694f42e569a6d9f7d71c669465019bf06": {
      "type": "Yfilerename",
      "commitMessage": "move to src directory\n",
      "commitDate": "2019/6/1 下午11:06",
      "commitName": "ca278a8694f42e569a6d9f7d71c669465019bf06",
      "commitAuthor": "David Lord",
      "commitDateOld": "2019/6/1 下午9:53",
      "commitNameOld": "09392e0348e22dcac63973dd25ac10afc90230dd",
      "commitAuthorOld": "David Lord",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod \u003d sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \"__file__\"):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader \u003d pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we\u0027re referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name \u003d\u003d \"__main__\":\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \"get_filename\"):\n        filepath \u003d loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod \u003d sys.modules[import_name]\n        filepath \u003d getattr(mod, \"__file__\", None)\n\n        # If we don\u0027t have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided \"\n                \u0027module \"%s\".  This can happen because the \u0027\n                \"module came from an import hook that does \"\n                \"not provide file name information or because \"\n                \"it\u0027s a namespace package.  In this case \"\n                \"the root path needs to be explicitly \"\n                \"provided.\" % import_name\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n",
      "path": "src/flask/helpers.py",
      "functionStartLine": 768,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "flask/helpers.py",
        "newPath": "src/flask/helpers.py"
      }
    },
    "025589ee766249652e2e097da05808fe64911ddc": {
      "type": "Ybodychange",
      "commitMessage": "Reformat with black\n\nhttps://github.com/python/black\n",
      "commitDate": "2019/5/7 上午4:28",
      "commitName": "025589ee766249652e2e097da05808fe64911ddc",
      "commitAuthor": "David Baumgold",
      "commitDateOld": "2019/1/8 上午2:00",
      "commitNameOld": "a74864ec229141784374f1998324d2cbac837295",
      "commitAuthorOld": "",
      "daysBetweenCommits": 119.1,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod \u003d sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \"__file__\"):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader \u003d pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we\u0027re referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name \u003d\u003d \"__main__\":\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \"get_filename\"):\n        filepath \u003d loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod \u003d sys.modules[import_name]\n        filepath \u003d getattr(mod, \"__file__\", None)\n\n        # If we don\u0027t have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided \"\n                \u0027module \"%s\".  This can happen because the \u0027\n                \"module came from an import hook that does \"\n                \"not provide file name information or because \"\n                \"it\u0027s a namespace package.  In this case \"\n                \"the root path needs to be explicitly \"\n                \"provided.\" % import_name\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 765,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "@@ -1,45 +1,47 @@\n def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n     # Module already imported and has a file attribute.  Use that first.\n     mod \u003d sys.modules.get(import_name)\n-    if mod is not None and hasattr(mod, \u0027__file__\u0027):\n+    if mod is not None and hasattr(mod, \"__file__\"):\n         return os.path.dirname(os.path.abspath(mod.__file__))\n \n     # Next attempt: check the loader.\n     loader \u003d pkgutil.get_loader(import_name)\n \n     # Loader does not exist or we\u0027re referring to an unloaded main module\n     # or a main module without path (interactive sessions), go with the\n     # current working directory.\n-    if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n+    if loader is None or import_name \u003d\u003d \"__main__\":\n         return os.getcwd()\n \n     # For .egg, zipimporter does not have get_filename until Python 2.7.\n     # Some other loaders might exhibit the same behavior.\n-    if hasattr(loader, \u0027get_filename\u0027):\n+    if hasattr(loader, \"get_filename\"):\n         filepath \u003d loader.get_filename(import_name)\n     else:\n         # Fall back to imports.\n         __import__(import_name)\n         mod \u003d sys.modules[import_name]\n-        filepath \u003d getattr(mod, \u0027__file__\u0027, None)\n+        filepath \u003d getattr(mod, \"__file__\", None)\n \n         # If we don\u0027t have a filepath it might be because we are a\n         # namespace package.  In this case we pick the root path from the\n         # first module that is contained in our package.\n         if filepath is None:\n-            raise RuntimeError(\u0027No root path can be found for the provided \u0027\n-                               \u0027module \"%s\".  This can happen because the \u0027\n-                               \u0027module came from an import hook that does \u0027\n-                               \u0027not provide file name information or because \u0027\n-                               \u0027it\\\u0027s a namespace package.  In this case \u0027\n-                               \u0027the root path needs to be explicitly \u0027\n-                               \u0027provided.\u0027 % import_name)\n+            raise RuntimeError(\n+                \"No root path can be found for the provided \"\n+                \u0027module \"%s\".  This can happen because the \u0027\n+                \"module came from an import hook that does \"\n+                \"not provide file name information or because \"\n+                \"it\u0027s a namespace package.  In this case \"\n+                \"the root path needs to be explicitly \"\n+                \"provided.\" % import_name\n+            )\n \n     # filepath is import_name.py for a module, or __init__.py for a package.\n     return os.path.dirname(os.path.abspath(filepath))\n \n",
      "extendedDetails": {}
    },
    "52fa195d459a70f8ef73e954b20a9512b2f5001b": {
      "type": "Ybodychange",
      "commitMessage": "few mispelling errors\n",
      "commitDate": "2014/4/23 下午10:46",
      "commitName": "52fa195d459a70f8ef73e954b20a9512b2f5001b",
      "commitAuthor": "Carlos E. Garcia",
      "commitDateOld": "2014/4/12 上午1:59",
      "commitNameOld": "d4b3d16c142e2189c6faf8f784a195e7f827c596",
      "commitAuthorOld": "Armin Ronacher",
      "daysBetweenCommits": 11.87,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod \u003d sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \u0027__file__\u0027):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader \u003d pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we\u0027re referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \u0027get_filename\u0027):\n        filepath \u003d loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod \u003d sys.modules[import_name]\n        filepath \u003d getattr(mod, \u0027__file__\u0027, None)\n\n        # If we don\u0027t have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\u0027No root path can be found for the provided \u0027\n                               \u0027module \"%s\".  This can happen because the \u0027\n                               \u0027module came from an import hook that does \u0027\n                               \u0027not provide file name information or because \u0027\n                               \u0027it\\\u0027s a namespace package.  In this case \u0027\n                               \u0027the root path needs to be explicitly \u0027\n                               \u0027provided.\u0027 % import_name)\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 626,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "@@ -1,45 +1,45 @@\n def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n     # Module already imported and has a file attribute.  Use that first.\n     mod \u003d sys.modules.get(import_name)\n     if mod is not None and hasattr(mod, \u0027__file__\u0027):\n         return os.path.dirname(os.path.abspath(mod.__file__))\n \n     # Next attempt: check the loader.\n     loader \u003d pkgutil.get_loader(import_name)\n \n     # Loader does not exist or we\u0027re referring to an unloaded main module\n     # or a main module without path (interactive sessions), go with the\n     # current working directory.\n     if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n         return os.getcwd()\n \n     # For .egg, zipimporter does not have get_filename until Python 2.7.\n     # Some other loaders might exhibit the same behavior.\n     if hasattr(loader, \u0027get_filename\u0027):\n         filepath \u003d loader.get_filename(import_name)\n     else:\n         # Fall back to imports.\n         __import__(import_name)\n         mod \u003d sys.modules[import_name]\n         filepath \u003d getattr(mod, \u0027__file__\u0027, None)\n \n         # If we don\u0027t have a filepath it might be because we are a\n         # namespace package.  In this case we pick the root path from the\n         # first module that is contained in our package.\n         if filepath is None:\n             raise RuntimeError(\u0027No root path can be found for the provided \u0027\n                                \u0027module \"%s\".  This can happen because the \u0027\n                                \u0027module came from an import hook that does \u0027\n                                \u0027not provide file name information or because \u0027\n                                \u0027it\\\u0027s a namespace package.  In this case \u0027\n-                               \u0027the root path needs to be explictly \u0027\n+                               \u0027the root path needs to be explicitly \u0027\n                                \u0027provided.\u0027 % import_name)\n \n     # filepath is import_name.py for a module, or __init__.py for a package.\n     return os.path.dirname(os.path.abspath(filepath))\n \n",
      "extendedDetails": {}
    },
    "d4b3d16c142e2189c6faf8f784a195e7f827c596": {
      "type": "Ybodychange",
      "commitMessage": "Better support for namespace packages.\n",
      "commitDate": "2014/4/12 上午1:59",
      "commitName": "d4b3d16c142e2189c6faf8f784a195e7f827c596",
      "commitAuthor": "Armin Ronacher",
      "commitDateOld": "2014/4/11 下午7:31",
      "commitNameOld": "a293b99b219c13ea94b33a2470a545e07c73b804",
      "commitAuthorOld": "Armin Ronacher",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod \u003d sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \u0027__file__\u0027):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader \u003d pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we\u0027re referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \u0027get_filename\u0027):\n        filepath \u003d loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod \u003d sys.modules[import_name]\n        filepath \u003d getattr(mod, \u0027__file__\u0027, None)\n\n        # If we don\u0027t have a filepath it might be because we are a\n        # namespace package.  In this case we pick the root path from the\n        # first module that is contained in our package.\n        if filepath is None:\n            raise RuntimeError(\u0027No root path can be found for the provided \u0027\n                               \u0027module \"%s\".  This can happen because the \u0027\n                               \u0027module came from an import hook that does \u0027\n                               \u0027not provide file name information or because \u0027\n                               \u0027it\\\u0027s a namespace package.  In this case \u0027\n                               \u0027the root path needs to be explictly \u0027\n                               \u0027provided.\u0027 % import_name)\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 626,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "@@ -1,32 +1,45 @@\n def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n     # Module already imported and has a file attribute.  Use that first.\n     mod \u003d sys.modules.get(import_name)\n     if mod is not None and hasattr(mod, \u0027__file__\u0027):\n         return os.path.dirname(os.path.abspath(mod.__file__))\n \n     # Next attempt: check the loader.\n     loader \u003d pkgutil.get_loader(import_name)\n \n     # Loader does not exist or we\u0027re referring to an unloaded main module\n     # or a main module without path (interactive sessions), go with the\n     # current working directory.\n     if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n         return os.getcwd()\n \n     # For .egg, zipimporter does not have get_filename until Python 2.7.\n     # Some other loaders might exhibit the same behavior.\n     if hasattr(loader, \u0027get_filename\u0027):\n         filepath \u003d loader.get_filename(import_name)\n     else:\n         # Fall back to imports.\n         __import__(import_name)\n-        filepath \u003d sys.modules[import_name].__file__\n+        mod \u003d sys.modules[import_name]\n+        filepath \u003d getattr(mod, \u0027__file__\u0027, None)\n+\n+        # If we don\u0027t have a filepath it might be because we are a\n+        # namespace package.  In this case we pick the root path from the\n+        # first module that is contained in our package.\n+        if filepath is None:\n+            raise RuntimeError(\u0027No root path can be found for the provided \u0027\n+                               \u0027module \"%s\".  This can happen because the \u0027\n+                               \u0027module came from an import hook that does \u0027\n+                               \u0027not provide file name information or because \u0027\n+                               \u0027it\\\u0027s a namespace package.  In this case \u0027\n+                               \u0027the root path needs to be explictly \u0027\n+                               \u0027provided.\u0027 % import_name)\n \n     # filepath is import_name.py for a module, or __init__.py for a package.\n     return os.path.dirname(os.path.abspath(filepath))\n \n",
      "extendedDetails": {}
    },
    "8071f11328ab2b767608c5c63d0bad72d9408120": {
      "type": "Ybodychange",
      "commitMessage": "Fixed an issue with the new path finding logic\n",
      "commitDate": "2012/6/26 下午11:18",
      "commitName": "8071f11328ab2b767608c5c63d0bad72d9408120",
      "commitAuthor": "Armin Ronacher",
      "commitDateOld": "2012/5/8 下午6:56",
      "commitNameOld": "2053d04db0f303430f5f6c5bc6e97b8bec46c399",
      "commitAuthorOld": "Armin Ronacher",
      "daysBetweenCommits": 49.18,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    # Module already imported and has a file attribute.  Use that first.\n    mod \u003d sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, \u0027__file__\u0027):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader \u003d pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we\u0027re referring to an unloaded main module\n    # or a main module without path (interactive sessions), go with the\n    # current working directory.\n    if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n        return os.getcwd()\n\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    # Some other loaders might exhibit the same behavior.\n    if hasattr(loader, \u0027get_filename\u0027):\n        filepath \u003d loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        filepath \u003d sys.modules[import_name].__file__\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 613,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "@@ -1,20 +1,32 @@\n def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n+    # Module already imported and has a file attribute.  Use that first.\n+    mod \u003d sys.modules.get(import_name)\n+    if mod is not None and hasattr(mod, \u0027__file__\u0027):\n+        return os.path.dirname(os.path.abspath(mod.__file__))\n+\n+    # Next attempt: check the loader.\n     loader \u003d pkgutil.get_loader(import_name)\n+\n+    # Loader does not exist or we\u0027re referring to an unloaded main module\n+    # or a main module without path (interactive sessions), go with the\n+    # current working directory.\n     if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n-        # import name is not found, or interactive/main module\n         return os.getcwd()\n+\n     # For .egg, zipimporter does not have get_filename until Python 2.7.\n+    # Some other loaders might exhibit the same behavior.\n     if hasattr(loader, \u0027get_filename\u0027):\n         filepath \u003d loader.get_filename(import_name)\n     else:\n         # Fall back to imports.\n         __import__(import_name)\n         filepath \u003d sys.modules[import_name].__file__\n+\n     # filepath is import_name.py for a module, or __init__.py for a package.\n     return os.path.dirname(os.path.abspath(filepath))\n \n",
      "extendedDetails": {}
    },
    "a3b30b7e3b026e821716be63d586e078eaa6ee7f": {
      "type": "Ybodychange",
      "commitMessage": "Handle zip \u0026 interactive cases in module helpers.\n",
      "commitDate": "2012/1/8 上午6:54",
      "commitName": "a3b30b7e3b026e821716be63d586e078eaa6ee7f",
      "commitAuthor": "Ron DuPlain",
      "commitDateOld": "2012/1/8 上午6:52",
      "commitNameOld": "d16491145dc553bc30aa9c71fb3647fda8d23534",
      "commitAuthorOld": "Ron DuPlain",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    loader \u003d pkgutil.get_loader(import_name)\n    if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n        # import name is not found, or interactive/main module\n        return os.getcwd()\n    # For .egg, zipimporter does not have get_filename until Python 2.7.\n    if hasattr(loader, \u0027get_filename\u0027):\n        filepath \u003d loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        filepath \u003d sys.modules[import_name].__file__\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 491,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "@@ -1,13 +1,20 @@\n def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n     loader \u003d pkgutil.get_loader(import_name)\n-    if loader is None:\n+    if loader is None or import_name \u003d\u003d \u0027__main__\u0027:\n+        # import name is not found, or interactive/main module\n         return os.getcwd()\n-    filepath \u003d os.path.abspath(loader.get_filename(import_name))\n-    # filepath for import_name.py for a module, or __init__.py for a package.\n-    return os.path.dirname(filepath)\n+    # For .egg, zipimporter does not have get_filename until Python 2.7.\n+    if hasattr(loader, \u0027get_filename\u0027):\n+        filepath \u003d loader.get_filename(import_name)\n+    else:\n+        # Fall back to imports.\n+        __import__(import_name)\n+        filepath \u003d sys.modules[import_name].__file__\n+    # filepath is import_name.py for a module, or __init__.py for a package.\n+    return os.path.dirname(os.path.abspath(filepath))\n \n",
      "extendedDetails": {}
    },
    "d16491145dc553bc30aa9c71fb3647fda8d23534": {
      "type": "Ybodychange",
      "commitMessage": "Update module helpers to avoid Python imports.\n\nThis avoids errors in creating Flask instances where there are import\nerrors in the module or package matching the import name.  Those runtime\nerrors will be apparent to the user soon enough, but tools which build\nFlask instances meta-programmatically benefit from a Flask which does\nnot __import__.\n",
      "commitDate": "2012/1/8 上午6:52",
      "commitName": "d16491145dc553bc30aa9c71fb3647fda8d23534",
      "commitAuthor": "Ron DuPlain",
      "commitDateOld": "2011/11/4 上午9:46",
      "commitNameOld": "f52e7a9dc944f425c2f2a77706bc2af98b23295c",
      "commitAuthorOld": "Armin Ronacher",
      "daysBetweenCommits": 64.88,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    loader \u003d pkgutil.get_loader(import_name)\n    if loader is None:\n        return os.getcwd()\n    filepath \u003d os.path.abspath(loader.get_filename(import_name))\n    # filepath for import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(filepath)\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 491,
      "functionName": "get_root_path",
      "functionAnnotation": "",
      "diff": "@@ -1,15 +1,13 @@\n def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n-    __import__(import_name)\n-    try:\n-        directory \u003d os.path.dirname(sys.modules[import_name].__file__)\n-        return os.path.abspath(directory)\n-    except AttributeError:\n-        # this is necessary in case we are running from the interactive\n-        # python shell.  It will never be used for production code however\n+    loader \u003d pkgutil.get_loader(import_name)\n+    if loader is None:\n         return os.getcwd()\n+    filepath \u003d os.path.abspath(loader.get_filename(import_name))\n+    # filepath for import_name.py for a module, or __init__.py for a package.\n+    return os.path.dirname(filepath)\n \n",
      "extendedDetails": {}
    },
    "1d6f86bc87253c1dc1cf0c156f421214c38c3202": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Updated docstring\n",
      "commitDate": "2011/8/11 上午5:25",
      "commitName": "1d6f86bc87253c1dc1cf0c156f421214c38c3202",
      "commitAuthor": "Armin Ronacher",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Updated docstring\n",
          "commitDate": "2011/8/11 上午5:25",
          "commitName": "1d6f86bc87253c1dc1cf0c156f421214c38c3202",
          "commitAuthor": "Armin Ronacher",
          "commitDateOld": "2011/8/11 上午5:21",
          "commitNameOld": "c3844d11026f84400d5a088dd5c24c6a4a04dcd1",
          "commitAuthorOld": "Armin Ronacher",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    __import__(import_name)\n    try:\n        directory \u003d os.path.dirname(sys.modules[import_name].__file__)\n        return os.path.abspath(directory)\n    except AttributeError:\n        return os.getcwd()\n\n",
          "path": "flask/helpers.py",
          "functionStartLine": 469,
          "functionName": "get_root_path",
          "functionAnnotation": "",
          "diff": "@@ -1,11 +1,13 @@\n-def get_root_path(name):\n+def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n+    __import__(import_name)\n     try:\n-        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n-    except (KeyError, AttributeError):\n+        directory \u003d os.path.dirname(sys.modules[import_name].__file__)\n+        return os.path.abspath(directory)\n+    except AttributeError:\n         return os.getcwd()\n \n",
          "extendedDetails": {
            "oldValue": "[name]",
            "newValue": "[import_name]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Updated docstring\n",
          "commitDate": "2011/8/11 上午5:25",
          "commitName": "1d6f86bc87253c1dc1cf0c156f421214c38c3202",
          "commitAuthor": "Armin Ronacher",
          "commitDateOld": "2011/8/11 上午5:21",
          "commitNameOld": "c3844d11026f84400d5a088dd5c24c6a4a04dcd1",
          "commitAuthorOld": "Armin Ronacher",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "def get_root_path(import_name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    __import__(import_name)\n    try:\n        directory \u003d os.path.dirname(sys.modules[import_name].__file__)\n        return os.path.abspath(directory)\n    except AttributeError:\n        return os.getcwd()\n\n",
          "path": "flask/helpers.py",
          "functionStartLine": 469,
          "functionName": "get_root_path",
          "functionAnnotation": "",
          "diff": "@@ -1,11 +1,13 @@\n-def get_root_path(name):\n+def get_root_path(import_name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n     returns the path of a package or the folder that contains a module.\n \n     Not to be confused with the package path returned by :func:`find_package`.\n     \"\"\"\n+    __import__(import_name)\n     try:\n-        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n-    except (KeyError, AttributeError):\n+        directory \u003d os.path.dirname(sys.modules[import_name].__file__)\n+        return os.path.abspath(directory)\n+    except AttributeError:\n         return os.getcwd()\n \n",
          "extendedDetails": {}
        }
      ]
    },
    "c3844d11026f84400d5a088dd5c24c6a4a04dcd1": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "Rename _get_package_path to get_root_path to avoid confusion\n",
      "commitDate": "2011/8/11 上午5:21",
      "commitName": "c3844d11026f84400d5a088dd5c24c6a4a04dcd1",
      "commitAuthor": "Armin Ronacher",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Rename _get_package_path to get_root_path to avoid confusion\n",
          "commitDate": "2011/8/11 上午5:21",
          "commitName": "c3844d11026f84400d5a088dd5c24c6a4a04dcd1",
          "commitAuthor": "Armin Ronacher",
          "commitDateOld": "2011/8/11 上午5:19",
          "commitNameOld": "b3aaf6d5ca4fa53cc78456b2df01ab4d11cec84a",
          "commitAuthorOld": "Armin Ronacher",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "def get_root_path(name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    try:\n        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n    except (KeyError, AttributeError):\n        return os.getcwd()\n\n",
          "path": "flask/helpers.py",
          "functionStartLine": 469,
          "functionName": "get_root_path",
          "functionAnnotation": "",
          "diff": "@@ -1,7 +1,11 @@\n-def get_package_path(name):\n-    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n+def get_root_path(name):\n+    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n+    returns the path of a package or the folder that contains a module.\n+\n+    Not to be confused with the package path returned by :func:`find_package`.\n+    \"\"\"\n     try:\n         return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n     except (KeyError, AttributeError):\n         return os.getcwd()\n \n",
          "extendedDetails": {
            "oldValue": "get_package_path",
            "newValue": "get_root_path"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename _get_package_path to get_root_path to avoid confusion\n",
          "commitDate": "2011/8/11 上午5:21",
          "commitName": "c3844d11026f84400d5a088dd5c24c6a4a04dcd1",
          "commitAuthor": "Armin Ronacher",
          "commitDateOld": "2011/8/11 上午5:19",
          "commitNameOld": "b3aaf6d5ca4fa53cc78456b2df01ab4d11cec84a",
          "commitAuthorOld": "Armin Ronacher",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "def get_root_path(name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n    returns the path of a package or the folder that contains a module.\n\n    Not to be confused with the package path returned by :func:`find_package`.\n    \"\"\"\n    try:\n        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n    except (KeyError, AttributeError):\n        return os.getcwd()\n\n",
          "path": "flask/helpers.py",
          "functionStartLine": 469,
          "functionName": "get_root_path",
          "functionAnnotation": "",
          "diff": "@@ -1,7 +1,11 @@\n-def get_package_path(name):\n-    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n+def get_root_path(name):\n+    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n+    returns the path of a package or the folder that contains a module.\n+\n+    Not to be confused with the package path returned by :func:`find_package`.\n+    \"\"\"\n     try:\n         return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n     except (KeyError, AttributeError):\n         return os.getcwd()\n \n",
          "extendedDetails": {}
        }
      ]
    },
    "175d43b2f9c7825b0df4c1049ab571cb1877a807": {
      "type": "Yrename",
      "commitMessage": "Instance paths are now moved into virtualenv/share/appname-instance if installed\n",
      "commitDate": "2011/8/10 下午11:46",
      "commitName": "175d43b2f9c7825b0df4c1049ab571cb1877a807",
      "commitAuthor": "Armin Ronacher",
      "commitDateOld": "2011/8/10 下午7:55",
      "commitNameOld": "187cb80dcc1b087f1a7b7d4d67afbd531ad01cd2",
      "commitAuthorOld": "Armin Ronacher",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "def get_package_path(name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n    try:\n        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n    except (KeyError, AttributeError):\n        return os.getcwd()\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 469,
      "functionName": "get_package_path",
      "functionAnnotation": "",
      "diff": "@@ -1,7 +1,7 @@\n-def _get_package_path(name):\n+def get_package_path(name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n     try:\n         return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n     except (KeyError, AttributeError):\n         return os.getcwd()\n \n",
      "extendedDetails": {
        "oldValue": "_get_package_path",
        "newValue": "get_package_path"
      }
    },
    "d0dc89ea802130e8a3a16b4fba73fa10815c09fb": {
      "type": "Yintroduced",
      "commitMessage": "in with the new. i have the bits in places where i think they should be, now i just need to work on the import scheme layout",
      "commitDate": "2010/7/3 上午2:20",
      "commitName": "d0dc89ea802130e8a3a16b4fba73fa10815c09fb",
      "commitAuthor": "Justin Quick",
      "diff": "@@ -0,0 +1,8 @@\n+def _get_package_path(name):\n+    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n+    try:\n+        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n+    except (KeyError, AttributeError):\n+        return os.getcwd()\n+\n+\n",
      "actualSource": "def _get_package_path(name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n    try:\n        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n    except (KeyError, AttributeError):\n        return os.getcwd()\n\n\n",
      "path": "flask/helpers.py",
      "functionStartLine": 266,
      "functionName": "_get_package_path",
      "functionAnnotation": ""
    }
  }
}