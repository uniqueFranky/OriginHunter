{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "RevisionInfoConfiguration.java",
  "functionName": "configure",
  "functionId": "configure___metadata-MetadataImplementor__reflectionManager-ReflectionManager",
  "sourceFilePath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 296,
  "functionEndLine": 438,
  "numCommitsSeen": 58,
  "timeTaken": 3144,
  "changeHistory": [
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
    "410a785dfe40ae030bec31c4c06a5a7998f1feeb",
    "b70bc0080e8e206f83debf8f456fe323caccc01b",
    "63a0f03c5ae773f96c92c02fba9d13133d02485b",
    "364a47f2c746a5eeb1642102580a9daa8bc27fc9",
    "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
    "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
    "95ec3457af961c4116015509180dcca04967604f",
    "c4822556c19a6ea2d7be93b505548e834c83d955",
    "45f3ced6daf96f1a697f350e134512562b48d3fd",
    "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
    "403b15cae8d19f83c35c9490826d24b0bf5c2fa0",
    "1878b238503f3b52a6e7b31f849d7253206c7465",
    "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
    "b36b095c3ce32d2981f5780463bbea8d48105f5a",
    "53699cecac7477d64ac3dff6c3a24d5658bfc789",
    "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
    "86c15fd21234381e2cc713d07e9652f01078613d",
    "ac49a906e8566f29767927a0dd8dc6b9328115ab",
    "e21fed8304935dc8a1efeee115a4e720b9d2667b",
    "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
    "558d9469e018962a2b3159561bcc0996ecfc62fc",
    "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
    "f39550fff19a72faec27632409b50970d4d9d2da",
    "4603c8a4dd267aab345ec915b932f736d404daa7",
    "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578",
    "a94515206db0eee8867d399bee6a87aa9e8cb074",
    "90f70231c682e22693f85977497d2dc429ef29da",
    "dd35cf7b1461fc883148b148e5c81731d9c08a35",
    "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b"
  ],
  "changeHistoryShort": {
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": "Ybodychange",
    "410a785dfe40ae030bec31c4c06a5a7998f1feeb": "Ybodychange",
    "b70bc0080e8e206f83debf8f456fe323caccc01b": "Ybodychange",
    "63a0f03c5ae773f96c92c02fba9d13133d02485b": "Ymultichange(Yparameterchange,Ybodychange)",
    "364a47f2c746a5eeb1642102580a9daa8bc27fc9": "Ybodychange",
    "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2": "Ymultichange(Yfilerename,Ybodychange)",
    "6c6df695350f917fe707b4f830e29c8c52c3f5d0": "Ybodychange",
    "95ec3457af961c4116015509180dcca04967604f": "Ybodychange",
    "c4822556c19a6ea2d7be93b505548e834c83d955": "Ybodychange",
    "45f3ced6daf96f1a697f350e134512562b48d3fd": "Ybodychange",
    "13c9fd4f9d177fb7d022c72d674f1a23b909c443": "Ybodychange",
    "403b15cae8d19f83c35c9490826d24b0bf5c2fa0": "Ybodychange",
    "1878b238503f3b52a6e7b31f849d7253206c7465": "Ybodychange",
    "dd55a99b00c447e53fe97bdbc423f3e6d7d59557": "Ybodychange",
    "b36b095c3ce32d2981f5780463bbea8d48105f5a": "Ybodychange",
    "53699cecac7477d64ac3dff6c3a24d5658bfc789": "Ybodychange",
    "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217": "Ybodychange",
    "86c15fd21234381e2cc713d07e9652f01078613d": "Ybodychange",
    "ac49a906e8566f29767927a0dd8dc6b9328115ab": "Ybodychange",
    "e21fed8304935dc8a1efeee115a4e720b9d2667b": "Yfilerename",
    "6c6e6ab193f48ed93d5b76f394e6bef78205921a": "Ymultichange(Ybodychange,Yannotationchange)",
    "558d9469e018962a2b3159561bcc0996ecfc62fc": "Ymultichange(Ybodychange,Yannotationchange)",
    "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09": "Ymultichange(Ybodychange,Yannotationchange)",
    "f39550fff19a72faec27632409b50970d4d9d2da": "Ybodychange",
    "4603c8a4dd267aab345ec915b932f736d404daa7": "Ybodychange",
    "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578": "Ybodychange",
    "a94515206db0eee8867d399bee6a87aa9e8cb074": "Ymultichange(Yparameterchange,Ybodychange)",
    "90f70231c682e22693f85977497d2dc429ef29da": "Ybodychange",
    "dd35cf7b1461fc883148b148e5c81731d9c08a35": "Yfilerename",
    "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9837 - Remove reliance during annotation binding on org.hibernate.internal.util.ClassLoaderHelper\nHHH-9841 - Redesign org.hibernate.property.PropertyAccessorFactory\n",
      "commitDate": "2015/6/5 上午3:12",
      "commitName": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/5/19 下午12:25",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 16.62,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        if (persistentClass.getClassName() !\u003d null) {\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(persistentClass.getClassName());\n            } catch (ClassLoadingException e) {\n                throw new MappingException(e);\n            }\n            final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n                revisionEntityFound \u003d true;\n                final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                }\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                }\n                revisionInfoEntityName \u003d persistentClass.getEntityName();\n                revisionInfoClass \u003d persistentClass.getMappedClass();\n                final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry());\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), metadata.getMetadataBuildingOptions().getServiceRegistry());\n                }\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry());\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), metadata.getMetadataBuildingOptions().getServiceRegistry());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry()), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry()) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 296,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n         if (persistentClass.getClassName() !\u003d null) {\n             XClass clazz;\n             try {\n                 clazz \u003d reflectionManager.classForName(persistentClass.getClassName());\n             } catch (ClassLoadingException e) {\n                 throw new MappingException(e);\n             }\n             final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n                 revisionEntityFound \u003d true;\n                 final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                 }\n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                 }\n                 revisionInfoEntityName \u003d persistentClass.getEntityName();\n                 revisionInfoClass \u003d persistentClass.getMappedClass();\n                 final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n-                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry());\n                     globalCfg.setTrackEntitiesChangedInRevision(true);\n                 } else {\n-                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n+                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), metadata.getMetadataBuildingOptions().getServiceRegistry());\n                 }\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n-            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry());\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n-            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), metadata.getMetadataBuildingOptions().getServiceRegistry());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry()), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry()) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "410a785dfe40ae030bec31c4c06a5a7998f1feeb": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9680 updated OSGi quickstarts, added necessary contracts to Envers blueprint, corrected a few uses of ReflectionManager\n",
      "commitDate": "2015/3/31 上午3:36",
      "commitName": "410a785dfe40ae030bec31c4c06a5a7998f1feeb",
      "commitAuthor": "Brett Meyer",
      "commitDateOld": "2015/3/22 下午1:30",
      "commitNameOld": "b70bc0080e8e206f83debf8f456fe323caccc01b",
      "commitAuthorOld": "Brett Meyer",
      "daysBetweenCommits": 8.59,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        if (persistentClass.getClassName() !\u003d null) {\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(persistentClass.getClassName());\n            } catch (ClassLoadingException e) {\n                throw new MappingException(e);\n            }\n            final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n                revisionEntityFound \u003d true;\n                final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                }\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                }\n                revisionInfoEntityName \u003d persistentClass.getEntityName();\n                revisionInfoClass \u003d persistentClass.getMappedClass();\n                final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 313,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n         if (persistentClass.getClassName() !\u003d null) {\n             XClass clazz;\n             try {\n-                clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n-            } catch (ClassNotFoundException e) {\n+                clazz \u003d reflectionManager.classForName(persistentClass.getClassName());\n+            } catch (ClassLoadingException e) {\n                 throw new MappingException(e);\n             }\n             final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity !\u003d null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n                 if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n                 revisionEntityFound \u003d true;\n                 final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                 final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                 final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                 }\n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                 }\n                 revisionInfoEntityName \u003d persistentClass.getEntityName();\n                 revisionInfoClass \u003d persistentClass.getMappedClass();\n                 final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                     revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevision(true);\n                 } else {\n                     revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b70bc0080e8e206f83debf8f456fe323caccc01b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8769 gracefully handle the lack of dynamic mode support in Envers\n",
      "commitDate": "2015/3/22 下午1:30",
      "commitName": "b70bc0080e8e206f83debf8f456fe323caccc01b",
      "commitAuthor": "Brett Meyer",
      "commitDateOld": "2015/3/19 上午9:22",
      "commitNameOld": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        if (persistentClass.getClassName() !\u003d null) {\n            XClass clazz;\n            try {\n                clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n            final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity !\u003d null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n                revisionEntityFound \u003d true;\n                final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n                final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n                final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                }\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                }\n                revisionInfoEntityName \u003d persistentClass.getEntityName();\n                revisionInfoClass \u003d persistentClass.getMappedClass();\n                final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 312,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,59 @@\n public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n-        XClass clazz;\n-        try {\n-            clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n-        } catch (ClassNotFoundException e) {\n-            throw new MappingException(e);\n-        }\n-        final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n-        if (revisionEntity !\u003d null) {\n-            if (revisionEntityFound) {\n-                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+        if (persistentClass.getClassName() !\u003d null) {\n+            XClass clazz;\n+            try {\n+                clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n+            } catch (ClassNotFoundException e) {\n+                throw new MappingException(e);\n             }\n-            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n-                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n-            }\n-            revisionEntityFound \u003d true;\n-            final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n-            final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-            final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n-            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n-            if (!revisionNumberFound.isSet()) {\n-                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n-            }\n-            if (!revisionTimestampFound.isSet()) {\n-                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n-            }\n-            revisionInfoEntityName \u003d persistentClass.getEntityName();\n-            revisionInfoClass \u003d persistentClass.getMappedClass();\n-            final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n-            revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n-                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n-                globalCfg.setTrackEntitiesChangedInRevision(true);\n-            } else {\n-                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n+            final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n+            if (revisionEntity !\u003d null) {\n+                if (revisionEntityFound) {\n+                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+                }\n+                if (clazz.getAnnotation(Audited.class) !\u003d null) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n+                }\n+                revisionEntityFound \u003d true;\n+                final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n+                final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+                final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n+                if (!revisionNumberFound.isSet()) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n+                }\n+                if (!revisionTimestampFound.isSet()) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n+                }\n+                revisionInfoEntityName \u003d persistentClass.getEntityName();\n+                revisionInfoClass \u003d persistentClass.getMappedClass();\n+                final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n+                revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n+                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n+                    revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                    globalCfg.setTrackEntitiesChangedInRevision(true);\n+                } else {\n+                    revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n+                }\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63a0f03c5ae773f96c92c02fba9d13133d02485b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
      "commitDate": "2015/3/19 上午9:22",
      "commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
      "commitAuthor": "Steve Ebersole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
          "commitDate": "2015/3/19 上午9:22",
          "commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013/11/24 下午11:44",
          "commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 479.4,
          "commitsBetweenForRepo": 421,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d persistentClass.getEntityName();\n            revisionInfoClass \u003d persistentClass.getMappedClass();\n            final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 313,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,59 +1,57 @@\n-public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n-    final Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n-    while (classes.hasNext()) {\n-        PersistentClass pc \u003d classes.next();\n+    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n         XClass clazz;\n         try {\n-            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n+            clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n-            revisionInfoEntityName \u003d pc.getEntityName();\n-            revisionInfoClass \u003d pc.getMappedClass();\n+            revisionInfoEntityName \u003d persistentClass.getEntityName();\n+            revisionInfoClass \u003d persistentClass.getMappedClass();\n             final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n-            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n+            revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevision(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[cfg-Configuration, reflectionManager-ReflectionManager]",
            "newValue": "[metadata-MetadataImplementor, reflectionManager-ReflectionManager]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
          "commitDate": "2015/3/19 上午9:22",
          "commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013/11/24 下午11:44",
          "commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 479.4,
          "commitsBetweenForRepo": 421,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d persistentClass.getEntityName();\n            revisionInfoClass \u003d persistentClass.getMappedClass();\n            final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 313,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,59 +1,57 @@\n-public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n-    final Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n-    while (classes.hasNext()) {\n-        PersistentClass pc \u003d classes.next();\n+    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n         XClass clazz;\n         try {\n-            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n+            clazz \u003d reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n-            revisionInfoEntityName \u003d pc.getEntityName();\n-            revisionInfoClass \u003d pc.getMappedClass();\n+            revisionInfoEntityName \u003d persistentClass.getEntityName();\n+            revisionInfoClass \u003d persistentClass.getMappedClass();\n             final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n-            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n+            revisionInfoTimestampType \u003d persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevision(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "364a47f2c746a5eeb1642102580a9daa8bc27fc9": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8159 - Apply fixups indicated by analysis tools\n",
      "commitDate": "2013/5/2 下午11:01",
      "commitName": "364a47f2c746a5eeb1642102580a9daa8bc27fc9",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013/4/8 下午8:43",
      "commitNameOld": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 24.1,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    final Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
      "functionStartLine": 314,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n-    Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n+    final Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n-        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n+        final RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n-            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n-            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+            final MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n+            final MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+            final MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n-            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n+            final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevision(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n-    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n+    final Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
      "commitDate": "2013/4/8 下午8:43",
      "commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
      "commitAuthor": "Lukasz Antoniak",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
          "commitDate": "2013/4/8 下午8:43",
          "commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
          "commitAuthor": "Lukasz Antoniak",
          "commitDateOld": "2013/4/6 上午4:15",
          "commitNameOld": "2b2f333593c1989624d332d47b1358afd1999a91",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 2.69,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 251,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n-                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                globalCfg.setTrackEntitiesChangedInRevision(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n-        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
            "newPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
          "commitDate": "2013/4/8 下午8:43",
          "commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
          "commitAuthor": "Lukasz Antoniak",
          "commitDateOld": "2013/4/6 上午4:15",
          "commitNameOld": "2b2f333593c1989624d332d47b1358afd1999a91",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 2.69,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
          "functionStartLine": 251,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n-                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                globalCfg.setTrackEntitiesChangedInRevision(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n-        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6c6df695350f917fe707b4f830e29c8c52c3f5d0": {
      "type": "Ybodychange",
      "commitMessage": "refactor, remove redundant type cast\n",
      "commitDate": "2012/12/25 下午7:25",
      "commitName": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2012/11/20 上午2:03",
      "commitNameOld": "c01dd40a6566b62e3ae85f6c0024c147cf2d78ff",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 35.72,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 251,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n-    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n+    Iterator\u003cPersistentClass\u003e classes \u003d cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95ec3457af961c4116015509180dcca04967604f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7187 - Renaming and documenting enhanced revision entity\n",
      "commitDate": "2012/4/20 上午5:49",
      "commitName": "95ec3457af961c4116015509180dcca04967604f",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2012/4/19 下午8:15",
      "commitNameOld": "c4822556c19a6ea2d7be93b505548e834c83d955",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.4,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 251,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (!globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() \u0026\u0026 SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-            revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n-            revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class : DefaultRevisionEntity.class;\n+            revisionInfoClass \u003d globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4822556c19a6ea2d7be93b505548e834c83d955": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7187 - Enhanced default revision entity\n",
      "commitDate": "2012/4/19 下午8:15",
      "commitName": "c4822556c19a6ea2d7be93b505548e834c83d955",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2012/1/29 上午6:27",
      "commitNameOld": "46b7a0d38e59e91d3c6b6b1e6a0200dd3118a1a6",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 81.58,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (!globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d revisionInfoClass.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class : DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 249,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (!globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (globalCfg.isUseEnhancedRevisionEntity() \u0026\u0026 org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-            revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n-            revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n+            revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+            revisionInfoEntityName \u003d revisionInfoClass.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n-            revisionInfoClass \u003d DefaultRevisionEntity.class;\n+            revisionInfoClass \u003d globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class : DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45f3ced6daf96f1a697f350e134512562b48d3fd": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6696 - RevisionListener class configuration parameter\n",
      "commitDate": "2011/9/30 上午2:50",
      "commitName": "45f3ced6daf96f1a697f350e134512562b48d3fd",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/6/12 下午7:55",
      "commitNameOld": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 109.29,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 243,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,59 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n+            Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(revisionEntity.value());\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n-                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n-                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n+    Class\u003c? extends RevisionListener\u003e revisionListenerClass \u003d getRevisionListenerClass(RevisionListener.class);\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n             revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n             revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n-            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n-            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13c9fd4f9d177fb7d022c72d674f1a23b909c443": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Persisting entity name by default\n",
      "commitDate": "2011/6/12 下午7:55",
      "commitName": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/5/28 下午11:01",
      "commitNameOld": "40225711963be4f38e961b2faef4a7ea545cba1a",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 243,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-            MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n-            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n+            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n-                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n+                revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n-            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n-            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n+            revisionInfoClass \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+            revisionInfoEntityName \u003d DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n+            revisionInfoGenerator \u003d new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "403b15cae8d19f83c35c9490826d24b0bf5c2fa0": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Query refactoring\n",
      "commitDate": "2011/5/18 上午5:14",
      "commitName": "403b15cae8d19f83c35c9490826d24b0bf5c2fa0",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/5/17 上午1:18",
      "commitNameOld": "1878b238503f3b52a6e7b31f849d7253206c7465",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n             revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n             revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n         } else {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1878b238503f3b52a6e7b31f849d7253206c7465": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Naming\n",
      "commitDate": "2011/5/17 上午1:18",
      "commitName": "1878b238503f3b52a6e7b31f849d7253206c7465",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/5/15 上午6:46",
      "commitNameOld": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n-            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n+            MutableBoolean modifiedEntityTypesFound \u003d new MutableBoolean();\n+            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n-                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n+                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n             revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n             revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n-            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n         } else {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd55a99b00c447e53fe97bdbc423f3e6d7d59557": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Using Criteria API in RevisionInfoQueryCreator\n",
      "commitDate": "2011/5/15 上午6:46",
      "commitName": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/5/15 上午5:47",
      "commitNameOld": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n             revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n             revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName() : null), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36b095c3ce32d2981f5780463bbea8d48105f5a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Refactoring\n",
      "commitDate": "2011/5/15 上午5:47",
      "commitName": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/5/8 上午1:06",
      "commitNameOld": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 7.2,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName() : null), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 225,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                 revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                 globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n             } else {\n                 revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n             revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n             revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n             revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n         } else {\n             revisionInfoClass \u003d DefaultRevisionEntity.class;\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName() : null), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53699cecac7477d64ac3dff6c3a24d5658bfc789": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Modified EntityTrackingRevisionListener interface\n",
      "commitDate": "2011/5/8 上午1:06",
      "commitName": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/4/28 上午5:49",
      "commitNameOld": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 9.8,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 223,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5580 - Tracking entity names in revision\n",
      "commitDate": "2011/4/28 上午5:49",
      "commitName": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/4/20 上午1:19",
      "commitNameOld": "86c15fd21234381e2cc713d07e9652f01078613d",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass \u003d DefaultRevisionEntity.class;\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 223,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,57 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n-            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n+            MutableBoolean modifiedEntityNamesFound \u003d new MutableBoolean();\n+            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n+                revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+            } else {\n+                revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+            }\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n-        revisionInfoClass \u003d DefaultRevisionEntity.class;\n-        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+            revisionInfoClass \u003d DefaultTrackingModifiedTypesRevisionEntity.class;\n+            revisionInfoEntityName \u003d DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n+            revisionInfoGenerator \u003d new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+        } else {\n+            revisionInfoClass \u003d DefaultRevisionEntity.class;\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+        }\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "86c15fd21234381e2cc713d07e9652f01078613d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5276 - Refactoring\n",
      "commitDate": "2011/4/20 上午1:19",
      "commitName": "86c15fd21234381e2cc713d07e9652f01078613d",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/4/20 上午1:19",
      "commitNameOld": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 181,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n-        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping(cfg);\n+        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ac49a906e8566f29767927a0dd8dc6b9328115ab": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5276 - REVINFO in different database schema creation\n",
      "commitDate": "2011/4/20 上午1:19",
      "commitName": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
      "commitAuthor": "Lukasz Antoniak",
      "commitDateOld": "2011/4/19 下午11:27",
      "commitNameOld": "d7cc102b008d1586b85f6f443dce90b531df3b71",
      "commitAuthorOld": "Lukasz Antoniak",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping(cfg);\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 179,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n-        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n+        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping(cfg);\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e21fed8304935dc8a1efeee115a4e720b9d2667b": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds .. envers\n",
      "commitDate": "2010/10/12 上午3:41",
      "commitName": "e21fed8304935dc8a1efeee115a4e720b9d2667b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/10/12 上午3:41",
      "commitNameOld": "89298608b0ba18049272fc0f2784fb3d251da905",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
      "path": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 178,
      "functionName": "configure",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
        "newPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java"
      }
    },
    "6c6e6ab193f48ed93d5b76f394e6bef78205921a": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "HHH-5371 Support revend timestamp to enable audit table partioning by time\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20775 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/10/5 上午2:11",
      "commitName": "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
      "commitAuthor": "Erik-Berndt Scheper",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-5371 Support revend timestamp to enable audit table partioning by time\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20775 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/10/5 上午2:11",
          "commitName": "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
          "commitAuthor": "Erik-Berndt Scheper",
          "commitDateOld": "2010/9/29 上午7:50",
          "commitNameOld": "558d9469e018962a2b3159561bcc0996ecfc62fc",
          "commitAuthorOld": "Erik-Berndt Scheper",
          "daysBetweenCommits": 5.76,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 178,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,46 +1,45 @@\n-@SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "HHH-5371 Support revend timestamp to enable audit table partioning by time\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20775 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/10/5 上午2:11",
          "commitName": "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
          "commitAuthor": "Erik-Berndt Scheper",
          "commitDateOld": "2010/9/29 上午7:50",
          "commitNameOld": "558d9469e018962a2b3159561bcc0996ecfc62fc",
          "commitAuthorOld": "Erik-Berndt Scheper",
          "daysBetweenCommits": 5.76,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 178,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,46 +1,45 @@\n-@SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings({ \"unchecked\" })",
            "newValue": ""
          }
        }
      ]
    },
    "558d9469e018962a2b3159561bcc0996ecfc62fc": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "HHH5371 - Rollback until after 3.6.0 release as per Adam\u0027s request via IM\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20745 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/9/29 上午7:50",
      "commitName": "558d9469e018962a2b3159561bcc0996ecfc62fc",
      "commitAuthor": "Erik-Berndt Scheper",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HHH5371 - Rollback until after 3.6.0 release as per Adam\u0027s request via IM\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20745 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/9/29 上午7:50",
          "commitName": "558d9469e018962a2b3159561bcc0996ecfc62fc",
          "commitAuthor": "Erik-Berndt Scheper",
          "commitDateOld": "2010/9/29 上午6:23",
          "commitNameOld": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
          "commitAuthorOld": "Erik-Berndt Scheper",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 180,
          "functionName": "configure",
          "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,46 @@\n+@SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "HHH5371 - Rollback until after 3.6.0 release as per Adam\u0027s request via IM\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20745 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/9/29 上午7:50",
          "commitName": "558d9469e018962a2b3159561bcc0996ecfc62fc",
          "commitAuthor": "Erik-Berndt Scheper",
          "commitDateOld": "2010/9/29 上午6:23",
          "commitNameOld": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
          "commitAuthorOld": "Erik-Berndt Scheper",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 180,
          "functionName": "configure",
          "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,46 @@\n+@SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings({ \"unchecked\" })"
          }
        }
      ]
    },
    "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "HHH-5371 - Add support for REVEND_TSTMP which will enable audit table partitioning\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20743 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/9/29 上午6:23",
      "commitName": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
      "commitAuthor": "Erik-Berndt Scheper",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-5371 - Add support for REVEND_TSTMP which will enable audit table partitioning\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20743 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/9/29 上午6:23",
          "commitName": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
          "commitAuthor": "Erik-Berndt Scheper",
          "commitDateOld": "2009/12/7 下午4:36",
          "commitNameOld": "e9ff8cf3b6b7d10c13ad76de574047935373d38f",
          "commitAuthorOld": "Adam Warski",
          "daysBetweenCommits": 295.57,
          "commitsBetweenForRepo": 910,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 178,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,46 +1,45 @@\n-@SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "HHH-5371 - Add support for REVEND_TSTMP which will enable audit table partitioning\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20743 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/9/29 上午6:23",
          "commitName": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
          "commitAuthor": "Erik-Berndt Scheper",
          "commitDateOld": "2009/12/7 下午4:36",
          "commitNameOld": "e9ff8cf3b6b7d10c13ad76de574047935373d38f",
          "commitAuthorOld": "Adam Warski",
          "daysBetweenCommits": 295.57,
          "commitsBetweenForRepo": 910,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 178,
          "functionName": "configure",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,46 +1,45 @@\n-@SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings({ \"unchecked\" })",
            "newValue": ""
          }
        }
      ]
    },
    "f39550fff19a72faec27632409b50970d4d9d2da": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4540:\n- applying patch from Nicolas Rougé\n- the revision timestamp can now be a j.u.Date or a j.s.Date, and be mapped to a Date in the DB\n- test\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18032 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/11/24 下午11:21",
      "commitName": "f39550fff19a72faec27632409b50970d4d9d2da",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2009/4/30 下午1:47",
      "commitNameOld": "1553578808ee052e41595da94952ea63f19af038",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 208.4,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 164,
      "functionName": "configure",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,46 @@\n @SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n-            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData);\n+            revisionInfoTimestampType \u003d pc.getProperty(revisionInfoTimestampData.getName()).getType();\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n-        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData);\n+        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4603c8a4dd267aab345ec915b932f736d404daa7": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3570: more renaming\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15517 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/11/5 下午5:13",
      "commitName": "4603c8a4dd267aab345ec915b932f736d404daa7",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2008/11/5 下午4:41",
      "commitNameOld": "843d3c648f0d28ae921d701fd340656c27bb40f3",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 158,
      "functionName": "configure",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3565: adding support for field and property access types; changed the way properties are read. Now, instead of a sole property name, a special \"PropertyData\" object is passed around which encapsulates the  property name and access type information.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15481 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/11/3 下午7:24",
      "commitName": "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2008/10/31 下午8:23",
      "commitNameOld": "a94515206db0eee8867d399bee6a87aa9e8cb074",
      "commitAuthorOld": "Adam Warski",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 158,
      "functionName": "configure",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n @SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n-                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n+                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n-            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData);\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n-        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n+        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData);\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n-    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a94515206db0eee8867d399bee6a87aa9e8cb074": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/31 下午8:23",
      "commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
      "commitAuthor": "Adam Warski",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2008/10/31 下午8:23",
          "commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
          "commitAuthor": "Adam Warski",
          "commitDateOld": "2008/10/31 下午7:42",
          "commitNameOld": "90f70231c682e22693f85977497d2dc429ef29da",
          "commitAuthorOld": "Adam Warski",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 157,
          "functionName": "configure",
          "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,45 @@\n @SuppressWarnings({ \"unchecked\" })\n-public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n-        YClass clazz;\n+        XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[cfg-Configuration, reflectionManager-YReflectionManager]",
            "newValue": "[cfg-Configuration, reflectionManager-ReflectionManager]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2008/10/31 下午8:23",
          "commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
          "commitAuthor": "Adam Warski",
          "commitDateOld": "2008/10/31 下午7:42",
          "commitNameOld": "90f70231c682e22693f85977497d2dc429ef29da",
          "commitAuthorOld": "Adam Warski",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        XClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}",
          "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
          "functionStartLine": 157,
          "functionName": "configure",
          "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,45 @@\n @SuppressWarnings({ \"unchecked\" })\n-public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n-        YClass clazz;\n+        XClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n             if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "90f70231c682e22693f85977497d2dc429ef29da": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3570: renaming versioned to audited\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15459 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/31 下午7:42",
      "commitName": "90f70231c682e22693f85977497d2dc429ef29da",
      "commitAuthor": "Adam Warski",
      "commitDateOld": "2008/10/29 下午11:51",
      "commitNameOld": "8cf6a823974ddfe74548da9913e0df7adf541ee8",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 1.83,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        YClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 157,
      "functionName": "configure",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n @SuppressWarnings({ \"unchecked\" })\n public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n     Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n     boolean revisionEntityFound \u003d false;\n     RevisionInfoGenerator revisionInfoGenerator \u003d null;\n     Class\u003c?\u003e revisionInfoClass \u003d null;\n     while (classes.hasNext()) {\n         PersistentClass pc \u003d classes.next();\n         YClass clazz;\n         try {\n             clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n         } catch (ClassNotFoundException e) {\n             throw new MappingException(e);\n         }\n         RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n         if (revisionEntity !\u003d null) {\n             if (revisionEntityFound) {\n                 throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n             }\n-            if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n+            if (clazz.getAnnotation(Audited.class) !\u003d null) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n             }\n             revisionEntityFound \u003d true;\n             MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n             MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n             searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n             if (!revisionNumberFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n             }\n             if (!revisionTimestampFound.isSet()) {\n                 throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n             }\n             revisionInfoEntityName \u003d pc.getEntityName();\n             revisionInfoClass \u003d pc.getMappedClass();\n             revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n         }\n     }\n     Document revisionInfoXmlMapping \u003d null;\n     if (revisionInfoGenerator \u003d\u003d null) {\n         revisionInfoClass \u003d DefaultRevisionEntity.class;\n         revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n         revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n     }\n     return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd35cf7b1461fc883148b148e5c81731d9c08a35": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3351 : import envers as core module\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15434 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/29 下午11:17",
      "commitName": "dd35cf7b1461fc883148b148e5c81731d9c08a35",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008/10/29 下午10:59",
      "commitNameOld": "15ac9155d2798f5d797310a2fb5f67ef0809428e",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        YClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}",
      "path": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 161,
      "functionName": "configure",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "envers/src/main/java/org/jboss/envers/configuration/RevisionInfoConfiguration.java",
        "newPath": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java"
      }
    },
    "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3351 : import envers as core module\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15406 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/28 上午2:56",
      "commitName": "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,45 @@\n+@SuppressWarnings({ \"unchecked\" })\n+public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n+    boolean revisionEntityFound \u003d false;\n+    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n+    Class\u003c?\u003e revisionInfoClass \u003d null;\n+    while (classes.hasNext()) {\n+        PersistentClass pc \u003d classes.next();\n+        YClass clazz;\n+        try {\n+            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n+        } catch (ClassNotFoundException e) {\n+            throw new MappingException(e);\n+        }\n+        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n+        if (revisionEntity !\u003d null) {\n+            if (revisionEntityFound) {\n+                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+            }\n+            if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n+                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n+            }\n+            revisionEntityFound \u003d true;\n+            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n+            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n+            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n+            if (!revisionNumberFound.isSet()) {\n+                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n+            }\n+            if (!revisionTimestampFound.isSet()) {\n+                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n+            }\n+            revisionInfoEntityName \u003d pc.getEntityName();\n+            revisionInfoClass \u003d pc.getMappedClass();\n+            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n+        }\n+    }\n+    Document revisionInfoXmlMapping \u003d null;\n+    if (revisionInfoGenerator \u003d\u003d null) {\n+        revisionInfoClass \u003d DefaultRevisionEntity.class;\n+        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n+        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n+    }\n+    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n    Iterator\u003cPersistentClass\u003e classes \u003d (Iterator\u003cPersistentClass\u003e) cfg.getClassMappings();\n    boolean revisionEntityFound \u003d false;\n    RevisionInfoGenerator revisionInfoGenerator \u003d null;\n    Class\u003c?\u003e revisionInfoClass \u003d null;\n    while (classes.hasNext()) {\n        PersistentClass pc \u003d classes.next();\n        YClass clazz;\n        try {\n            clazz \u003d reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity \u003d clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity !\u003d null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Versioned.class) !\u003d null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound \u003d true;\n            MutableBoolean revisionNumberFound \u003d new MutableBoolean();\n            MutableBoolean revisionTimestampFound \u003d new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName \u003d pc.getEntityName();\n            revisionInfoClass \u003d pc.getMappedClass();\n            revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping \u003d null;\n    if (revisionInfoGenerator \u003d\u003d null) {\n        revisionInfoClass \u003d DefaultRevisionEntity.class;\n        revisionInfoGenerator \u003d new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping \u003d generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}",
      "path": "envers/src/main/java/org/jboss/envers/configuration/RevisionInfoConfiguration.java",
      "functionStartLine": 152,
      "functionName": "configure",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": ""
    }
  }
}