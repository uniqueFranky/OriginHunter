{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "MethodResolutionLogic.java",
  "functionName": "isApplicable",
  "functionId": "isApplicable___method-ResolvedMethodDeclaration__name-String__argumentsTypes-List__ResolvedType____typeSolver-TypeSolver__withWildcardTolerance-boolean",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 71,
  "functionEndLine": 143,
  "numCommitsSeen": 166,
  "timeTaken": 1394,
  "changeHistory": [
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
    "69e724f5a168e148ea4479c872cfbf656fce8acc",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
    "b20f28d6034a54108c056947c631c360fa079138",
    "c48864ccaea00039c2f6a8390d21cffd3fbde054",
    "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
    "84afc7be2fabd511eccc69e29fca9c4238c9469e",
    "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
    "8907128c87954825abed135e781f272f67648f95",
    "ead147279ca0b84d2f479a714943b20cd689e7c7",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "9506a1844d5076b4edcc2b9a5bc375acf7e95c35",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
    "3337bf584f7ef47f4f56b81743ca0d83930763bf",
    "0b419e87200878fe13db395a415efc4d1338cef2",
    "adb02497ed443e836ae552e20bcb11ab8c1ab623",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "eec165d9e3ef0ab1d93f69a231964984a3379762",
    "558fc9b4f808d718b9b266071078752ba68d4203",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
    "a7fa0c3db19bd74be9affdd624447251963b68af",
    "80f951258992f75441239c79e0f31eda7d47e107",
    "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd"
  ],
  "changeHistoryShort": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650": "Ymultichange(Yparameterchange,Ybodychange)",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ybodychange",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": "Ymultichange(Yparameterchange,Ybodychange)",
    "69e724f5a168e148ea4479c872cfbf656fce8acc": "Ybodychange",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "6e654694b8d141fd5503b46f9e77b8763cfa9a81": "Ybodychange",
    "b20f28d6034a54108c056947c631c360fa079138": "Ybodychange",
    "c48864ccaea00039c2f6a8390d21cffd3fbde054": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd": "Ybodychange",
    "84afc7be2fabd511eccc69e29fca9c4238c9469e": "Ybodychange",
    "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601": "Ybodychange",
    "8907128c87954825abed135e781f272f67648f95": "Yfilerename",
    "ead147279ca0b84d2f479a714943b20cd689e7c7": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "9506a1844d5076b4edcc2b9a5bc375acf7e95c35": "Yfilerename",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": "Ybodychange",
    "3337bf584f7ef47f4f56b81743ca0d83930763bf": "Ybodychange",
    "0b419e87200878fe13db395a415efc4d1338cef2": "Ybodychange",
    "adb02497ed443e836ae552e20bcb11ab8c1ab623": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "eec165d9e3ef0ab1d93f69a231964984a3379762": "Ybodychange",
    "558fc9b4f808d718b9b266071078752ba68d4203": "Ybodychange",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": "Ybodychange",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": "Ybodychange",
    "a7fa0c3db19bd74be9affdd624447251963b68af": "Ybodychange",
    "80f951258992f75441239c79e0f31eda7d47e107": "Ymultichange(Yparameterchange,Ybodychange)",
    "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018/1/10 下午8:52",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/1/10 下午4:01",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n            ResolvedType expectedType \u003d method.getLastParam().getType();\n            ResolvedType actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos \u003e argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n        ResolvedType expectedType \u003d method.getParam(i).getType();\n        ResolvedType actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 72,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "correcting module core to use new classes\n",
      "commitDate": "2017/9/29 下午2:07",
      "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "correcting module core to use new classes\n",
          "commitDate": "2017/9/29 下午2:07",
          "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/9/29 上午4:36",
          "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.4,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n            ResolvedType expectedType \u003d method.getLastParam().getType();\n            ResolvedType actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos \u003e argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n        ResolvedType expectedType \u003d method.getParam(i).getType();\n        ResolvedType actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 72,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,66 +1,66 @@\n-private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNumberOfParams() - 1;\n         if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n-            Type expectedType \u003d method.getLastParam().getType();\n-            Type actualType \u003d argumentsTypes.get(pos);\n+            ResolvedType expectedType \u003d method.getLastParam().getType();\n+            ResolvedType actualType \u003d argumentsTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n-                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n+                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                         argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n                         argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             if (pos \u003e argumentsTypes.size()) {\n                 return false;\n             }\n             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n         return false;\n     }\n-    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n-        Type expectedType \u003d method.getParam(i).getType();\n-        Type actualType \u003d argumentsTypes.get(i);\n+        ResolvedType expectedType \u003d method.getParam(i).getType();\n+        ResolvedType actualType \u003d argumentsTypes.get(i);\n         if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n-            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n+            List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n-            for (TypeParameterDeclaration tp : typeParameters) {\n+            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n-                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n+                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
            "newValue": "[method-ResolvedMethodDeclaration, name-String, argumentsTypes-List\u003cResolvedType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "correcting module core to use new classes\n",
          "commitDate": "2017/9/29 下午2:07",
          "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/9/29 上午4:36",
          "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.4,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n            ResolvedType expectedType \u003d method.getLastParam().getType();\n            ResolvedType actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos \u003e argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n        ResolvedType expectedType \u003d method.getParam(i).getType();\n        ResolvedType actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 72,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,66 +1,66 @@\n-private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNumberOfParams() - 1;\n         if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n-            Type expectedType \u003d method.getLastParam().getType();\n-            Type actualType \u003d argumentsTypes.get(pos);\n+            ResolvedType expectedType \u003d method.getLastParam().getType();\n+            ResolvedType actualType \u003d argumentsTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n-                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n+                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                         argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n                         argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             if (pos \u003e argumentsTypes.size()) {\n                 return false;\n             }\n             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n         return false;\n     }\n-    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n-        Type expectedType \u003d method.getParam(i).getType();\n-        Type actualType \u003d argumentsTypes.get(i);\n+        ResolvedType expectedType \u003d method.getParam(i).getType();\n+        ResolvedType actualType \u003d argumentsTypes.get(i);\n         if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n-            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n+            List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n-            for (TypeParameterDeclaration tp : typeParameters) {\n+            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n-                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n+                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ybodychange",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016/12/13 下午9:10",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefévère-Laoide",
      "commitDateOld": "2016/11/6 下午4:42",
      "commitNameOld": "a7803cf050435e3162f7fdde83fb9692a891e92e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 37.19,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos \u003e argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 85,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,63 +1,66 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNumberOfParams() - 1;\n         if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n             Type actualType \u003d argumentsTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                         argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n                         argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n+            if (pos \u003e argumentsTypes.size()) {\n+                return false;\n+            }\n             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n         Type actualType \u003d argumentsTypes.get(i);\n         if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
      "type": "Ybodychange",
      "commitMessage": "adding more comments in model declarations\n",
      "commitDate": "2016/10/21 下午2:55",
      "commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/21 上午4:06",
      "commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 67,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,63 +1,63 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n-        int pos \u003d method.getNoParams() - 1;\n-        if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n+        int pos \u003d method.getNumberOfParams() - 1;\n+        if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n             Type actualType \u003d argumentsTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                         argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n                         argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n         }\n     }\n-    if (method.getNoParams() !\u003d argumentsTypes.size()) {\n+    if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n-    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n+    for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n         Type actualType \u003d argumentsTypes.get(i);\n         if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n-                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n+                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016/10/20 下午2:39",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 下午2:32",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 67,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
      "commitDate": "2016/10/18 上午1:25",
      "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016/10/18 上午1:25",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/17 上午12:13",
          "commitNameOld": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 51,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,63 +1,63 @@\n-private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n-        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n+        if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n-            Type actualType \u003d paramTypes.get(pos);\n+            Type actualType \u003d argumentsTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n-                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n+                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n-                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n-            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n         }\n     }\n-    if (method.getNoParams() !\u003d paramTypes.size()) {\n+    if (method.getNoParams() !\u003d argumentsTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n-        Type actualType \u003d paramTypes.get(i);\n+        Type actualType \u003d argumentsTypes.get(i);\n         if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
            "newValue": "[method-MethodDeclaration, name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016/10/18 上午1:25",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/17 上午12:13",
          "commitNameOld": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d argumentsTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 51,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,63 +1,63 @@\n-private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n-        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n+        if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n-            Type actualType \u003d paramTypes.get(pos);\n+            Type actualType \u003d argumentsTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n-                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n+                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n-                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                        argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n-            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n         }\n     }\n-    if (method.getNoParams() !\u003d paramTypes.size()) {\n+    if (method.getNoParams() !\u003d argumentsTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n-        Type actualType \u003d paramTypes.get(i);\n+        Type actualType \u003d argumentsTypes.get(i);\n         if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "69e724f5a168e148ea4479c872cfbf656fce8acc": {
      "type": "Ybodychange",
      "commitMessage": "improvement on verifying method compatibility\n",
      "commitDate": "2016/10/15 下午8:29",
      "commitName": "69e724f5a168e148ea4479c872cfbf656fce8acc",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午4:57",
      "commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d paramTypes.get(i);\n        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,63 +1,63 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n             Type actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                         paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n         Type actualType \u003d paramTypes.get(i);\n-        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n+        if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
      "type": "Ybodychange",
      "commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
      "commitDate": "2016/10/15 上午4:57",
      "commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午1:24",
      "commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d paramTypes.get(i);\n        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,63 +1,63 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n             Type actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n-                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n+                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n+                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                     } else {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n         Type actualType \u003d paramTypes.get(i);\n         if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n-            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n+            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016/10/15 上午12:51",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 下午2:36",
      "commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d paramTypes.get(i);\n        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,63 +1,63 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             Type expectedType \u003d method.getLastParam().getType();\n             Type actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n-                for (TypeParameter tp : method.getTypeParameters()) {\n+                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                         paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                     } else {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         Type expectedType \u003d method.getParam(i).getType();\n         Type actualType \u003d paramTypes.get(i);\n         if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n-            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n+            List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n-            for (TypeParameter tp : typeParameters) {\n+            for (TypeParameterDeclaration tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                     if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016/10/14 上午4:11",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/14 上午3:29",
          "commitNameOld": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d paramTypes.get(i);\n        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,63 +1,63 @@\n-private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n-            TypeUsage expectedType \u003d method.getLastParam().getType();\n-            TypeUsage actualType \u003d paramTypes.get(pos);\n+            Type expectedType \u003d method.getLastParam().getType();\n+            Type actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                         paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                     } else {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n-    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        TypeUsage expectedType \u003d method.getParam(i).getType();\n-        TypeUsage actualType \u003d paramTypes.get(i);\n+        Type expectedType \u003d method.getParam(i).getType();\n+        Type actualType \u003d paramTypes.get(i);\n         if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n-                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
            "newValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/14 上午3:29",
          "commitNameOld": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            Type expectedType \u003d method.getLastParam().getType();\n            Type actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        Type expectedType \u003d method.getParam(i).getType();\n        Type actualType \u003d paramTypes.get(i);\n        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,63 +1,63 @@\n-private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n-            TypeUsage expectedType \u003d method.getLastParam().getType();\n-            TypeUsage actualType \u003d paramTypes.get(pos);\n+            Type expectedType \u003d method.getLastParam().getType();\n+            Type actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                         paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                     } else {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n-    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        TypeUsage expectedType \u003d method.getParam(i).getType();\n-        TypeUsage actualType \u003d paramTypes.get(i);\n+        Type expectedType \u003d method.getParam(i).getType();\n+        Type actualType \u003d paramTypes.get(i);\n         if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n             matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n             continue;\n         }\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n-                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6e654694b8d141fd5503b46f9e77b8763cfa9a81": {
      "type": "Ybodychange",
      "commitMessage": "issue80: resolve conflicts between variadic and not variadic alternatives\n",
      "commitDate": "2016/10/14 上午3:29",
      "commitName": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 上午12:07",
      "commitNameOld": "b20f28d6034a54108c056947c631c360fa079138",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,63 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                         paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                     } else {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n+        if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n+            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n+            continue;\n+        }\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n                 if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                     if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                         continue;\n                     }\n                 }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b20f28d6034a54108c056947c631c360fa079138": {
      "type": "Ybodychange",
      "commitMessage": "issue80: other fix for variadic arguments\n",
      "commitDate": "2016/10/14 上午12:07",
      "commitName": "b20f28d6034a54108c056947c631c360fa079138",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/13 下午11:26",
      "commitNameOld": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,50 +1,59 @@\n private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                    if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n+                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n+                    } else {\n+                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                    }\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                     needForWildCardTolerance \u003d true;\n                     continue;\n                 }\n+                if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n+                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                        continue;\n+                    }\n+                }\n                 return false;\n             }\n         }\n     }\n     return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c48864ccaea00039c2f6a8390d21cffd3fbde054": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
      "commitDate": "2016/10/13 下午11:26",
      "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
          "commitDate": "2016/10/13 下午11:26",
          "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午6:43",
          "commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,50 @@\n-public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n+                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n+                    needForWildCardTolerance \u003d true;\n+                    continue;\n+                }\n                 return false;\n             }\n         }\n     }\n-    return true;\n+    return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]",
            "newValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
          "commitDate": "2016/10/13 下午11:26",
          "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午6:43",
          "commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,50 @@\n-public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n+                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n+                    needForWildCardTolerance \u003d true;\n+                    continue;\n+                }\n                 return false;\n             }\n         }\n     }\n-    return true;\n+    return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
          "commitDate": "2016/10/13 下午11:26",
          "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午6:43",
          "commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    boolean needForWildCardTolerance \u003d false;\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                    needForWildCardTolerance \u003d true;\n                    continue;\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,50 @@\n-public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+    boolean needForWildCardTolerance \u003d false;\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n+                if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n+                    needForWildCardTolerance \u003d true;\n+                    continue;\n+                }\n                 return false;\n             }\n         }\n     }\n-    return true;\n+    return !withWildcardTolerance || needForWildCardTolerance;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving support for variadic arguments\n",
      "commitDate": "2016/10/13 下午6:43",
      "commitName": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/12 上午4:53",
      "commitNameOld": "37576d078d11264fec1a28bbffea400003160b6b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84afc7be2fabd511eccc69e29fca9c4238c9469e": {
      "type": "Ybodychange",
      "commitMessage": "unused code removed\n",
      "commitDate": "2016/10/5 下午9:04",
      "commitName": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
      "commitAuthor": "rpau",
      "commitDateOld": "2016/10/3 下午9:24",
      "commitNameOld": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 1.99,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,46 +1,45 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n-    List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n             typeParameters.addAll(method.declaringType().getTypeParameters());\n             for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601": {
      "type": "Ybodychange",
      "commitMessage": "Regard type parameter of method\u0027s declaring type when testing if method is applicable. Solves issue #67.\n",
      "commitDate": "2016/10/3 下午9:24",
      "commitName": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016/9/28 下午7:58",
      "commitNameOld": "325c0dcdee2e0fcfe28f64abec9e39fc9d9adba5",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,46 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.hasVariadicParameter()) {\n         int pos \u003d method.getNoParams() - 1;\n         if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n             TypeUsage expectedType \u003d method.getLastParam().getType();\n             TypeUsage actualType \u003d paramTypes.get(pos);\n             if (!expectedType.isAssignableBy(actualType)) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                 }\n             }\n         } else {\n             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n         }\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n-            for (TypeParameter tp : method.getTypeParameters()) {\n+            List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n+            typeParameters.addAll(method.declaringType().getTypeParameters());\n+            for (TypeParameter tp : typeParameters) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8907128c87954825abed135e781f272f67648f95": {
      "type": "Yfilerename",
      "commitMessage": "modules: create logic module\n",
      "commitDate": "2015/11/21 上午6:00",
      "commitName": "8907128c87954825abed135e781f272f67648f95",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/21 上午1:31",
      "commitNameOld": "01dd50e954e60eb6c50ddbff8937e4186c8bb587",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 37,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "ead147279ca0b84d2f479a714943b20cd689e7c7": {
      "type": "Ybodychange",
      "commitMessage": "issue7: consider type parameters and varargs combinations\n",
      "commitDate": "2015/11/21 上午12:04",
      "commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/14 下午7:41",
      "commitNameOld": "454904fe0cb3b15aa506e3f5fa8f0c9fb1313f61",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos \u003d method.getNoParams() - 1;\n        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n            TypeUsage expectedType \u003d method.getLastParam().getType();\n            TypeUsage actualType \u003d paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,44 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+    List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n+    if (method.hasVariadicParameter()) {\n+        int pos \u003d method.getNoParams() - 1;\n+        if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n+            TypeUsage expectedType \u003d method.getLastParam().getType();\n+            TypeUsage actualType \u003d paramTypes.get(pos);\n+            if (!expectedType.isAssignableBy(actualType)) {\n+                for (TypeParameter tp : method.getTypeParameters()) {\n+                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n+                }\n+                if (!expectedType.isAssignableBy(actualType)) {\n+                    paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                }\n+            }\n+        } else {\n+            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+        }\n+    }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015/11/13 下午5:12",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午4:53",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
      "functionStartLine": 21,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java"
      }
    },
    "9506a1844d5076b4edcc2b9a5bc375acf7e95c35": {
      "type": "Yfilerename",
      "commitMessage": "creating AbstractClassDeclaration\n",
      "commitDate": "2015/11/3 上午3:55",
      "commitName": "9506a1844d5076b4edcc2b9a5bc375acf7e95c35",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/3 上午3:48",
      "commitNameOld": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
      "functionStartLine": 21,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java"
      }
    },
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": {
      "type": "Ybodychange",
      "commitMessage": "removing TypeSolver from model.declarations\n",
      "commitDate": "2015/11/3 上午3:48",
      "commitName": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/1 下午9:35",
      "commitNameOld": "52869e6fb17d3b13f60dea0064b90a81307392b4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.26,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType();\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 18,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,26 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n+        TypeUsage expectedType \u003d method.getParam(i).getType();\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n         if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n             isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n         }\n         if (!isAssignableWithoutSubstitution) {\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3337bf584f7ef47f4f56b81743ca0d83930763bf": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/11/1 下午7:02",
      "commitName": "3337bf584f7ef47f4f56b81743ca0d83930763bf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/1 上午7:08",
      "commitNameOld": "0b419e87200878fe13db395a415efc4d1338cef2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.5,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 21,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,26 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n+    Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n         TypeUsage actualType \u003d paramTypes.get(i);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n+        if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n+            isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n+        }\n         if (!isAssignableWithoutSubstitution) {\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b419e87200878fe13db395a415efc4d1338cef2": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/11/1 上午7:08",
      "commitName": "0b419e87200878fe13db395a415efc4d1338cef2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 下午5:22",
      "commitNameOld": "960364fad3fc2ead6113d4c5d4b7d9ebf23e2f9a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.57,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        TypeUsage actualType \u003d paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,22 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i));\n+        TypeUsage actualType \u003d paramTypes.get(i);\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n         if (!isAssignableWithoutSubstitution) {\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n-            if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n+            if (!expectedType.isAssignableBy(actualType)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "adb02497ed443e836ae552e20bcb11ab8c1ab623": {
      "type": "Ybodychange",
      "commitMessage": "TypeUsage: clean up completed\n",
      "commitDate": "2015/10/31 上午6:51",
      "commitName": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 上午6:37",
      "commitNameOld": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i));\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n-        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i));\n         if (!isAssignableWithoutSubstitution) {\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n-            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n+            if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015/10/30 下午5:53",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午5:29",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "eec165d9e3ef0ab1d93f69a231964984a3379762": {
      "type": "Ybodychange",
      "commitMessage": "consider array modifiers\n",
      "commitDate": "2015/8/25 下午5:57",
      "commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 下午3:22",
      "commitNameOld": "558fc9b4f808d718b9b266071078752ba68d4203",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n         boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n         if (!isAssignableWithoutSubstitution) {\n             for (TypeParameter tp : method.getTypeParameters()) {\n-                expectedType \u003d replaceTypeParam(expectedType, tp);\n+                expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n             }\n             if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "558fc9b4f808d718b9b266071078752ba68d4203": {
      "type": "Ybodychange",
      "commitMessage": "improve method type parameter substitution\n",
      "commitDate": "2015/8/25 下午3:22",
      "commitName": "558fc9b4f808d718b9b266071078752ba68d4203",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午5:05",
      "commitNameOld": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,21 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n-        for (TypeParameter tp : method.getTypeParameters()) {\n-            expectedType \u003d replaceTypeParam(expectedType, tp);\n-        }\n-        if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n-            return false;\n+        boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n+        if (!isAssignableWithoutSubstitution) {\n+            for (TypeParameter tp : method.getTypeParameters()) {\n+                expectedType \u003d replaceTypeParam(expectedType, tp);\n+            }\n+            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n+                return false;\n+            }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
      "type": "Ybodychange",
      "commitMessage": "remove noise\n",
      "commitDate": "2015/8/25 上午5:05",
      "commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午4:42",
      "commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        for (TypeParameter tp : method.getTypeParameters()) {\n            expectedType \u003d replaceTypeParam(expectedType, tp);\n        }\n        if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,18 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n         TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n         for (TypeParameter tp : method.getTypeParameters()) {\n             expectedType \u003d replaceTypeParam(expectedType, tp);\n         }\n-        if (name.equals(\"cloneNodes\")) {\n-            System.out.println(\"foo\");\n-        }\n         if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
      "type": "Ybodychange",
      "commitMessage": "considering method type parameters\n",
      "commitDate": "2015/8/25 上午4:42",
      "commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午3:19",
      "commitNameOld": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n        for (TypeParameter tp : method.getTypeParameters()) {\n            expectedType \u003d replaceTypeParam(expectedType, tp);\n        }\n        if (name.equals(\"cloneNodes\")) {\n            System.out.println(\"foo\");\n        }\n        if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,21 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)) {\n+        TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n+        for (TypeParameter tp : method.getTypeParameters()) {\n+            expectedType \u003d replaceTypeParam(expectedType, tp);\n+        }\n+        if (name.equals(\"cloneNodes\")) {\n+            System.out.println(\"foo\");\n+        }\n+        if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a7fa0c3db19bd74be9affdd624447251963b68af": {
      "type": "Ybodychange",
      "commitMessage": "add tests for ClassOrInterfaceDeclarationContext.solveMethodAsUsage\n",
      "commitDate": "2015/8/19 下午5:17",
      "commitName": "a7fa0c3db19bd74be9affdd624447251963b68af",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/18 上午3:28",
      "commitNameOld": "b7eaf3c62cf45b94426b96eaf4ccab268bb5eaac",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 16,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))) {\n+        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80f951258992f75441239c79e0f31eda7d47e107": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/4 下午9:54",
      "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "wip\n",
          "commitDate": "2015/8/4 下午9:54",
          "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/3 下午2:37",
          "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
          "functionStartLine": 14,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n+public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))) {\n+        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e]",
            "newValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "wip\n",
          "commitDate": "2015/8/4 下午9:54",
          "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/3 下午2:37",
          "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
          "functionStartLine": 14,
          "functionName": "isApplicable",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n+public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n     if (!method.getName().equals(name)) {\n         return false;\n     }\n     if (method.getNoParams() !\u003d paramTypes.size()) {\n         return false;\n     }\n     for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-        if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))) {\n+        if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd": {
      "type": "Yintroduced",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/2 下午11:54",
      "commitName": "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,14 @@\n+public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n+    if (!method.getName().equals(name)) {\n+        return false;\n+    }\n+    if (method.getNoParams() !\u003d paramTypes.size()) {\n+        return false;\n+    }\n+    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n+        if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() !\u003d paramTypes.size()) {\n        return false;\n    }\n    for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n        if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 12,
      "functionName": "isApplicable",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}