{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "IndexDiff.java",
  "functionName": "diff",
  "functionId": "diff___monitor-ProgressMonitor(modifiers-final)__estWorkTreeSize-int__estIndexSize-int__title-String(modifiers-final)",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
  "functionAnnotation": "",
  "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title a {@link java.lang.String} object.\n@return if anything is different between index, tree, and workdir\n@throws java.io.IOException\n",
  "functionStartLine": 409,
  "functionEndLine": 593,
  "numCommitsSeen": 75,
  "timeTaken": 2848,
  "changeHistory": [
    "5639639b06c004d18415f59a271319da2fb7b930",
    "0c259eaf1db076837768512deb6c251c86e67941",
    "8a6af368c4129ef35520ec72cc9f55a3f685bfb8",
    "df3469f6ad81dccb314bf2d5021a3cec2b184985",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "5d9f595eb87fba31c2253051102116fc7876e6c0",
    "12280c02dbb8e4ac10893fbbd415be757afab4c1",
    "2390531888af6dc9e4fda6cb026271dc068c40ab",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "da595f093e5547a7da583fa0459400e47a2638c6",
    "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
    "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
    "d8fcc964a85b255aac431c14ac35624f0634620b",
    "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
    "95172dea173425697814e3ba0b4eb823301bf7d0",
    "5404e70dc64201786cd6a21efb41310912860122",
    "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
    "53ef3e51145adb4b060110e262d7c064be0d5fc5",
    "6befabcb1584118fb02188f602f7ca34b9a7efc5",
    "298486a7c320629de12f9506e0133686a7382b01",
    "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
    "5e2e3819a690b739eba773415899d20db88a452e",
    "1783749e169c57cef7131e1749a01ee269b89df8",
    "18abb8195a67a0502a71e2420078dd95563e18c6",
    "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
    "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
    "e6c39227640536ac1c2e41d8970aeca84b3c6268",
    "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2",
    "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
    "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
    "a02be9725c9f83f0a0280a9a1f00e8d484825885",
    "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
    "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07",
    "6f3b089188ef4937ab4e9970b0987b061000831e",
    "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
    "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
    "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
    "3ba1c7c0681642da30fce234b4a4f405852adfdd",
    "203bd6626767015dfb04d421c572b26a34e9cecf",
    "1a6964c8274c50f0253db75f010d78ef0e739343"
  ],
  "changeHistoryShort": {
    "5639639b06c004d18415f59a271319da2fb7b930": "Ybodychange",
    "0c259eaf1db076837768512deb6c251c86e67941": "Ybodychange",
    "8a6af368c4129ef35520ec72cc9f55a3f685bfb8": "Ydocchange",
    "df3469f6ad81dccb314bf2d5021a3cec2b184985": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "5d9f595eb87fba31c2253051102116fc7876e6c0": "Ybodychange",
    "12280c02dbb8e4ac10893fbbd415be757afab4c1": "Ybodychange",
    "2390531888af6dc9e4fda6cb026271dc068c40ab": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "da595f093e5547a7da583fa0459400e47a2638c6": "Ybodychange",
    "9597c41ea9db20d769f7b8c54eafa207824e5bd6": "Ybodychange",
    "abb57e6b5674b7251bd94b7238e5d995ad9c30c5": "Ybodychange",
    "d8fcc964a85b255aac431c14ac35624f0634620b": "Ybodychange",
    "5328c8c9164414a63ce7f1323d8194b84b6f1e49": "Ybodychange",
    "95172dea173425697814e3ba0b4eb823301bf7d0": "Ybodychange",
    "5404e70dc64201786cd6a21efb41310912860122": "Ybodychange",
    "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238": "Ybodychange",
    "53ef3e51145adb4b060110e262d7c064be0d5fc5": "Ybodychange",
    "6befabcb1584118fb02188f602f7ca34b9a7efc5": "Ybodychange",
    "298486a7c320629de12f9506e0133686a7382b01": "Ybodychange",
    "1a867d10b974cab4d43d77f5b392f4f07807ebd8": "Ybodychange",
    "5e2e3819a690b739eba773415899d20db88a452e": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "1783749e169c57cef7131e1749a01ee269b89df8": "Ybodychange",
    "18abb8195a67a0502a71e2420078dd95563e18c6": "Ybodychange",
    "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f": "Ybodychange",
    "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd": "Ybodychange",
    "e6c39227640536ac1c2e41d8970aeca84b3c6268": "Ybodychange",
    "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2": "Ybodychange",
    "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c": "Ybodychange",
    "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b": "Ybodychange",
    "a02be9725c9f83f0a0280a9a1f00e8d484825885": "Ybodychange",
    "b4359cb8294de1e80147f00caabad9ebd6b7bce1": "Ybodychange",
    "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07": "Ybodychange",
    "6f3b089188ef4937ab4e9970b0987b061000831e": "Ybodychange",
    "ea4ff61ad3de3f5742905c7a92e99cf041d19596": "Ybodychange",
    "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6": "Ybodychange",
    "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf": "Ybodychange",
    "3ba1c7c0681642da30fce234b4a4f405852adfdd": "Ybodychange",
    "203bd6626767015dfb04d421c572b26a34e9cecf": "Ybodychange",
    "1a6964c8274c50f0253db75f010d78ef0e739343": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5639639b06c004d18415f59a271319da2fb7b930": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Refactor to open Repository in try-with-resource\n\nChange-Id: I667d685ccedc730e786f1e52323fdeba4b91af3e\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/3/15 上午6:57",
      "commitName": "5639639b06c004d18415f59a271319da2fb7b930",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/12/20 上午7:02",
      "commitNameOld": "0c259eaf1db076837768512deb6c251c86e67941",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 85.0,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()), e);\n            }\n            try (Repository subRepo \u003d smw.getRepository()) {\n                if (subRepo !\u003d null) {\n                    String subRepoPath \u003d smw.getPath();\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 409,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title a {@link java.lang.String} object.\n@return if anything is different between index, tree, and workdir\n@throws java.io.IOException\n",
      "diff": "@@ -1,131 +1,128 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n         treeWalk.setOperationType(OperationType.CHECKIN_OP);\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n         initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n         Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             String path \u003d treeWalk.getPathString();\n             if (path !\u003d null) {\n                 for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                     recordFileMode(path, treeWalk.getFileMode(i));\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 throw new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()), e);\n             }\n-            Repository subRepo \u003d smw.getRepository();\n-            if (subRepo !\u003d null) {\n-                String subRepoPath \u003d smw.getPath();\n-                try {\n+            try (Repository subRepo \u003d smw.getRepository()) {\n+                if (subRepo !\u003d null) {\n+                    String subRepoPath \u003d smw.getPath();\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n                         modified.add(subRepoPath);\n                         recordFileMode(subRepoPath, FileMode.GITLINK);\n                     } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(subRepoPath, smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(subRepoPath);\n                             recordFileMode(subRepoPath, FileMode.GITLINK);\n                         }\n                     }\n-                } finally {\n-                    subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c259eaf1db076837768512deb6c251c86e67941": {
      "type": "Ybodychange",
      "commitMessage": "Replace explicit calls to initCause where possible\n\nWhere the exception being thrown has a constructor that takes a\nThrowable, use that instead of instantiating the exception and then\nexplicitly calling initCause.\n\nChange-Id: I06a0df407ba751a7af8c1c4a46f9e2714f13dbe3\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/12/20 上午7:02",
      "commitName": "0c259eaf1db076837768512deb6c251c86e67941",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/12/19 下午8:43",
      "commitNameOld": "8a6af368c4129ef35520ec72cc9f55a3f685bfb8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()), e);\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                String subRepoPath \u003d smw.getPath();\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 409,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title a {@link java.lang.String} object.\n@return if anything is different between index, tree, and workdir\n@throws java.io.IOException\n",
      "diff": "@@ -1,133 +1,131 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n         treeWalk.setOperationType(OperationType.CHECKIN_OP);\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n         initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n         Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             String path \u003d treeWalk.getPathString();\n             if (path !\u003d null) {\n                 for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                     recordFileMode(path, treeWalk.getFileMode(i));\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n-                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n-                e1.initCause(e);\n-                throw e1;\n+                throw new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()), e);\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n                 String subRepoPath \u003d smw.getPath();\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n                         modified.add(subRepoPath);\n                         recordFileMode(subRepoPath, FileMode.GITLINK);\n                     } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(subRepoPath, smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(subRepoPath);\n                             recordFileMode(subRepoPath, FileMode.GITLINK);\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a6af368c4129ef35520ec72cc9f55a3f685bfb8": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit lib package\n\nChange-Id: I1e85a951488177993521ce177fdea212615e6164\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/19 下午8:43",
      "commitName": "8a6af368c4129ef35520ec72cc9f55a3f685bfb8",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/8/14 下午8:03",
      "commitNameOld": "df3469f6ad81dccb314bf2d5021a3cec2b184985",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 127.03,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                String subRepoPath \u003d smw.getPath();\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 409,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title a {@link java.lang.String} object.\n@return if anything is different between index, tree, and workdir\n@throws java.io.IOException\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
        "newValue": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title a {@link java.lang.String} object.\n@return if anything is different between index, tree, and workdir\n@throws java.io.IOException\n"
      }
    },
    "df3469f6ad81dccb314bf2d5021a3cec2b184985": {
      "type": "Ybodychange",
      "commitMessage": "Record submodule paths with untracked changes as FileMode.GITLINK\n\nBug: 520702\nChange-Id: I9bb48af9e8f1f2ce7968a82297c7c16f1237f987\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e\n",
      "commitDate": "2017/8/14 下午8:03",
      "commitName": "df3469f6ad81dccb314bf2d5021a3cec2b184985",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2017/2/21 上午5:47",
      "commitNameOld": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 174.59,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                String subRepoPath \u003d smw.getPath();\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 404,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,134 +1,133 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n         treeWalk.setOperationType(OperationType.CHECKIN_OP);\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n         initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n         Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n-            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n-                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n-                String path \u003d treeWalk.getPathString();\n-                if (path !\u003d null) {\n-                    if (values \u003d\u003d null)\n-                        values \u003d new HashSet\u003c\u003e();\n-                    values.add(path);\n-                    fileModes.put(treeWalk.getFileMode(i), values);\n+            String path \u003d treeWalk.getPathString();\n+            if (path !\u003d null) {\n+                for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n+                    recordFileMode(path, treeWalk.getFileMode(i));\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n+                String subRepoPath \u003d smw.getPath();\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n-                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n-                        modified.add(smw.getPath());\n-                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId())) {\n+                        modified.add(subRepoPath);\n+                        recordFileMode(subRepoPath, FileMode.GITLINK);\n+                    } else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n-                            submoduleIndexDiffs.put(smw.getPath(), smid);\n+                            submoduleIndexDiffs.put(subRepoPath, smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n-                            modified.add(smw.getPath());\n+                            modified.add(subRepoPath);\n+                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/21 上午5:47",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/20 上午8:05",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                String path \u003d treeWalk.getPathString();\n                if (path !\u003d null) {\n                    if (values \u003d\u003d null)\n                        values \u003d new HashSet\u003c\u003e();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 404,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,134 +1,134 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n         treeWalk.setOperationType(OperationType.CHECKIN_OP);\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n         initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n-        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003c\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                 Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                 String path \u003d treeWalk.getPathString();\n                 if (path !\u003d null) {\n                     if (values \u003d\u003d null)\n-                        values \u003d new HashSet\u003cString\u003e();\n+                        values \u003d new HashSet\u003c\u003e();\n                     values.add(path);\n                     fileModes.put(treeWalk.getFileMode(i), values);\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                         modified.add(smw.getPath());\n                     else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(smw.getPath(), smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(smw.getPath());\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d9f595eb87fba31c2253051102116fc7876e6c0": {
      "type": "Ybodychange",
      "commitMessage": "Add support for clean filters\n\nWhen filters are defined for certain paths in gitattributes make\nsure that clean filters are processed when adding new content to the\nobject database.\n\nChange-Id: Iffd72914cec5b434ba4d0de232e285b7492db868\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2015/11/28 上午6:23",
      "commitName": "5d9f595eb87fba31c2253051102116fc7876e6c0",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2015/11/18 上午7:28",
      "commitNameOld": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
      "commitAuthorOld": "Arthur Daussy",
      "daysBetweenCommits": 9.95,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                String path \u003d treeWalk.getPathString();\n                if (path !\u003d null) {\n                    if (values \u003d\u003d null)\n                        values \u003d new HashSet\u003cString\u003e();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 401,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,133 +1,134 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n         treeWalk.setOperationType(OperationType.CHECKIN_OP);\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n+        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n         Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                 Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                 String path \u003d treeWalk.getPathString();\n                 if (path !\u003d null) {\n                     if (values \u003d\u003d null)\n                         values \u003d new HashSet\u003cString\u003e();\n                     values.add(path);\n                     fileModes.put(treeWalk.getFileMode(i), values);\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                         modified.add(smw.getPath());\n                     else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(smw.getPath(), smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(smw.getPath());\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "12280c02dbb8e4ac10893fbbd415be757afab4c1": {
      "type": "Ybodychange",
      "commitMessage": "Adds the git attributes computation on the treewalk\n\nAdds the getAttributes feature to the tree walk. The computation of\nattributes needs to be done by the TreeWalk since it needs both a\nWorkingTreeIterator and a DirCacheIterator.\n\nBug: 342372\nCQ: 9120\nChange-Id: I5e33257fd8c9895869a128bad3fd1e720409d361\nSigned-off-by: Arthur Daussy \u003carthur.daussy@obeo.fr\u003e\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2015/11/18 上午7:28",
      "commitName": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
      "commitAuthor": "Arthur Daussy",
      "commitDateOld": "2015/5/26 下午4:52",
      "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 175.61,
      "commitsBetweenForRepo": 270,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                String path \u003d treeWalk.getPathString();\n                if (path !\u003d null) {\n                    if (values \u003d\u003d null)\n                        values \u003d new HashSet\u003cString\u003e();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 401,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,132 +1,133 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n+        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n         Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                 Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                 String path \u003d treeWalk.getPathString();\n                 if (path !\u003d null) {\n                     if (values \u003d\u003d null)\n                         values \u003d new HashSet\u003cString\u003e();\n                     values.add(path);\n                     fileModes.put(treeWalk.getFileMode(i), values);\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                         modified.add(smw.getPath());\n                     else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(smw.getPath(), smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(smw.getPath());\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2390531888af6dc9e4fda6cb026271dc068c40ab": {
      "type": "Ybodychange",
      "commitMessage": "Externalize translatable texts in org.eclipse.jgit\n\nChange-Id: Ibf4c299f9d203c78cae79e61f88d4bea60ea2795\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/26 下午4:52",
      "commitName": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015/5/21 上午6:01",
      "commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                String path \u003d treeWalk.getPathString();\n                if (path !\u003d null) {\n                    if (values \u003d\u003d null)\n                        values \u003d new HashSet\u003cString\u003e();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 400,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,132 +1,132 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n         treeWalk.setRecursive(true);\n         if (tree !\u003d null)\n             treeWalk.addTree(tree);\n         else\n             treeWalk.addTree(new EmptyTreeIterator());\n         treeWalk.addTree(new DirCacheIterator(dirCache));\n         treeWalk.addTree(initialWorkingTreeIterator);\n         Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n         if (monitor !\u003d null) {\n             if (estIndexSize \u003d\u003d 0)\n                 estIndexSize \u003d dirCache.getEntryCount();\n             int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n             monitor.beginTask(title, total);\n             filters.add(new ProgressReportingFilter(monitor, total));\n         }\n         if (filter !\u003d null)\n             filters.add(filter);\n         filters.add(new SkipWorkTreeFilter(INDEX));\n         indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n         filters.add(indexDiffFilter);\n         treeWalk.setFilter(AndTreeFilter.create(filters));\n         fileModes.clear();\n         while (treeWalk.next()) {\n             AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n             DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n             WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n                 final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                 if (dirCacheEntry !\u003d null) {\n                     int stage \u003d dirCacheEntry.getStage();\n                     if (stage \u003e 0) {\n                         String path \u003d treeWalk.getPathString();\n                         addConflict(path, stage);\n                         continue;\n                     }\n                 }\n             }\n             if (treeIterator !\u003d null) {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                         if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                             changed.add(treeWalk.getPathString());\n                     }\n                 } else {\n                     if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         removed.add(treeWalk.getPathString());\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (dirCacheIterator !\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         added.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                         untracked.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             if (dirCacheIterator !\u003d null) {\n                 if (workingTreeIterator \u003d\u003d null) {\n                     if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         missing.add(treeWalk.getPathString());\n                 } else {\n                     if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                         if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                             modified.add(treeWalk.getPathString());\n                     }\n                 }\n             }\n             for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                 Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                 String path \u003d treeWalk.getPathString();\n                 if (path !\u003d null) {\n                     if (values \u003d\u003d null)\n                         values \u003d new HashSet\u003cString\u003e();\n                     values.add(path);\n                     fileModes.put(treeWalk.getFileMode(i), values);\n                 }\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n-                IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n+                IOException e1 \u003d new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                         modified.add(smw.getPath());\n                     else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(smw.getPath(), smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(smw.getPath());\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/21 上午6:01",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014/12/12 下午9:49",
      "commitNameOld": "da595f093e5547a7da583fa0459400e47a2638c6",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 159.34,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n        treeWalk.setRecursive(true);\n        if (tree !\u003d null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n        if (monitor !\u003d null) {\n            if (estIndexSize \u003d\u003d 0)\n                estIndexSize \u003d dirCache.getEntryCount();\n            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter !\u003d null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator !\u003d null) {\n                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry !\u003d null) {\n                    int stage \u003d dirCacheEntry.getStage();\n                    if (stage \u003e 0) {\n                        String path \u003d treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator !\u003d null) {\n                if (dirCacheIterator !\u003d null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator !\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator !\u003d null) {\n                if (workingTreeIterator \u003d\u003d null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n                String path \u003d treeWalk.getPathString();\n                if (path !\u003d null) {\n                    if (values \u003d\u003d null)\n                        values \u003d new HashSet\u003cString\u003e();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,131 +1,132 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n-    TreeWalk treeWalk \u003d new TreeWalk(repository);\n-    treeWalk.setRecursive(true);\n-    if (tree !\u003d null)\n-        treeWalk.addTree(tree);\n-    else\n-        treeWalk.addTree(new EmptyTreeIterator());\n-    treeWalk.addTree(new DirCacheIterator(dirCache));\n-    treeWalk.addTree(initialWorkingTreeIterator);\n-    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n-    if (monitor !\u003d null) {\n-        if (estIndexSize \u003d\u003d 0)\n-            estIndexSize \u003d dirCache.getEntryCount();\n-        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n-        monitor.beginTask(title, total);\n-        filters.add(new ProgressReportingFilter(monitor, total));\n-    }\n-    if (filter !\u003d null)\n-        filters.add(filter);\n-    filters.add(new SkipWorkTreeFilter(INDEX));\n-    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n-    filters.add(indexDiffFilter);\n-    treeWalk.setFilter(AndTreeFilter.create(filters));\n-    fileModes.clear();\n-    while (treeWalk.next()) {\n-        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n-        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n-        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n-        if (dirCacheIterator !\u003d null) {\n-            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n-            if (dirCacheEntry !\u003d null) {\n-                int stage \u003d dirCacheEntry.getStage();\n-                if (stage \u003e 0) {\n-                    String path \u003d treeWalk.getPathString();\n-                    addConflict(path, stage);\n-                    continue;\n-                }\n-            }\n+    try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\n+        treeWalk.setRecursive(true);\n+        if (tree !\u003d null)\n+            treeWalk.addTree(tree);\n+        else\n+            treeWalk.addTree(new EmptyTreeIterator());\n+        treeWalk.addTree(new DirCacheIterator(dirCache));\n+        treeWalk.addTree(initialWorkingTreeIterator);\n+        Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+        if (monitor !\u003d null) {\n+            if (estIndexSize \u003d\u003d 0)\n+                estIndexSize \u003d dirCache.getEntryCount();\n+            int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n+            monitor.beginTask(title, total);\n+            filters.add(new ProgressReportingFilter(monitor, total));\n         }\n-        if (treeIterator !\u003d null) {\n+        if (filter !\u003d null)\n+            filters.add(filter);\n+        filters.add(new SkipWorkTreeFilter(INDEX));\n+        indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n+        filters.add(indexDiffFilter);\n+        treeWalk.setFilter(AndTreeFilter.create(filters));\n+        fileModes.clear();\n+        while (treeWalk.next()) {\n+            AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n+            DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n+            WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n             if (dirCacheIterator !\u003d null) {\n-                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n-                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-                        changed.add(treeWalk.getPathString());\n+                final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n+                if (dirCacheEntry !\u003d null) {\n+                    int stage \u003d dirCacheEntry.getStage();\n+                    if (stage \u003e 0) {\n+                        String path \u003d treeWalk.getPathString();\n+                        addConflict(path, stage);\n+                        continue;\n+                    }\n+                }\n+            }\n+            if (treeIterator !\u003d null) {\n+                if (dirCacheIterator !\u003d null) {\n+                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n+                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                            changed.add(treeWalk.getPathString());\n+                    }\n+                } else {\n+                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                        removed.add(treeWalk.getPathString());\n+                    if (workingTreeIterator !\u003d null)\n+                        untracked.add(treeWalk.getPathString());\n                 }\n             } else {\n-                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-                    removed.add(treeWalk.getPathString());\n-                if (workingTreeIterator !\u003d null)\n-                    untracked.add(treeWalk.getPathString());\n+                if (dirCacheIterator !\u003d null) {\n+                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                        added.add(treeWalk.getPathString());\n+                } else {\n+                    if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n+                        untracked.add(treeWalk.getPathString());\n+                    }\n+                }\n             }\n-        } else {\n             if (dirCacheIterator !\u003d null) {\n-                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-                    added.add(treeWalk.getPathString());\n-            } else {\n-                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n-                    untracked.add(treeWalk.getPathString());\n+                if (workingTreeIterator \u003d\u003d null) {\n+                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                        missing.add(treeWalk.getPathString());\n+                } else {\n+                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n+                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n+                            modified.add(treeWalk.getPathString());\n+                    }\n                 }\n             }\n-        }\n-        if (dirCacheIterator !\u003d null) {\n-            if (workingTreeIterator \u003d\u003d null) {\n-                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n-                    missing.add(treeWalk.getPathString());\n-            } else {\n-                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n-                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n-                        modified.add(treeWalk.getPathString());\n+            for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n+                Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n+                String path \u003d treeWalk.getPathString();\n+                if (path !\u003d null) {\n+                    if (values \u003d\u003d null)\n+                        values \u003d new HashSet\u003cString\u003e();\n+                    values.add(path);\n+                    fileModes.put(treeWalk.getFileMode(i), values);\n                 }\n             }\n         }\n-        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n-            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n-            String path \u003d treeWalk.getPathString();\n-            if (path !\u003d null) {\n-                if (values \u003d\u003d null)\n-                    values \u003d new HashSet\u003cString\u003e();\n-                values.add(path);\n-                fileModes.put(treeWalk.getFileMode(i), values);\n-            }\n-        }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n                 try {\n                     ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                     if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                         modified.add(smw.getPath());\n                     else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                         IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                         if (smid \u003d\u003d null) {\n                             smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                             submoduleIndexDiffs.put(smw.getPath(), smid);\n                         }\n                         if (smid.diff()) {\n                             if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                 continue;\n                             }\n                             modified.add(smw.getPath());\n                         }\n                     }\n                 } finally {\n                     subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da595f093e5547a7da583fa0459400e47a2638c6": {
      "type": "Ybodychange",
      "commitMessage": "Fix tests on windows by closing repos\n\nWithout explicitly closing repos we can\u0027t delete the test repositories\non windows.\n\nChange-Id: Id5fa17bd764cbf28703c2f21639d7e969289c2d6\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/12/12 下午9:49",
      "commitName": "da595f093e5547a7da583fa0459400e47a2638c6",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014/11/10 上午5:44",
      "commitNameOld": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 32.67,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                if (values \u003d\u003d null)\n                    values \u003d new HashSet\u003cString\u003e();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                try {\n                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                        if (smid \u003d\u003d null) {\n                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,127 +1,131 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     fileModes.clear();\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null) {\n                 int stage \u003d dirCacheEntry.getStage();\n                 if (stage \u003e 0) {\n                     String path \u003d treeWalk.getPathString();\n                     addConflict(path, stage);\n                     continue;\n                 }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                     if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                         modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n             Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n             String path \u003d treeWalk.getPathString();\n             if (path !\u003d null) {\n                 if (values \u003d\u003d null)\n                     values \u003d new HashSet\u003cString\u003e();\n                 values.add(path);\n                 fileModes.put(treeWalk.getFileMode(i), values);\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             if (subRepo !\u003d null) {\n-                ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n-                if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n-                    modified.add(smw.getPath());\n-                else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n-                    IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n-                    if (smid \u003d\u003d null) {\n-                        smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n-                        submoduleIndexDiffs.put(smw.getPath(), smid);\n-                    }\n-                    if (smid.diff()) {\n-                        if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n-                            continue;\n-                        }\n+                try {\n+                    ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n+                    if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                         modified.add(smw.getPath());\n+                    else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+                        IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n+                        if (smid \u003d\u003d null) {\n+                            smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n+                            submoduleIndexDiffs.put(smw.getPath(), smid);\n+                        }\n+                        if (smid.diff()) {\n+                            if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n+                                continue;\n+                            }\n+                            modified.add(smw.getPath());\n+                        }\n                     }\n+                } finally {\n+                    subRepo.close();\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9597c41ea9db20d769f7b8c54eafa207824e5bd6": {
      "type": "Ybodychange",
      "commitMessage": "Fix possible NPE in IndexDiff when not all submodules are cloned\n\nThe latest changes to IndexDiff just assumed that all configured\nsubmodules are allways cloned. If a configured submodule did not exist\nan exception was thrown. This is fixed by this commit.\n\nBug: 450567\nChange-Id: Iabe3b196d998c19483082e5720038ebddaeb1890\n",
      "commitDate": "2014/11/10 上午5:44",
      "commitName": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014/11/6 下午4:48",
      "commitNameOld": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 3.54,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                if (values \u003d\u003d null)\n                    values \u003d new HashSet\u003cString\u003e();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            if (subRepo !\u003d null) {\n                ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n                if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                    modified.add(smw.getPath());\n                else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                    IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                    if (smid \u003d\u003d null) {\n                        smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                        submoduleIndexDiffs.put(smw.getPath(), smid);\n                    }\n                    if (smid.diff()) {\n                        if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                            continue;\n                        }\n                        modified.add(smw.getPath());\n                    }\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,125 +1,127 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     fileModes.clear();\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null) {\n                 int stage \u003d dirCacheEntry.getStage();\n                 if (stage \u003e 0) {\n                     String path \u003d treeWalk.getPathString();\n                     addConflict(path, stage);\n                     continue;\n                 }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                     if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                         modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n             Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n             String path \u003d treeWalk.getPathString();\n             if (path !\u003d null) {\n                 if (values \u003d\u003d null)\n                     values \u003d new HashSet\u003cString\u003e();\n                 values.add(path);\n                 fileModes.put(treeWalk.getFileMode(i), values);\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                 e1.initCause(e);\n                 throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n-            ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n-            if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n-                modified.add(smw.getPath());\n-            else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n-                IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n-                if (smid \u003d\u003d null) {\n-                    smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n-                    submoduleIndexDiffs.put(smw.getPath(), smid);\n-                }\n-                if (smid.diff()) {\n-                    if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n-                        continue;\n-                    }\n+            if (subRepo !\u003d null) {\n+                ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n+                if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                     modified.add(smw.getPath());\n+                else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+                    IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n+                    if (smid \u003d\u003d null) {\n+                        smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n+                        submoduleIndexDiffs.put(smw.getPath(), smid);\n+                    }\n+                    if (smid.diff()) {\n+                        if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n+                            continue;\n+                        }\n+                        modified.add(smw.getPath());\n+                    }\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abb57e6b5674b7251bd94b7238e5d995ad9c30c5": {
      "type": "Ybodychange",
      "commitMessage": "Do not swallow exception if IndexDiff hits invalid ignore param\n\nChange-Id: I8a595e1f01a0731118d3c537be420222f7fec744\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/11/6 下午4:48",
      "commitName": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014/11/6 下午4:46",
      "commitNameOld": "d8fcc964a85b255aac431c14ac35624f0634620b",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                if (values \u003d\u003d null)\n                    values \u003d new HashSet\u003cString\u003e();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo \u003d smw.getRepository();\n            ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n            if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                if (smid \u003d\u003d null) {\n                    smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,123 +1,125 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     fileModes.clear();\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null) {\n                 int stage \u003d dirCacheEntry.getStage();\n                 if (stage \u003e 0) {\n                     String path \u003d treeWalk.getPathString();\n                     addConflict(path, stage);\n                     continue;\n                 }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                     if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                         modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n             Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n             String path \u003d treeWalk.getPathString();\n             if (path !\u003d null) {\n                 if (values \u003d\u003d null)\n                     values \u003d new HashSet\u003cString\u003e();\n                 values.add(path);\n                 fileModes.put(treeWalk.getFileMode(i), values);\n             }\n         }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n-                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n+                IOException e1 \u003d new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n+                e1.initCause(e);\n+                throw e1;\n             }\n             Repository subRepo \u003d smw.getRepository();\n             ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n             if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                 modified.add(smw.getPath());\n             else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                 IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                 if (smid \u003d\u003d null) {\n                     smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                     submoduleIndexDiffs.put(smw.getPath(), smid);\n                 }\n                 if (smid.diff()) {\n                     if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                         continue;\n                     }\n                     modified.add(smw.getPath());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d8fcc964a85b255aac431c14ac35624f0634620b": {
      "type": "Ybodychange",
      "commitMessage": "Fix non-externalized string warnings in IndexDiff\n\nChange-Id: Ia803182114f0e8b418428e03601f9afc6542ed28\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/11/6 下午4:46",
      "commitName": "d8fcc964a85b255aac431c14ac35624f0634620b",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014/11/6 下午4:40",
      "commitNameOld": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
      "commitAuthorOld": "Axel Richard",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                if (values \u003d\u003d null)\n                    values \u003d new HashSet\u003cString\u003e();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n            }\n            Repository subRepo \u003d smw.getRepository();\n            ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n            if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                if (smid \u003d\u003d null) {\n                    smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "",
      "extendedDetails": {}
    },
    "5328c8c9164414a63ce7f1323d8194b84b6f1e49": {
      "type": "Ybodychange",
      "commitMessage": "Add new method IndexDiff#getPathsWithIndexMode\n\nGet the list of paths that have the given file mode.\n\nThis helps EGit to efficiently determine which modified files are\nsymlinks and should be shown with a symlink icon in the staging view.\n\nBug: 429302\nChange-Id: Id15f0c6f265667f5b8b57cc2d9f97de568371919\nSigned-off-by: Axel Richard \u003caxel.richard@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/11/6 下午4:40",
      "commitName": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
      "commitAuthor": "Axel Richard",
      "commitDateOld": "2014/11/4 上午12:08",
      "commitNameOld": "c017ac4c85cab7449a49b681843b9bc33e54d2b6",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n            String path \u003d treeWalk.getPathString();\n            if (path !\u003d null) {\n                if (values \u003d\u003d null)\n                    values \u003d new HashSet\u003cString\u003e();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n            }\n            Repository subRepo \u003d smw.getRepository();\n            ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n            if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                if (smid \u003d\u003d null) {\n                    smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 398,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,112 +1,123 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n+    fileModes.clear();\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null) {\n                 int stage \u003d dirCacheEntry.getStage();\n                 if (stage \u003e 0) {\n                     String path \u003d treeWalk.getPathString();\n                     addConflict(path, stage);\n                     continue;\n                 }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                         changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                     missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                     if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                         modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n+        for (int i \u003d 0; i \u003c treeWalk.getTreeCount(); i++) {\n+            Set\u003cString\u003e values \u003d fileModes.get(treeWalk.getFileMode(i));\n+            String path \u003d treeWalk.getPathString();\n+            if (path !\u003d null) {\n+                if (values \u003d\u003d null)\n+                    values \u003d new HashSet\u003cString\u003e();\n+                values.add(path);\n+                fileModes.put(treeWalk.getFileMode(i), values);\n+            }\n+        }\n     }\n     if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n         IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n         SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n         while (smw.next()) {\n             try {\n                 if (localIgnoreSubmoduleMode \u003d\u003d null)\n                     localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                 if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                     continue;\n             } catch (ConfigInvalidException e) {\n                 throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n             }\n             Repository subRepo \u003d smw.getRepository();\n             ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n             if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                 modified.add(smw.getPath());\n             else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                 IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                 if (smid \u003d\u003d null) {\n                     smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                     submoduleIndexDiffs.put(smw.getPath(), smid);\n                 }\n                 if (smid.diff()) {\n                     if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                         continue;\n                     }\n                     modified.add(smw.getPath());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95172dea173425697814e3ba0b4eb823301bf7d0": {
      "type": "Ybodychange",
      "commitMessage": "Support for Submodule configuration submodule.\u003cname\u003e.ignore\n\nFor each submodule native git allows to configure which modifications to\nsubmodules should be ignored by the status command. It is possible to\nignore \"none\", \"all\", \"dirty\", \"untracked\" [1]. This configuration is\nnow supported by IndexDiff. The StatusCommand offers the possibility to\nspecify this mode.\n\n[1] http://git-scm.com/docs/gitmodules\n\nChange-Id: Ifd81d574a680f9b4152945ba70f8ec4af4f452c9\n",
      "commitDate": "2014/11/3 下午5:32",
      "commitName": "95172dea173425697814e3ba0b4eb823301bf7d0",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014/2/2 下午8:16",
      "commitNameOld": "5404e70dc64201786cd6a21efb41310912860122",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 273.89,
      "commitsBetweenForRepo": 346,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode \u003d\u003d null)\n                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n            }\n            Repository subRepo \u003d smw.getRepository();\n            ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n            if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n                if (smid \u003d\u003d null) {\n                    smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 392,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,76 +1,112 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null) {\n                 int stage \u003d dirCacheEntry.getStage();\n                 if (stage \u003e 0) {\n                     String path \u003d treeWalk.getPathString();\n                     addConflict(path, stage);\n                     continue;\n                 }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n-                    changed.add(treeWalk.getPathString());\n+                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                        changed.add(treeWalk.getPathString());\n                 }\n             } else {\n-                removed.add(treeWalk.getPathString());\n+                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                    removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n-                added.add(treeWalk.getPathString());\n+                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                    added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n-                missing.add(treeWalk.getPathString());\n+                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL)\n+                    missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n-                    modified.add(treeWalk.getPathString());\n+                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL \u0026\u0026 ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY))\n+                        modified.add(treeWalk.getPathString());\n+                }\n+            }\n+        }\n+    }\n+    if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.ALL) {\n+        IgnoreSubmoduleMode localIgnoreSubmoduleMode \u003d ignoreSubmoduleMode;\n+        SubmoduleWalk smw \u003d SubmoduleWalk.forIndex(repository);\n+        while (smw.next()) {\n+            try {\n+                if (localIgnoreSubmoduleMode \u003d\u003d null)\n+                    localIgnoreSubmoduleMode \u003d smw.getModulesIgnore();\n+                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n+                    continue;\n+            } catch (ConfigInvalidException e) {\n+                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n+            }\n+            Repository subRepo \u003d smw.getRepository();\n+            ObjectId subHead \u003d subRepo.resolve(\"HEAD\");\n+            if (subHead !\u003d null \u0026\u0026 !subHead.equals(smw.getObjectId()))\n+                modified.add(smw.getPath());\n+            else if (ignoreSubmoduleMode !\u003d IgnoreSubmoduleMode.DIRTY) {\n+                IndexDiff smid \u003d submoduleIndexDiffs.get(smw.getPath());\n+                if (smid \u003d\u003d null) {\n+                    smid \u003d new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n+                    submoduleIndexDiffs.put(smw.getPath(), smid);\n+                }\n+                if (smid.diff()) {\n+                    if (ignoreSubmoduleMode \u003d\u003d IgnoreSubmoduleMode.UNTRACKED \u0026\u0026 smid.getAdded().isEmpty() \u0026\u0026 smid.getChanged().isEmpty() \u0026\u0026 smid.getConflicting().isEmpty() \u0026\u0026 smid.getMissing().isEmpty() \u0026\u0026 smid.getModified().isEmpty() \u0026\u0026 smid.getRemoved().isEmpty()) {\n+                        continue;\n+                    }\n+                    modified.add(smw.getPath());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5404e70dc64201786cd6a21efb41310912860122": {
      "type": "Ybodychange",
      "commitMessage": "Fix for core.autocrlf\u003dinput resulting in modified file\n\nThis version does not attempt to unsmudge, unlike the first attempt\nin Idafad150553df14827eccfde2e3b95760e16a8b6.\n\nBug: 372834\nChange-Id: I9300e735cb16d6208e1df963abb1ff69f688155d\nAlso-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2014/2/2 下午8:16",
      "commitName": "5404e70dc64201786cd6a21efb41310912860122",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/4/19 下午11:05",
      "commitNameOld": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 288.88,
      "commitsBetweenForRepo": 282,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 356,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,76 +1,76 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null) {\n                 int stage \u003d dirCacheEntry.getStage();\n                 if (stage \u003e 0) {\n                     String path \u003d treeWalk.getPathString();\n                     addConflict(path, stage);\n                     continue;\n                 }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n-                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n+                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Provide stage state for conflicting entries\n\nAdds a new method getConflictingStageStates() which returns a\nMap\u003cString, StageState\u003e (path to stage state). StageState is an enum for\nall possible stage combinations (BOTH_DELETED, ADDED_BY_US, ...).\n\nThis can be used to implement the conflict text for unmerged paths in\noutput of \"git status\" or in EGit for decorations/hints.\n\nBug: 403697\nChange-Id: Ib461640a43111b7df4a0debe92ff69b82171329c\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2013/4/19 下午11:05",
      "commitName": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012/12/27 下午11:57",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 112.96,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null) {\n                int stage \u003d dirCacheEntry.getStage();\n                if (stage \u003e 0) {\n                    String path \u003d treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 356,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,72 +1,76 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n-            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n-                conflicts.add(treeWalk.getPathString());\n-                continue;\n+            if (dirCacheEntry !\u003d null) {\n+                int stage \u003d dirCacheEntry.getStage();\n+                if (stage \u003e 0) {\n+                    String path \u003d treeWalk.getPathString();\n+                    addConflict(path, stage);\n+                    continue;\n+                }\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53ef3e51145adb4b060110e262d7c064be0d5fc5": {
      "type": "Ybodychange",
      "commitMessage": "Add detection of untracked folders to IndexDiffFilter\n\nDecorators need to know whether folders in the working tree contain only\nuntracked files. This change enhances IndexDiffFilter to report such\nfolders. This works only together with treewalks which operate in\ndefault traversal mode. For treewalks which process entries in\npostorder mode (files are walked before their parent folder is walked)\nthis detection doesn\u0027t work.\n\nBug: 359264\nChange-Id: I9298d1e3ccac0aec8bbd4e8ac867bc06a5c89c9f\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2011/11/11 上午3:15",
      "commitName": "53ef3e51145adb4b060110e262d7c064be0d5fc5",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011/10/5 下午7:56",
      "commitNameOld": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 36.3,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n                conflicts.add(treeWalk.getPathString());\n                continue;\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 254,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,72 +1,72 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n-    IndexDiffFilter indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n+    indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n     filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n                 conflicts.add(treeWalk.getPathString());\n                 continue;\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6befabcb1584118fb02188f602f7ca34b9a7efc5": {
      "type": "Ybodychange",
      "commitMessage": "Extend IndexDiff to calculate ignored files and folders\n\nIndexDiff was extended to calculate ignored files and folders.\nThe calculation only considers files that are NOT in the index.\nThis functionality is required by the new EGit decorator implementation.\n\nBug: 359264\nChange-Id: I8f09d6a4d61b64aeea80fd22bf3a2963c2bca347\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\n",
      "commitDate": "2011/10/5 下午7:56",
      "commitName": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011/8/17 上午4:22",
      "commitNameOld": "ac909ec89d7a6f59e2d02dcc900a4f80576b12a4",
      "commitAuthorOld": "Kevin Sawicki",
      "daysBetweenCommits": 49.65,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    IndexDiffFilter indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n                conflicts.add(treeWalk.getPathString());\n                continue;\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    ignored \u003d indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 251,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,70 +1,72 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n-    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n+    IndexDiffFilter indexDiffFilter \u003d new IndexDiffFilter(INDEX, WORKDIR);\n+    filters.add(indexDiffFilter);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (dirCacheIterator !\u003d null) {\n             final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n             if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n                 conflicts.add(treeWalk.getPathString());\n                 continue;\n             }\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n+    ignored \u003d indexDiffFilter.getIgnoredPaths();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "298486a7c320629de12f9506e0133686a7382b01": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: conflicting files aren\u0027t properly shown\n\nBefore this change any files in the conflicting set would\nalso be listed in the the other IndexDiff Sets which is\nconfusing.  With this change a conflicting file will not\nbe included in any of the other sets.\n\nChange-Id: Ife9f2652685220bcfddc1f9820423acdcd5acfdc\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/5/6 上午2:48",
      "commitName": "298486a7c320629de12f9506e0133686a7382b01",
      "commitAuthor": "Bernard Leach",
      "commitDateOld": "2011/4/20 上午6:11",
      "commitNameOld": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
      "commitAuthorOld": "Bernard Leach",
      "daysBetweenCommits": 15.86,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n                conflicts.add(treeWalk.getPathString());\n                continue;\n            }\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 249,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,67 +1,70 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n+        if (dirCacheIterator !\u003d null) {\n+            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n+            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n+                conflicts.add(treeWalk.getPathString());\n+                continue;\n+            }\n+        }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n-            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n-            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n-                conflicts.add(treeWalk.getPathString());\n-            }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a867d10b974cab4d43d77f5b392f4f07807ebd8": {
      "type": "Ybodychange",
      "commitMessage": "Added support to IndexDiff to return information on conflicts\n\nChange-Id: I43c13eb72a44f80135c93525fce0c0280b0e64a2\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/4/20 上午6:11",
      "commitName": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
      "commitAuthor": "Bernard Leach",
      "commitDateOld": "2011/3/9 上午7:05",
      "commitNameOld": "c7e9f013b716b6c25bffd8f4f83b738c1a1f1cd8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 41.96,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n                conflicts.add(treeWalk.getPathString());\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 249,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,63 +1,67 @@\n public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (monitor !\u003d null) {\n         if (estIndexSize \u003d\u003d 0)\n             estIndexSize \u003d dirCache.getEntryCount();\n         int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n         monitor.beginTask(title, total);\n         filters.add(new ProgressReportingFilter(monitor, total));\n     }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n+            final DirCacheEntry dirCacheEntry \u003d dirCacheIterator.getDirCacheEntry();\n+            if (dirCacheEntry !\u003d null \u0026\u0026 dirCacheEntry.getStage() \u003e 0) {\n+                conflicts.add(treeWalk.getPathString());\n+            }\n         }\n     }\n     if (monitor !\u003d null)\n         monitor.endTask();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e2e3819a690b739eba773415899d20db88a452e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011/1/21 上午8:28",
      "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2011/1/21 上午8:28",
          "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2010/12/10 上午1:51",
          "commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 42.28,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
          "functionStartLine": 245,
          "functionName": "diff",
          "functionAnnotation": "",
          "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
          "diff": "@@ -1,54 +1,63 @@\n-public boolean diff() throws IOException {\n+public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+    if (monitor !\u003d null) {\n+        if (estIndexSize \u003d\u003d 0)\n+            estIndexSize \u003d dirCache.getEntryCount();\n+        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n+        monitor.beginTask(title, total);\n+        filters.add(new ProgressReportingFilter(monitor, total));\n+    }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n+    if (monitor !\u003d null)\n+        monitor.endTask();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[monitor-ProgressMonitor(modifiers-final), estWorkTreeSize-int, estIndexSize-int, title-String(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2011/1/21 上午8:28",
          "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2010/12/10 上午1:51",
          "commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 42.28,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
          "functionStartLine": 245,
          "functionName": "diff",
          "functionAnnotation": "",
          "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
          "diff": "@@ -1,54 +1,63 @@\n-public boolean diff() throws IOException {\n+public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+    if (monitor !\u003d null) {\n+        if (estIndexSize \u003d\u003d 0)\n+            estIndexSize \u003d dirCache.getEntryCount();\n+        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n+        monitor.beginTask(title, total);\n+        filters.add(new ProgressReportingFilter(monitor, total));\n+    }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n+    if (monitor !\u003d null)\n+        monitor.endTask();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2011/1/21 上午8:28",
          "commitName": "5e2e3819a690b739eba773415899d20db88a452e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2010/12/10 上午1:51",
          "commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 42.28,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (monitor !\u003d null) {\n        if (estIndexSize \u003d\u003d 0)\n            estIndexSize \u003d dirCache.getEntryCount();\n        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor !\u003d null)\n        monitor.endTask();\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
          "functionStartLine": 245,
          "functionName": "diff",
          "functionAnnotation": "",
          "functionDoc": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
          "diff": "@@ -1,54 +1,63 @@\n-public boolean diff() throws IOException {\n+public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n+    if (monitor !\u003d null) {\n+        if (estIndexSize \u003d\u003d 0)\n+            estIndexSize \u003d dirCache.getEntryCount();\n+        int total \u003d Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n+        monitor.beginTask(title, total);\n+        filters.add(new ProgressReportingFilter(monitor, total));\n+    }\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n+    if (monitor !\u003d null)\n+        monitor.endTask();\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
            "newValue": "Run the diff operation. Until this is called, all lists will be empty.\n\u003cp\u003e\nThe operation may be aborted by the progress monitor. In that event it\nwill report what was found before the cancel operation was detected.\nCallers should ignore the result if monitor.isCancelled() is true. If a\nprogress monitor is not needed, callers should use {@link #diff()}\ninstead. Progress reporting is crude and approximate and only intended\nfor informing the user.\n\n@param monitor for reporting progress, may be null\n@param estWorkTreeSize number or estimated files in the working tree\n@param estIndexSize number of estimated entries in the cache\n@param title\n@return if anything is different between index, tree, and workdir\n@throws IOException\n"
          }
        }
      ]
    },
    "1783749e169c57cef7131e1749a01ee269b89df8": {
      "type": "Ybodychange",
      "commitMessage": "Add a performance optimized variant of the ANY_DIFF filter\n\nIf a treewalk walks also over index and the workingtree then the\nIndexDiffFilter filter can be used which works much faster then\nthe semantically equivalent ANY_DIFF filter. This is because this\nfilter can better avoid computing SHA-1 ids over the content of\nworking-tree files which is very costly.\n\nThis fix will significantly improve the performance of e.g.\nEGit\u0027s commit dialog.\n\nChange-Id: I2a51816f4ed9df2900c6307a54cd09f50004266f\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2010/12/10 上午1:51",
      "commitName": "1783749e169c57cef7131e1749a01ee269b89df8",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "18abb8195a67a0502a71e2420078dd95563e18c6",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,55 +1,54 @@\n public boolean diff() throws IOException {\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n-    filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n-    filters.add(TreeFilter.ANY_DIFF);\n+    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                 }\n             }\n         }\n     }\n     if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n         return false;\n     else\n         return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "18abb8195a67a0502a71e2420078dd95563e18c6": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Remove unnecessary changesExist flag\n\nInstead of setting a boolean when a difference record is found, return\nfalse from diff() only if all of the collections are empty.  When all\nof them are empty, no difference was found.\n\nChange-Id: I555fef37adb764ce253481751071c53ad12cf416\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "18abb8195a67a0502a71e2420078dd95563e18c6",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n        return false;\n    else\n        return true;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,59 +1,55 @@\n public boolean diff() throws IOException {\n-    boolean changesExist \u003d false;\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n-                    changesExist \u003d true;\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n-                changesExist \u003d true;\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n-                changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n-                    changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n-                changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n-                    changesExist \u003d true;\n                 }\n             }\n         }\n     }\n-    return changesExist;\n+    if (added.isEmpty() \u0026\u0026 changed.isEmpty() \u0026\u0026 removed.isEmpty() \u0026\u0026 missing.isEmpty() \u0026\u0026 modified.isEmpty() \u0026\u0026 untracked.isEmpty())\n+        return false;\n+    else\n+        return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Use isModified() when comparing index-worktree\n\nThe isModified() is more efficient because it can skip over files that\nare stat clean, without needing to scan them.\n\nThis is useful to efficently work on paths that were already staged\nand thus differ between HEAD and the index, but not between the index\nand the working tree.\n\nChange-Id: I4418202e612f0571974e0898050d987c6c280966\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist \u003d true;\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,59 +1,59 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n-                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n+                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                     modified.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Clean up tree-index compare for staged files\n\nWhen comparing the ObjectIds for two tree entries its faster\nto use the raw buffer compares over allocating ObjectIds and\nthen performing equals on their contents.\n\nHowever, this also needs to consider the raw modes.  It is possible\nfor a path to change modes but not ObjectId (e.g. making a file\nexecutable), and in this case its still a staged change to report back\nto the caller.\n\nChange-Id: I1a267254c04b3273a97f63c71d1e6718cd9d2fa8\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist \u003d true;\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,59 +1,59 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n-                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n+                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() !\u003d dirCacheIterator.getEntryRawMode()) {\n                     changed.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e6c39227640536ac1c2e41d8970aeca84b3c6268": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Fix getAssumeUnchanged()\n\nIf the caller really needs the list of files that are flagged as\nassume-unchanged (aka assume-valid in the DirCache), we should give\nthem the complete list and not just those that we wrongly identified\nas being modified during diff().\n\nThis change is necessary because diff() is slightly broken and is\ndiscovering differences on files that it shouldn\u0027t have considered.\n\nChange-Id: Ibe464c1a0e51c19dc287a4bc5348b7b07f4d840b\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "72f87adce69da858164c70c40d9e0ae778aa5257",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist \u003d true;\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 170,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,63 +1,59 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n-    DirCache dirCache \u003d repository.readDirCache();\n+    dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n-        if (dirCacheIterator !\u003d null) {\n-            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n-                assumeUnchanged.add(treeWalk.getPathString());\n-        }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 removed.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n                 if (workingTreeIterator !\u003d null)\n                     untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Remove always true not-subtree check\n\nThe TreeWalk is configured to be recursive, which means subtrees are\nnever presented to the application.  Therefore the working tree file\nmode can never be a subtree/subdirectory at this point in the code.\n\nChange-Id: Ie842ddc147957d09205c0d2ce87b25c566862fd9\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator !\u003d null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(treeWalk.getPathString());\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist \u003d true;\n                if (workingTreeIterator !\u003d null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,66 +1,63 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n-        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (dirCacheIterator !\u003d null) {\n             if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                 assumeUnchanged.add(treeWalk.getPathString());\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n-                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n-                    removed.add(treeWalk.getPathString());\n-                    changesExist \u003d true;\n-                    if (workingTreeIterator !\u003d null)\n-                        untracked.add(treeWalk.getPathString());\n-                }\n+                removed.add(treeWalk.getPathString());\n+                changesExist \u003d true;\n+                if (workingTreeIterator !\u003d null)\n+                    untracked.add(treeWalk.getPathString());\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Always use TreeWalk.getPathString()\n\nInstead of asking the individual iterators for their path string, use\nthe TreeWalk\u0027s generic getPathString() method.  Its just as fast\nbecause it uses the path of the current matching iterator.\n\nChange-Id: I9b827fbbafce1c78f09d5527cdc64fbe9022a16e\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/9 上午2:03",
      "commitNameOld": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (dirCacheIterator !\u003d null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(treeWalk.getPathString());\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(treeWalk.getPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,66 +1,66 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (dirCacheIterator !\u003d null) {\n             if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n-                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n+                assumeUnchanged.add(treeWalk.getPathString());\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n-                    changed.add(dirCacheIterator.getEntryPathString());\n+                    changed.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n-                    removed.add(treeIterator.getEntryPathString());\n+                    removed.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                     if (workingTreeIterator !\u003d null)\n-                        untracked.add(workingTreeIterator.getEntryPathString());\n+                        untracked.add(treeWalk.getPathString());\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n-                added.add(dirCacheIterator.getEntryPathString());\n+                added.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n-                    untracked.add(workingTreeIterator.getEntryPathString());\n+                    untracked.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n-                missing.add(dirCacheIterator.getEntryPathString());\n+                missing.add(treeWalk.getPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n-                    modified.add(dirCacheIterator.getEntryPathString());\n+                    modified.add(treeWalk.getPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: Simplify allocation of filter list\n\nWe add either 3 or 4 filters.  If we are adding only 3 filters,\nallocating the array for 4 isn\u0027t a huge waste of memory, but it\ndoes simplify our code.\n\nChange-Id: I7df29b414f6d5cfcf533edb1405083e6fcec32cf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/9 上午2:03",
      "commitName": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/8 上午8:49",
      "commitNameOld": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (dirCacheIterator !\u003d null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,66 +1,66 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n-    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n+    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (dirCacheIterator !\u003d null) {\n             if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                 assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(workingTreeIterator.getEntryPathString());\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a02be9725c9f83f0a0280a9a1f00e8d484825885": {
      "type": "Ybodychange",
      "commitMessage": "Remove empty iterator from TreeWalk\n\nIts confusing that a new TreeWalk() needs to have reset() invoked\non it before addTree().  This is a historical accident caused by\nhow TreeWalk was abused within ObjectWalk.\n\nDrop the initial empty tree from the TreeWalk and thus remove a\nnumber of pointless reset() operations from unit tests and some of\nthe internal JGit code.\n\nExisting application code which is still calling reset() will simply\nbe incurring a few unnecessary field assignments, but they should\nconsider cleaning up their code in the future.\n\nChange-Id: I434e94ffa43491019e7dff52ca420a4d2245f48b\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/8 上午8:49",
      "commitName": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/12/1 上午2:51",
      "commitNameOld": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 7.25,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (dirCacheIterator !\u003d null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,67 +1,66 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n-    treeWalk.reset();\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (dirCacheIterator !\u003d null) {\n             if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                 assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n         }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(workingTreeIterator.getEntryPathString());\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4359cb8294de1e80147f00caabad9ebd6b7bce1": {
      "type": "Ybodychange",
      "commitMessage": "Include list of assume unchanged files in IndexDiff\n\nThe IndexDiff had not collected the info if the flag\n\"assume-unchanged\" is set. This information is useful for clients\nwhich may want to decide if specific actions are allowed on a file.\n\nBug: 326213\nChange-Id: I14bb7b03247d6c0b429a9d8d3f6b10f21d8ddeb1\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2010/12/1 上午2:51",
      "commitName": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2010/11/30 下午6:05",
      "commitNameOld": "7bf0f5070e977d716fbce9309266bb7c26be0a74",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (dirCacheIterator !\u003d null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n        }\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 168,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,63 +1,67 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.reset();\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n+        if (dirCacheIterator !\u003d null) {\n+            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n+                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n+        }\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                     if (workingTreeIterator !\u003d null)\n                         untracked.add(workingTreeIterator.getEntryPathString());\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff: support state [removed, untracked]\n\nIndexDiff was extended to detect files which are both removed from the\nindex and untracked.  Before this change these files were only added\nto the removed collection.\n\nChange-Id: I971d8261d2e8932039fce462b59c12e143f79f90\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/11/9 上午7:32",
      "commitName": "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010/10/25 下午7:00",
      "commitNameOld": "6f3b089188ef4937ab4e9970b0987b061000831e",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 14.52,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                    if (workingTreeIterator !\u003d null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 163,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,61 +1,63 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.reset();\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n     if (filter !\u003d null)\n         filters.add(filter);\n     filters.add(new NotIgnoredFilter(WORKDIR));\n     filters.add(new SkipWorkTreeFilter(INDEX));\n     filters.add(TreeFilter.ANY_DIFF);\n     treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n+                    if (workingTreeIterator !\u003d null)\n+                        untracked.add(workingTreeIterator.getEntryPathString());\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f3b089188ef4937ab4e9970b0987b061000831e": {
      "type": "Ybodychange",
      "commitMessage": "Allow setting a filter in IndexDiff\n\nIndexDiff now allows to set an additional filter. This can be used\ne.g. for restricting the tree walk to a given set of files.\n\nChange-Id: I642de17e74b997fa0c5878c90631f6640ed70bdd\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\n",
      "commitDate": "2010/10/25 下午7:00",
      "commitName": "6f3b089188ef4937ab4e9970b0987b061000831e",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010/9/2 上午6:19",
      "commitNameOld": "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
      "commitAuthorOld": "Marc Strapetz",
      "daysBetweenCommits": 53.53,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n    if (filter !\u003d null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 163,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,56 +1,61 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.reset();\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n-    treeWalk.setFilter(TreeFilter.ANY_DIFF);\n-    treeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] { new NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX), TreeFilter.ANY_DIFF }));\n+    Collection\u003cTreeFilter\u003e filters \u003d new ArrayList\u003cTreeFilter\u003e(filter \u003d\u003d null ? 3 : 4);\n+    if (filter !\u003d null)\n+        filters.add(filter);\n+    filters.add(new NotIgnoredFilter(WORKDIR));\n+    filters.add(new SkipWorkTreeFilter(INDEX));\n+    filters.add(TreeFilter.ANY_DIFF);\n+    treeWalk.setFilter(AndTreeFilter.create(filters));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea4ff61ad3de3f5742905c7a92e99cf041d19596": {
      "type": "Ybodychange",
      "commitMessage": "IndexDiff honors Index entries\u0027 \"skipWorkTree\" flag.\n\nChange-Id: I428d11412130b64fc46d7052011f5dff3d653802\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/9/2 上午6:19",
      "commitName": "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
      "commitAuthor": "Marc Strapetz",
      "commitDateOld": "2010/8/13 上午12:43",
      "commitNameOld": "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 20.23,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    treeWalk.setFilter(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] { new NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX), TreeFilter.ANY_DIFF }));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 150,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,56 +1,56 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.reset();\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     treeWalk.setFilter(TreeFilter.ANY_DIFF);\n-    treeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF, new NotIgnoredFilter(WORKDIR)));\n+    treeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] { new NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX), TreeFilter.ANY_DIFF }));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6": {
      "type": "Ybodychange",
      "commitMessage": "Improve IndexDiff performance\n\nExclude ignored files from IndexDiff tree walk.\nThis makes EGit commit much faster.\n\nChange-Id: I398499510c22c37667b7612db32eac3b31d325f0\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010/8/13 上午12:43",
      "commitName": "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010/8/9 下午5:14",
      "commitNameOld": "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    treeWalk.setFilter(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF, new NotIgnoredFilter(WORKDIR)));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 149,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,55 +1,56 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.reset();\n     treeWalk.setRecursive(true);\n     if (tree !\u003d null)\n         treeWalk.addTree(tree);\n     else\n         treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     treeWalk.setFilter(TreeFilter.ANY_DIFF);\n+    treeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF, new NotIgnoredFilter(WORKDIR)));\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf": {
      "type": "Ybodychange",
      "commitMessage": "Fix NPE on commit in empty Repository\n\nNPE occured when committing in an empty repository.\n\nBug: 321858\nChange-Id: Ibddb056c32c14c1444785501c43b95fdf64884b1\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\n",
      "commitDate": "2010/8/9 下午5:14",
      "commitName": "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010/8/4 下午11:03",
      "commitNameOld": "3ba1c7c0681642da30fce234b4a4f405852adfdd",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 4.76,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree !\u003d null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    treeWalk.setFilter(TreeFilter.ANY_DIFF);\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 147,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,52 +1,55 @@\n public boolean diff() throws IOException {\n     boolean changesExist \u003d false;\n     DirCache dirCache \u003d repository.readDirCache();\n     TreeWalk treeWalk \u003d new TreeWalk(repository);\n     treeWalk.reset();\n     treeWalk.setRecursive(true);\n-    treeWalk.addTree(tree);\n+    if (tree !\u003d null)\n+        treeWalk.addTree(tree);\n+    else\n+        treeWalk.addTree(new EmptyTreeIterator());\n     treeWalk.addTree(new DirCacheIterator(dirCache));\n     treeWalk.addTree(initialWorkingTreeIterator);\n     treeWalk.setFilter(TreeFilter.ANY_DIFF);\n     while (treeWalk.next()) {\n         AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n         DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n         WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n         FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n         if (treeIterator !\u003d null) {\n             if (dirCacheIterator !\u003d null) {\n                 if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                     changed.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             } else {\n                 if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                     removed.add(treeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         } else {\n             if (dirCacheIterator !\u003d null) {\n                 added.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                     untracked.add(workingTreeIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n         if (dirCacheIterator !\u003d null) {\n             if (workingTreeIterator \u003d\u003d null) {\n                 missing.add(dirCacheIterator.getEntryPathString());\n                 changesExist \u003d true;\n             } else {\n                 if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                     modified.add(dirCacheIterator.getEntryPathString());\n                     changesExist \u003d true;\n                 }\n             }\n         }\n     }\n     return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ba1c7c0681642da30fce234b4a4f405852adfdd": {
      "type": "Ybodychange",
      "commitMessage": "Add gitignore support to IndexDiff and use TreeWalk\n\nIndexDiff was re-implemented and now uses TreeWalk instead\nof GitIndex. Additionally, gitignore support and retrieval of\nuntracked files was added.\n\nChange-Id: Ie6a8e04833c61d44c668c906b161202b200bb509\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010/8/4 下午11:03",
      "commitName": "3ba1c7c0681642da30fce234b4a4f405852adfdd",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2010/7/23 上午5:56",
      "commitNameOld": "fa9b225e06f16ca7fd7ffca5689f4af0942a73e1",
      "commitAuthorOld": "",
      "daysBetweenCommits": 12.71,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    boolean changesExist \u003d false;\n    DirCache dirCache \u003d repository.readDirCache();\n    TreeWalk treeWalk \u003d new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    treeWalk.addTree(tree);\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    treeWalk.setFilter(TreeFilter.ANY_DIFF);\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n        if (treeIterator !\u003d null) {\n            if (dirCacheIterator !\u003d null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        } else {\n            if (dirCacheIterator !\u003d null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n        if (dirCacheIterator !\u003d null) {\n            if (workingTreeIterator \u003d\u003d null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist \u003d true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist \u003d true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 138,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,33 +1,52 @@\n public boolean diff() throws IOException {\n-    final File root \u003d index.getRepository().getWorkTree();\n-    new IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n-\n-        public void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n-            if (treeEntry \u003d\u003d null) {\n-                added.add(indexEntry.getName());\n-                anyChanges \u003d true;\n-            } else if (indexEntry \u003d\u003d null) {\n-                if (!(treeEntry instanceof Tree))\n-                    removed.add(treeEntry.getFullName());\n-                anyChanges \u003d true;\n+    boolean changesExist \u003d false;\n+    DirCache dirCache \u003d repository.readDirCache();\n+    TreeWalk treeWalk \u003d new TreeWalk(repository);\n+    treeWalk.reset();\n+    treeWalk.setRecursive(true);\n+    treeWalk.addTree(tree);\n+    treeWalk.addTree(new DirCacheIterator(dirCache));\n+    treeWalk.addTree(initialWorkingTreeIterator);\n+    treeWalk.setFilter(TreeFilter.ANY_DIFF);\n+    while (treeWalk.next()) {\n+        AbstractTreeIterator treeIterator \u003d treeWalk.getTree(TREE, AbstractTreeIterator.class);\n+        DirCacheIterator dirCacheIterator \u003d treeWalk.getTree(INDEX, DirCacheIterator.class);\n+        WorkingTreeIterator workingTreeIterator \u003d treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n+        FileMode fileModeTree \u003d treeWalk.getFileMode(TREE);\n+        if (treeIterator !\u003d null) {\n+            if (dirCacheIterator !\u003d null) {\n+                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n+                    changed.add(dirCacheIterator.getEntryPathString());\n+                    changesExist \u003d true;\n+                }\n             } else {\n-                if (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n-                    changed.add(indexEntry.getName());\n-                    anyChanges \u003d true;\n+                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n+                    removed.add(treeIterator.getEntryPathString());\n+                    changesExist \u003d true;\n                 }\n             }\n-            if (indexEntry !\u003d null) {\n-                if (!file.exists()) {\n-                    missing.add(indexEntry.getName());\n-                    anyChanges \u003d true;\n-                } else {\n-                    if (indexEntry.isModified(root, true)) {\n-                        modified.add(indexEntry.getName());\n-                        anyChanges \u003d true;\n-                    }\n+        } else {\n+            if (dirCacheIterator !\u003d null) {\n+                added.add(dirCacheIterator.getEntryPathString());\n+                changesExist \u003d true;\n+            } else {\n+                if (workingTreeIterator !\u003d null \u0026\u0026 !workingTreeIterator.isEntryIgnored()) {\n+                    untracked.add(workingTreeIterator.getEntryPathString());\n+                    changesExist \u003d true;\n                 }\n             }\n         }\n-    }).walk();\n-    return anyChanges;\n+        if (dirCacheIterator !\u003d null) {\n+            if (workingTreeIterator \u003d\u003d null) {\n+                missing.add(dirCacheIterator.getEntryPathString());\n+                changesExist \u003d true;\n+            } else {\n+                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n+                    modified.add(dirCacheIterator.getEntryPathString());\n+                    changesExist \u003d true;\n+                }\n+            }\n+        }\n+    }\n+    return changesExist;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "203bd6626767015dfb04d421c572b26a34e9cecf": {
      "type": "Ybodychange",
      "commitMessage": "Rename Repository getWorkDir to getWorkTree\n\nThis better matches with the name used in the environment\n(GIT_WORK_TREE), in the configuration file (core.worktree),\nand in our builder object.\n\nSince we are already breaking a good chunk of other code\nrelated to repository access, and this fairly easy to fix\nin an application\u0027s code base, I\u0027m not going to offer the\nwrapper getWorkDir() method.\n\nChange-Id: Ib698ba4bbc213c48114f342378cecfe377e37bb7\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/26 上午9:03",
      "commitName": "203bd6626767015dfb04d421c572b26a34e9cecf",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2009/11/1 上午5:48",
      "commitNameOld": "4d91645e890527efbe04ffaee12b4aa3637733c4",
      "commitAuthorOld": "Alex Blewitt",
      "daysBetweenCommits": 237.14,
      "commitsBetweenForRepo": 269,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean diff() throws IOException {\n    final File root \u003d index.getRepository().getWorkTree();\n    new IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n\n        public void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n            if (treeEntry \u003d\u003d null) {\n                added.add(indexEntry.getName());\n                anyChanges \u003d true;\n            } else if (indexEntry \u003d\u003d null) {\n                if (!(treeEntry instanceof Tree))\n                    removed.add(treeEntry.getFullName());\n                anyChanges \u003d true;\n            } else {\n                if (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n                    changed.add(indexEntry.getName());\n                    anyChanges \u003d true;\n                }\n            }\n            if (indexEntry !\u003d null) {\n                if (!file.exists()) {\n                    missing.add(indexEntry.getName());\n                    anyChanges \u003d true;\n                } else {\n                    if (indexEntry.isModified(root, true)) {\n                        modified.add(indexEntry.getName());\n                        anyChanges \u003d true;\n                    }\n                }\n            }\n        }\n    }).walk();\n    return anyChanges;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 91,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n",
      "diff": "@@ -1,33 +1,33 @@\n public boolean diff() throws IOException {\n-    final File root \u003d index.getRepository().getWorkDir();\n+    final File root \u003d index.getRepository().getWorkTree();\n     new IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n \n         public void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n             if (treeEntry \u003d\u003d null) {\n                 added.add(indexEntry.getName());\n                 anyChanges \u003d true;\n             } else if (indexEntry \u003d\u003d null) {\n                 if (!(treeEntry instanceof Tree))\n                     removed.add(treeEntry.getFullName());\n                 anyChanges \u003d true;\n             } else {\n                 if (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n                     changed.add(indexEntry.getName());\n                     anyChanges \u003d true;\n                 }\n             }\n             if (indexEntry !\u003d null) {\n                 if (!file.exists()) {\n                     missing.add(indexEntry.getName());\n                     anyChanges \u003d true;\n                 } else {\n                     if (indexEntry.isModified(root, true)) {\n                         modified.add(indexEntry.getName());\n                         anyChanges \u003d true;\n                     }\n                 }\n             }\n         }\n     }).walk();\n     return anyChanges;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a6964c8274c50f0253db75f010d78ef0e739343": {
      "type": "Yintroduced",
      "commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2009/9/30 上午7:47",
      "commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
      "commitAuthor": "Git Development Community",
      "diff": "@@ -0,0 +1,33 @@\n+public boolean diff() throws IOException {\n+    final File root \u003d index.getRepository().getWorkDir();\n+    new IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n+\n+        public void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n+            if (treeEntry \u003d\u003d null) {\n+                added.add(indexEntry.getName());\n+                anyChanges \u003d true;\n+            } else if (indexEntry \u003d\u003d null) {\n+                if (!(treeEntry instanceof Tree))\n+                    removed.add(treeEntry.getFullName());\n+                anyChanges \u003d true;\n+            } else {\n+                if (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n+                    changed.add(indexEntry.getName());\n+                    anyChanges \u003d true;\n+                }\n+            }\n+            if (indexEntry !\u003d null) {\n+                if (!file.exists()) {\n+                    missing.add(indexEntry.getName());\n+                    anyChanges \u003d true;\n+                } else {\n+                    if (indexEntry.isModified(root, true)) {\n+                        modified.add(indexEntry.getName());\n+                        anyChanges \u003d true;\n+                    }\n+                }\n+            }\n+        }\n+    }).walk();\n+    return anyChanges;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public boolean diff() throws IOException {\n    final File root \u003d index.getRepository().getWorkDir();\n    new IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n\n        public void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n            if (treeEntry \u003d\u003d null) {\n                added.add(indexEntry.getName());\n                anyChanges \u003d true;\n            } else if (indexEntry \u003d\u003d null) {\n                if (!(treeEntry instanceof Tree))\n                    removed.add(treeEntry.getFullName());\n                anyChanges \u003d true;\n            } else {\n                if (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n                    changed.add(indexEntry.getName());\n                    anyChanges \u003d true;\n                }\n            }\n            if (indexEntry !\u003d null) {\n                if (!file.exists()) {\n                    missing.add(indexEntry.getName());\n                    anyChanges \u003d true;\n                } else {\n                    if (indexEntry.isModified(root, true)) {\n                        modified.add(indexEntry.getName());\n                        anyChanges \u003d true;\n                    }\n                }\n            }\n        }\n    }).walk();\n    return anyChanges;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
      "functionStartLine": 91,
      "functionName": "diff",
      "functionAnnotation": "",
      "functionDoc": "Run the diff operation. Until this is called, all lists will be empty\n\n@return if anything is different between index, tree, and workdir\n@throws IOException\n"
    }
  }
}