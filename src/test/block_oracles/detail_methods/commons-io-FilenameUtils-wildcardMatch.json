{
  "origin": "codeshovel",
  "repositoryName": "commons-io",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-io/.git",
  "startCommitName": "559de2c461e94ab636c959149c775bb27111fb48",
  "sourceFileName": "FilenameUtils.java",
  "functionName": "wildcardMatch",
  "functionId": "wildcardMatch___fileName-String(modifiers-final)__wildcardMatcher-String(modifiers-final)__caseSensitivity-IOCase",
  "sourceFilePath": "src/main/java/org/apache/commons/io/FilenameUtils.java",
  "functionAnnotation": "",
  "functionDoc": "Checks a fileName to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param fileName the fileName to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the fileName matches the wildcard string\n@since 1.3\n",
  "functionStartLine": 1374,
  "functionEndLine": 1454,
  "numCommitsSeen": 303,
  "timeTaken": 2045,
  "changeHistory": [
    "e4e03ef4c091f5a35da0d97a6a35224197b8be02",
    "8b9fe1b01ce21003f6a6ff8391ad2a64f4d21030",
    "51f13c846dae950e1d27693c9e23c1063945210f",
    "63eba2740e08ede085c78b131bc1a9c3f1d5ddb1",
    "6aa00766b9103d75c763160280429af8e1f0549e",
    "cf5c462807a137b823a3155dfe9800b3cbf2303d",
    "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
    "226bb72340b7ad715df7a2de586531e7c3078026",
    "5e0fe4de1790c5e50573a8b6a4f26510a3b3d62a",
    "d062bd01f7e9e9194ae0fd9dc01683e7c934c315",
    "5c13fa7579650c2cbcab61c6b18e509951f640aa",
    "a74a5a0c6ff41a4ca0a08caf740ebce1dc3c6d10",
    "eff391033a01a092d943db90513412b08bb01525",
    "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
    "49ca3a4241c1847e08921ead7b582419fa53537c",
    "745375d22e427574f1ef1301c8378cd81e85a1fc",
    "1ead1cc51d537700eb72e3fa991e1d68162029d5",
    "84b251bf545c9df52c9c750835a86d5af4bf0387",
    "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
    "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c",
    "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
    "fe44f3401d6d2b6c66eca32058de5bcd1f6facb9",
    "400e99de58edf0d46a2b22818c37384a3ec9d122",
    "4fbac940f62e0e5196498c3b7cb4ab909ce1a337"
  ],
  "changeHistoryShort": {
    "e4e03ef4c091f5a35da0d97a6a35224197b8be02": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "8b9fe1b01ce21003f6a6ff8391ad2a64f4d21030": "Ydocchange",
    "51f13c846dae950e1d27693c9e23c1063945210f": "Ybodychange",
    "63eba2740e08ede085c78b131bc1a9c3f1d5ddb1": "Ybodychange",
    "6aa00766b9103d75c763160280429af8e1f0549e": "Ymultichange(Ybodychange,Yparametermetachange)",
    "cf5c462807a137b823a3155dfe9800b3cbf2303d": "Ydocchange",
    "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a": "Yfilerename",
    "226bb72340b7ad715df7a2de586531e7c3078026": "Ydocchange",
    "5e0fe4de1790c5e50573a8b6a4f26510a3b3d62a": "Ydocchange",
    "d062bd01f7e9e9194ae0fd9dc01683e7c934c315": "Ybodychange",
    "5c13fa7579650c2cbcab61c6b18e509951f640aa": "Ybodychange",
    "a74a5a0c6ff41a4ca0a08caf740ebce1dc3c6d10": "Ybodychange",
    "eff391033a01a092d943db90513412b08bb01525": "Ybodychange",
    "07751ea95c575cb95a310a23a78dc8cbe85b27a9": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
    "49ca3a4241c1847e08921ead7b582419fa53537c": "Ybodychange",
    "745375d22e427574f1ef1301c8378cd81e85a1fc": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
    "1ead1cc51d537700eb72e3fa991e1d68162029d5": "Ybodychange",
    "84b251bf545c9df52c9c750835a86d5af4bf0387": "Ymultichange(Ybodychange,Ydocchange)",
    "a09ebfc6c0f84a0aa9a05da04801461d99509ec5": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "4694d5a982413a12bce4ce0e5570404b8cc7b1f7": "Ymultichange(Ymovefromfile,Ydocchange,Yrename)",
    "fe44f3401d6d2b6c66eca32058de5bcd1f6facb9": "Yfilerename",
    "400e99de58edf0d46a2b22818c37384a3ec9d122": "Ybodychange",
    "4fbac940f62e0e5196498c3b7cb4ab909ce1a337": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e4e03ef4c091f5a35da0d97a6a35224197b8be02": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Fix param names \u0027filename\u0027 -\u003e \u0027fileName\u0027 in code and Javadocs.",
      "commitDate": "2018/3/8 下午11:50",
      "commitName": "e4e03ef4c091f5a35da0d97a6a35224197b8be02",
      "commitAuthor": "Gary Gregory",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix param names \u0027filename\u0027 -\u003e \u0027fileName\u0027 in code and Javadocs.",
          "commitDate": "2018/3/8 下午11:50",
          "commitName": "e4e03ef4c091f5a35da0d97a6a35224197b8be02",
          "commitAuthor": "Gary Gregory",
          "commitDateOld": "2018/3/8 下午11:32",
          "commitNameOld": "90b2e46494eea8461523c55fd9cf3fe3d1bf00ce",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e fileName.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d fileName.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d NOT_FOUND) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1368,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a fileName to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param fileName the fileName to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the fileName matches the wildcard string\n@since 1.3\n",
          "diff": "@@ -1,60 +1,60 @@\n-public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n-    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n+public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n+    if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n-    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n+    if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n-                if (textIdx \u003e filename.length()) {\n+                if (textIdx \u003e fileName.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n-                    textIdx \u003d filename.length();\n+                    textIdx \u003d fileName.length();\n                 }\n             } else {\n                 if (anyChars) {\n-                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n+                    textIdx \u003d caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d NOT_FOUND) {\n                         break;\n                     }\n-                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n+                    final int repeat \u003d caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n+                    if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n-        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n+        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[filename-String(modifiers-final), wildcardMatcher-String(modifiers-final), caseSensitivity-IOCase]",
            "newValue": "[fileName-String(modifiers-final), wildcardMatcher-String(modifiers-final), caseSensitivity-IOCase]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix param names \u0027filename\u0027 -\u003e \u0027fileName\u0027 in code and Javadocs.",
          "commitDate": "2018/3/8 下午11:50",
          "commitName": "e4e03ef4c091f5a35da0d97a6a35224197b8be02",
          "commitAuthor": "Gary Gregory",
          "commitDateOld": "2018/3/8 下午11:32",
          "commitNameOld": "90b2e46494eea8461523c55fd9cf3fe3d1bf00ce",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e fileName.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d fileName.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d NOT_FOUND) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1368,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a fileName to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param fileName the fileName to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the fileName matches the wildcard string\n@since 1.3\n",
          "diff": "@@ -1,60 +1,60 @@\n-public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n-    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n+public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n+    if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n-    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n+    if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n-                if (textIdx \u003e filename.length()) {\n+                if (textIdx \u003e fileName.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n-                    textIdx \u003d filename.length();\n+                    textIdx \u003d fileName.length();\n                 }\n             } else {\n                 if (anyChars) {\n-                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n+                    textIdx \u003d caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d NOT_FOUND) {\n                         break;\n                     }\n-                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n+                    final int repeat \u003d caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n+                    if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n-        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n+        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fix param names \u0027filename\u0027 -\u003e \u0027fileName\u0027 in code and Javadocs.",
          "commitDate": "2018/3/8 下午11:50",
          "commitName": "e4e03ef4c091f5a35da0d97a6a35224197b8be02",
          "commitAuthor": "Gary Gregory",
          "commitDateOld": "2018/3/8 下午11:32",
          "commitNameOld": "90b2e46494eea8461523c55fd9cf3fe3d1bf00ce",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e fileName.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d fileName.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d NOT_FOUND) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1368,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a fileName to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param fileName the fileName to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the fileName matches the wildcard string\n@since 1.3\n",
          "diff": "@@ -1,60 +1,60 @@\n-public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n-    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n+public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n+    if (fileName \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n-    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n+    if (fileName \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n-                if (textIdx \u003e filename.length()) {\n+                if (textIdx \u003e fileName.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n-                    textIdx \u003d filename.length();\n+                    textIdx \u003d fileName.length();\n                 }\n             } else {\n                 if (anyChars) {\n-                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n+                    textIdx \u003d caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d NOT_FOUND) {\n                         break;\n                     }\n-                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n+                    final int repeat \u003d caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n+                    if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n-        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n+        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d fileName.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wildcard string\n@since 1.3\n",
            "newValue": "Checks a fileName to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param fileName the fileName to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the fileName matches the wildcard string\n@since 1.3\n"
          }
        }
      ]
    },
    "8b9fe1b01ce21003f6a6ff8391ad2a64f4d21030": {
      "type": "Ydocchange",
      "commitMessage": "Fix Javadoc typos (closes #30)\n",
      "commitDate": "2017/2/16 上午2:37",
      "commitName": "8b9fe1b01ce21003f6a6ff8391ad2a64f4d21030",
      "commitAuthor": "Sebastian Kürten",
      "commitDateOld": "2016/12/2 上午10:05",
      "commitNameOld": "703228a3d40881ea52faada723726b05f6d77b8a",
      "commitAuthorOld": "",
      "daysBetweenCommits": 75.69,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d NOT_FOUND) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1328,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wildcard string\n@since 1.3\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n",
        "newValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wildcard string\n@since 1.3\n"
      }
    },
    "51f13c846dae950e1d27693c9e23c1063945210f": {
      "type": "Ybodychange",
      "commitMessage": "Updated for Java7 features\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1746593 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2016/6/2 下午11:36",
      "commitName": "51f13c846dae950e1d27693c9e23c1063945210f",
      "commitAuthor": "Kristian Rosenvold",
      "commitDateOld": "2015/9/10 下午2:35",
      "commitNameOld": "5d072ef89fbc2532f621a5a0b4d6791cb926a997",
      "commitAuthorOld": "Kristian Rosenvold",
      "daysBetweenCommits": 266.38,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d NOT_FOUND) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1327,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n",
      "diff": "@@ -1,60 +1,60 @@\n public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n+    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003c\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 if (textIdx \u003e filename.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d NOT_FOUND) {\n                         break;\n                     }\n                     final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63eba2740e08ede085c78b131bc1a9c3f1d5ddb1": {
      "type": "Ybodychange",
      "commitMessage": "Refactor magic number into constant.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1586309 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/4/10 下午10:08",
      "commitName": "63eba2740e08ede085c78b131bc1a9c3f1d5ddb1",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2014/4/10 下午9:58",
      "commitNameOld": "c4a7e644a5fc43210fa0a563e9087347e3eef67d",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d NOT_FOUND) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1287,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n",
      "diff": "@@ -1,60 +1,60 @@\n public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 if (textIdx \u003e filename.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n-                    if (textIdx \u003d\u003d -1) {\n+                    if (textIdx \u003d\u003d NOT_FOUND) {\n                         break;\n                     }\n                     final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6aa00766b9103d75c763160280429af8e1f0549e": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Use final where possible.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1415850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/12/1 上午4:51",
      "commitName": "6aa00766b9103d75c763160280429af8e1f0549e",
      "commitAuthor": "Gary D. Gregory",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Use final where possible.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1415850 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2012/12/1 上午4:51",
          "commitName": "6aa00766b9103d75c763160280429af8e1f0549e",
          "commitAuthor": "Gary D. Gregory",
          "commitDateOld": "2012/3/30 下午11:13",
          "commitNameOld": "3ef56378e33ed5ccc296806e4ad6b8c463e5979f",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 245.24,
          "commitsBetweenForRepo": 143,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1277,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n",
          "diff": "@@ -1,60 +1,60 @@\n-public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n+public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n-    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n+    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n+    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n-            int[] array \u003d backtrack.pop();\n+            final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 if (textIdx \u003e filename.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n-                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n+                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Use final where possible.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1415850 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2012/12/1 上午4:51",
          "commitName": "6aa00766b9103d75c763160280429af8e1f0549e",
          "commitAuthor": "Gary D. Gregory",
          "commitDateOld": "2012/3/30 下午11:13",
          "commitNameOld": "3ef56378e33ed5ccc296806e4ad6b8c463e5979f",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 245.24,
          "commitsBetweenForRepo": 143,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            final int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1277,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n",
          "diff": "@@ -1,60 +1,60 @@\n-public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n+public static boolean wildcardMatch(final String filename, final String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n-    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n+    final String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n+    final Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n-            int[] array \u003d backtrack.pop();\n+            final int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 if (textIdx \u003e filename.length()) {\n                     break;\n                 }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n-                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n+                    final int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[filename-String, wildcardMatcher-String, caseSensitivity-IOCase]",
            "newValue": "[filename-String(modifiers-final), wildcardMatcher-String(modifiers-final), caseSensitivity-IOCase]"
          }
        }
      ]
    },
    "cf5c462807a137b823a3155dfe9800b3cbf2303d": {
      "type": "Ydocchange",
      "commitMessage": "Use \"@since x.y\" instead of \"@since Commons IO x.y\"\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1304052 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/3/23 上午4:55",
      "commitName": "cf5c462807a137b823a3155dfe9800b3cbf2303d",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012/3/23 上午2:16",
      "commitNameOld": "e3646441205b9271fe2bad0e93088304a8db5a44",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1277,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
        "newValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since 1.3\n"
      }
    },
    "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a": {
      "type": "Yfilerename",
      "commitMessage": "Build changes - re-organize to standard m2 layout, remove useless JIRA report and fix some Ant issues\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1004358 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/10/5 上午2:54",
      "commitName": "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": "2010/10/5 上午1:54",
      "commitNameOld": "19f48eb1711427a43a5e10c84bbbf1218a08bdd2",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1244,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/io/FilenameUtils.java",
        "newPath": "src/main/java/org/apache/commons/io/FilenameUtils.java"
      }
    },
    "226bb72340b7ad715df7a2de586531e7c3078026": {
      "type": "Ydocchange",
      "commitMessage": "Document that \"*?\" does not work properly currently\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002804 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/9/30 上午2:50",
      "commitName": "226bb72340b7ad715df7a2de586531e7c3078026",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2010/9/30 上午2:39",
      "commitNameOld": "5e0fe4de1790c5e50573a8b6a4f26510a3b3d62a",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1239,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
        "newValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\nN.B. the sequence \"*?\" does not work properly at present in match strings.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n"
      }
    },
    "5e0fe4de1790c5e50573a8b6a4f26510a3b3d62a": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc clarifications\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002801 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/9/30 上午2:39",
      "commitName": "5e0fe4de1790c5e50573a8b6a4f26510a3b3d62a",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2010/9/29 下午7:28",
      "commitNameOld": "d062bd01f7e9e9194ae0fd9dc01683e7c934c315",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1236,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
        "newValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple (zero or more) wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n"
      }
    },
    "d062bd01f7e9e9194ae0fd9dc01683e7c934c315": {
      "type": "Ybodychange",
      "commitMessage": "IO-246 FilenameUtils - wildcardMatch gives incorrect results - thanks to wa\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002582 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/9/29 下午7:28",
      "commitName": "d062bd01f7e9e9194ae0fd9dc01683e7c934c315",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": "2009/1/23 上午10:02",
      "commitNameOld": "d4c5044c7b7697d944a444470a296dcd15911595",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 614.39,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                if (textIdx \u003e filename.length()) {\n                    break;\n                }\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1236,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "@@ -1,57 +1,60 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n+                if (textIdx \u003e filename.length()) {\n+                    break;\n+                }\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c13fa7579650c2cbcab61c6b18e509951f640aa": {
      "type": "Ybodychange",
      "commitMessage": "IO-167 Fix case-insensitive string handling - thanks to Benjamin Bentmann\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@661822 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008/5/31 上午3:12",
      "commitName": "5c13fa7579650c2cbcab61c6b18e509951f640aa",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": "2008/3/7 上午8:16",
      "commitNameOld": "ce0e40253805516e781e4acac9001428fc01ecfd",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 84.79,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1139,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "@@ -1,59 +1,57 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n-    filename \u003d caseSensitivity.convertCase(filename);\n-    wildcardMatcher \u003d caseSensitivity.convertCase(wildcardMatcher);\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n-                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n+                    textIdx \u003d caseSensitivity.checkIndexOf(filename, textIdx, wcs[wcsIdx]);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n-                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n+                    int repeat \u003d caseSensitivity.checkIndexOf(filename, textIdx + 1, wcs[wcsIdx]);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n+                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a74a5a0c6ff41a4ca0a08caf740ebce1dc3c6d10": {
      "type": "Ybodychange",
      "commitMessage": "IO-140 JDK 1.5 changes: Use generics\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@619103 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008/2/7 上午3:01",
      "commitName": "a74a5a0c6ff41a4ca0a08caf740ebce1dc3c6d10",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": "2008/1/8 下午12:46",
      "commitNameOld": "14978fec52d916b2e371044c714191013d3bb02c",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 29.59,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    filename \u003d caseSensitivity.convertCase(filename);\n    wildcardMatcher \u003d caseSensitivity.convertCase(wildcardMatcher);\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1139,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "@@ -1,59 +1,59 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     filename \u003d caseSensitivity.convertCase(filename);\n     wildcardMatcher \u003d caseSensitivity.convertCase(wildcardMatcher);\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    Stack backtrack \u003d new Stack();\n+    Stack\u003cint[]\u003e backtrack \u003d new Stack\u003cint[]\u003e();\n     do {\n         if (backtrack.size() \u003e 0) {\n-            int[] array \u003d (int[]) backtrack.pop();\n+            int[] array \u003d backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eff391033a01a092d943db90513412b08bb01525": {
      "type": "Ybodychange",
      "commitMessage": "Test and fix case sensitive wildcard filter\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@418641 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/7/3 上午3:42",
      "commitName": "eff391033a01a092d943db90513412b08bb01525",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2006/6/26 上午7:19",
      "commitNameOld": "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 6.85,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    filename \u003d caseSensitivity.convertCase(filename);\n    wildcardMatcher \u003d caseSensitivity.convertCase(wildcardMatcher);\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1127,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
      "diff": "@@ -1,57 +1,59 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (caseSensitivity \u003d\u003d null) {\n         caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n+    filename \u003d caseSensitivity.convertCase(filename);\n+    wildcardMatcher \u003d caseSensitivity.convertCase(wildcardMatcher);\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n+                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "07751ea95c575cb95a310a23a78dc8cbe85b27a9": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "Add methods to use IOCase case-sensitivity\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@417091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/6/26 上午7:19",
      "commitName": "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add methods to use IOCase case-sensitivity\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@417091 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/6/26 上午7:19",
          "commitName": "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2006/6/26 上午6:40",
          "commitNameOld": "49ca3a4241c1847e08921ead7b582419fa53537c",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1127,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
          "diff": "@@ -1,58 +1,57 @@\n-private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n+public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (system \u0026\u0026 isSystemWindows()) {\n-        filename \u003d filename.toLowerCase();\n-        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n+    if (caseSensitivity \u003d\u003d null) {\n+        caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n+                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[filename-String, wildcardMatcher-String, system-boolean]",
            "newValue": "[filename-String, wildcardMatcher-String, caseSensitivity-IOCase]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Add methods to use IOCase case-sensitivity\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@417091 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/6/26 上午7:19",
          "commitName": "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2006/6/26 上午6:40",
          "commitNameOld": "49ca3a4241c1847e08921ead7b582419fa53537c",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1127,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
          "diff": "@@ -1,58 +1,57 @@\n-private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n+public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (system \u0026\u0026 isSystemWindows()) {\n-        filename \u003d filename.toLowerCase();\n-        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n+    if (caseSensitivity \u003d\u003d null) {\n+        caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n+                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add methods to use IOCase case-sensitivity\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@417091 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/6/26 上午7:19",
          "commitName": "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2006/6/26 上午6:40",
          "commitNameOld": "49ca3a4241c1847e08921ead7b582419fa53537c",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1127,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
          "diff": "@@ -1,58 +1,57 @@\n-private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n+public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (system \u0026\u0026 isSystemWindows()) {\n-        filename \u003d filename.toLowerCase();\n-        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n+    if (caseSensitivity \u003d\u003d null) {\n+        caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n+                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Add methods to use IOCase case-sensitivity\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@417091 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/6/26 上午7:19",
          "commitName": "07751ea95c575cb95a310a23a78dc8cbe85b27a9",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2006/6/26 上午6:40",
          "commitNameOld": "49ca3a4241c1847e08921ead7b582419fa53537c",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (caseSensitivity \u003d\u003d null) {\n        caseSensitivity \u003d IOCase.SENSITIVE;\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 1127,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n",
          "diff": "@@ -1,58 +1,57 @@\n-private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n+public static boolean wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (system \u0026\u0026 isSystemWindows()) {\n-        filename \u003d filename.toLowerCase();\n-        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n+    if (caseSensitivity \u003d\u003d null) {\n+        caseSensitivity \u003d IOCase.SENSITIVE;\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n-                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n+                    if (!caseSensitivity.checkRegionMatches(filename, textIdx, wcs[wcsIdx])) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n",
            "newValue": "Checks a filename to see if it matches the specified wildcard matcher\nallowing control over case-sensitivity.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param caseSensitivity what case sensitivity rule to use, null means case-sensitive\n@return true if the filename matches the wilcard string\n@since Commons IO 1.3\n"
          }
        }
      ]
    },
    "49ca3a4241c1847e08921ead7b582419fa53537c": {
      "type": "Ybodychange",
      "commitMessage": "Refactor windows identification to a method\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@417086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/6/26 上午6:40",
      "commitName": "49ca3a4241c1847e08921ead7b582419fa53537c",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2005/9/19 上午7:12",
      "commitNameOld": "990ea5d016b6ebc1961be059ba9aab0f5079683b",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 279.98,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (system \u0026\u0026 isSystemWindows()) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 1123,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n",
      "diff": "@@ -1,58 +1,58 @@\n private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n+    if (system \u0026\u0026 isSystemWindows()) {\n         filename \u003d filename.toLowerCase();\n         wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "745375d22e427574f1ef1301c8378cd81e85a1fc": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "Make FilenameUtils equals methods case-sensitive, with some optional system case matching\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@160343 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/4/7 上午7:35",
      "commitName": "745375d22e427574f1ef1301c8378cd81e85a1fc",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Make FilenameUtils equals methods case-sensitive, with some optional system case matching\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@160343 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2005/4/7 上午7:35",
          "commitName": "745375d22e427574f1ef1301c8378cd81e85a1fc",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2005/3/5 上午9:22",
          "commitNameOld": "1ead1cc51d537700eb72e3fa991e1d68162029d5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 32.93,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 912,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,58 +1,58 @@\n-public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n+    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n         filename \u003d filename.toLowerCase();\n         wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[filename-String, wildcardMatcher-String]",
            "newValue": "[filename-String, wildcardMatcher-String, system-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Make FilenameUtils equals methods case-sensitive, with some optional system case matching\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@160343 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2005/4/7 上午7:35",
          "commitName": "745375d22e427574f1ef1301c8378cd81e85a1fc",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2005/3/5 上午9:22",
          "commitNameOld": "1ead1cc51d537700eb72e3fa991e1d68162029d5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 32.93,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 912,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,58 +1,58 @@\n-public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n+    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n         filename \u003d filename.toLowerCase();\n         wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Make FilenameUtils equals methods case-sensitive, with some optional system case matching\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@160343 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2005/4/7 上午7:35",
          "commitName": "745375d22e427574f1ef1301c8378cd81e85a1fc",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2005/3/5 上午9:22",
          "commitNameOld": "1ead1cc51d537700eb72e3fa991e1d68162029d5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 32.93,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 912,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,58 +1,58 @@\n-public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n+    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n         filename \u003d filename.toLowerCase();\n         wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Make FilenameUtils equals methods case-sensitive, with some optional system case matching\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@160343 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2005/4/7 上午7:35",
          "commitName": "745375d22e427574f1ef1301c8378cd81e85a1fc",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2005/3/5 上午9:22",
          "commitNameOld": "1ead1cc51d537700eb72e3fa991e1d68162029d5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 32.93,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 912,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,58 +1,58 @@\n-public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+private static boolean wildcardMatch(String filename, String wildcardMatcher, boolean system) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n-    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n+    if (system \u0026\u0026 (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR)) {\n         filename \u003d filename.toLowerCase();\n         wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     Stack backtrack \u003d new Stack();\n     do {\n         if (backtrack.size() \u003e 0) {\n             int[] array \u003d (int[]) backtrack.pop();\n             wcsIdx \u003d array[0];\n             textIdx \u003d array[1];\n             anyChars \u003d true;\n         }\n         while (wcsIdx \u003c wcs.length) {\n             if (wcs[wcsIdx].equals(\"?\")) {\n                 textIdx++;\n                 anyChars \u003d false;\n             } else if (wcs[wcsIdx].equals(\"*\")) {\n                 anyChars \u003d true;\n                 if (wcsIdx \u003d\u003d wcs.length - 1) {\n                     textIdx \u003d filename.length();\n                 }\n             } else {\n                 if (anyChars) {\n                     textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                     if (textIdx \u003d\u003d -1) {\n                         break;\n                     }\n                     int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                     if (repeat \u003e\u003d 0) {\n                         backtrack.push(new int[] { wcsIdx, repeat });\n                     }\n                 } else {\n                     if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                         break;\n                     }\n                 }\n                 textIdx +\u003d wcs[wcsIdx].length();\n                 anyChars \u003d false;\n             }\n             wcsIdx++;\n         }\n         if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n             return true;\n         }\n     } while (backtrack.size() \u003e 0);\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\nThe extension check is case sensitive on Unix and case insensitive on Windows.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
            "newValue": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@param system whether to use the system (windows or unix)\n@return true if the filename matches the wilcard string\n"
          }
        }
      ]
    },
    "1ead1cc51d537700eb72e3fa991e1d68162029d5": {
      "type": "Ybodychange",
      "commitMessage": "Fix bug in wildcard search for advanced repetitive matches\nbug 33303, from Danival Taffarel Calegari\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@156217 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/3/5 上午9:22",
      "commitName": "1ead1cc51d537700eb72e3fa991e1d68162029d5",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2005/2/13 下午8:08",
      "commitNameOld": "7a009ea80932204d693c2f80fb89bb43df3907f0",
      "commitAuthorOld": "Jeremias Maerki",
      "daysBetweenCommits": 19.55,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    Stack backtrack \u003d new Stack();\n    do {\n        if (backtrack.size() \u003e 0) {\n            int[] array \u003d (int[]) backtrack.pop();\n            wcsIdx \u003d array[0];\n            textIdx \u003d array[1];\n            anyChars \u003d true;\n        }\n        while (wcsIdx \u003c wcs.length) {\n            if (wcs[wcsIdx].equals(\"?\")) {\n                textIdx++;\n                anyChars \u003d false;\n            } else if (wcs[wcsIdx].equals(\"*\")) {\n                anyChars \u003d true;\n                if (wcsIdx \u003d\u003d wcs.length - 1) {\n                    textIdx \u003d filename.length();\n                }\n            } else {\n                if (anyChars) {\n                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                    if (textIdx \u003d\u003d -1) {\n                        break;\n                    }\n                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n                    if (repeat \u003e\u003d 0) {\n                        backtrack.push(new int[] { wcsIdx, repeat });\n                    }\n                } else {\n                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                        break;\n                    }\n                }\n                textIdx +\u003d wcs[wcsIdx].length();\n                anyChars \u003d false;\n            }\n            wcsIdx++;\n        }\n        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n            return true;\n        }\n    } while (backtrack.size() \u003e 0);\n    return false;\n}",
      "path": "src/java/org/apache/commons/io/FilenameUtils.java",
      "functionStartLine": 841,
      "functionName": "wildcardMatch",
      "functionAnnotation": "",
      "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\nThe extension check is case sensitive on Unix and case insensitive on Windows.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
      "diff": "@@ -1,50 +1,58 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n     if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n         return true;\n     }\n     if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n         return false;\n     }\n     if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n         filename \u003d filename.toLowerCase();\n         wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n     }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n-        if (wcs[wcsIdx].equals(\"?\")) {\n-            textIdx++;\n-            anyChars \u003d false;\n-        } else if (wcs[wcsIdx].equals(\"*\")) {\n+    Stack backtrack \u003d new Stack();\n+    do {\n+        if (backtrack.size() \u003e 0) {\n+            int[] array \u003d (int[]) backtrack.pop();\n+            wcsIdx \u003d array[0];\n+            textIdx \u003d array[1];\n             anyChars \u003d true;\n-        } else {\n-            if (anyChars) {\n-                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n-                if (textIdx \u003d\u003d -1) {\n-                    return false;\n+        }\n+        while (wcsIdx \u003c wcs.length) {\n+            if (wcs[wcsIdx].equals(\"?\")) {\n+                textIdx++;\n+                anyChars \u003d false;\n+            } else if (wcs[wcsIdx].equals(\"*\")) {\n+                anyChars \u003d true;\n+                if (wcsIdx \u003d\u003d wcs.length - 1) {\n+                    textIdx \u003d filename.length();\n                 }\n             } else {\n-                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n-                    return false;\n+                if (anyChars) {\n+                    textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n+                    if (textIdx \u003d\u003d -1) {\n+                        break;\n+                    }\n+                    int repeat \u003d filename.indexOf(wcs[wcsIdx], textIdx + 1);\n+                    if (repeat \u003e\u003d 0) {\n+                        backtrack.push(new int[] { wcsIdx, repeat });\n+                    }\n+                } else {\n+                    if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n+                        break;\n+                    }\n                 }\n+                textIdx +\u003d wcs[wcsIdx].length();\n+                anyChars \u003d false;\n             }\n-            textIdx +\u003d wcs[wcsIdx].length();\n-            anyChars \u003d false;\n+            wcsIdx++;\n         }\n-        wcsIdx++;\n-    }\n-    if (wcsIdx \u003c wcs.length) {\n-        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n-            return false;\n+        if (wcsIdx \u003d\u003d wcs.length \u0026\u0026 textIdx \u003d\u003d filename.length()) {\n+            return true;\n         }\n-    }\n-    if (textIdx \u003e filename.length()) {\n-        return false;\n-    }\n-    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n-        return false;\n-    }\n-    return true;\n+    } while (backtrack.size() \u003e 0);\n+    return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84b251bf545c9df52c9c750835a86d5af4bf0387": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Convert wildcard method to match based on OS case sensitivity\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140647 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/12/11 上午6:36",
      "commitName": "84b251bf545c9df52c9c750835a86d5af4bf0387",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Convert wildcard method to match based on OS case sensitivity\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140647 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/12/11 上午6:36",
          "commitName": "84b251bf545c9df52c9c750835a86d5af4bf0387",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/12/5 上午3:28",
          "commitNameOld": "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 6.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n            anyChars \u003d false;\n        } else if (wcs[wcsIdx].equals(\"*\")) {\n            anyChars \u003d true;\n        } else {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n            anyChars \u003d false;\n        }\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 840,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\nThe extension check is case sensitive on Unix and case insensitive on Windows.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,50 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n+        return true;\n+    }\n+    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n+        return false;\n+    }\n+    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n+        filename \u003d filename.toLowerCase();\n+        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n+    }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n+    boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n-        } else if (!wcs[wcsIdx].equals(\"*\")) {\n+            anyChars \u003d false;\n+        } else if (wcs[wcsIdx].equals(\"*\")) {\n+            anyChars \u003d true;\n+        } else {\n             if (anyChars) {\n                 textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n+            anyChars \u003d false;\n         }\n-        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e filename.length()) {\n         return false;\n     }\n     if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Convert wildcard method to match based on OS case sensitivity\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140647 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/12/11 上午6:36",
          "commitName": "84b251bf545c9df52c9c750835a86d5af4bf0387",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/12/5 上午3:28",
          "commitNameOld": "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 6.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n        return true;\n    }\n    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n        return false;\n    }\n    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n        filename \u003d filename.toLowerCase();\n        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n    }\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    boolean anyChars \u003d false;\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n            anyChars \u003d false;\n        } else if (wcs[wcsIdx].equals(\"*\")) {\n            anyChars \u003d true;\n        } else {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n            anyChars \u003d false;\n        }\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 840,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\nThe extension check is case sensitive on Unix and case insensitive on Windows.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,50 @@\n public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+    if (filename \u003d\u003d null \u0026\u0026 wildcardMatcher \u003d\u003d null) {\n+        return true;\n+    }\n+    if (filename \u003d\u003d null || wildcardMatcher \u003d\u003d null) {\n+        return false;\n+    }\n+    if (SYSTEM_SEPARATOR \u003d\u003d WINDOWS_SEPARATOR) {\n+        filename \u003d filename.toLowerCase();\n+        wildcardMatcher \u003d wildcardMatcher.toLowerCase();\n+    }\n     String[] wcs \u003d splitOnTokens(wildcardMatcher);\n+    boolean anyChars \u003d false;\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n-    boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n-        } else if (!wcs[wcsIdx].equals(\"*\")) {\n+            anyChars \u003d false;\n+        } else if (wcs[wcsIdx].equals(\"*\")) {\n+            anyChars \u003d true;\n+        } else {\n             if (anyChars) {\n                 textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n+            anyChars \u003d false;\n         }\n-        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e filename.length()) {\n         return false;\n     }\n     if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
            "newValue": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\nThe extension check is case sensitive on Unix and case insensitive on Windows.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n"
          }
        }
      ]
    },
    "a09ebfc6c0f84a0aa9a05da04801461d99509ec5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Add equals methods, document Unix/Windows behaviour\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140646 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/12/5 上午3:28",
      "commitName": "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add equals methods, document Unix/Windows behaviour\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140646 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/12/5 上午3:28",
          "commitName": "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/11/28 上午1:00",
          "commitNameOld": "289a56cf5d5c89ad3d85389b9651b0e227ded057",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 7.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 839,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean wildcardMatch(String filename, String wildcard) {\n-    String[] wcs \u003d splitOnTokens(wildcard);\n+public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n                 textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e filename.length()) {\n         return false;\n     }\n     if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[filename-String, wildcard-String]",
            "newValue": "[filename-String, wildcardMatcher-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add equals methods, document Unix/Windows behaviour\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140646 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/12/5 上午3:28",
          "commitName": "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/11/28 上午1:00",
          "commitNameOld": "289a56cf5d5c89ad3d85389b9651b0e227ded057",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 7.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 839,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean wildcardMatch(String filename, String wildcard) {\n-    String[] wcs \u003d splitOnTokens(wildcard);\n+public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n                 textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e filename.length()) {\n         return false;\n     }\n     if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Add equals methods, document Unix/Windows behaviour\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140646 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/12/5 上午3:28",
          "commitName": "a09ebfc6c0f84a0aa9a05da04801461d99509ec5",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/11/28 上午1:00",
          "commitNameOld": "289a56cf5d5c89ad3d85389b9651b0e227ded057",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 7.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 839,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean wildcardMatch(String filename, String wildcard) {\n-    String[] wcs \u003d splitOnTokens(wildcard);\n+public static boolean wildcardMatch(String filename, String wildcardMatcher) {\n+    String[] wcs \u003d splitOnTokens(wildcardMatcher);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n                 textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e filename.length()) {\n         return false;\n     }\n     if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n\n@param filename the filename to match on\n@param wildcard the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
            "newValue": "Checks a filename to see if it matches the specified wildcard matcher.\n\u003cp\u003e\nThe wildcard matcher uses the characters \u0027?\u0027 and \u0027*\u0027 to represent a\nsingle or multiple wildcard characters.\nThis is the same as often found on Dos/Unix command lines.\n\u003cpre\u003e\nwildcardMatch(\"c.txt\", \"*.txt\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.jpg\")      --\u003e false\nwildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --\u003e true\nwildcardMatch(\"c.txt\", \"*.???\")      --\u003e true\nwildcardMatch(\"c.txt\", \"*.????\")     --\u003e false\n\u003c/pre\u003e\n\n@param filename the filename to match on\n@param wildcardMatcher the wildcard string to match against\n@return true if the filename matches the wilcard string\n"
          }
        }
      ]
    },
    "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Add commented out implementations of prefix handling, Javadoc\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140640 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/11/22 上午9:11",
      "commitName": "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add commented out implementations of prefix handling, Javadoc\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140640 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/11/22 上午9:11",
          "commitName": "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/10/31 下午12:17",
          "commitNameOld": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 21.87,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 763,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n\n@param filename the filename to match on\n@param wildcard the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean wildcardMatch(String text, String wildcard) {\n+public static boolean wildcardMatch(String filename, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n-    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n+    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n-                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n+                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n-                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n+                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n-    if (textIdx \u003e text.length()) {\n+    if (textIdx \u003e filename.length()) {\n         return false;\n     }\n-    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n+    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[text-String, wildcard-String]",
            "newValue": "[filename-String, wildcard-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add commented out implementations of prefix handling, Javadoc\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140640 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/11/22 上午9:11",
          "commitName": "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/10/31 下午12:17",
          "commitNameOld": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 21.87,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 763,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n\n@param filename the filename to match on\n@param wildcard the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean wildcardMatch(String text, String wildcard) {\n+public static boolean wildcardMatch(String filename, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n-    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n+    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n-                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n+                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n-                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n+                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n-    if (textIdx \u003e text.length()) {\n+    if (textIdx \u003e filename.length()) {\n         return false;\n     }\n-    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n+    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Add commented out implementations of prefix handling, Javadoc\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140640 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/11/22 上午9:11",
          "commitName": "f93f8bebb4fc714a6b60e1d2a4452d6ff6d3df5c",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/10/31 下午12:17",
          "commitNameOld": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 21.87,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String filename, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e filename.length()) {\n        return false;\n    }\n    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 763,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n\n@param filename the filename to match on\n@param wildcard the wildcard string to match against\n@return true if the filename matches the wilcard string\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean wildcardMatch(String text, String wildcard) {\n+public static boolean wildcardMatch(String filename, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n-    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n+    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c filename.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n-                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n+                textIdx \u003d filename.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n-                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n+                if (!filename.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n-    if (textIdx \u003e text.length()) {\n+    if (textIdx \u003e filename.length()) {\n         return false;\n     }\n-    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n+    if (textIdx \u003c filename.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n",
            "newValue": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n\n@param filename the filename to match on\n@param wildcard the wildcard string to match against\n@return true if the filename matches the wilcard string\n"
          }
        }
      ]
    },
    "4694d5a982413a12bce4ce0e5570404b8cc7b1f7": {
      "type": "Ymultichange(Ymovefromfile,Ydocchange,Yrename)",
      "commitMessage": "merged WildcardUtils into FilenameUtils; thought the test case is still a separate file\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140639 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/10/31 下午12:17",
      "commitName": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "merged WildcardUtils into FilenameUtils; thought the test case is still a separate file\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140639 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/10/31 下午12:17",
          "commitName": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2004/10/31 上午8:03",
          "commitNameOld": "4a61d8cf150c561fe24477350eb6de2bb41ef750",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String text, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e text.length()) {\n        return false;\n    }\n    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 560,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean match(String text, String wildcard) {\n+public static boolean wildcardMatch(String text, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n                 textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e text.length()) {\n         return false;\n     }\n     if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/java/org/apache/commons/io/WildcardUtils.java",
            "newPath": "src/java/org/apache/commons/io/FilenameUtils.java",
            "oldMethodName": "match",
            "newMethodName": "wildcardMatch"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "merged WildcardUtils into FilenameUtils; thought the test case is still a separate file\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140639 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/10/31 下午12:17",
          "commitName": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2004/10/31 上午8:03",
          "commitNameOld": "4a61d8cf150c561fe24477350eb6de2bb41ef750",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String text, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e text.length()) {\n        return false;\n    }\n    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 560,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean match(String text, String wildcard) {\n+public static boolean wildcardMatch(String text, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n                 textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e text.length()) {\n         return false;\n     }\n     if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard.\n",
            "newValue": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n"
          }
        },
        {
          "type": "Yrename",
          "commitMessage": "merged WildcardUtils into FilenameUtils; thought the test case is still a separate file\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140639 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/10/31 下午12:17",
          "commitName": "4694d5a982413a12bce4ce0e5570404b8cc7b1f7",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2004/10/31 上午8:03",
          "commitNameOld": "4a61d8cf150c561fe24477350eb6de2bb41ef750",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean wildcardMatch(String text, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e text.length()) {\n        return false;\n    }\n    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
          "path": "src/java/org/apache/commons/io/FilenameUtils.java",
          "functionStartLine": 560,
          "functionName": "wildcardMatch",
          "functionAnnotation": "",
          "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard, as seen on DOS/UNIX command lines.\n",
          "diff": "@@ -1,37 +1,37 @@\n-public static boolean match(String text, String wildcard) {\n+public static boolean wildcardMatch(String text, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n     int wcsIdx \u003d 0;\n     boolean anyChars \u003d false;\n     while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n         if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n         } else if (!wcs[wcsIdx].equals(\"*\")) {\n             if (anyChars) {\n                 textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                 if (textIdx \u003d\u003d -1) {\n                     return false;\n                 }\n             } else {\n                 if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                     return false;\n                 }\n             }\n             textIdx +\u003d wcs[wcsIdx].length();\n         }\n         anyChars \u003d wcs[wcsIdx].equals(\"*\");\n         wcsIdx++;\n     }\n     if (wcsIdx \u003c wcs.length) {\n         if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n             return false;\n         }\n     }\n     if (textIdx \u003e text.length()) {\n         return false;\n     }\n     if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n         return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "match",
            "newValue": "wildcardMatch"
          }
        }
      ]
    },
    "fe44f3401d6d2b6c66eca32058de5bcd1f6facb9": {
      "type": "Yfilerename",
      "commitMessage": "moved WildcardUtils up a directory as it is used in two sub-packages of IO\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140620 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/10/26 上午6:55",
      "commitName": "fe44f3401d6d2b6c66eca32058de5bcd1f6facb9",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2004/10/26 上午6:53",
      "commitNameOld": "dfb79b3263d2a1f2c77e4d307e7af4e4341e604a",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean match(String text, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e text.length()) {\n        return false;\n    }\n    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
      "path": "src/java/org/apache/commons/io/WildcardUtils.java",
      "functionStartLine": 30,
      "functionName": "match",
      "functionAnnotation": "",
      "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/io/find/WildcardUtils.java",
        "newPath": "src/java/org/apache/commons/io/WildcardUtils.java"
      }
    },
    "400e99de58edf0d46a2b22818c37384a3ec9d122": {
      "type": "Ybodychange",
      "commitMessage": "More tests for WildcardUtils.match and a new implementation of the match method.\nMostly the same as Bugzilla #31115, though the old tests were kept and they\nshowed a bug.\n\nSubmitted by:\tJason Anderson\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140606 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/9/22 下午12:12",
      "commitName": "400e99de58edf0d46a2b22818c37384a3ec9d122",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2004/9/17 上午8:14",
      "commitNameOld": "4fbac940f62e0e5196498c3b7cb4ab909ce1a337",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 5.16,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean match(String text, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    int wcsIdx \u003d 0;\n    boolean anyChars \u003d false;\n    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n        if (wcs[wcsIdx].equals(\"?\")) {\n            textIdx++;\n        } else if (!wcs[wcsIdx].equals(\"*\")) {\n            if (anyChars) {\n                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n                if (textIdx \u003d\u003d -1) {\n                    return false;\n                }\n            } else {\n                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n                    return false;\n                }\n            }\n            textIdx +\u003d wcs[wcsIdx].length();\n        }\n        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n        wcsIdx++;\n    }\n    if (wcsIdx \u003c wcs.length) {\n        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n            return false;\n        }\n    }\n    if (textIdx \u003e text.length()) {\n        return false;\n    }\n    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n        return false;\n    }\n    return true;\n}",
      "path": "src/java/org/apache/commons/io/find/WildcardUtils.java",
      "functionStartLine": 30,
      "functionName": "match",
      "functionAnnotation": "",
      "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard.\n",
      "diff": "@@ -1,33 +1,37 @@\n public static boolean match(String text, String wildcard) {\n     String[] wcs \u003d splitOnTokens(wildcard);\n     int textIdx \u003d 0;\n-    for (int i \u003d 0; i \u003c wcs.length; i++) {\n-        if (textIdx \u003d\u003d text.length()) {\n-            if (\"*\".equals(wcs[i])) {\n-                return true;\n-            }\n-            return wcs[i].length() \u003d\u003d 0;\n-        }\n-        if (\"?\".equals(wcs[i])) {\n+    int wcsIdx \u003d 0;\n+    boolean anyChars \u003d false;\n+    while (wcsIdx \u003c wcs.length \u0026\u0026 textIdx \u003c text.length()) {\n+        if (wcs[wcsIdx].equals(\"?\")) {\n             textIdx++;\n-        } else if (\"*\".equals(wcs[i])) {\n-            int nextIdx \u003d i + 1;\n-            if (nextIdx \u003d\u003d wcs.length) {\n-                return true;\n-            }\n-            int restartIdx \u003d text.indexOf(wcs[nextIdx], textIdx);\n-            if (restartIdx \u003d\u003d -1) {\n-                return false;\n+        } else if (!wcs[wcsIdx].equals(\"*\")) {\n+            if (anyChars) {\n+                textIdx \u003d text.indexOf(wcs[wcsIdx], textIdx);\n+                if (textIdx \u003d\u003d -1) {\n+                    return false;\n+                }\n             } else {\n-                textIdx \u003d restartIdx;\n+                if (!text.startsWith(wcs[wcsIdx], textIdx)) {\n+                    return false;\n+                }\n             }\n-        } else {\n-            if (!text.startsWith(wcs[i], textIdx)) {\n-                return false;\n-            } else {\n-                textIdx +\u003d wcs[i].length();\n-            }\n+            textIdx +\u003d wcs[wcsIdx].length();\n         }\n+        anyChars \u003d wcs[wcsIdx].equals(\"*\");\n+        wcsIdx++;\n+    }\n+    if (wcsIdx \u003c wcs.length) {\n+        if (wcsIdx + 1 !\u003d wcs.length || !(wcs[wcsIdx].equals(\"*\") || wcs[wcsIdx].equals(\"\"))) {\n+            return false;\n+        }\n+    }\n+    if (textIdx \u003e text.length()) {\n+        return false;\n+    }\n+    if (textIdx \u003c text.length() \u0026\u0026 !anyChars) {\n+        return false;\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4fbac940f62e0e5196498c3b7cb4ab909ce1a337": {
      "type": "Yintroduced",
      "commitMessage": "added finding subsystem to IO along with WildcardUtils\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/trunk@140602 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/9/17 上午8:14",
      "commitName": "4fbac940f62e0e5196498c3b7cb4ab909ce1a337",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,33 @@\n+public static boolean match(String text, String wildcard) {\n+    String[] wcs \u003d splitOnTokens(wildcard);\n+    int textIdx \u003d 0;\n+    for (int i \u003d 0; i \u003c wcs.length; i++) {\n+        if (textIdx \u003d\u003d text.length()) {\n+            if (\"*\".equals(wcs[i])) {\n+                return true;\n+            }\n+            return wcs[i].length() \u003d\u003d 0;\n+        }\n+        if (\"?\".equals(wcs[i])) {\n+            textIdx++;\n+        } else if (\"*\".equals(wcs[i])) {\n+            int nextIdx \u003d i + 1;\n+            if (nextIdx \u003d\u003d wcs.length) {\n+                return true;\n+            }\n+            int restartIdx \u003d text.indexOf(wcs[nextIdx], textIdx);\n+            if (restartIdx \u003d\u003d -1) {\n+                return false;\n+            } else {\n+                textIdx \u003d restartIdx;\n+            }\n+        } else {\n+            if (!text.startsWith(wcs[i], textIdx)) {\n+                return false;\n+            } else {\n+                textIdx +\u003d wcs[i].length();\n+            }\n+        }\n+    }\n+    return true;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static boolean match(String text, String wildcard) {\n    String[] wcs \u003d splitOnTokens(wildcard);\n    int textIdx \u003d 0;\n    for (int i \u003d 0; i \u003c wcs.length; i++) {\n        if (textIdx \u003d\u003d text.length()) {\n            if (\"*\".equals(wcs[i])) {\n                return true;\n            }\n            return wcs[i].length() \u003d\u003d 0;\n        }\n        if (\"?\".equals(wcs[i])) {\n            textIdx++;\n        } else if (\"*\".equals(wcs[i])) {\n            int nextIdx \u003d i + 1;\n            if (nextIdx \u003d\u003d wcs.length) {\n                return true;\n            }\n            int restartIdx \u003d text.indexOf(wcs[nextIdx], textIdx);\n            if (restartIdx \u003d\u003d -1) {\n                return false;\n            } else {\n                textIdx \u003d restartIdx;\n            }\n        } else {\n            if (!text.startsWith(wcs[i], textIdx)) {\n                return false;\n            } else {\n                textIdx +\u003d wcs[i].length();\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/java/org/apache/commons/io/find/WildcardUtils.java",
      "functionStartLine": 30,
      "functionName": "match",
      "functionAnnotation": "",
      "functionDoc": "See if a particular piece of text, often a filename, \nmatches to a specified wildcard.\n"
    }
  }
}