{
  "origin": "codeshovel",
  "repositoryName": "django",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/django/.git",
  "startCommitName": "39791c8e6de3a71879eb26dd9f8d01273847f395",
  "sourceFileName": "forms.py",
  "functionName": "_html_output",
  "functionId": "BaseForm___html_output___self__normal_row__error_row__row_ender__help_text_html__errors_on_separate_row",
  "sourceFilePath": "django/forms/forms.py",
  "functionAnnotation": "",
  "functionStartLine": 192,
  "functionEndLine": 268,
  "numCommitsSeen": 287,
  "timeTaken": 11267,
  "changeHistory": [
    "7c7bc6391a3e83566f9ace59955e63503bc76cee",
    "301de774c21d055e9e5a7073e5bffdb52bc71079",
    "8346680e1ca4a8ddc8190baf3f5f944f6418d5cf",
    "3eb679a86956d9eedf24492f0002de002f7180f5",
    "7b2f2e74adb36a4334e83130f6abc2f79d395235",
    "1884bf8e8e9fb3f9f44a9ec216aca96f63974268",
    "3f9ec12d9c9eff9a3b1a205d87c7e66587cf9967",
    "053de6131af83c63ec17d38578889c71de913d24",
    "584bd14dcfdee9585fec7794d53ce120ea73d0bc",
    "962f133f72abe2a1174d48baa52aa8549762a022",
    "c5ef65bcf324f4c90b53be90f4aec069a68e8c59",
    "bdca5ea345c548a82a80d198906818c9ccbef896",
    "8fdc56d2a6f7537cdd52272501af9e94cab96ed4",
    "a92e7f37c4ae84b6b8d8016cc6783211e9047219",
    "4a103086d5c67fa4fcc53c106c9fdf644c742dd8",
    "477f4d80616392bbd3352cad50faedb9c1494b33",
    "5e83b79d260598fcdcc2014f99e6669c5b2a44f7",
    "92803205cbcaaee16ac0eb724c45019a9d896aac",
    "bcd63cbfb0590a2e2bed3e4beab3f467279ad3db",
    "9931c9e1321e3290b065bc0f5ec8353b1bcb71f3",
    "46786b4193e04d398532bbfc3dcf63c03c1793cb",
    "931b9f310854e30a814cb3073c67007e709f6e5f",
    "356662cf74c99fac90afb0f5e6aac8d2d573e62a",
    "748e55b1daa1260964d9ec29f50e01b4b4c0f5d8",
    "ce249d4366a800ebc033cefb8beb33b9b0dba051",
    "953badbea5a04159adbfa970f5805c0232b6a401",
    "8a4a8023d61cb31093db7b511e58ea3502e47cb6",
    "b8fa80bd0020eee186e5288e3fd2552695093025",
    "cf75fcc8321b822cb4758d167f1fade56a60ad4f",
    "54b8277ffb4cad90fb65ca4edf69d8279b8df898",
    "d0fcef9db0f53ef84535694f4fbcb135f0648e24",
    "d93021eb10b1ff8c49a4f4746789c22589886260",
    "c50d333c23a3c53d05623ce15df79e624c57f37c",
    "b4a67359a34c77e2e40f1ab8e30b96278a063007"
  ],
  "changeHistoryShort": {
    "7c7bc6391a3e83566f9ace59955e63503bc76cee": "Ybodychange",
    "301de774c21d055e9e5a7073e5bffdb52bc71079": "Ybodychange",
    "8346680e1ca4a8ddc8190baf3f5f944f6418d5cf": "Ybodychange",
    "3eb679a86956d9eedf24492f0002de002f7180f5": "Ybodychange",
    "7b2f2e74adb36a4334e83130f6abc2f79d395235": "Ybodychange",
    "1884bf8e8e9fb3f9f44a9ec216aca96f63974268": "Ybodychange",
    "3f9ec12d9c9eff9a3b1a205d87c7e66587cf9967": "Ybodychange",
    "053de6131af83c63ec17d38578889c71de913d24": "Ybodychange",
    "584bd14dcfdee9585fec7794d53ce120ea73d0bc": "Ybodychange",
    "962f133f72abe2a1174d48baa52aa8549762a022": "Ybodychange",
    "c5ef65bcf324f4c90b53be90f4aec069a68e8c59": "Ybodychange",
    "bdca5ea345c548a82a80d198906818c9ccbef896": "Ybodychange",
    "8fdc56d2a6f7537cdd52272501af9e94cab96ed4": "Ybodychange",
    "a92e7f37c4ae84b6b8d8016cc6783211e9047219": "Ybodychange",
    "4a103086d5c67fa4fcc53c106c9fdf644c742dd8": "Ybodychange",
    "477f4d80616392bbd3352cad50faedb9c1494b33": "Ybodychange",
    "5e83b79d260598fcdcc2014f99e6669c5b2a44f7": "Ybodychange",
    "92803205cbcaaee16ac0eb724c45019a9d896aac": "Ybodychange",
    "bcd63cbfb0590a2e2bed3e4beab3f467279ad3db": "Ybodychange",
    "9931c9e1321e3290b065bc0f5ec8353b1bcb71f3": "Ybodychange",
    "46786b4193e04d398532bbfc3dcf63c03c1793cb": "Yfilerename",
    "931b9f310854e30a814cb3073c67007e709f6e5f": "Ybodychange",
    "356662cf74c99fac90afb0f5e6aac8d2d573e62a": "Ybodychange",
    "748e55b1daa1260964d9ec29f50e01b4b4c0f5d8": "Ybodychange",
    "ce249d4366a800ebc033cefb8beb33b9b0dba051": "Ybodychange",
    "953badbea5a04159adbfa970f5805c0232b6a401": "Ybodychange",
    "8a4a8023d61cb31093db7b511e58ea3502e47cb6": "Ybodychange",
    "b8fa80bd0020eee186e5288e3fd2552695093025": "Ybodychange",
    "cf75fcc8321b822cb4758d167f1fade56a60ad4f": "Ymultichange(Yparameterchange,Ybodychange)",
    "54b8277ffb4cad90fb65ca4edf69d8279b8df898": "Ybodychange",
    "d0fcef9db0f53ef84535694f4fbcb135f0648e24": "Ybodychange",
    "d93021eb10b1ff8c49a4f4746789c22589886260": "Ybodychange",
    "c50d333c23a3c53d05623ce15df79e624c57f37c": "Ybodychange",
    "b4a67359a34c77e2e40f1ab8e30b96278a063007": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c7bc6391a3e83566f9ace59955e63503bc76cee": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #28874 -- Prevented double escaping of errors on hidden form fields.\n\n",
      "commitDate": "2017/12/11 下午8:30",
      "commitName": "7c7bc6391a3e83566f9ace59955e63503bc76cee",
      "commitAuthor": "Daniil",
      "commitDateOld": "2017/12/8 上午6:13",
      "commitNameOld": "2b81faab257832d3dbd42947a884f7ec99685d18",
      "commitAuthorOld": "Tim Graham",
      "daysBetweenCommits": 3.6,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class(bf.errors)\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: str(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % str(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(bf.label)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: bf_errors,\n                    \u0027label\u0027: label,\n                    \u0027field\u0027: bf,\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027css_classes\u0027: css_classes,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027css_classes\u0027: \u0027\u0027,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 194,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,77 +1,76 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n-            # Escape and cache in local variable.\n-            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n+            bf_errors \u003d self.error_class(bf.errors)\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: str(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(str(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % str(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(bf.label)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % field.help_text\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: bf_errors,\n                     \u0027label\u0027: label,\n                     \u0027field\u0027: bf,\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n                     \u0027css_classes\u0027: css_classes,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % top_errors)\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\n                         \u0027errors\u0027: \u0027\u0027,\n                         \u0027label\u0027: \u0027\u0027,\n                         \u0027field\u0027: \u0027\u0027,\n                         \u0027help_text\u0027: \u0027\u0027,\n                         \u0027html_class_attr\u0027: html_class_attr,\n                         \u0027css_classes\u0027: \u0027\u0027,\n                         \u0027field_name\u0027: \u0027\u0027,\n                     })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "301de774c21d055e9e5a7073e5bffdb52bc71079": {
      "type": "Ybodychange",
      "commitMessage": "Refs #27795 -- Replaced many force_text() with str()\n\nThanks Tim Graham for the review.\n",
      "commitDate": "2017/4/27 下午3:10",
      "commitName": "301de774c21d055e9e5a7073e5bffdb52bc71079",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2017/4/2 上午6:43",
      "commitNameOld": "1aa8e8605cca95b31eaf6f5e47bc0742d6f2e0c7",
      "commitAuthorOld": "Stefan Wehrmeyer",
      "daysBetweenCommits": 25.35,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: str(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % str(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(bf.label)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: bf_errors,\n                    \u0027label\u0027: label,\n                    \u0027field\u0027: bf,\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027css_classes\u0027: css_classes,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027css_classes\u0027: \u0027\u0027,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 194,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,77 +1,77 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n-                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n+                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: str(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(str(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n-                    output.append(error_row % force_text(bf_errors))\n+                    output.append(error_row % str(bf_errors))\n \n                 if bf.label:\n-                    label \u003d conditional_escape(force_text(bf.label))\n+                    label \u003d conditional_escape(bf.label)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % field.help_text\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: bf_errors,\n                     \u0027label\u0027: label,\n                     \u0027field\u0027: bf,\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n                     \u0027css_classes\u0027: css_classes,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % top_errors)\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\n                         \u0027errors\u0027: \u0027\u0027,\n                         \u0027label\u0027: \u0027\u0027,\n                         \u0027field\u0027: \u0027\u0027,\n                         \u0027help_text\u0027: \u0027\u0027,\n                         \u0027html_class_attr\u0027: html_class_attr,\n                         \u0027css_classes\u0027: \u0027\u0027,\n                         \u0027field_name\u0027: \u0027\u0027,\n                     })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "8346680e1ca4a8ddc8190baf3f5f944f6418d5cf": {
      "type": "Ybodychange",
      "commitMessage": "Refs #27795 -- Removed unneeded force_text calls\n\nThanks Tim Graham for the review.\n",
      "commitDate": "2017/3/5 上午1:18",
      "commitName": "8346680e1ca4a8ddc8190baf3f5f944f6418d5cf",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2017/2/21 上午8:57",
      "commitNameOld": "3eb679a86956d9eedf24492f0002de002f7180f5",
      "commitAuthorOld": "Anton Samarchyan",
      "daysBetweenCommits": 11.68,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: bf_errors,\n                    \u0027label\u0027: label,\n                    \u0027field\u0027: bf,\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027css_classes\u0027: css_classes,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027css_classes\u0027: \u0027\u0027,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 195,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,77 +1,77 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(str(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n-                    help_text \u003d help_text_html % force_text(field.help_text)\n+                    help_text \u003d help_text_html % field.help_text\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n-                    \u0027errors\u0027: force_text(bf_errors),\n-                    \u0027label\u0027: force_text(label),\n-                    \u0027field\u0027: str(bf),\n+                    \u0027errors\u0027: bf_errors,\n+                    \u0027label\u0027: label,\n+                    \u0027field\u0027: bf,\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n                     \u0027css_classes\u0027: css_classes,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n-            output.insert(0, error_row % force_text(top_errors))\n+            output.insert(0, error_row % top_errors)\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\n                         \u0027errors\u0027: \u0027\u0027,\n                         \u0027label\u0027: \u0027\u0027,\n                         \u0027field\u0027: \u0027\u0027,\n                         \u0027help_text\u0027: \u0027\u0027,\n                         \u0027html_class_attr\u0027: html_class_attr,\n                         \u0027css_classes\u0027: \u0027\u0027,\n                         \u0027field_name\u0027: \u0027\u0027,\n                     })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "3eb679a86956d9eedf24492f0002de002f7180f5": {
      "type": "Ybodychange",
      "commitMessage": "Refs #27656 -- Updated django.forms/http docstring verbs according to PEP 257.\n",
      "commitDate": "2017/2/21 上午8:57",
      "commitName": "3eb679a86956d9eedf24492f0002de002f7180f5",
      "commitAuthor": "Anton Samarchyan",
      "commitDateOld": "2017/2/7 下午4:04",
      "commitNameOld": "c651331b34b7c3841c126959e6e52879bc6f0834",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 13.7,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: str(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027css_classes\u0027: css_classes,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027css_classes\u0027: \u0027\u0027,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 195,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,77 +1,77 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n-        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n+        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(str(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: str(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n                     \u0027css_classes\u0027: css_classes,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\n                         \u0027errors\u0027: \u0027\u0027,\n                         \u0027label\u0027: \u0027\u0027,\n                         \u0027field\u0027: \u0027\u0027,\n                         \u0027help_text\u0027: \u0027\u0027,\n                         \u0027html_class_attr\u0027: html_class_attr,\n                         \u0027css_classes\u0027: \u0027\u0027,\n                         \u0027field_name\u0027: \u0027\u0027,\n                     })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "7b2f2e74adb36a4334e83130f6abc2f79d395235": {
      "type": "Ybodychange",
      "commitMessage": "Refs #23919 -- Removed six.\u003cvarious\u003e_types usage\n\nThanks Tim Graham and Simon Charette for the reviews.\n",
      "commitDate": "2017/1/19 上午3:18",
      "commitName": "7b2f2e74adb36a4334e83130f6abc2f79d395235",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2017/1/18 下午8:44",
      "commitNameOld": "f3c43ad1fd9556f0fd026a5dfa93c67a5cf186ca",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: str(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027css_classes\u0027: css_classes,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027css_classes\u0027: \u0027\u0027,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 197,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,77 +1,77 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n-                hidden_fields.append(six.text_type(bf))\n+                hidden_fields.append(str(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n-                    \u0027field\u0027: six.text_type(bf),\n+                    \u0027field\u0027: str(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n                     \u0027css_classes\u0027: css_classes,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\n                         \u0027errors\u0027: \u0027\u0027,\n                         \u0027label\u0027: \u0027\u0027,\n                         \u0027field\u0027: \u0027\u0027,\n                         \u0027help_text\u0027: \u0027\u0027,\n                         \u0027html_class_attr\u0027: html_class_attr,\n                         \u0027css_classes\u0027: \u0027\u0027,\n                         \u0027field_name\u0027: \u0027\u0027,\n                     })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "1884bf8e8e9fb3f9f44a9ec216aca96f63974268": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #12437 -- Added css_classes to Form._html_output()\n",
      "commitDate": "2015/6/7 上午7:23",
      "commitName": "1884bf8e8e9fb3f9f44a9ec216aca96f63974268",
      "commitAuthor": "Markus Amalthea Magnuson",
      "commitDateOld": "2015/6/5 上午1:51",
      "commitNameOld": "5987b3c46d5a6948737627d294d95ed54d49eae6",
      "commitAuthorOld": "Alasdair Nicol",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027css_classes\u0027: css_classes,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027css_classes\u0027: \u0027\u0027,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 187,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,75 +1,77 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n+                    \u0027css_classes\u0027: css_classes,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\n                         \u0027errors\u0027: \u0027\u0027,\n                         \u0027label\u0027: \u0027\u0027,\n                         \u0027field\u0027: \u0027\u0027,\n                         \u0027help_text\u0027: \u0027\u0027,\n                         \u0027html_class_attr\u0027: html_class_attr,\n+                        \u0027css_classes\u0027: \u0027\u0027,\n                         \u0027field_name\u0027: \u0027\u0027,\n                     })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "3f9ec12d9c9eff9a3b1a205d87c7e66587cf9967": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #23712 -- Fixed KeyError with BaseForm._html_output()\n",
      "commitDate": "2015/1/16 上午9:19",
      "commitName": "3f9ec12d9c9eff9a3b1a205d87c7e66587cf9967",
      "commitAuthor": "Yang Liu",
      "commitDateOld": "2014/12/4 上午3:27",
      "commitNameOld": "560b4207b1490a7d0cbf70cfbeba7daf2082e5be",
      "commitAuthorOld": "Berker Peksag",
      "daysBetweenCommits": 43.24,
      "commitsBetweenForRepo": 378,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\n                        \u0027errors\u0027: \u0027\u0027,\n                        \u0027label\u0027: \u0027\u0027,\n                        \u0027field\u0027: \u0027\u0027,\n                        \u0027help_text\u0027: \u0027\u0027,\n                        \u0027html_class_attr\u0027: html_class_attr,\n                        \u0027field_name\u0027: \u0027\u0027,\n                    })\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 194,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,70 +1,75 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors()  # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 attribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr,\n                     \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields:  # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n-                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n-                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027: \u0027\u0027,\n-                                              \u0027html_class_attr\u0027: html_class_attr})\n+                    last_row \u003d (normal_row % {\n+                        \u0027errors\u0027: \u0027\u0027,\n+                        \u0027label\u0027: \u0027\u0027,\n+                        \u0027field\u0027: \u0027\u0027,\n+                        \u0027help_text\u0027: \u0027\u0027,\n+                        \u0027html_class_attr\u0027: html_class_attr,\n+                        \u0027field_name\u0027: \u0027\u0027,\n+                    })\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "053de6131af83c63ec17d38578889c71de913d24": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #5749 -- Added field_name as a key in the _html_output dict\n\nThanks SmileyChris for the suggestion.\n",
      "commitDate": "2013/9/11 上午1:00",
      "commitName": "053de6131af83c63ec17d38578889c71de913d24",
      "commitAuthor": "e0ne",
      "commitDateOld": "2013/8/22 下午3:52",
      "commitNameOld": "8cd8742981020e315acc4e70bdf3613fcf68e3a8",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 19.38,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr,\n                    \u0027field_name\u0027: bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 146,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,69 +1,70 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n-                    \u0027html_class_attr\u0027: html_class_attr\n+                    \u0027html_class_attr\u0027: html_class_attr,\n+                    \u0027field_name\u0027: bf.html_name,\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "584bd14dcfdee9585fec7794d53ce120ea73d0bc": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #18134 -- BoundField.label_tag now includes the form\u0027s label_suffix\n\nThere was an inconsistency between how the label_tag for forms were\ngenerated depending on which method was used: as_p, as_ul and as_table\ncontained code to append the label_suffix where as label_tag called on a\nform field directly did NOT append the label_suffix. The code for\nappending the label_suffix has been moved in to the label_tag code of\nthe field and the HTML generation code for as_p, as_ul and as_table now\ncalls this code as well.\n\nThis is a backwards incompatible change because users who have added the\nlabel_suffix manually in their templates may now get double label_suffix\ncharacters in their forms.\n",
      "commitDate": "2013/6/11 上午2:23",
      "commitName": "584bd14dcfdee9585fec7794d53ce120ea73d0bc",
      "commitAuthor": "Gabe Jackson",
      "commitDateOld": "2013/5/27 上午10:47",
      "commitNameOld": "0fa8d43e742ee8b480d938a47836b5a3720c2677",
      "commitAuthorOld": "Ramiro Morales",
      "daysBetweenCommits": 14.65,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 145,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,74 +1,69 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             # Escape and cache in local variable.\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend(\n                         [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                          for e in bf_errors])\n                 hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n-                    # Only add the suffix if the label does not end in\n-                    # punctuation.\n-                    if self.label_suffix:\n-                        if label[-1] not in \u0027:?.!\u0027:\n-                            label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "962f133f72abe2a1174d48baa52aa8549762a022": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #18483 -- Marked hidden field error string for translation\n\nThanks Evil Clay for the report and Emil Stenstrom for the initial\npatch.\n",
      "commitDate": "2013/1/27 上午2:59",
      "commitName": "962f133f72abe2a1174d48baa52aa8549762a022",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2013/1/26 上午5:41",
      "commitNameOld": "58062a6302a2bf1013d100deb053ccae2298bb84",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            # Escape and cache in local variable.\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 144,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,74 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n-            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n+            # Escape and cache in local variable.\n+            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors])\n             if bf.is_hidden:\n                 if bf_errors:\n-                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_text(e)) for e in bf_errors])\n+                    top_errors.extend(\n+                        [_(\u0027(Hidden field %(name)s) %(error)s\u0027) % {\u0027name\u0027: name, \u0027error\u0027: force_text(e)}\n+                         for e in bf_errors])\n                 hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_text(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_text(bf_errors),\n                     \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "c5ef65bcf324f4c90b53be90f4aec069a68e8c59": {
      "type": "Ybodychange",
      "commitMessage": "[py3] Ported django.utils.encoding.\n\n* Renamed smart_unicode to smart_text (but kept the old name under\n  Python 2 for backwards compatibility).\n* Renamed smart_str to smart_bytes.\n* Re-introduced smart_str as an alias for smart_text under Python 3\n  and smart_bytes under Python 2 (which is backwards compatible).\n  Thus smart_str always returns a str objects.\n* Used the new smart_str in a few places where both Python 2 and 3\n  want a str.\n",
      "commitDate": "2012/8/7 下午6:00",
      "commitName": "c5ef65bcf324f4c90b53be90f4aec069a68e8c59",
      "commitAuthor": "Aymeric Augustin",
      "commitDateOld": "2012/8/7 下午6:00",
      "commitNameOld": "ee191715eae73362768184aa95206cf61bac5d38",
      "commitAuthorOld": "Aymeric Augustin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_text(e)) for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_text(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_text(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_text(bf_errors),\n                    \u0027label\u0027: force_text(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 142,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n-                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n+                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_text(e)) for e in bf_errors])\n                 hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n-                    output.append(error_row % force_unicode(bf_errors))\n+                    output.append(error_row % force_text(bf_errors))\n \n                 if bf.label:\n-                    label \u003d conditional_escape(force_unicode(bf.label))\n+                    label \u003d conditional_escape(force_text(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n-                    help_text \u003d help_text_html % force_unicode(field.help_text)\n+                    help_text \u003d help_text_html % force_text(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n-                    \u0027errors\u0027: force_unicode(bf_errors),\n-                    \u0027label\u0027: force_unicode(label),\n+                    \u0027errors\u0027: force_text(bf_errors),\n+                    \u0027label\u0027: force_text(label),\n                     \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n-            output.insert(0, error_row % force_unicode(top_errors))\n+            output.insert(0, error_row % force_text(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "bdca5ea345c548a82a80d198906818c9ccbef896": {
      "type": "Ybodychange",
      "commitMessage": "[py3] Replaced unicode/str by six.text_type/bytes.\n",
      "commitDate": "2012/7/22 下午3:29",
      "commitName": "bdca5ea345c548a82a80d198906818c9ccbef896",
      "commitAuthor": "Aymeric Augustin",
      "commitDateOld": "2012/7/22 下午3:29",
      "commitNameOld": "d11d45aad969be313b9e046d0d42b179a3fb6906",
      "commitAuthorOld": "Aymeric Augustin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: six.text_type(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 142,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n-                hidden_fields.append(unicode(bf))\n+                hidden_fields.append(six.text_type(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_unicode(bf_errors),\n                     \u0027label\u0027: force_unicode(label),\n-                    \u0027field\u0027: unicode(bf),\n+                    \u0027field\u0027: six.text_type(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "8fdc56d2a6f7537cdd52272501af9e94cab96ed4": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #18572 - Python26 string format incompatibility\n\nThanks to anonymous/AeroNotix for the report\n",
      "commitDate": "2012/7/6 上午7:23",
      "commitName": "8fdc56d2a6f7537cdd52272501af9e94cab96ed4",
      "commitAuthor": "Luke Plant",
      "commitDateOld": "2012/7/4 上午5:20",
      "commitNameOld": "a92e7f37c4ae84b6b8d8016cc6783211e9047219",
      "commitAuthorOld": "Luke Plant",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: unicode(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 141,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n-                            label \u003d format_html(\u0027{}{}\u0027, label, self.label_suffix)\n+                            label \u003d format_html(\u0027{0}{1}\u0027, label, self.label_suffix)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_unicode(bf_errors),\n                     \u0027label\u0027: force_unicode(label),\n                     \u0027field\u0027: unicode(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "a92e7f37c4ae84b6b8d8016cc6783211e9047219": {
      "type": "Ybodychange",
      "commitMessage": "Changed a lot of internal code to use \u0027format_html\u0027 where appropriate/possible\n",
      "commitDate": "2012/7/4 上午5:20",
      "commitName": "a92e7f37c4ae84b6b8d8016cc6783211e9047219",
      "commitAuthor": "Luke Plant",
      "commitDateOld": "2012/6/8 上午12:08",
      "commitNameOld": "4a103086d5c67fa4fcc53c106c9fdf644c742dd8",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 26.22,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label \u003d format_html(\u0027{}{}\u0027, label, self.label_suffix)\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: unicode(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 141,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n-                            label +\u003d self.label_suffix\n+                            label \u003d format_html(\u0027{}{}\u0027, label, self.label_suffix)\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_unicode(bf_errors),\n                     \u0027label\u0027: force_unicode(label),\n                     \u0027field\u0027: unicode(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "4a103086d5c67fa4fcc53c106c9fdf644c742dd8": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #18269 -- Applied unicode_literals for Python 3 compatibility.\n\nThanks Vinay Sajip for the support of his django3 branch and\nJannis Leidel for the review.\n",
      "commitDate": "2012/6/8 上午12:08",
      "commitName": "4a103086d5c67fa4fcc53c106c9fdf644c742dd8",
      "commitAuthor": "Claude Paroz",
      "commitDateOld": "2012/4/30 上午2:57",
      "commitNameOld": "3904b74a3f2f92fefe1d39281ed683c52f2fef03",
      "commitAuthorOld": "Claude Paroz",
      "daysBetweenCommits": 38.88,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d \u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: unicode(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 141,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n             bf \u003d self[name]\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n-                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n+                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n-                    help_text \u003d u\u0027\u0027\n+                    help_text \u003d \u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_unicode(bf_errors),\n                     \u0027label\u0027: force_unicode(label),\n                     \u0027field\u0027: unicode(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n-            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n+            str_hidden \u003d \u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n-        return mark_safe(u\u0027\\n\u0027.join(output))\n+        return mark_safe(\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "477f4d80616392bbd3352cad50faedb9c1494b33": {
      "type": "Ybodychange",
      "commitMessage": "Clean up the form\u0027s code a little bit, to make it more consistantly go through one code path. Patch from Travis Swicegood.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17381 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2012/1/20 上午6:05",
      "commitName": "477f4d80616392bbd3352cad50faedb9c1494b33",
      "commitAuthor": "Alex Gaynor",
      "commitDateOld": "2011/12/8 上午7:08",
      "commitNameOld": "08bec4fbc10ca5638ad22f20a753ec5e8d92eb0e",
      "commitAuthorOld": "Adrian Holovaty",
      "daysBetweenCommits": 42.96,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d self[name]\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: unicode(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 141,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n \n         for name, field in self.fields.items():\n             html_class_attr \u003d \u0027\u0027\n-            bf \u003d BoundField(self, field, name)\n+            bf \u003d self[name]\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_unicode(bf_errors),\n                     \u0027label\u0027: force_unicode(label),\n                     \u0027field\u0027: unicode(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "5e83b79d260598fcdcc2014f99e6669c5b2a44f7": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #12466 - Set HTML class attributes for each field separately. Thanks for the patch, Bernd Schlapsi.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@12153 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2010/1/10 上午6:51",
      "commitName": "5e83b79d260598fcdcc2014f99e6669c5b2a44f7",
      "commitAuthor": "Jannis Leidel",
      "commitDateOld": "2010/1/5 上午11:56",
      "commitNameOld": "471596fc1afcb9c6258d317c619eaf5fd394e797",
      "commitAuthorOld": "Joseph Kocherhans",
      "daysBetweenCommits": 4.79,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n\n        for name, field in self.fields.items():\n            html_class_attr \u003d \u0027\u0027\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: unicode(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 137,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,71 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n-        html_class_attr \u003d \u0027\u0027\n \n         for name, field in self.fields.items():\n+            html_class_attr \u003d \u0027\u0027\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                 # CSS classes applied.\n                 css_classes \u003d bf.css_classes()\n                 if css_classes:\n                     html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n \n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n \n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n \n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n \n                 output.append(normal_row % {\n                     \u0027errors\u0027: force_unicode(bf_errors),\n                     \u0027label\u0027: force_unicode(label),\n                     \u0027field\u0027: unicode(bf),\n                     \u0027help_text\u0027: help_text,\n                     \u0027html_class_attr\u0027: html_class_attr\n                 })\n \n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n \n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                               \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                               \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "92803205cbcaaee16ac0eb724c45019a9d896aac": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #3512: it\u0027s now possible to add CSS hooks to required/erroneous form rows. Thanks, SmileyChris.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@11830 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2009/12/13 上午2:52",
      "commitName": "92803205cbcaaee16ac0eb724c45019a9d896aac",
      "commitAuthor": "Jacob Kaplan-Moss",
      "commitDateOld": "2009/12/13 上午2:18",
      "commitNameOld": "9c4bd2aa33fed8ba8ba328ae487e80135ac1498f",
      "commitAuthorOld": "Karen Tracey",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        html_class_attr \u003d \u0027\u0027\n\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n                # CSS classes applied.\n                css_classes \u003d bf.css_classes()\n                if css_classes:\n                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n\n                output.append(normal_row % {\n                    \u0027errors\u0027: force_unicode(bf_errors),\n                    \u0027label\u0027: force_unicode(label),\n                    \u0027field\u0027: unicode(bf),\n                    \u0027help_text\u0027: help_text,\n                    \u0027html_class_attr\u0027: html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n                                              \u0027html_class_attr\u0027: html_class_attr})\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 137,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,50 +1,71 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n+        html_class_attr \u003d \u0027\u0027\n+\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n+                # Create a \u0027class\u003d\"...\"\u0027 atribute if the row should have any\n+                # CSS classes applied.\n+                css_classes \u003d bf.css_classes()\n+                if css_classes:\n+                    html_class_attr \u003d \u0027 class\u003d\"%s\"\u0027 % css_classes\n+\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n+\n                 if bf.label:\n                     label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n+\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n-                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n+\n+                output.append(normal_row % {\n+                    \u0027errors\u0027: force_unicode(bf_errors),\n+                    \u0027label\u0027: force_unicode(label),\n+                    \u0027field\u0027: unicode(bf),\n+                    \u0027help_text\u0027: help_text,\n+                    \u0027html_class_attr\u0027: html_class_attr\n+                })\n+\n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n+\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n-                    last_row \u003d normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027, \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027: \u0027\u0027}\n+                    last_row \u003d (normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027,\n+                                              \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027:\u0027\u0027,\n+                                              \u0027html_class_attr\u0027: html_class_attr})\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "bcd63cbfb0590a2e2bed3e4beab3f467279ad3db": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #6160, #9111 -- Consistently apply conditional_escape to form errors and labels when outputing them as HTML.  \n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@9365 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/11/7 上午3:49",
      "commitName": "bcd63cbfb0590a2e2bed3e4beab3f467279ad3db",
      "commitAuthor": "Karen Tracey",
      "commitDateOld": "2008/9/18 下午3:16",
      "commitNameOld": "9931c9e1321e3290b065bc0f5ec8353b1bcb71f3",
      "commitAuthorOld": "Malcolm Tredinnick",
      "daysBetweenCommits": 49.52,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027, \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027: \u0027\u0027}\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 137,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,50 +1,50 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n-            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n+            bf_errors \u003d self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n-                    label \u003d escape(force_unicode(bf.label))\n+                    label \u003d conditional_escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 if not last_row.endswith(row_ender):\n                     # This can happen in the as_p() case (and possibly others\n                     # that users write): if there are only top errors, we may\n                     # not be able to conscript the last row for our purposes,\n                     # so insert a new, empty row.\n                     last_row \u003d normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027, \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027: \u0027\u0027}\n                     output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "9931c9e1321e3290b065bc0f5ec8353b1bcb71f3": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #9125 -- When displaying errors for a form with only hidden fields, make sure the resulting XHTML is correct.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@9067 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/9/18 下午3:16",
      "commitName": "9931c9e1321e3290b065bc0f5ec8353b1bcb71f3",
      "commitAuthor": "Malcolm Tredinnick",
      "commitDateOld": "2008/9/2 上午5:33",
      "commitNameOld": "2487e3ae37864eb41c532c46ef7e3189ec910ca2",
      "commitAuthorOld": "Brian Rosner",
      "daysBetweenCommits": 16.4,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row \u003d normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027, \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027: \u0027\u0027}\n                    output.append(last_row)\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 137,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,43 +1,50 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n                     label \u003d escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % force_unicode(top_errors))\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n+                if not last_row.endswith(row_ender):\n+                    # This can happen in the as_p() case (and possibly others\n+                    # that users write): if there are only top errors, we may\n+                    # not be able to conscript the last row for our purposes,\n+                    # so insert a new, empty row.\n+                    last_row \u003d normal_row % {\u0027errors\u0027: \u0027\u0027, \u0027label\u0027: \u0027\u0027, \u0027field\u0027: \u0027\u0027, \u0027help_text\u0027: \u0027\u0027}\n+                    output.append(last_row)\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "46786b4193e04d398532bbfc3dcf63c03c1793cb": {
      "type": "Yfilerename",
      "commitMessage": "Fixed #7741: django.newforms is now django.forms. This is obviously a backwards-incompatible change. There\u0027s a warning upon import of django.newforms itself, but deeper imports will raise errors.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@7971 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/7/19 上午9:22",
      "commitName": "46786b4193e04d398532bbfc3dcf63c03c1793cb",
      "commitAuthor": "Jacob Kaplan-Moss",
      "commitDateOld": "2008/7/19 上午9:07",
      "commitNameOld": "39af2738fd64ba7f4c4af0783590e2b2b7b88460",
      "commitAuthorOld": "Russell Keith-Magee",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/forms/forms.py",
      "functionStartLine": 131,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "django/newforms/forms.py",
        "newPath": "django/forms/forms.py"
      }
    },
    "931b9f310854e30a814cb3073c67007e709f6e5f": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #5811 -- Added an explicit conversion to unicode that was otherwise causing problems in some cases. Thanks, Mike Maravillo.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@7186 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2008/3/1 上午3:05",
      "commitName": "931b9f310854e30a814cb3073c67007e709f6e5f",
      "commitAuthor": "Malcolm Tredinnick",
      "commitDateOld": "2008/2/15 上午1:38",
      "commitNameOld": "1159791cd5b706f01e282d6773a17b66b7cdac9f",
      "commitAuthorOld": "Malcolm Tredinnick",
      "daysBetweenCommits": 15.06,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 123,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,43 +1,43 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n-                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n+                    top_errors.extend([u\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n                     label \u003d escape(force_unicode(bf.label))\n                     # Only add the suffix if the label does not end in\n                     # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n-            output.insert(0, error_row % top_errors)\n+            output.insert(0, error_row % force_unicode(top_errors))\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                 # insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else:\n                 # If there aren\u0027t any rows in the output, just append the\n                 # hidden fields.\n                 output.append(str_hidden)\n         return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "356662cf74c99fac90afb0f5e6aac8d2d573e62a": {
      "type": "Ybodychange",
      "commitMessage": "Implemented auto-escaping of variable output in templates. Fully controllable by template authors and it\u0027s possible to write filters and templates that simulataneously work in both auto-escaped and non-auto-escaped environments if you need to. Fixed #2359\n\nSee documentation in templates.txt and templates_python.txt for how everything\nworks.\n\nBackwards incompatible if you\u0027re inserting raw HTML output via template variables.\n\nBased on an original design from Simon Willison and with debugging help from Michael Radziej.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@6671 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/11/14 下午8:58",
      "commitName": "356662cf74c99fac90afb0f5e6aac8d2d573e62a",
      "commitAuthor": "Malcolm Tredinnick",
      "commitDateOld": "2007/11/11 下午12:44",
      "commitNameOld": "a4907be38ecc9f6caf3d2a787a7046af3f8b9ceb",
      "commitAuthorOld": "Gary Wilson Jr",
      "daysBetweenCommits": 3.34,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n                # insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren\u0027t any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 106,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,39 +1,43 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n                     label \u003d escape(force_unicode(bf.label))\n-                    # Only add the suffix if the label does not end in punctuation.\n+                    # Only add the suffix if the label does not end in\n+                    # punctuation.\n                     if self.label_suffix:\n                         if label[-1] not in \u0027:?.!\u0027:\n                             label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n-                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n+                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and\n+                # insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n-            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n+            else:\n+                # If there aren\u0027t any rows in the output, just append the\n+                # hidden fields.\n                 output.append(str_hidden)\n-        return u\u0027\\n\u0027.join(output)\n+        return mark_safe(u\u0027\\n\u0027.join(output))\n",
      "extendedDetails": {}
    },
    "748e55b1daa1260964d9ec29f50e01b4b4c0f5d8": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #4975 -- Allow the default label suffix character to be configured. Thanks, Vincent Foley.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@6352 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/9/16 下午12:38",
      "commitName": "748e55b1daa1260964d9ec29f50e01b4b4c0f5d8",
      "commitAuthor": "Malcolm Tredinnick",
      "commitDateOld": "2007/9/15 下午6:12",
      "commitNameOld": "f0cd172cd0bccc519a6ecdf41b6a10b46ccffbcf",
      "commitAuthorOld": "Malcolm Tredinnick",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in \u0027:?.!\u0027:\n                            label +\u003d self.label_suffix\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 117,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,38 +1,39 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n                     label \u003d escape(force_unicode(bf.label))\n-                    # Only add a colon if the label does not end in punctuation.\n-                    if label[-1] not in \u0027:?.!\u0027:\n-                        label +\u003d \u0027:\u0027\n+                    # Only add the suffix if the label does not end in punctuation.\n+                    if self.label_suffix:\n+                        if label[-1] not in \u0027:?.!\u0027:\n+                            label +\u003d self.label_suffix\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "ce249d4366a800ebc033cefb8beb33b9b0dba051": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #4752 -- Make default ErrorList customisable in newforms display. Based on a patch from michal@logix.cz and SmileyChris.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@6142 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/9/14 上午7:09",
      "commitName": "ce249d4366a800ebc033cefb8beb33b9b0dba051",
      "commitAuthor": "Malcolm Tredinnick",
      "commitDateOld": "2007/8/6 下午9:58",
      "commitNameOld": "fbd1a6277e9cc04a953a242c45d216685afbf873",
      "commitAuthorOld": "Russell Keith-Magee",
      "daysBetweenCommits": 38.38,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add a colon if the label does not end in punctuation.\n                    if label[-1] not in \u0027:?.!\u0027:\n                        label +\u003d \u0027:\u0027\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 116,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,38 +1,38 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n-            bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n+            bf_errors \u003d self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n                     label \u003d escape(force_unicode(bf.label))\n                     # Only add a colon if the label does not end in punctuation.\n                     if label[-1] not in \u0027:?.!\u0027:\n                         label +\u003d \u0027:\u0027\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "953badbea5a04159adbfa970f5805c0232b6a401": {
      "type": "Ybodychange",
      "commitMessage": "Merged Unicode branch into trunk (r4952:5608). This should be fully\nbackwards compatible for all practical purposes.\n\nFixed #2391, #2489, #2996, #3322, #3344, #3370, #3406, #3432, #3454, #3492, #3582, #3690, #3878, #3891, #3937, #4039, #4141, #4227, #4286, #4291, #4300, #4452, #4702\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@5609 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/7/4 下午8:11",
      "commitName": "953badbea5a04159adbfa970f5805c0232b6a401",
      "commitAuthor": "Malcolm Tredinnick",
      "commitDateOld": "2007/6/23 下午2:19",
      "commitNameOld": "553a20075e6991e7a60baee51ea68c8adc520d9a",
      "commitAuthorOld": "Malcolm Tredinnick",
      "daysBetweenCommits": 11.24,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label \u003d escape(force_unicode(bf.label))\n                    # Only add a colon if the label does not end in punctuation.\n                    if label[-1] not in \u0027:?.!\u0027:\n                        label +\u003d \u0027:\u0027\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 113,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,38 +1,38 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n-                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n+                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, force_unicode(e)) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n-                    output.append(error_row % bf_errors)\n+                    output.append(error_row % force_unicode(bf_errors))\n                 if bf.label:\n-                    label \u003d escape(bf.label)\n+                    label \u003d escape(force_unicode(bf.label))\n                     # Only add a colon if the label does not end in punctuation.\n                     if label[-1] not in \u0027:?.!\u0027:\n                         label +\u003d \u0027:\u0027\n                     label \u003d bf.label_tag(label) or \u0027\u0027\n                 else:\n                     label \u003d \u0027\u0027\n                 if field.help_text:\n-                    help_text \u003d help_text_html % field.help_text\n+                    help_text \u003d help_text_html % force_unicode(field.help_text)\n                 else:\n                     help_text \u003d u\u0027\u0027\n-                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n+                output.append(normal_row % {\u0027errors\u0027: force_unicode(bf_errors), \u0027label\u0027: force_unicode(label), \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "8a4a8023d61cb31093db7b511e58ea3502e47cb6": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #3698 -- Modified newforms labels to only add a colon if the label text doesn\u0027t end with punctuation. Thanks, SmileyChris.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@5112 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/4/27 下午10:27",
      "commitName": "8a4a8023d61cb31093db7b511e58ea3502e47cb6",
      "commitAuthor": "Russell Keith-Magee",
      "commitDateOld": "2007/4/26 下午9:30",
      "commitNameOld": "439cb4047fb583d08149f28e2ce66a8edfe0efa7",
      "commitAuthorOld": "Malcolm Tredinnick",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                if bf.label:\n                    label \u003d escape(bf.label)\n                    # Only add a colon if the label does not end in punctuation.\n                    if label[-1] not in \u0027:?.!\u0027:\n                        label +\u003d \u0027:\u0027\n                    label \u003d bf.label_tag(label) or \u0027\u0027\n                else:\n                    label \u003d \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 111,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,31 +1,38 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n-                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n+                if bf.label:\n+                    label \u003d escape(bf.label)\n+                    # Only add a colon if the label does not end in punctuation.\n+                    if label[-1] not in \u0027:?.!\u0027:\n+                        label +\u003d \u0027:\u0027\n+                    label \u003d bf.label_tag(label) or \u0027\u0027\n+                else:\n+                    label \u003d \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % field.help_text\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "b8fa80bd0020eee186e5288e3fd2552695093025": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #3510 -- newforms validation errors are now HTML-escaped for HTML output. Thanks, scott@staplefish.com\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4544 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/2/20 上午7:54",
      "commitName": "b8fa80bd0020eee186e5288e3fd2552695093025",
      "commitAuthor": "Adrian Holovaty",
      "commitDateOld": "2007/2/16 上午6:43",
      "commitNameOld": "4a85a75fb0e3185dc77362c16e80219dac168c05",
      "commitAuthorOld": "Adrian Holovaty",
      "daysBetweenCommits": 4.05,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 110,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,31 +1,31 @@\n     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n-            bf_errors \u003d bf.errors # Cache in local variable.\n+            bf_errors \u003d ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n                 label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n                 if field.help_text:\n                     help_text \u003d help_text_html % field.help_text\n                 else:\n                     help_text \u003d u\u0027\u0027\n                 output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "cf75fcc8321b822cb4758d167f1fade56a60ad4f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fixed #3255 -- Added help_text argument to newforms Field class.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4440 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/1/29 上午6:10",
      "commitName": "cf75fcc8321b822cb4758d167f1fade56a60ad4f",
      "commitAuthor": "Adrian Holovaty",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fixed #3255 -- Added help_text argument to newforms Field class.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4440 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
          "commitDate": "2007/1/29 上午6:10",
          "commitName": "cf75fcc8321b822cb4758d167f1fade56a60ad4f",
          "commitAuthor": "Adrian Holovaty",
          "commitDateOld": "2007/1/28 上午6:06",
          "commitNameOld": "c93686c6987df97880cb0edc5535c6d5cbec9e6d",
          "commitAuthorOld": "Adrian Holovaty",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
          "path": "django/newforms/forms.py",
          "functionStartLine": 97,
          "functionName": "_html_output",
          "functionAnnotation": "",
          "diff": "@@ -1,27 +1,31 @@\n-    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n+    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d bf.errors # Cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n                 label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n-                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf)})\n+                if field.help_text:\n+                    help_text \u003d help_text_html % field.help_text\n+                else:\n+                    help_text \u003d u\u0027\u0027\n+                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
          "extendedDetails": {
            "oldValue": "[self, normal_row, error_row, row_ender, errors_on_separate_row]",
            "newValue": "[self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fixed #3255 -- Added help_text argument to newforms Field class.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4440 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
          "commitDate": "2007/1/29 上午6:10",
          "commitName": "cf75fcc8321b822cb4758d167f1fade56a60ad4f",
          "commitAuthor": "Adrian Holovaty",
          "commitDateOld": "2007/1/28 上午6:06",
          "commitNameOld": "c93686c6987df97880cb0edc5535c6d5cbec9e6d",
          "commitAuthorOld": "Adrian Holovaty",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n                if field.help_text:\n                    help_text \u003d help_text_html % field.help_text\n                else:\n                    help_text \u003d u\u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
          "path": "django/newforms/forms.py",
          "functionStartLine": 97,
          "functionName": "_html_output",
          "functionAnnotation": "",
          "diff": "@@ -1,27 +1,31 @@\n-    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n+    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d bf.errors # Cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n                 label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n-                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf)})\n+                if field.help_text:\n+                    help_text \u003d help_text_html % field.help_text\n+                else:\n+                    help_text \u003d u\u0027\u0027\n+                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf), \u0027help_text\u0027: help_text})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
          "extendedDetails": {}
        }
      ]
    },
    "54b8277ffb4cad90fb65ca4edf69d8279b8df898": {
      "type": "Ybodychange",
      "commitMessage": "newforms: Fixed Unicode issue on Python 2.3 when a BoundField\u0027s __unicode__() included non-ASCII characters. Thanks for reporting the error, Johannes Froehlich\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4296 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2007/1/9 上午11:37",
      "commitName": "54b8277ffb4cad90fb65ca4edf69d8279b8df898",
      "commitAuthor": "Adrian Holovaty",
      "commitDateOld": "2007/1/5 上午8:04",
      "commitNameOld": "02f690f73838f59cb622031751fd75b82f728b2f",
      "commitAuthorOld": "Adrian Holovaty",
      "daysBetweenCommits": 4.15,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf)})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 87,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,27 +1,27 @@\n     def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d bf.errors # Cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n                 label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n-                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: bf})\n+                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: unicode(bf)})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "d0fcef9db0f53ef84535694f4fbcb135f0648e24": {
      "type": "Ybodychange",
      "commitMessage": "newforms: A label can now be the empty string, in which case a label won\u0027t be displayed\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4240 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2006/12/27 上午7:33",
      "commitName": "d0fcef9db0f53ef84535694f4fbcb135f0648e24",
      "commitAuthor": "Adrian Holovaty",
      "commitDateOld": "2006/12/27 上午7:16",
      "commitNameOld": "30c2bffe17c46a1f599b3e5cf0bfcfd164f203fc",
      "commitAuthorOld": "Adrian Holovaty",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: bf})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 88,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,26 +1,27 @@\n     def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d bf.errors # Cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n-                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: bf.label_tag(escape(bf.label+\u0027:\u0027)), \u0027field\u0027: bf})\n+                label \u003d bf.label and bf.label_tag(escape(bf.label + \u0027:\u0027)) or \u0027\u0027\n+                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: label, \u0027field\u0027: bf})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "d93021eb10b1ff8c49a4f4746789c22589886260": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #3102 -- newforms: Fields can now designate their human-friendly labels. BoundField.verbose_name is now BoundField.label\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4188 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2006/12/9 上午4:06",
      "commitName": "d93021eb10b1ff8c49a4f4746789c22589886260",
      "commitAuthor": "Adrian Holovaty",
      "commitDateOld": "2006/12/7 下午11:49",
      "commitNameOld": "c50d333c23a3c53d05623ce15df79e624c57f37c",
      "commitAuthorOld": "Adrian Holovaty",
      "daysBetweenCommits": 1.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: bf.label_tag(escape(bf.label+\u0027:\u0027)), \u0027field\u0027: bf})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 75,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,26 +1,26 @@\n     def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d bf.errors # Cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n                 if errors_on_separate_row and bf_errors:\n                     output.append(error_row % bf_errors)\n-                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: bf.label_tag(escape(bf.verbose_name+\u0027:\u0027)), \u0027field\u0027: bf})\n+                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: bf.label_tag(escape(bf.label+\u0027:\u0027)), \u0027field\u0027: bf})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "c50d333c23a3c53d05623ce15df79e624c57f37c": {
      "type": "Ybodychange",
      "commitMessage": "newforms: Changed Form._html_output() to use dictionary-style format strings for more flexibility. Thanks, Waylan Limberg\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4182 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2006/12/7 下午11:49",
      "commitName": "c50d333c23a3c53d05623ce15df79e624c57f37c",
      "commitAuthor": "Adrian Holovaty",
      "commitDateOld": "2006/12/7 下午2:59",
      "commitNameOld": "b4a67359a34c77e2e40f1ab8e30b96278a063007",
      "commitAuthorOld": "Adrian Holovaty",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: bf.label_tag(escape(bf.verbose_name+\u0027:\u0027)), \u0027field\u0027: bf})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 75,
      "functionName": "_html_output",
      "functionAnnotation": "",
      "diff": "@@ -1,30 +1,26 @@\n     def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n         \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n         top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n         output, hidden_fields \u003d [], []\n         for name, field in self.fields.items():\n             bf \u003d BoundField(self, field, name)\n             bf_errors \u003d bf.errors # Cache in local variable.\n             if bf.is_hidden:\n                 if bf_errors:\n                     top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                 hidden_fields.append(unicode(bf))\n             else:\n-                label \u003d bf.label_tag(escape(bf.verbose_name+\u0027:\u0027))\n-                if errors_on_separate_row:\n-                    if bf_errors:\n-                        output.append(error_row % bf_errors)\n-                    output.append(normal_row % (label, bf))\n-                else:\n-                    output.append(normal_row % ((bf_errors, label, bf)))\n+                if errors_on_separate_row and bf_errors:\n+                    output.append(error_row % bf_errors)\n+                output.append(normal_row % {\u0027errors\u0027: bf_errors, \u0027label\u0027: bf.label_tag(escape(bf.verbose_name+\u0027:\u0027)), \u0027field\u0027: bf})\n         if top_errors:\n             output.insert(0, error_row % top_errors)\n         if hidden_fields: # Insert any hidden fields in the last row.\n             str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n             if output:\n                 last_row \u003d output[-1]\n                 # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                 output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n             else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                 output.append(str_hidden)\n         return u\u0027\\n\u0027.join(output)\n",
      "extendedDetails": {}
    },
    "b4a67359a34c77e2e40f1ab8e30b96278a063007": {
      "type": "Yintroduced",
      "commitMessage": "newforms: Abstracted common code in Form as_table(), as_ul() and as_p() into Form._html_output(). It\u0027s slightly obscure but saves on a lot of redundancy and code bloat.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@4179 bcc190cf-cafb-0310-a4f2-bffc1f526a37\n",
      "commitDate": "2006/12/7 下午2:59",
      "commitName": "b4a67359a34c77e2e40f1ab8e30b96278a063007",
      "commitAuthor": "Adrian Holovaty",
      "diff": "@@ -0,0 +1,30 @@\n+    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n+        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n+        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n+        output, hidden_fields \u003d [], []\n+        for name, field in self.fields.items():\n+            bf \u003d BoundField(self, field, name)\n+            bf_errors \u003d bf.errors # Cache in local variable.\n+            if bf.is_hidden:\n+                if bf_errors:\n+                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n+                hidden_fields.append(unicode(bf))\n+            else:\n+                label \u003d bf.label_tag(escape(bf.verbose_name+\u0027:\u0027))\n+                if errors_on_separate_row:\n+                    if bf_errors:\n+                        output.append(error_row % bf_errors)\n+                    output.append(normal_row % (label, bf))\n+                else:\n+                    output.append(normal_row % ((bf_errors, label, bf)))\n+        if top_errors:\n+            output.insert(0, error_row % top_errors)\n+        if hidden_fields: # Insert any hidden fields in the last row.\n+            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n+            if output:\n+                last_row \u003d output[-1]\n+                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n+                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n+            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n+                output.append(str_hidden)\n+        return u\u0027\\n\u0027.join(output)\n",
      "actualSource": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors \u003d self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields \u003d [], []\n        for name, field in self.fields.items():\n            bf \u003d BoundField(self, field, name)\n            bf_errors \u003d bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([\u0027(Hidden field %s) %s\u0027 % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                label \u003d bf.label_tag(escape(bf.verbose_name+\u0027:\u0027))\n                if errors_on_separate_row:\n                    if bf_errors:\n                        output.append(error_row % bf_errors)\n                    output.append(normal_row % (label, bf))\n                else:\n                    output.append(normal_row % ((bf_errors, label, bf)))\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden \u003d u\u0027\u0027.join(hidden_fields)\n            if output:\n                last_row \u003d output[-1]\n                # Chop off the trailing row_ender (e.g. \u0027\u003c/td\u003e\u003c/tr\u003e\u0027) and insert the hidden fields.\n                output[-1] \u003d last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren\u0027t any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u\u0027\\n\u0027.join(output)\n",
      "path": "django/newforms/forms.py",
      "functionStartLine": 75,
      "functionName": "_html_output",
      "functionAnnotation": ""
    }
  }
}