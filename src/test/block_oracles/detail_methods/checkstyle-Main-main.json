{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "Main.java",
  "functionName": "main",
  "functionId": "main___args-String",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
  "functionAnnotation": "",
  "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace, CallToSystemExit\n",
  "functionStartLine": 181,
  "functionEndLine": 244,
  "numCommitsSeen": 170,
  "timeTaken": 6815,
  "changeHistory": [
    "2a5654734a64c5459819c5ced97bdacd0285ccc7",
    "b1b49751d38af0bf2476aea1f4595283615ab7de",
    "dab682c2f0e2853858a6d24e1fe2c2088315a0cc",
    "de022d2434e58dd633fd50a7f9bb50565a8767b5",
    "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6",
    "a6ab6053e6b3d421d19764418cba3858c683e6e8",
    "1549ea4822139938296a58f59c38ae14f633c5aa",
    "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
    "25621a3c3391ddf4bc0bb56535d23e73cd293657",
    "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
    "c225479c7d3a7b82fec7d26131ac27496d336853",
    "f65b17cbc30795247fef3077cce16a8bb53e9ffc",
    "f020066f8bdfb378df36904af3df8b5bc48858fd",
    "5391df43637f6522979d46c5c4e35f772f08f4ac",
    "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
    "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
    "da6a8d083cb82a94707146de559911578f39affe",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
    "186625600d7678f597f56aa6a83d4b0a89e1fe35",
    "2880edd6554400955fb950bf8127311c436d2a7a",
    "aaf39002ac7fa00b95f4719beca058f6f7445574",
    "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
    "fe6db3ab8a864e11eebfb0496f6a41852bdee019",
    "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
    "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
    "ab2f93f9bf61816d84154e636d32c81c05854e24",
    "702a1a957607881e72bb94b3104c2603ef10891f",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "fe9057366308642868c25d427c3ee94411b37170",
    "f38d8abd42c3e824635e542e6031b3da1997c02e",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b",
    "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "dd477210aefeabb265e105a9fe8120c8310605e8",
    "784842200f5307597d721ba0190c912cfab1b77f",
    "f2b01a44a216e88957eb6cb22e4b0e39429a6c84",
    "47802121745d9113b54cdb2d8ccef59e74ce3e72",
    "00fb7f0c1852eb015933c7c121284597de29caad",
    "2820c1d09d418935f7e7c410274f86da173eb96b",
    "88e89a138aa39f50f7642106cde6568f6e07783f",
    "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
    "822384a711290170148b43b5ae390dd4e8cfaf4f",
    "2debda611fe487021711aa4acce56651799a778f",
    "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
    "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
    "4cbd709c019cf1b69796858506d673f7b66d37c7",
    "1cea3765893e83e0d58ca110113e0d05b15a798a",
    "3288a81e30ddea194f76bd74f3b509500b864163",
    "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
    "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b",
    "add2bdfb27494bff5fa9c305d9782f57c6170b18",
    "ef5716560b2b52a5fcd233ac9ad546a53749339f",
    "e200d9bf3d07b103e633d56215280e5e7d7a980b",
    "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
    "69138e40225407ef560fd9d06d2903de37c83c2c",
    "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3"
  ],
  "changeHistoryShort": {
    "2a5654734a64c5459819c5ced97bdacd0285ccc7": "Ydocchange",
    "b1b49751d38af0bf2476aea1f4595283615ab7de": "Ybodychange",
    "dab682c2f0e2853858a6d24e1fe2c2088315a0cc": "Ybodychange",
    "de022d2434e58dd633fd50a7f9bb50565a8767b5": "Ybodychange",
    "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6": "Ybodychange",
    "a6ab6053e6b3d421d19764418cba3858c683e6e8": "Ybodychange",
    "1549ea4822139938296a58f59c38ae14f633c5aa": "Ybodychange",
    "68b49fd2843f23f55dc711a89213d59f2acf3a0a": "Ybodychange",
    "25621a3c3391ddf4bc0bb56535d23e73cd293657": "Ybodychange",
    "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6": "Ybodychange",
    "c225479c7d3a7b82fec7d26131ac27496d336853": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "f65b17cbc30795247fef3077cce16a8bb53e9ffc": "Ybodychange",
    "f020066f8bdfb378df36904af3df8b5bc48858fd": "Ymultichange(Ybodychange,Ydocchange)",
    "5391df43637f6522979d46c5c4e35f772f08f4ac": "Ybodychange",
    "b6d9344d1c152f225a22ce9ce09341b3cc9488af": "Ymultichange(Yexceptionschange,Ydocchange)",
    "0fc8b62a35beddc89cb3412388c27e88cd8cab4a": "Ybodychange",
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2": "Ybodychange",
    "da6a8d083cb82a94707146de559911578f39affe": "Ybodychange",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": "Ybodychange",
    "186625600d7678f597f56aa6a83d4b0a89e1fe35": "Ydocchange",
    "2880edd6554400955fb950bf8127311c436d2a7a": "Ybodychange",
    "aaf39002ac7fa00b95f4719beca058f6f7445574": "Ybodychange",
    "4299a4b408304cd0bcad6c25b4a322dbd94169a3": "Ymultichange(Yexceptionschange,Ybodychange)",
    "fe6db3ab8a864e11eebfb0496f6a41852bdee019": "Ybodychange",
    "1a2c318e22a0b2b22ccc76019217c0892fe2d59b": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "c0446a825514ea0279b8c22f633f2c4e3c73dc1f": "Yparameterchange",
    "ab2f93f9bf61816d84154e636d32c81c05854e24": "Ybodychange",
    "702a1a957607881e72bb94b3104c2603ef10891f": "Ymultichange(Yexceptionschange,Ydocchange)",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "fe9057366308642868c25d427c3ee94411b37170": "Ybodychange",
    "f38d8abd42c3e824635e542e6031b3da1997c02e": "Ybodychange",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": "Ybodychange",
    "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "dd477210aefeabb265e105a9fe8120c8310605e8": "Ybodychange",
    "784842200f5307597d721ba0190c912cfab1b77f": "Ybodychange",
    "f2b01a44a216e88957eb6cb22e4b0e39429a6c84": "Ybodychange",
    "47802121745d9113b54cdb2d8ccef59e74ce3e72": "Ybodychange",
    "00fb7f0c1852eb015933c7c121284597de29caad": "Ybodychange",
    "2820c1d09d418935f7e7c410274f86da173eb96b": "Ybodychange",
    "88e89a138aa39f50f7642106cde6568f6e07783f": "Ybodychange",
    "16ba5b35f9f346e7cea294afaad7f9211605ecaa": "Ybodychange",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": "Ybodychange",
    "822384a711290170148b43b5ae390dd4e8cfaf4f": "Ybodychange",
    "2debda611fe487021711aa4acce56651799a778f": "Ybodychange",
    "3c0608f33a6c41cf96056c52ae99070cbe5062d5": "Ybodychange",
    "6f4247181beca3530b5c2dc762d9c5c6a018a06c": "Ybodychange",
    "4cbd709c019cf1b69796858506d673f7b66d37c7": "Ybodychange",
    "1cea3765893e83e0d58ca110113e0d05b15a798a": "Ybodychange",
    "3288a81e30ddea194f76bd74f3b509500b864163": "Ybodychange",
    "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b": "Ybodychange",
    "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b": "Ybodychange",
    "add2bdfb27494bff5fa9c305d9782f57c6170b18": "Ybodychange",
    "ef5716560b2b52a5fcd233ac9ad546a53749339f": "Ybodychange",
    "e200d9bf3d07b103e633d56215280e5e7d7a980b": "Ybodychange",
    "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5": "Ybodychange",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": "Ybodychange",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": "Ybodychange",
    "69138e40225407ef560fd9d06d2903de37c83c2c": "Ybodychange",
    "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9": "Ybodychange",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2a5654734a64c5459819c5ced97bdacd0285ccc7": {
      "type": "Ydocchange",
      "commitMessage": "Issue #4801: fix some violations from the eleventh part of idea violations\n",
      "commitDate": "2017/8/9 下午8:02",
      "commitName": "2a5654734a64c5459819c5ced97bdacd0285ccc7",
      "commitAuthor": "vasilyeva",
      "commitDateOld": "2017/8/9 下午7:54",
      "commitNameOld": "dc88a9954baf88df6543cf73baabed710f882363",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                messages.forEach(System.out::println);\n            } else {\n                errorCounter \u003d runCli(commandLine, filesToProcess);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0) {\n            if (!cliViolations) {\n                final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0, Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER, new String[] { String.valueOf(errorCounter) }, null, Main.class, null);\n                System.out.println(errorCounterMessage.getMessage());\n            }\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 180,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace, CallToSystemExit\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
        "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace, CallToSystemExit\n"
      }
    },
    "b1b49751d38af0bf2476aea1f4595283615ab7de": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4399: increase coverage of pitest-checkstyle main profile to 100%\n",
      "commitDate": "2017/7/27 下午8:54",
      "commitName": "b1b49751d38af0bf2476aea1f4595283615ab7de",
      "commitAuthor": "vasilyeva",
      "commitDateOld": "2017/7/24 上午9:19",
      "commitNameOld": "4c10bc55b4aea0f7e3b95b06d820eedb7c6a6fb2",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 3.48,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                messages.forEach(System.out::println);\n            } else {\n                errorCounter \u003d runCli(commandLine, filesToProcess);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0) {\n            if (!cliViolations) {\n                final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0, Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER, new String[] { String.valueOf(errorCounter) }, null, Main.class, null);\n                System.out.println(errorCounterMessage.getMessage());\n            }\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 179,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,43 +1,45 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 messages.forEach(System.out::println);\n             } else {\n                 errorCounter \u003d runCli(commandLine, filesToProcess);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n-        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n-            final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0, Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER, new String[] { String.valueOf(errorCounter) }, null, Main.class, null);\n-            System.out.println(errorCounterMessage.getMessage());\n+        if (errorCounter !\u003d 0) {\n+            if (!cliViolations) {\n+                final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0, Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER, new String[] { String.valueOf(errorCounter) }, null, Main.class, null);\n+                System.out.println(errorCounterMessage.getMessage());\n+            }\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dab682c2f0e2853858a6d24e1fe2c2088315a0cc": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3110: Modified Main to remove hardcoded messages and to support i18n for the messages\n",
      "commitDate": "2017/7/8 上午10:55",
      "commitName": "dab682c2f0e2853858a6d24e1fe2c2088315a0cc",
      "commitAuthor": "Subbu Dantu",
      "commitDateOld": "2017/7/3 上午10:43",
      "commitNameOld": "036582d728d2e2bb37f360bb3a74f899f04d587d",
      "commitAuthorOld": "Andrew Kuchev",
      "daysBetweenCommits": 5.01,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                messages.forEach(System.out::println);\n            } else {\n                errorCounter \u003d runCli(commandLine, filesToProcess);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0, Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER, new String[] { String.valueOf(errorCounter) }, null, Main.class, null);\n            System.out.println(errorCounterMessage.getMessage());\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 179,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,42 +1,43 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 messages.forEach(System.out::println);\n             } else {\n                 errorCounter \u003d runCli(commandLine, filesToProcess);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n-            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n+            final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0, Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER, new String[] { String.valueOf(errorCounter) }, null, Main.class, null);\n+            System.out.println(errorCounterMessage.getMessage());\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de022d2434e58dd633fd50a7f9bb50565a8767b5": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3233: Resolve IntelijIdea inspection violations for java8 migration (#3434)\n\n",
      "commitDate": "2016/9/8 下午8:30",
      "commitName": "de022d2434e58dd633fd50a7f9bb50565a8767b5",
      "commitAuthor": "Mariia Mykhailova",
      "commitDateOld": "2016/8/2 下午10:23",
      "commitNameOld": "77081171f2d8deade9fb4f5f677c4b07e05d1540",
      "commitAuthorOld": "Glenn Hollingsworth",
      "daysBetweenCommits": 36.92,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                messages.forEach(System.out::println);\n            } else {\n                errorCounter \u003d runCli(commandLine, filesToProcess);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 143,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,44 +1,42 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n-                for (String message : messages) {\n-                    System.out.println(message);\n-                }\n+                messages.forEach(System.out::println);\n             } else {\n                 errorCounter \u003d runCli(commandLine, filesToProcess);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3287: added exclude directory option (#3288)\n\n",
      "commitDate": "2016/7/27 上午10:55",
      "commitName": "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6",
      "commitAuthor": "rnveach",
      "commitDateOld": "2016/7/12 下午12:47",
      "commitNameOld": "44119413b68542bb1db3f50d2585834b9d00d1b3",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 14.92,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                errorCounter \u003d runCli(commandLine, filesToProcess);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 143,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,44 +1,44 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n-            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n+            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine), commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 errorCounter \u003d runCli(commandLine, filesToProcess);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6ab6053e6b3d421d19764418cba3858c683e6e8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3086: added debug option",
      "commitDate": "2016/5/27 下午9:18",
      "commitName": "a6ab6053e6b3d421d19764418cba3858c683e6e8",
      "commitAuthor": "rnveach",
      "commitDateOld": "2016/4/11 上午5:08",
      "commitNameOld": "1549ea4822139938296a58f59c38ae14f633c5aa",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 46.67,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                errorCounter \u003d runCli(commandLine, filesToProcess);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 130,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,63 +1,44 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n-                final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n-                if (commandLine.hasOption(OPTION_T_NAME)) {\n-                    final File file \u003d config.files.get(0);\n-                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n-                    System.out.print(stringAst);\n-                } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n-                    final File file \u003d config.files.get(0);\n-                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n-                    System.out.print(stringAst);\n-                } else if (commandLine.hasOption(OPTION_J_NAME)) {\n-                    final File file \u003d config.files.get(0);\n-                    final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n-                    System.out.print(stringAst);\n-                } else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n-                    final File file \u003d config.files.get(0);\n-                    final String stringAst \u003d AstTreeStringPrinter.printJavaAndJavadocTree(file);\n-                    System.out.print(stringAst);\n-                } else {\n-                    errorCounter \u003d runCheckstyle(config);\n-                    exitStatus \u003d errorCounter;\n-                }\n+                errorCounter \u003d runCli(commandLine, filesToProcess);\n+                exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1549ea4822139938296a58f59c38ae14f633c5aa": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3040: New CLI option to print full tree (java+comments+javadoc). (#3078)",
      "commitDate": "2016/4/11 上午5:08",
      "commitName": "1549ea4822139938296a58f59c38ae14f633c5aa",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "2016/3/17 下午9:19",
      "commitNameOld": "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 24.33,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                    System.out.print(stringAst);\n                } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                    System.out.print(stringAst);\n                } else if (commandLine.hasOption(OPTION_J_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n                    System.out.print(stringAst);\n                } else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printJavaAndJavadocTree(file);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 114,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,59 +1,63 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                 if (commandLine.hasOption(OPTION_T_NAME)) {\n                     final File file \u003d config.files.get(0);\n                     final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                     System.out.print(stringAst);\n                 } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                     final File file \u003d config.files.get(0);\n                     final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                     System.out.print(stringAst);\n                 } else if (commandLine.hasOption(OPTION_J_NAME)) {\n                     final File file \u003d config.files.get(0);\n                     final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n                     System.out.print(stringAst);\n+                } else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n+                    final File file \u003d config.files.get(0);\n+                    final String stringAst \u003d AstTreeStringPrinter.printJavaAndJavadocTree(file);\n+                    System.out.print(stringAst);\n                 } else {\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68b49fd2843f23f55dc711a89213d59f2acf3a0a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #652: New CLI option to print Javadoc comment parse tree\n",
      "commitDate": "2016/3/17 下午9:19",
      "commitName": "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "2016/2/23 下午11:07",
      "commitNameOld": "25621a3c3391ddf4bc0bb56535d23e73cd293657",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 22.93,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                    System.out.print(stringAst);\n                } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                    System.out.print(stringAst);\n                } else if (commandLine.hasOption(OPTION_J_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 108,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,55 +1,59 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                 if (commandLine.hasOption(OPTION_T_NAME)) {\n                     final File file \u003d config.files.get(0);\n                     final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                     System.out.print(stringAst);\n                 } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                     final File file \u003d config.files.get(0);\n                     final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                     System.out.print(stringAst);\n+                } else if (commandLine.hasOption(OPTION_J_NAME)) {\n+                    final File file \u003d config.files.get(0);\n+                    final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n+                    System.out.print(stringAst);\n                 } else {\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25621a3c3391ddf4bc0bb56535d23e73cd293657": {
      "type": "Ybodychange",
      "commitMessage": "Issue #652: New option to print AST with comment nodes.\n",
      "commitDate": "2016/2/23 下午11:07",
      "commitName": "25621a3c3391ddf4bc0bb56535d23e73cd293657",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "2016/2/10 下午10:07",
      "commitNameOld": "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 13.04,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                    System.out.print(stringAst);\n                } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 102,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,51 +1,55 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n             final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                 if (commandLine.hasOption(OPTION_T_NAME)) {\n                     final File file \u003d config.files.get(0);\n-                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n+                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n+                    System.out.print(stringAst);\n+                } else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n+                    final File file \u003d config.files.get(0);\n+                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                     System.out.print(stringAst);\n                 } else {\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2103: removed excess file gathering in main",
      "commitDate": "2016/2/10 下午10:07",
      "commitName": "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
      "commitAuthor": "rnveach",
      "commitDateOld": "2016/2/4 下午6:32",
      "commitNameOld": "c225479c7d3a7b82fec7d26131ac27496d336853",
      "commitAuthorOld": "Vladislav Lisetskiy",
      "daysBetweenCommits": 6.15,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 90,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,50 +1,51 @@\n public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n-            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n+            final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n+            final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n-                final CliOptions config \u003d convertCliToPojo(commandLine);\n+                final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                 if (commandLine.hasOption(OPTION_T_NAME)) {\n                     final File file \u003d config.files.get(0);\n                     final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n                     System.out.print(stringAst);\n                 } else {\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c225479c7d3a7b82fec7d26131ac27496d336853": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
      "commitDate": "2016/2/4 下午6:32",
      "commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
      "commitAuthor": "Vladislav Lisetskiy",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
          "commitDate": "2016/2/4 下午6:32",
          "commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
          "commitAuthor": "Vladislav Lisetskiy",
          "commitDateOld": "2016/1/24 下午10:35",
          "commitNameOld": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
          "commitAuthorOld": "Bhavik Patel",
          "daysBetweenCommits": 10.83,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 90,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
          "diff": "@@ -1,44 +1,50 @@\n-public static void main(String... args) throws FileNotFoundException {\n+public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n-                errorCounter \u003d runCheckstyle(config);\n-                exitStatus \u003d errorCounter;\n+                if (commandLine.hasOption(OPTION_T_NAME)) {\n+                    final File file \u003d config.files.get(0);\n+                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n+                    System.out.print(stringAst);\n+                } else {\n+                    errorCounter \u003d runCheckstyle(config);\n+                    exitStatus \u003d errorCounter;\n+                }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[FileNotFoundException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
          "commitDate": "2016/2/4 下午6:32",
          "commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
          "commitAuthor": "Vladislav Lisetskiy",
          "commitDateOld": "2016/1/24 下午10:35",
          "commitNameOld": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
          "commitAuthorOld": "Bhavik Patel",
          "daysBetweenCommits": 10.83,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 90,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
          "diff": "@@ -1,44 +1,50 @@\n-public static void main(String... args) throws FileNotFoundException {\n+public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n-                errorCounter \u003d runCheckstyle(config);\n-                exitStatus \u003d errorCounter;\n+                if (commandLine.hasOption(OPTION_T_NAME)) {\n+                    final File file \u003d config.files.get(0);\n+                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n+                    System.out.print(stringAst);\n+                } else {\n+                    errorCounter \u003d runCheckstyle(config);\n+                    exitStatus \u003d errorCounter;\n+                }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
          "commitDate": "2016/2/4 下午6:32",
          "commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
          "commitAuthor": "Vladislav Lisetskiy",
          "commitDateOld": "2016/1/24 下午10:35",
          "commitNameOld": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
          "commitAuthorOld": "Bhavik Patel",
          "daysBetweenCommits": 10.83,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws IOException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                if (commandLine.hasOption(OPTION_T_NAME)) {\n                    final File file \u003d config.files.get(0);\n                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n                    System.out.print(stringAst);\n                } else {\n                    errorCounter \u003d runCheckstyle(config);\n                    exitStatus \u003d errorCounter;\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 90,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
          "diff": "@@ -1,44 +1,50 @@\n-public static void main(String... args) throws FileNotFoundException {\n+public static void main(String... args) throws IOException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n-                errorCounter \u003d runCheckstyle(config);\n-                exitStatus \u003d errorCounter;\n+                if (commandLine.hasOption(OPTION_T_NAME)) {\n+                    final File file \u003d config.files.get(0);\n+                    final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n+                    System.out.print(stringAst);\n+                } else {\n+                    errorCounter \u003d runCheckstyle(config);\n+                    exitStatus \u003d errorCounter;\n+                }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
            "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws IOException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n"
          }
        }
      ]
    },
    "f65b17cbc30795247fef3077cce16a8bb53e9ffc": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2616: Fix CatchParameterName check violations in Checkstyle code\n",
      "commitDate": "2015/12/4 上午7:16",
      "commitName": "f65b17cbc30795247fef3077cce16a8bb53e9ffc",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/11/3 下午10:04",
      "commitNameOld": "1c5d01c3b48ab48fcfb0e7f3764e98d46727870e",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 30.38,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException ex) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        ex.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 87,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
      "diff": "@@ -1,44 +1,44 @@\n public static void main(String... args) throws FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n-    } catch (CheckstyleException e) {\n+    } catch (CheckstyleException ex) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n-        e.printStackTrace();\n+        ex.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f020066f8bdfb378df36904af3df8b5bc48858fd": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Issue #2109: CLI should print a file name where exception is happen\n",
      "commitDate": "2015/11/1 下午9:52",
      "commitName": "f020066f8bdfb378df36904af3df8b5bc48858fd",
      "commitAuthor": "Roman Ivanov",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #2109: CLI should print a file name where exception is happen\n",
          "commitDate": "2015/11/1 下午9:52",
          "commitName": "f020066f8bdfb378df36904af3df8b5bc48858fd",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/10/8 上午8:55",
          "commitNameOld": "423ed9e469db620671459827b58c89025d8f6c66",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 24.54,
          "commitsBetweenForRepo": 188,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        e.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 87,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
          "diff": "@@ -1,44 +1,44 @@\n public static void main(String... args) throws FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n-        printMessageAndCause(e);\n+        e.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Issue #2109: CLI should print a file name where exception is happen\n",
          "commitDate": "2015/11/1 下午9:52",
          "commitName": "f020066f8bdfb378df36904af3df8b5bc48858fd",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/10/8 上午8:55",
          "commitNameOld": "423ed9e469db620671459827b58c89025d8f6c66",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 24.54,
          "commitsBetweenForRepo": 188,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        e.printStackTrace();\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 87,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n",
          "diff": "@@ -1,44 +1,44 @@\n public static void main(String... args) throws FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n-        printMessageAndCause(e);\n+        e.printStackTrace();\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n",
            "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n@noinspection CallToPrintStackTrace\n"
          }
        }
      ]
    },
    "5391df43637f6522979d46c5c4e35f772f08f4ac": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2213: Print missing cause of exception to console on error\n",
      "commitDate": "2015/9/20 下午8:48",
      "commitName": "5391df43637f6522979d46c5c4e35f772f08f4ac",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/9/18 上午6:01",
      "commitNameOld": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
      "commitAuthorOld": "Michael Osipov",
      "daysBetweenCommits": 2.62,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        printMessageAndCause(e);\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 86,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,44 +1,44 @@\n public static void main(String... args) throws FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n-        System.out.println(e.getMessage());\n+        printMessageAndCause(e);\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6d9344d1c152f225a22ce9ce09341b3cc9488af": {
      "type": "Ymultichange(Yexceptionschange,Ydocchange)",
      "commitMessage": "Pull #2034: Use StandardCharsets and get rid of UnsupportedEncodingException\n",
      "commitDate": "2015/9/18 上午6:01",
      "commitName": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
      "commitAuthor": "Michael Osipov",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Pull #2034: Use StandardCharsets and get rid of UnsupportedEncodingException\n",
          "commitDate": "2015/9/18 上午6:01",
          "commitName": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
          "commitAuthor": "Michael Osipov",
          "commitDateOld": "2015/9/12 上午7:32",
          "commitNameOld": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 5.94,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 86,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,44 +1,44 @@\n-public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n+public static void main(String... args) throws FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[UnsupportedEncodingException, FileNotFoundException]",
            "newValue": "[FileNotFoundException]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Pull #2034: Use StandardCharsets and get rid of UnsupportedEncodingException\n",
          "commitDate": "2015/9/18 上午6:01",
          "commitName": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
          "commitAuthor": "Michael Osipov",
          "commitDateOld": "2015/9/12 上午7:32",
          "commitNameOld": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 5.94,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 86,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,44 +1,44 @@\n-public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n+public static void main(String... args) throws FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n",
            "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws FileNotFoundException if there is a problem with files access\n"
          }
        }
      ]
    },
    "0fc8b62a35beddc89cb3412388c27e88cd8cab4a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2080: Fix typos in code\n",
      "commitDate": "2015/9/12 上午7:32",
      "commitName": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/9/10 下午5:57",
      "commitNameOld": "a29f01a95b9dee1e64ec7ed91b4d0876eb82c0bf",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 1.57,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 88,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "",
      "extendedDetails": {}
    },
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: MultipleStringLiterals violations partial fix\n",
      "commitDate": "2015/8/25 下午8:12",
      "commitName": "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "2015/8/20 上午11:42",
      "commitNameOld": "da6a8d083cb82a94707146de559911578f39affe",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(OPTION_V_NAME)) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 87,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,44 +1,44 @@\n public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n-        if (commandLine.hasOption(\"v\")) {\n+        if (commandLine.hasOption(OPTION_V_NAME)) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da6a8d083cb82a94707146de559911578f39affe": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary local variables. #1555\n\nFixes `UnnecessaryLocalVariable` inspection violation.\n\nDescription:\n\u003eReports unnecessary local variables, which add nothing to the comprehensibility of a method. Variables caught include local variables which are immediately returned, local variables that are immediately assigned to another variable and then not used, and local variables which always have the same value as another local variable or parameter.\n",
      "commitDate": "2015/8/20 上午11:42",
      "commitName": "da6a8d083cb82a94707146de559911578f39affe",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/18 下午4:25",
      "commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 66,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,45 +1,44 @@\n public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             } else {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n-        final int exitWithCheckstyleException \u003d -2;\n-        exitStatus \u003d exitWithCheckstyleException;\n+        exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": {
      "type": "Ybodychange",
      "commitMessage": "Invert if statements with negated conditions. #1555\n\nFixes `NegatedIfElse` inspection violations.\n\nDescription:\n\u003eReports if statements which contain else branches and whose conditions are negated. Flipping the order of the if and else branches will usually increase the clarity of such statements.\n",
      "commitDate": "2015/8/10 下午2:46",
      "commitName": "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/8/8 下午1:23",
      "commitNameOld": "186625600d7678f597f56aa6a83d4b0a89e1fe35",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 2.06,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (cliViolations) {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            } else {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        final int exitWithCheckstyleException \u003d -2;\n        exitStatus \u003d exitWithCheckstyleException;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 63,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,45 +1,45 @@\n public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n-            if (!cliViolations) {\n-                final CliOptions config \u003d convertCliToPojo(commandLine);\n-                errorCounter \u003d runCheckstyle(config);\n-                exitStatus \u003d errorCounter;\n-            } else {\n+            if (cliViolations) {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n+            } else {\n+                final CliOptions config \u003d convertCliToPojo(commandLine);\n+                errorCounter \u003d runCheckstyle(config);\n+                exitStatus \u003d errorCounter;\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         final int exitWithCheckstyleException \u003d -2;\n         exitStatus \u003d exitWithCheckstyleException;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "186625600d7678f597f56aa6a83d4b0a89e1fe35": {
      "type": "Ydocchange",
      "commitMessage": "Resolved javadoc problems that reported by java 8, issue #291.\n",
      "commitDate": "2015/8/8 下午1:23",
      "commitName": "186625600d7678f597f56aa6a83d4b0a89e1fe35",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": "2015/8/8 下午12:12",
      "commitNameOld": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (!cliViolations) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            } else {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        final int exitWithCheckstyleException \u003d -2;\n        exitStatus \u003d exitWithCheckstyleException;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 63,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
        "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments.\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws FileNotFoundException if there is a problem with files access\n"
      }
    },
    "2880edd6554400955fb950bf8127311c436d2a7a": {
      "type": "Ybodychange",
      "commitMessage": "Decrease scope of variables. #1538\n",
      "commitDate": "2015/8/3 上午9:48",
      "commitName": "2880edd6554400955fb950bf8127311c436d2a7a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/7/30 下午6:23",
      "commitNameOld": "88f75f5413914bea5b39ba318edf912ee706226d",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 3.64,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (!cliViolations) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            } else {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        final int exitWithCheckstyleException \u003d -2;\n        exitStatus \u003d exitWithCheckstyleException;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 64,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,45 +1,45 @@\n public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n-    final int exitWithCheckstyleException \u003d -2;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (!cliViolations) {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             } else {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n+        final int exitWithCheckstyleException \u003d -2;\n         exitStatus \u003d exitWithCheckstyleException;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         if (exitStatus !\u003d 0) {\n             System.exit(exitStatus);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aaf39002ac7fa00b95f4719beca058f6f7445574": {
      "type": "Ybodychange",
      "commitMessage": "100% coverage for Main.java . #1294\n",
      "commitDate": "2015/7/29 下午3:29",
      "commitName": "aaf39002ac7fa00b95f4719beca058f6f7445574",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "2015/7/23 下午1:58",
      "commitNameOld": "acbd47a66b01acc392a7bd37ad3a2e65eecd308a",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    final int exitWithCheckstyleException \u003d -2;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (!cliViolations) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            } else {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d exitWithCheckstyleException;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        if (exitStatus !\u003d 0) {\n            System.exit(exitStatus);\n        }\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 64,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,43 +1,45 @@\n public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     final int exitWithCliViolation \u003d -1;\n     final int exitWithCheckstyleException \u003d -2;\n     int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n             exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (!cliViolations) {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n                 exitStatus \u003d errorCounter;\n             } else {\n                 exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n         exitStatus \u003d exitWithCheckstyleException;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n-        System.exit(exitStatus);\n+        if (exitStatus !\u003d 0) {\n+            System.exit(exitStatus);\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4299a4b408304cd0bcad6c25b4a322dbd94169a3": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
      "commitDate": "2015/6/14 下午10:37",
      "commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
      "commitAuthor": "Bhavik Patel",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
          "commitDate": "2015/6/14 下午10:37",
          "commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
          "commitAuthor": "Bhavik Patel",
          "commitDateOld": "2015/6/13 下午11:41",
          "commitNameOld": "3004b4d8810fae5956864d1493ea94f183b9442c",
          "commitAuthorOld": "Bhavik Patel",
          "daysBetweenCommits": 0.96,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    final int exitWithCheckstyleException \u003d -2;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (!cliViolations) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            } else {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d exitWithCheckstyleException;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        System.exit(exitStatus);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 63,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,35 +1,43 @@\n-public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n+public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n+    final int exitWithCliViolation \u003d -1;\n+    final int exitWithCheckstyleException \u003d -2;\n+    int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+            exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n-            if (messages.isEmpty()) {\n+            if (!cliViolations) {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n+                exitStatus \u003d errorCounter;\n             } else {\n+                exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n+        exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n+        exitStatus \u003d exitWithCheckstyleException;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n-        System.exit(errorCounter);\n+        System.exit(exitStatus);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[UnsupportedEncodingException, CheckstyleException, FileNotFoundException]",
            "newValue": "[UnsupportedEncodingException, FileNotFoundException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
          "commitDate": "2015/6/14 下午10:37",
          "commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
          "commitAuthor": "Bhavik Patel",
          "commitDateOld": "2015/6/13 下午11:41",
          "commitNameOld": "3004b4d8810fae5956864d1493ea94f183b9442c",
          "commitAuthorOld": "Bhavik Patel",
          "daysBetweenCommits": 0.96,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    final int exitWithCliViolation \u003d -1;\n    final int exitWithCheckstyleException \u003d -2;\n    int exitStatus \u003d 0;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n            exitStatus \u003d 0;\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (!cliViolations) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n                exitStatus \u003d errorCounter;\n            } else {\n                exitStatus \u003d exitWithCliViolation;\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        exitStatus \u003d exitWithCliViolation;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        exitStatus \u003d exitWithCheckstyleException;\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        System.exit(exitStatus);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 63,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,35 +1,43 @@\n-public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n+public static void main(String... args) throws UnsupportedEncodingException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n+    final int exitWithCliViolation \u003d -1;\n+    final int exitWithCheckstyleException \u003d -2;\n+    int exitStatus \u003d 0;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+            exitStatus \u003d 0;\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n-            if (messages.isEmpty()) {\n+            if (!cliViolations) {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n+                exitStatus \u003d errorCounter;\n             } else {\n+                exitStatus \u003d exitWithCliViolation;\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n+        exitStatus \u003d exitWithCliViolation;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n     } catch (CheckstyleException e) {\n+        exitStatus \u003d exitWithCheckstyleException;\n         errorCounter \u003d 1;\n         System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n-        System.exit(errorCounter);\n+        System.exit(exitStatus);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "fe6db3ab8a864e11eebfb0496f6a41852bdee019": {
      "type": "Ybodychange",
      "commitMessage": "Solution to \"Incorrect config file cause CLI finish with error but no output with details\" solves #1180\n",
      "commitDate": "2015/6/9 上午2:42",
      "commitName": "fe6db3ab8a864e11eebfb0496f6a41852bdee019",
      "commitAuthor": "Bhavik Patel",
      "commitDateOld": "2015/6/7 下午11:42",
      "commitNameOld": "8a3ccee4918bc1ce5f6bc2dfea51389a59684eb0",
      "commitAuthorOld": "Bhavik Patel",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (messages.isEmpty()) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n            } else {\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (CheckstyleException e) {\n        errorCounter \u003d 1;\n        System.out.println(e.getMessage());\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        System.exit(errorCounter);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 63,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
      "diff": "@@ -1,35 +1,35 @@\n public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n     int errorCounter \u003d 0;\n     boolean cliViolations \u003d false;\n     try {\n         final CommandLine commandLine \u003d parseCli(args);\n         if (commandLine.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         } else {\n             final List\u003cString\u003e messages \u003d validateCli(commandLine);\n             cliViolations \u003d !messages.isEmpty();\n             if (messages.isEmpty()) {\n                 final CliOptions config \u003d convertCliToPojo(commandLine);\n                 errorCounter \u003d runCheckstyle(config);\n             } else {\n                 errorCounter \u003d 1;\n                 for (String message : messages) {\n                     System.out.println(message);\n                 }\n             }\n         }\n     } catch (ParseException pex) {\n         cliViolations \u003d true;\n         errorCounter \u003d 1;\n         System.out.println(pex.getMessage());\n         printUsage();\n-    } catch (Exception ex) {\n+    } catch (CheckstyleException e) {\n         errorCounter \u003d 1;\n-        throw ex;\n+        System.out.println(e.getMessage());\n     } finally {\n         if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n             System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n         }\n         System.exit(errorCounter);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a2c318e22a0b2b22ccc76019217c0892fe2d59b": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
      "commitDate": "2015/5/6 上午2:12",
      "commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
      "commitAuthor": "Roman Ivanov",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
          "commitDate": "2015/5/6 上午2:12",
          "commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/5/3 下午2:27",
          "commitNameOld": "0f543a21fee9dec9b388bb6f2c42540fe8bf02ec",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 2.49,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (messages.isEmpty()) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n            } else {\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (Exception ex) {\n        errorCounter \u003d 1;\n        throw ex;\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        System.exit(errorCounter);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 64,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,18 +1,35 @@\n-public static void main(String... args) throws UnsupportedEncodingException {\n-    boolean parseResult \u003d false;\n+public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n+    int errorCounter \u003d 0;\n+    boolean cliViolations \u003d false;\n     try {\n-        processCommandLine(parseCli(args));\n-        parseResult \u003d true;\n-    } catch (final ParseException e) {\n-        System.err.println(\"Could not parse parameters: \" + e.getMessage());\n-        e.printStackTrace();\n-    } catch (final Exception e) {\n-        System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n-        e.printStackTrace();\n-    } finally {\n-        if (!parseResult) {\n-            usage();\n+        final CommandLine commandLine \u003d parseCli(args);\n+        if (commandLine.hasOption(\"v\")) {\n+            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+        } else {\n+            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n+            cliViolations \u003d !messages.isEmpty();\n+            if (messages.isEmpty()) {\n+                final CliOptions config \u003d convertCliToPojo(commandLine);\n+                errorCounter \u003d runCheckstyle(config);\n+            } else {\n+                errorCounter \u003d 1;\n+                for (String message : messages) {\n+                    System.out.println(message);\n+                }\n+            }\n         }\n-        System.exit(parseResult ? 0 : 1);\n+    } catch (ParseException pex) {\n+        cliViolations \u003d true;\n+        errorCounter \u003d 1;\n+        System.out.println(pex.getMessage());\n+        printUsage();\n+    } catch (Exception ex) {\n+        errorCounter \u003d 1;\n+        throw ex;\n+    } finally {\n+        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n+            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n+        }\n+        System.exit(errorCounter);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[UnsupportedEncodingException]",
            "newValue": "[UnsupportedEncodingException, CheckstyleException, FileNotFoundException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
          "commitDate": "2015/5/6 上午2:12",
          "commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/5/3 下午2:27",
          "commitNameOld": "0f543a21fee9dec9b388bb6f2c42540fe8bf02ec",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 2.49,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (messages.isEmpty()) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n            } else {\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (Exception ex) {\n        errorCounter \u003d 1;\n        throw ex;\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        System.exit(errorCounter);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 64,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,18 +1,35 @@\n-public static void main(String... args) throws UnsupportedEncodingException {\n-    boolean parseResult \u003d false;\n+public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n+    int errorCounter \u003d 0;\n+    boolean cliViolations \u003d false;\n     try {\n-        processCommandLine(parseCli(args));\n-        parseResult \u003d true;\n-    } catch (final ParseException e) {\n-        System.err.println(\"Could not parse parameters: \" + e.getMessage());\n-        e.printStackTrace();\n-    } catch (final Exception e) {\n-        System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n-        e.printStackTrace();\n-    } finally {\n-        if (!parseResult) {\n-            usage();\n+        final CommandLine commandLine \u003d parseCli(args);\n+        if (commandLine.hasOption(\"v\")) {\n+            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+        } else {\n+            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n+            cliViolations \u003d !messages.isEmpty();\n+            if (messages.isEmpty()) {\n+                final CliOptions config \u003d convertCliToPojo(commandLine);\n+                errorCounter \u003d runCheckstyle(config);\n+            } else {\n+                errorCounter \u003d 1;\n+                for (String message : messages) {\n+                    System.out.println(message);\n+                }\n+            }\n         }\n-        System.exit(parseResult ? 0 : 1);\n+    } catch (ParseException pex) {\n+        cliViolations \u003d true;\n+        errorCounter \u003d 1;\n+        System.out.println(pex.getMessage());\n+        printUsage();\n+    } catch (Exception ex) {\n+        errorCounter \u003d 1;\n+        throw ex;\n+    } finally {\n+        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n+            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n+        }\n+        System.exit(errorCounter);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
          "commitDate": "2015/5/6 上午2:12",
          "commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/5/3 下午2:27",
          "commitNameOld": "0f543a21fee9dec9b388bb6f2c42540fe8bf02ec",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 2.49,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n    int errorCounter \u003d 0;\n    boolean cliViolations \u003d false;\n    try {\n        final CommandLine commandLine \u003d parseCli(args);\n        if (commandLine.hasOption(\"v\")) {\n            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        } else {\n            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n            cliViolations \u003d !messages.isEmpty();\n            if (messages.isEmpty()) {\n                final CliOptions config \u003d convertCliToPojo(commandLine);\n                errorCounter \u003d runCheckstyle(config);\n            } else {\n                errorCounter \u003d 1;\n                for (String message : messages) {\n                    System.out.println(message);\n                }\n            }\n        }\n    } catch (ParseException pex) {\n        cliViolations \u003d true;\n        errorCounter \u003d 1;\n        System.out.println(pex.getMessage());\n        printUsage();\n    } catch (Exception ex) {\n        errorCounter \u003d 1;\n        throw ex;\n    } finally {\n        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n        }\n        System.exit(errorCounter);\n    }\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 64,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n",
          "diff": "@@ -1,18 +1,35 @@\n-public static void main(String... args) throws UnsupportedEncodingException {\n-    boolean parseResult \u003d false;\n+public static void main(String... args) throws UnsupportedEncodingException, CheckstyleException, FileNotFoundException {\n+    int errorCounter \u003d 0;\n+    boolean cliViolations \u003d false;\n     try {\n-        processCommandLine(parseCli(args));\n-        parseResult \u003d true;\n-    } catch (final ParseException e) {\n-        System.err.println(\"Could not parse parameters: \" + e.getMessage());\n-        e.printStackTrace();\n-    } catch (final Exception e) {\n-        System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n-        e.printStackTrace();\n-    } finally {\n-        if (!parseResult) {\n-            usage();\n+        final CommandLine commandLine \u003d parseCli(args);\n+        if (commandLine.hasOption(\"v\")) {\n+            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+        } else {\n+            final List\u003cString\u003e messages \u003d validateCli(commandLine);\n+            cliViolations \u003d !messages.isEmpty();\n+            if (messages.isEmpty()) {\n+                final CliOptions config \u003d convertCliToPojo(commandLine);\n+                errorCounter \u003d runCheckstyle(config);\n+            } else {\n+                errorCounter \u003d 1;\n+                for (String message : messages) {\n+                    System.out.println(message);\n+                }\n+            }\n         }\n-        System.exit(parseResult ? 0 : 1);\n+    } catch (ParseException pex) {\n+        cliViolations \u003d true;\n+        errorCounter \u003d 1;\n+        System.out.println(pex.getMessage());\n+        printUsage();\n+    } catch (Exception ex) {\n+        errorCounter \u003d 1;\n+        throw ex;\n+    } finally {\n+        if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n+            System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n+        }\n+        System.exit(errorCounter);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@exception UnsupportedEncodingException if there is a problem to use UTF-8\n",
            "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@throws UnsupportedEncodingException if there is a problem to use UTF-8\n@throws CheckstyleException if there is a problem with parsing a property file\n@throws FileNotFoundException if there is a problem with files access\n"
          }
        }
      ]
    },
    "c0446a825514ea0279b8c22f633f2c4e3c73dc1f": {
      "type": "Yparameterchange",
      "commitMessage": "Fix PMD violations from UseVarargs rule, issue #999\n\nThe changes are fully backward-compatible. Method with vararg can be invoked both using array and list of parameters.\n",
      "commitDate": "2015/4/30 上午8:21",
      "commitName": "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "2015/4/26 上午8:30",
      "commitNameOld": "55b266cd92adf7b5e18f84ddee839d63f9330c5b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String... args) throws UnsupportedEncodingException {\n    boolean parseResult \u003d false;\n    try {\n        processCommandLine(parseCli(args));\n        parseResult \u003d true;\n    } catch (final ParseException e) {\n        System.err.println(\"Could not parse parameters: \" + e.getMessage());\n        e.printStackTrace();\n    } catch (final Exception e) {\n        System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n        e.printStackTrace();\n    } finally {\n        if (!parseResult) {\n            usage();\n        }\n        System.exit(parseResult ? 0 : 1);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 55,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@exception UnsupportedEncodingException if there is a problem to use UTF-8\n",
      "diff": "@@ -1,18 +1,18 @@\n-public static void main(String[] args) throws UnsupportedEncodingException {\n+public static void main(String... args) throws UnsupportedEncodingException {\n     boolean parseResult \u003d false;\n     try {\n         processCommandLine(parseCli(args));\n         parseResult \u003d true;\n     } catch (final ParseException e) {\n         System.err.println(\"Could not parse parameters: \" + e.getMessage());\n         e.printStackTrace();\n     } catch (final Exception e) {\n         System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n         e.printStackTrace();\n     } finally {\n         if (!parseResult) {\n             usage();\n         }\n         System.exit(parseResult ? 0 : 1);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[args-String[]]",
        "newValue": "[args-String]"
      }
    },
    "ab2f93f9bf61816d84154e636d32c81c05854e24": {
      "type": "Ybodychange",
      "commitMessage": "Delete System.exit() and delegate exit control into separate method.\n\nIssue #596\n",
      "commitDate": "2015/4/24 下午1:18",
      "commitName": "ab2f93f9bf61816d84154e636d32c81c05854e24",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": "2015/4/9 下午1:37",
      "commitNameOld": "702a1a957607881e72bb94b3104c2603ef10891f",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 14.99,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] args) throws UnsupportedEncodingException {\n    boolean parseResult \u003d false;\n    try {\n        processCommandLine(parseCli(args));\n        parseResult \u003d true;\n    } catch (final ParseException e) {\n        System.err.println(\"Could not parse parameters: \" + e.getMessage());\n        e.printStackTrace();\n    } catch (final Exception e) {\n        System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n        e.printStackTrace();\n    } finally {\n        if (!parseResult) {\n            usage();\n        }\n        System.exit(parseResult ? 0 : 1);\n    }\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 55,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@exception UnsupportedEncodingException if there is a problem to use UTF-8\n",
      "diff": "@@ -1,41 +1,18 @@\n public static void main(String[] args) throws UnsupportedEncodingException {\n-    final CommandLineParser clp \u003d new PosixParser();\n-    CommandLine line \u003d null;\n+    boolean parseResult \u003d false;\n     try {\n-        line \u003d clp.parse(OPTS, args);\n+        processCommandLine(parseCli(args));\n+        parseResult \u003d true;\n     } catch (final ParseException e) {\n-        usage();\n-    }\n-    assert line !\u003d null;\n-    if (line.hasOption(\"v\")) {\n-        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n-        System.exit(0);\n-    }\n-    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n-    if (!line.hasOption(\"c\")) {\n-        System.out.println(\"Must specify a config XML file.\");\n-        usage();\n-    }\n-    final Configuration config \u003d loadConfig(line, props);\n-    OutputStream out \u003d null;\n-    boolean closeOut \u003d false;\n-    if (line.hasOption(\"o\")) {\n-        final String fname \u003d line.getOptionValue(\"o\");\n-        try {\n-            out \u003d new FileOutputStream(fname);\n-            closeOut \u003d true;\n-        } catch (final FileNotFoundException e) {\n-            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n-            System.exit(1);\n+        System.err.println(\"Could not parse parameters: \" + e.getMessage());\n+        e.printStackTrace();\n+    } catch (final Exception e) {\n+        System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n+        e.printStackTrace();\n+    } finally {\n+        if (!parseResult) {\n+            usage();\n         }\n-    } else {\n-        out \u003d System.out;\n-        closeOut \u003d false;\n+        System.exit(parseResult ? 0 : 1);\n     }\n-    final AuditListener listener \u003d createListener(line, out, closeOut);\n-    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n-    final Checker c \u003d createChecker(config, listener);\n-    final int numErrs \u003d c.process(files);\n-    c.destroy();\n-    System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "702a1a957607881e72bb94b3104c2603ef10891f": {
      "type": "Ymultichange(Yexceptionschange,Ydocchange)",
      "commitMessage": "fix for Findbugs violation DM_DEFAULT_ENCODING. Issue #778\n",
      "commitDate": "2015/4/9 下午1:37",
      "commitName": "702a1a957607881e72bb94b3104c2603ef10891f",
      "commitAuthor": "Roman Ivanov",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "fix for Findbugs violation DM_DEFAULT_ENCODING. Issue #778\n",
          "commitDate": "2015/4/9 下午1:37",
          "commitName": "702a1a957607881e72bb94b3104c2603ef10891f",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/3/21 下午11:17",
          "commitNameOld": "48eee721d989ee5933fe6849a2f693c28a9385c3",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 18.6,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String[] args) throws UnsupportedEncodingException {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, args);\n    } catch (final ParseException e) {\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 71,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@exception UnsupportedEncodingException if there is a problem to use UTF-8\n",
          "diff": "@@ -1,41 +1,41 @@\n-public static void main(String[] args) {\n+public static void main(String[] args) throws UnsupportedEncodingException {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, args);\n     } catch (final ParseException e) {\n         usage();\n     }\n     assert line !\u003d null;\n     if (line.hasOption(\"v\")) {\n         System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         System.exit(0);\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[UnsupportedEncodingException]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "fix for Findbugs violation DM_DEFAULT_ENCODING. Issue #778\n",
          "commitDate": "2015/4/9 下午1:37",
          "commitName": "702a1a957607881e72bb94b3104c2603ef10891f",
          "commitAuthor": "Roman Ivanov",
          "commitDateOld": "2015/3/21 下午11:17",
          "commitNameOld": "48eee721d989ee5933fe6849a2f693c28a9385c3",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 18.6,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String[] args) throws UnsupportedEncodingException {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, args);\n    } catch (final ParseException e) {\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 71,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@exception UnsupportedEncodingException if there is a problem to use UTF-8\n",
          "diff": "@@ -1,41 +1,41 @@\n-public static void main(String[] args) {\n+public static void main(String[] args) throws UnsupportedEncodingException {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, args);\n     } catch (final ParseException e) {\n         usage();\n     }\n     assert line !\u003d null;\n     if (line.hasOption(\"v\")) {\n         System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         System.exit(0);\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n",
            "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n@exception UnsupportedEncodingException if there is a problem to use UTF-8\n"
          }
        }
      ]
    },
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": {
      "type": "Ybodychange",
      "commitMessage": "Removed printStackTrace(...) from whole code, issue #660\n",
      "commitDate": "2015/3/17 下午1:46",
      "commitName": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
      "commitAuthor": "alexkravin",
      "commitDateOld": "2015/3/16 上午6:17",
      "commitNameOld": "ca1c33e3112d9217e89eec82bbcd589381d48715",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.31,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] args) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, args);\n    } catch (final ParseException e) {\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 69,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n",
      "diff": "@@ -1,42 +1,41 @@\n public static void main(String[] args) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, args);\n     } catch (final ParseException e) {\n-        e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     if (line.hasOption(\"v\")) {\n         System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         System.exit(0);\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": "2015/1/19 下午10:38",
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "2015/1/19 下午10:38",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "2014/12/30 上午6:41",
          "commitNameOld": "d91236c5ca052899bfd21ac5f378dcaf8e864750",
          "commitAuthorOld": "ychulovskyy",
          "daysBetweenCommits": 20.66,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String[] args) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, args);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 71,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n",
          "diff": "@@ -1,42 +1,42 @@\n-public static void main(String[] aArgs) {\n+public static void main(String[] args) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n-        line \u003d clp.parse(OPTS, aArgs);\n+        line \u003d clp.parse(OPTS, args);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     if (line.hasOption(\"v\")) {\n         System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         System.exit(0);\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[aArgs-String[]]",
            "newValue": "[args-String[]]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "2015/1/19 下午10:38",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "2014/12/30 上午6:41",
          "commitNameOld": "d91236c5ca052899bfd21ac5f378dcaf8e864750",
          "commitAuthorOld": "ychulovskyy",
          "daysBetweenCommits": 20.66,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String[] args) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, args);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 71,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n",
          "diff": "@@ -1,42 +1,42 @@\n-public static void main(String[] aArgs) {\n+public static void main(String[] args) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n-        line \u003d clp.parse(OPTS, aArgs);\n+        line \u003d clp.parse(OPTS, args);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     if (line.hasOption(\"v\")) {\n         System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         System.exit(0);\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "2015/1/19 下午10:38",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "2014/12/30 上午6:41",
          "commitNameOld": "d91236c5ca052899bfd21ac5f378dcaf8e864750",
          "commitAuthorOld": "ychulovskyy",
          "daysBetweenCommits": 20.66,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void main(String[] args) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, args);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
          "functionStartLine": 71,
          "functionName": "main",
          "functionAnnotation": "",
          "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n",
          "diff": "@@ -1,42 +1,42 @@\n-public static void main(String[] aArgs) {\n+public static void main(String[] args) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n-        line \u003d clp.parse(OPTS, aArgs);\n+        line \u003d clp.parse(OPTS, args);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     if (line.hasOption(\"v\")) {\n         System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n         System.exit(0);\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
            "newValue": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param args the command line arguments\n"
          }
        }
      ]
    },
    "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38": {
      "type": "Ybodychange",
      "commitMessage": "#9 -v CLI flag for querying the installed Checkstyle version\n",
      "commitDate": "2014/11/22 上午3:52",
      "commitName": "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38",
      "commitAuthor": "ychulovskyy",
      "commitDateOld": "2014/3/5 上午1:18",
      "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthorOld": "Ivan Sopov",
      "daysBetweenCommits": 262.11,
      "commitsBetweenForRepo": 268,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    if (line.hasOption(\"v\")) {\n        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n        System.exit(0);\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 72,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,38 +1,42 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n+    if (line.hasOption(\"v\")) {\n+        System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+        System.exit(0);\n+    }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "2014/3/5 上午1:18",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "2014/2/27 下午2:35",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 71,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java"
      }
    },
    "fe9057366308642868c25d427c3ee94411b37170": {
      "type": "Ybodychange",
      "commitMessage": "Apply patch #1914806 for PackageNamesLoader from Lars Koedderitzsch.\n",
      "commitDate": "2008/4/8 上午9:35",
      "commitName": "fe9057366308642868c25d427c3ee94411b37170",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2008/1/13 上午10:47",
      "commitNameOld": "5a7e221b757e91d49be1aea105eb4b839e653fbd",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 85.95,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 64,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,42 +1,38 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n-    ModuleFactory moduleFactory \u003d null;\n-    if (line.hasOption(\"n\")) {\n-        moduleFactory \u003d loadPackages(line);\n-    }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n-    final Checker c \u003d createChecker(config, moduleFactory, listener);\n+    final Checker c \u003d createChecker(config, listener);\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f38d8abd42c3e824635e542e6031b3da1997c02e": {
      "type": "Ybodychange",
      "commitMessage": "Removed a native array in favour of a List\u003cFile\u003e -- was it worth it??\n\nAdded @Override where possible -- did this as I got bitten by a subtle bug when making the first change. The @Override would have prevented it.\n",
      "commitDate": "2007/12/20 下午2:21",
      "commitName": "f38d8abd42c3e824635e542e6031b3da1997c02e",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2007/12/15 下午6:28",
      "commitNameOld": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        moduleFactory \u003d loadPackages(line);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, moduleFactory, listener);\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 65,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,44 +1,42 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         moduleFactory \u003d loadPackages(line);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, moduleFactory, listener);\n-    final File[] processedFiles \u003d new File[files.size()];\n-    files.toArray(processedFiles);\n-    final int numErrs \u003d c.process(processedFiles);\n+    final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": {
      "type": "Ybodychange",
      "commitMessage": "Finish of adding generics.\n",
      "commitDate": "2007/12/15 下午4:14",
      "commitName": "f1afaf83f39b83cc3bd07a2388448b262652a76b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2007/1/27 下午10:51",
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 321.72,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        moduleFactory \u003d loadPackages(line);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, moduleFactory, listener);\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 65,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,44 +1,44 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     assert line !\u003d null;\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         moduleFactory \u003d loadPackages(line);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n-    final List files \u003d getFilesToProcess(line);\n+    final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, moduleFactory, listener);\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0": {
      "type": "Ybodychange",
      "commitMessage": "Fix up warning about line possibly being null.\n",
      "commitDate": "2006/7/7 上午11:51",
      "commitName": "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2006/7/7 上午11:44",
      "commitNameOld": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    assert line !\u003d null;\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        moduleFactory \u003d loadPackages(line);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, moduleFactory, listener);\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 68,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,43 +1,44 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n+    assert line !\u003d null;\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         moduleFactory \u003d loadPackages(line);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, moduleFactory, listener);\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": "2006/7/7 上午11:44",
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2005/1/9 下午6:50",
      "commitNameOld": "0d887cde58e54d920644ee543dab346b93e8aae9",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 543.7,
      "commitsBetweenForRepo": 275,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (final ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        moduleFactory \u003d loadPackages(line);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (final FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, moduleFactory, listener);\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 68,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,43 +1,43 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n-    } catch (ParseException e) {\n+    } catch (final ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         moduleFactory \u003d loadPackages(line);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n-        } catch (FileNotFoundException e) {\n+        } catch (final FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, moduleFactory, listener);\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd477210aefeabb265e105a9fe8120c8310605e8": {
      "type": "Ybodychange",
      "commitMessage": "Custom listeners can be incorported as config modules,\nnot command line arguments and ant task elements.\n",
      "commitDate": "2003/7/18 下午7:31",
      "commitName": "dd477210aefeabb265e105a9fe8120c8310605e8",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2003/6/27 下午8:10",
      "commitNameOld": "784842200f5307597d721ba0190c912cfab1b77f",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 20.97,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        moduleFactory \u003d loadPackages(line);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, moduleFactory, listener);\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 68,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,44 +1,43 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     final Configuration config \u003d loadConfig(line, props);\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         moduleFactory \u003d loadPackages(line);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final AuditListener listener \u003d createListener(line, out, closeOut);\n     final List files \u003d getFilesToProcess(line);\n     final Checker c \u003d createChecker(config, moduleFactory, listener);\n-    addCustomListeners(c, line);\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "784842200f5307597d721ba0190c912cfab1b77f": {
      "type": "Ybodychange",
      "commitMessage": "Refactored, that was really ugly code I had written.\n",
      "commitDate": "2003/6/27 下午8:10",
      "commitName": "784842200f5307597d721ba0190c912cfab1b77f",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2003/6/27 下午7:04",
      "commitNameOld": "768256c32a3e397f837ce27602bda49e3c5e0062",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    final Configuration config \u003d loadConfig(line, props);\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        moduleFactory \u003d loadPackages(line);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final AuditListener listener \u003d createListener(line, out, closeOut);\n    final List files \u003d getFilesToProcess(line);\n    final Checker c \u003d createChecker(config, moduleFactory, listener);\n    addCustomListeners(c, line);\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 70,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,105 +1,44 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n-    Configuration config \u003d null;\n-    try {\n-        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), new PropertiesExpander(props));\n-    } catch (CheckstyleException e) {\n-        System.out.println(\"Error loading configuration file\");\n-        e.printStackTrace(System.out);\n-        System.exit(1);\n-    }\n+    final Configuration config \u003d loadConfig(line, props);\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n-        try {\n-            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n-        } catch (CheckstyleException e) {\n-            System.out.println(\"Error loading package names file\");\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n+        moduleFactory \u003d loadPackages(line);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n-    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n-    AuditListener listener \u003d null;\n-    if (\"xml\".equals(format)) {\n-        listener \u003d new XMLLogger(out, closeOut);\n-    } else if (\"plain\".equals(format)) {\n-        listener \u003d new DefaultLogger(out, closeOut);\n-    } else {\n-        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n-        usage();\n-    }\n-    final List files \u003d new LinkedList();\n-    if (line.hasOption(\"r\")) {\n-        final String[] values \u003d line.getOptionValues(\"r\");\n-        for (int i \u003d 0; i \u003c values.length; i++) {\n-            traverse(new File(values[i]), files);\n-        }\n-    }\n-    final String[] remainingArgs \u003d line.getArgs();\n-    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n-        files.add(new File(remainingArgs[i]));\n-    }\n-    if (files.isEmpty()) {\n-        System.out.println(\"Must specify files to process\");\n-        usage();\n-    }\n-    Checker c \u003d null;\n-    try {\n-        c \u003d new Checker();\n-        c.setModuleFactory(moduleFactory);\n-        c.configure(config);\n-        c.addListener(listener);\n-    } catch (Exception e) {\n-        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n-        e.printStackTrace(System.out);\n-        System.exit(1);\n-    }\n-    if (line.hasOption(\"l\")) {\n-        final String listeners \u003d line.getOptionValue(\"l\");\n-        final StringTokenizer t \u003d new StringTokenizer(listeners, \",\");\n-        while (t.hasMoreTokens()) {\n-            final String className \u003d t.nextToken();\n-            AuditListener customListener \u003d null;\n-            try {\n-                customListener \u003d (AuditListener) Class.forName(className).newInstance();\n-            } catch (Exception e) {\n-                System.out.println(\"Unable to create listener \u0027\" + className + \"\u0027: \" + e);\n-                e.printStackTrace(System.out);\n-                System.exit(1);\n-            }\n-            c.addListener(customListener);\n-        }\n-    }\n+    final AuditListener listener \u003d createListener(line, out, closeOut);\n+    final List files \u003d getFilesToProcess(line);\n+    final Checker c \u003d createChecker(config, moduleFactory, listener);\n+    addCustomListeners(c, line);\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f2b01a44a216e88957eb6cb22e4b0e39429a6c84": {
      "type": "Ybodychange",
      "commitMessage": "Added custom listener feature\n",
      "commitDate": "2003/5/28 上午1:33",
      "commitName": "f2b01a44a216e88957eb6cb22e4b0e39429a6c84",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2003/5/27 上午5:52",
      "commitNameOld": "7dd1ab24d1a75687f426cb43a6e70d18d435b0a7",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), new PropertiesExpander(props));\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        try {\n            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n        } catch (CheckstyleException e) {\n            System.out.println(\"Error loading package names file\");\n            e.printStackTrace(System.out);\n            System.exit(1);\n        }\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.setModuleFactory(moduleFactory);\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    if (line.hasOption(\"l\")) {\n        final String listeners \u003d line.getOptionValue(\"l\");\n        final StringTokenizer t \u003d new StringTokenizer(listeners, \",\");\n        while (t.hasMoreTokens()) {\n            final String className \u003d t.nextToken();\n            AuditListener customListener \u003d null;\n            try {\n                customListener \u003d (AuditListener) Class.forName(className).newInstance();\n            } catch (Exception e) {\n                System.out.println(\"Unable to create listener \u0027\" + className + \"\u0027: \" + e);\n                e.printStackTrace(System.out);\n                System.exit(1);\n            }\n            c.addListener(customListener);\n        }\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 70,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,89 +1,105 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), new PropertiesExpander(props));\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         try {\n             moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n         } catch (CheckstyleException e) {\n             System.out.println(\"Error loading package names file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker();\n         c.setModuleFactory(moduleFactory);\n         c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n+    if (line.hasOption(\"l\")) {\n+        final String listeners \u003d line.getOptionValue(\"l\");\n+        final StringTokenizer t \u003d new StringTokenizer(listeners, \",\");\n+        while (t.hasMoreTokens()) {\n+            final String className \u003d t.nextToken();\n+            AuditListener customListener \u003d null;\n+            try {\n+                customListener \u003d (AuditListener) Class.forName(className).newInstance();\n+            } catch (Exception e) {\n+                System.out.println(\"Unable to create listener \u0027\" + className + \"\u0027: \" + e);\n+                e.printStackTrace(System.out);\n+                System.exit(1);\n+            }\n+            c.addListener(customListener);\n+        }\n+    }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "47802121745d9113b54cdb2d8ccef59e74ce3e72": {
      "type": "Ybodychange",
      "commitMessage": "use a PropertyResolver interface instead of using Properties directly\n",
      "commitDate": "2003/2/23 下午8:29",
      "commitName": "47802121745d9113b54cdb2d8ccef59e74ce3e72",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2003/2/15 下午8:13",
      "commitNameOld": "00fb7f0c1852eb015933c7c121284597de29caad",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), new PropertiesExpander(props));\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        try {\n            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n        } catch (CheckstyleException e) {\n            System.out.println(\"Error loading package names file\");\n            e.printStackTrace(System.out);\n            System.exit(1);\n        }\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.setModuleFactory(moduleFactory);\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 66,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,89 +1,89 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n-        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n+        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), new PropertiesExpander(props));\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         try {\n             moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n         } catch (CheckstyleException e) {\n             System.out.println(\"Error loading package names file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker();\n         c.setModuleFactory(moduleFactory);\n         c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00fb7f0c1852eb015933c7c121284597de29caad": {
      "type": "Ybodychange",
      "commitMessage": "FileSetChecks are now responsible for filtering\nout the files they are not interested in, as discussed\non the checkstyle-devel list\n",
      "commitDate": "2003/2/15 下午8:13",
      "commitName": "00fb7f0c1852eb015933c7c121284597de29caad",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2003/2/4 下午7:45",
      "commitNameOld": "c13f6dd07d38a702143f7f78f74c59548e1f8453",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 11.02,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        try {\n            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n        } catch (CheckstyleException e) {\n            System.out.println(\"Error loading package names file\");\n            e.printStackTrace(System.out);\n            System.exit(1);\n        }\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.setModuleFactory(moduleFactory);\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 66,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,90 +1,89 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         try {\n             moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n         } catch (CheckstyleException e) {\n             System.out.println(\"Error loading package names file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n-    final String javaExtn \u003d \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n-            traverse(new File(values[i]), files, javaExtn);\n+            traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker();\n         c.setModuleFactory(moduleFactory);\n         c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2820c1d09d418935f7e7c410274f86da173eb96b": {
      "type": "Ybodychange",
      "commitMessage": "rfe-652294: added support for specifying file extension for Java files\n",
      "commitDate": "2003/2/2 上午9:29",
      "commitName": "2820c1d09d418935f7e7c410274f86da173eb96b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/12/16 下午2:26",
      "commitNameOld": "88e89a138aa39f50f7642106cde6568f6e07783f",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 47.79,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        try {\n            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n        } catch (CheckstyleException e) {\n            System.out.println(\"Error loading package names file\");\n            e.printStackTrace(System.out);\n            System.exit(1);\n        }\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String javaExtn \u003d \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files, javaExtn);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.setModuleFactory(moduleFactory);\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 70,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,89 +1,90 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         try {\n             moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n         } catch (CheckstyleException e) {\n             System.out.println(\"Error loading package names file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n+    final String javaExtn \u003d \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n-            traverse(new File(values[i]), files);\n+            traverse(new File(values[i]), files, javaExtn);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker();\n         c.setModuleFactory(moduleFactory);\n         c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88e89a138aa39f50f7642106cde6568f6e07783f": {
      "type": "Ybodychange",
      "commitMessage": "Changed implementation of module name resolution from inheritance to delegation approach\n",
      "commitDate": "2002/12/16 下午2:26",
      "commitName": "88e89a138aa39f50f7642106cde6568f6e07783f",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/12/6 上午2:54",
      "commitNameOld": "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 10.48,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    ModuleFactory moduleFactory \u003d null;\n    if (line.hasOption(\"n\")) {\n        try {\n            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n        } catch (CheckstyleException e) {\n            System.out.println(\"Error loading package names file\");\n            e.printStackTrace(System.out);\n            System.exit(1);\n        }\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.setModuleFactory(moduleFactory);\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 66,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,89 +1,89 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    String[] packageNames \u003d null;\n+    ModuleFactory moduleFactory \u003d null;\n     if (line.hasOption(\"n\")) {\n         try {\n-            packageNames \u003d PackageNamesLoader.loadPackageNames(line.getOptionValue(\"n\"));\n+            moduleFactory \u003d PackageNamesLoader.loadModuleFactory(line.getOptionValue(\"n\"));\n         } catch (CheckstyleException e) {\n             System.out.println(\"Error loading package names file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker();\n-        c.setPackageNames(packageNames);\n+        c.setModuleFactory(moduleFactory);\n         c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "16ba5b35f9f346e7cea294afaad7f9211605ecaa": {
      "type": "Ybodychange",
      "commitMessage": "modified for config XML and mapping names to full class names - see\nposting to checkstyle-devel@lists.sourceforge.net\n",
      "commitDate": "2002/12/6 上午2:54",
      "commitName": "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2002/12/1 上午2:29",
      "commitNameOld": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 5.02,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    String[] packageNames \u003d null;\n    if (line.hasOption(\"n\")) {\n        try {\n            packageNames \u003d PackageNamesLoader.loadPackageNames(line.getOptionValue(\"n\"));\n        } catch (CheckstyleException e) {\n            System.out.println(\"Error loading package names file\");\n            e.printStackTrace(System.out);\n            System.exit(1);\n        }\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.setPackageNames(packageNames);\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 66,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,78 +1,89 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n+    String[] packageNames \u003d null;\n+    if (line.hasOption(\"n\")) {\n+        try {\n+            packageNames \u003d PackageNamesLoader.loadPackageNames(line.getOptionValue(\"n\"));\n+        } catch (CheckstyleException e) {\n+            System.out.println(\"Error loading package names file\");\n+            e.printStackTrace(System.out);\n+            System.exit(1);\n+        }\n+    }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker();\n+        c.setPackageNames(packageNames);\n         c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": {
      "type": "Ybodychange",
      "commitMessage": "avalonization\n",
      "commitDate": "2002/12/1 上午2:29",
      "commitName": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/12/1 上午12:58",
      "commitNameOld": "085befb3adfaed30db6623bfc04fa7b1e8755d3a",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker();\n        c.configure(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 65,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,77 +1,78 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(config);\n+        c \u003d new Checker();\n+        c.configure(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final File[] processedFiles \u003d new File[files.size()];\n     files.toArray(processedFiles);\n     final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "822384a711290170148b43b5ae390dd4e8cfaf4f": {
      "type": "Ybodychange",
      "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
      "commitDate": "2002/11/17 下午2:48",
      "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/11/17 上午3:38",
      "commitNameOld": "2debda611fe487021711aa4acce56651799a778f",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.47,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new LinkedList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(new File(remainingArgs[i]));\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final File[] processedFiles \u003d new File[files.size()];\n    files.toArray(processedFiles);\n    final int numErrs \u003d c.process(processedFiles);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 62,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,75 +1,77 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n         config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n-    final List files \u003d new ArrayList();\n+    final List files \u003d new LinkedList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n-        files.add(remainingArgs[i]);\n+        files.add(new File(remainingArgs[i]));\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n+    final File[] processedFiles \u003d new File[files.size()];\n+    files.toArray(processedFiles);\n+    final int numErrs \u003d c.process(processedFiles);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2debda611fe487021711aa4acce56651799a778f": {
      "type": "Ybodychange",
      "commitMessage": "Added overriding global properties\nNeeds testing, especially in ant with CheckstyleTask.\n",
      "commitDate": "2002/11/17 上午3:38",
      "commitName": "2debda611fe487021711aa4acce56651799a778f",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2002/11/16 上午2:18",
      "commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 1.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new ArrayList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(remainingArgs[i]);\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 62,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,75 +1,75 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     Configuration config \u003d null;\n     try {\n-        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n+        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"), props);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new ArrayList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(remainingArgs[i]);\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3c0608f33a6c41cf96056c52ae99070cbe5062d5": {
      "type": "Ybodychange",
      "commitMessage": "Wrapped GlobalProperties and CheckConfiguration[] into a Configuration\nclass. TODO: Integrate with CheckStyleTask\n",
      "commitDate": "2002/11/16 上午2:18",
      "commitName": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2002/11/14 下午6:07",
      "commitNameOld": "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 1.34,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    Configuration config \u003d null;\n    try {\n        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new ArrayList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(remainingArgs[i]);\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(config);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 62,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,75 +1,75 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n-    CheckConfiguration[] checkConfigs \u003d null;\n+    Configuration config \u003d null;\n     try {\n-        checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+        config \u003d ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new ArrayList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(remainingArgs[i]);\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(new GlobalProperties(props, System.out), checkConfigs);\n+        c \u003d new Checker(config);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f4247181beca3530b5c2dc762d9c5c6a018a06c": {
      "type": "Ybodychange",
      "commitMessage": "rename Configuration to GlobalProperties\n",
      "commitDate": "2002/11/14 下午6:07",
      "commitName": "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
      "commitAuthor": "Rick Giles",
      "commitDateOld": "2002/11/13 下午12:21",
      "commitNameOld": "4cbd709c019cf1b69796858506d673f7b66d37c7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    CheckConfiguration[] checkConfigs \u003d null;\n    try {\n        checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new ArrayList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(remainingArgs[i]);\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new GlobalProperties(props, System.out), checkConfigs);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 62,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,75 +1,75 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     CheckConfiguration[] checkConfigs \u003d null;\n     try {\n         checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new ArrayList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(remainingArgs[i]);\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n+        c \u003d new Checker(new GlobalProperties(props, System.out), checkConfigs);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4cbd709c019cf1b69796858506d673f7b66d37c7": {
      "type": "Ybodychange",
      "commitMessage": "This is a really enjoyable commit to make. I have finally got to remove the\nugly Verifier class. The only remaining check are based on the new fileset\ncheck that Lars putting together. Magic. :-)\n",
      "commitDate": "2002/11/13 下午12:21",
      "commitName": "4cbd709c019cf1b69796858506d673f7b66d37c7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/11/12 上午5:52",
      "commitNameOld": "1cea3765893e83e0d58ca110113e0d05b15a798a",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    CheckConfiguration[] checkConfigs \u003d null;\n    try {\n        checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new ArrayList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(remainingArgs[i]);\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 62,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,75 +1,75 @@\n public static void main(String[] aArgs) {\n     final CommandLineParser clp \u003d new PosixParser();\n     CommandLine line \u003d null;\n     try {\n         line \u003d clp.parse(OPTS, aArgs);\n     } catch (ParseException e) {\n         e.printStackTrace();\n         usage();\n     }\n     final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n     if (!line.hasOption(\"c\")) {\n         System.out.println(\"Must specify a config XML file.\");\n         usage();\n     }\n     CheckConfiguration[] checkConfigs \u003d null;\n     try {\n         checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n     if (line.hasOption(\"o\")) {\n         final String fname \u003d line.getOptionValue(\"o\");\n         try {\n             out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n     } else {\n         out \u003d System.out;\n         closeOut \u003d false;\n     }\n     final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     final List files \u003d new ArrayList();\n     if (line.hasOption(\"r\")) {\n         final String[] values \u003d line.getOptionValues(\"r\");\n         for (int i \u003d 0; i \u003c values.length; i++) {\n             traverse(new File(values[i]), files);\n         }\n     }\n     final String[] remainingArgs \u003d line.getArgs();\n     for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n         files.add(remainingArgs[i]);\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Must specify files to process\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n+    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1cea3765893e83e0d58ca110113e0d05b15a798a": {
      "type": "Ybodychange",
      "commitMessage": "Refactoring the command line processing to use the new Jakarta Commons package\nhttp://jakarta.apache.org/commons/cli/. It is quite a nice package.\n",
      "commitDate": "2002/11/12 上午5:52",
      "commitName": "1cea3765893e83e0d58ca110113e0d05b15a798a",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/11/2 下午8:22",
      "commitNameOld": "3288a81e30ddea194f76bd74f3b509500b864163",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 9.4,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    final CommandLineParser clp \u003d new PosixParser();\n    CommandLine line \u003d null;\n    try {\n        line \u003d clp.parse(OPTS, aArgs);\n    } catch (ParseException e) {\n        e.printStackTrace();\n        usage();\n    }\n    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n    if (!line.hasOption(\"c\")) {\n        System.out.println(\"Must specify a config XML file.\");\n        usage();\n    }\n    CheckConfiguration[] checkConfigs \u003d null;\n    try {\n        checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    OutputStream out \u003d null;\n    boolean closeOut \u003d false;\n    if (line.hasOption(\"o\")) {\n        final String fname \u003d line.getOptionValue(\"o\");\n        try {\n            out \u003d new FileOutputStream(fname);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n            System.exit(1);\n        }\n    } else {\n        out \u003d System.out;\n        closeOut \u003d false;\n    }\n    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    final List files \u003d new ArrayList();\n    if (line.hasOption(\"r\")) {\n        final String[] values \u003d line.getOptionValues(\"r\");\n        for (int i \u003d 0; i \u003c values.length; i++) {\n            traverse(new File(values[i]), files);\n        }\n    }\n    final String[] remainingArgs \u003d line.getArgs();\n    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n        files.add(remainingArgs[i]);\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Must specify files to process\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 62,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,69 +1,75 @@\n public static void main(String[] aArgs) {\n-    if (aArgs.length \u003d\u003d 0) {\n+    final CommandLineParser clp \u003d new PosixParser();\n+    CommandLine line \u003d null;\n+    try {\n+        line \u003d clp.parse(OPTS, aArgs);\n+    } catch (ParseException e) {\n+        e.printStackTrace();\n         usage();\n     }\n-    String format \u003d \"plain\";\n-    String output \u003d null;\n-    Properties props \u003d System.getProperties();\n-    final List foundFiles \u003d new ArrayList();\n-    final ArrayList files \u003d new ArrayList();\n-    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n-        if (\"-f\".equals(aArgs[i])) {\n-            format \u003d aArgs[++i];\n-        } else if (\"-o\".equals(aArgs[i])) {\n-            output \u003d aArgs[++i];\n-        } else if (\"-r\".equals(aArgs[i])) {\n-            traverse(new File(aArgs[++i]), foundFiles);\n-        } else if (\"-p\".equals(aArgs[i])) {\n-            props \u003d loadProperties(new File(aArgs[++i]));\n-        } else {\n-            files.add(aArgs[i]);\n-        }\n+    final Properties props \u003d line.hasOption(\"p\") ? loadProperties(new File(line.getOptionValue(\"p\"))) : System.getProperties();\n+    if (!line.hasOption(\"c\")) {\n+        System.out.println(\"Must specify a config XML file.\");\n+        usage();\n     }\n-    OutputStream out \u003d System.out;\n+    CheckConfiguration[] checkConfigs \u003d null;\n+    try {\n+        checkConfigs \u003d ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+    } catch (CheckstyleException e) {\n+        System.out.println(\"Error loading configuration file\");\n+        e.printStackTrace(System.out);\n+        System.exit(1);\n+    }\n+    OutputStream out \u003d null;\n     boolean closeOut \u003d false;\n-    if (output !\u003d null) {\n+    if (line.hasOption(\"o\")) {\n+        final String fname \u003d line.getOptionValue(\"o\");\n         try {\n-            out \u003d new FileOutputStream(output);\n+            out \u003d new FileOutputStream(fname);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n-            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n+            System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n             System.exit(1);\n         }\n+    } else {\n+        out \u003d System.out;\n+        closeOut \u003d false;\n     }\n+    final String format \u003d line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n-    if (files.isEmpty()) {\n-        System.out.println(\"Need to specify a config file\");\n-        usage();\n+    final List files \u003d new ArrayList();\n+    if (line.hasOption(\"r\")) {\n+        final String[] values \u003d line.getOptionValues(\"r\");\n+        for (int i \u003d 0; i \u003c values.length; i++) {\n+            traverse(new File(values[i]), files);\n+        }\n     }\n-    final String configFname \u003d (String) files.remove(0);\n-    CheckConfiguration[] checkConfigs \u003d null;\n-    try {\n-        checkConfigs \u003d ConfigurationLoader.loadConfigs(configFname);\n-    } catch (CheckstyleException e) {\n-        System.out.println(\"Error loading configuration file\");\n-        e.printStackTrace(System.out);\n-        System.exit(1);\n+    final String[] remainingArgs \u003d line.getArgs();\n+    for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n+        files.add(remainingArgs[i]);\n+    }\n+    if (files.isEmpty()) {\n+        System.out.println(\"Must specify files to process\");\n+        usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    files.addAll(foundFiles);\n     final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3288a81e30ddea194f76bd74f3b509500b864163": {
      "type": "Ybodychange",
      "commitMessage": "Just converted over the Checkstyle ANT task to use the new framework. In\nprocess I had to fix numerous errors now being reported.\n\nThere are some bugs with the method checks, which I will now investigate.\n",
      "commitDate": "2002/11/2 下午8:22",
      "commitName": "3288a81e30ddea194f76bd74f3b509500b864163",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/10/31 下午8:28",
      "commitNameOld": "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    Properties props \u003d System.getProperties();\n    final List foundFiles \u003d new ArrayList();\n    final ArrayList files \u003d new ArrayList();\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else if (\"-r\".equals(aArgs[i])) {\n            traverse(new File(aArgs[++i]), foundFiles);\n        } else if (\"-p\".equals(aArgs[i])) {\n            props \u003d loadProperties(new File(aArgs[++i]));\n        } else {\n            files.add(aArgs[i]);\n        }\n    }\n    OutputStream out \u003d System.out;\n    boolean closeOut \u003d false;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Need to specify a config file\");\n        usage();\n    }\n    final String configFname \u003d (String) files.remove(0);\n    CheckConfiguration[] checkConfigs \u003d null;\n    try {\n        checkConfigs \u003d ConfigurationLoader.loadConfigs(configFname);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    files.addAll(foundFiles);\n    final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 42,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,69 +1,69 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n     Properties props \u003d System.getProperties();\n     final List foundFiles \u003d new ArrayList();\n     final ArrayList files \u003d new ArrayList();\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n         } else if (\"-r\".equals(aArgs[i])) {\n             traverse(new File(aArgs[++i]), foundFiles);\n         } else if (\"-p\".equals(aArgs[i])) {\n             props \u003d loadProperties(new File(aArgs[++i]));\n         } else {\n             files.add(aArgs[i]);\n         }\n     }\n     OutputStream out \u003d System.out;\n     boolean closeOut \u003d false;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     if (files.isEmpty()) {\n         System.out.println(\"Need to specify a config file\");\n         usage();\n     }\n     final String configFname \u003d (String) files.remove(0);\n     CheckConfiguration[] checkConfigs \u003d null;\n     try {\n-        checkConfigs \u003d loadConfigs(configFname);\n+        checkConfigs \u003d ConfigurationLoader.loadConfigs(configFname);\n     } catch (CheckstyleException e) {\n         System.out.println(\"Error loading configuration file\");\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     files.addAll(foundFiles);\n     final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b": {
      "type": "Ybodychange",
      "commitMessage": "Start of conversion to only supporting the new framework. Also refactored\nerror handling.\n",
      "commitDate": "2002/10/31 下午8:28",
      "commitName": "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/9/27 下午2:41",
      "commitNameOld": "d077a402da51bb238a7da99d5e2542437b145192",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 34.24,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    Properties props \u003d System.getProperties();\n    final List foundFiles \u003d new ArrayList();\n    final ArrayList files \u003d new ArrayList();\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else if (\"-r\".equals(aArgs[i])) {\n            traverse(new File(aArgs[++i]), foundFiles);\n        } else if (\"-p\".equals(aArgs[i])) {\n            props \u003d loadProperties(new File(aArgs[++i]));\n        } else {\n            files.add(aArgs[i]);\n        }\n    }\n    OutputStream out \u003d System.out;\n    boolean closeOut \u003d false;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    if (files.isEmpty()) {\n        System.out.println(\"Need to specify a config file\");\n        usage();\n    }\n    final String configFname \u003d (String) files.remove(0);\n    CheckConfiguration[] checkConfigs \u003d null;\n    try {\n        checkConfigs \u003d loadConfigs(configFname);\n    } catch (CheckstyleException e) {\n        System.out.println(\"Error loading configuration file\");\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    files.addAll(foundFiles);\n    final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 46,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,54 +1,69 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n-    Properties properties \u003d System.getProperties();\n+    Properties props \u003d System.getProperties();\n+    final List foundFiles \u003d new ArrayList();\n     final ArrayList files \u003d new ArrayList();\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n         } else if (\"-r\".equals(aArgs[i])) {\n-            traverse(new File(aArgs[++i]), files);\n+            traverse(new File(aArgs[++i]), foundFiles);\n         } else if (\"-p\".equals(aArgs[i])) {\n-            properties \u003d loadProperties(new File(aArgs[++i]));\n+            props \u003d loadProperties(new File(aArgs[++i]));\n         } else {\n             files.add(aArgs[i]);\n         }\n     }\n     OutputStream out \u003d System.out;\n     boolean closeOut \u003d false;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n+    if (files.isEmpty()) {\n+        System.out.println(\"Need to specify a config file\");\n+        usage();\n+    }\n+    final String configFname \u003d (String) files.remove(0);\n+    CheckConfiguration[] checkConfigs \u003d null;\n+    try {\n+        checkConfigs \u003d loadConfigs(configFname);\n+    } catch (CheckstyleException e) {\n+        System.out.println(\"Error loading configuration file\");\n+        e.printStackTrace(System.out);\n+        System.exit(1);\n+    }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(new Configuration(properties, System.out));\n+        c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n         c.addListener(listener);\n     } catch (Exception e) {\n         System.out.println(\"Unable to create Checker: \" + e.getMessage());\n         e.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n+    files.addAll(foundFiles);\n+    final int numErrs \u003d c.processNEW((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b": {
      "type": "Ybodychange",
      "commitMessage": "Implemented a new version of Checker for that uses the Checks. The intent is\nto be able reuse the existing checker.\n\nOT: Due to ISP problems, I am unable to receive email at the moment.\n",
      "commitDate": "2002/9/24 下午2:34",
      "commitName": "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/7/3 上午4:08",
      "commitNameOld": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 83.43,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    Properties properties \u003d System.getProperties();\n    final ArrayList files \u003d new ArrayList();\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else if (\"-r\".equals(aArgs[i])) {\n            traverse(new File(aArgs[++i]), files);\n        } else if (\"-p\".equals(aArgs[i])) {\n            properties \u003d loadProperties(new File(aArgs[++i]));\n        } else {\n            files.add(aArgs[i]);\n        }\n    }\n    OutputStream out \u003d System.out;\n    boolean closeOut \u003d false;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(properties, System.out));\n        c.addListener(listener);\n    } catch (Exception e) {\n        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n        e.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 43,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,58 +1,54 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n     Properties properties \u003d System.getProperties();\n     final ArrayList files \u003d new ArrayList();\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n         } else if (\"-r\".equals(aArgs[i])) {\n             traverse(new File(aArgs[++i]), files);\n         } else if (\"-p\".equals(aArgs[i])) {\n             properties \u003d loadProperties(new File(aArgs[++i]));\n         } else {\n             files.add(aArgs[i]);\n         }\n     }\n     OutputStream out \u003d System.out;\n     boolean closeOut \u003d false;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n             closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(properties, System.out));\n         c.addListener(listener);\n-    } catch (RESyntaxException rese) {\n-        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n-        rese.printStackTrace(System.out);\n-        System.exit(1);\n-    } catch (IOException ex) {\n-        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n-        ex.printStackTrace(System.out);\n+    } catch (Exception e) {\n+        System.out.println(\"Unable to create Checker: \" + e.getMessage());\n+        e.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "add2bdfb27494bff5fa9c305d9782f57c6170b18": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug 561616 (ant task should log errors, not infos)\n\nThis required a redesign of the AuditListener interface, the get/setOutputStream methoeds have been removed, as there might be listeners that have no or more than one OutputStream.\n\nThe DefaultLogger now differentiates between info messages (\"started checking file ...\", etc.) and error messages (style errors found by checkstyle) by writing the messages to two different OutputStreams.\n",
      "commitDate": "2002/7/3 上午4:08",
      "commitName": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/5/28 下午9:39",
      "commitNameOld": "34770c3eaa9ad06297c13fd43a55739c02c7d67d",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 35.27,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    Properties properties \u003d System.getProperties();\n    final ArrayList files \u003d new ArrayList();\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else if (\"-r\".equals(aArgs[i])) {\n            traverse(new File(aArgs[++i]), files);\n        } else if (\"-p\".equals(aArgs[i])) {\n            properties \u003d loadProperties(new File(aArgs[++i]));\n        } else {\n            files.add(aArgs[i]);\n        }\n    }\n    OutputStream out \u003d System.out;\n    boolean closeOut \u003d false;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n            closeOut \u003d true;\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out, closeOut);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out, closeOut);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(properties, System.out));\n        c.addListener(listener);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 43,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,56 +1,58 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n     Properties properties \u003d System.getProperties();\n     final ArrayList files \u003d new ArrayList();\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n         } else if (\"-r\".equals(aArgs[i])) {\n             traverse(new File(aArgs[++i]), files);\n         } else if (\"-p\".equals(aArgs[i])) {\n             properties \u003d loadProperties(new File(aArgs[++i]));\n         } else {\n             files.add(aArgs[i]);\n         }\n     }\n     OutputStream out \u003d System.out;\n+    boolean closeOut \u003d false;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n+            closeOut \u003d true;\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n-        listener \u003d new XMLLogger(out);\n+        listener \u003d new XMLLogger(out, closeOut);\n     } else if (\"plain\".equals(format)) {\n-        listener \u003d new DefaultLogger(out);\n+        listener \u003d new DefaultLogger(out, closeOut);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(properties, System.out));\n         c.addListener(listener);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n     } catch (IOException ex) {\n         System.out.println(\"I/O error occurred: \" + ex.getMessage());\n         ex.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ef5716560b2b52a5fcd233ac9ad546a53749339f": {
      "type": "Ybodychange",
      "commitMessage": "RFE #557544, load properties from file on cmdline\n",
      "commitDate": "2002/5/19 下午3:38",
      "commitName": "ef5716560b2b52a5fcd233ac9ad546a53749339f",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "2002/4/17 下午7:59",
      "commitNameOld": "e200d9bf3d07b103e633d56215280e5e7d7a980b",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 31.82,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    Properties properties \u003d System.getProperties();\n    final ArrayList files \u003d new ArrayList();\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else if (\"-r\".equals(aArgs[i])) {\n            traverse(new File(aArgs[++i]), files);\n        } else if (\"-p\".equals(aArgs[i])) {\n            properties \u003d loadProperties(new File(aArgs[++i]));\n        } else {\n            files.add(aArgs[i]);\n        }\n    }\n    OutputStream out \u003d System.out;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(properties, System.out));\n        c.addListener(listener);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 43,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,53 +1,56 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n+    Properties properties \u003d System.getProperties();\n     final ArrayList files \u003d new ArrayList();\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n         } else if (\"-r\".equals(aArgs[i])) {\n             traverse(new File(aArgs[++i]), files);\n+        } else if (\"-p\".equals(aArgs[i])) {\n+            properties \u003d loadProperties(new File(aArgs[++i]));\n         } else {\n             files.add(aArgs[i]);\n         }\n     }\n     OutputStream out \u003d System.out;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(new Configuration(System.getProperties(), System.out));\n+        c \u003d new Checker(new Configuration(properties, System.out));\n         c.addListener(listener);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n     } catch (IOException ex) {\n         System.out.println(\"I/O error occurred: \" + ex.getMessage());\n         ex.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e200d9bf3d07b103e633d56215280e5e7d7a980b": {
      "type": "Ybodychange",
      "commitMessage": "545128: implemented \"-r\" recursive option and improved the argument handling\n",
      "commitDate": "2002/4/17 下午7:59",
      "commitName": "e200d9bf3d07b103e633d56215280e5e7d7a980b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2002/2/4 下午8:44",
      "commitNameOld": "b779f3c1da7bacfe57900ccba7cd95de7ab54071",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 71.97,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    final ArrayList files \u003d new ArrayList();\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else if (\"-r\".equals(aArgs[i])) {\n            traverse(new File(aArgs[++i]), files);\n        } else {\n            files.add(aArgs[i]);\n        }\n    }\n    OutputStream out \u003d System.out;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(System.getProperties(), System.out));\n        c.addListener(listener);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 41,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,53 +1,53 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n-    String[] files \u003d null;\n+    final ArrayList files \u003d new ArrayList();\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n+        } else if (\"-r\".equals(aArgs[i])) {\n+            traverse(new File(aArgs[++i]), files);\n         } else {\n-            files \u003d new String[aArgs.length - i];\n-            System.arraycopy(aArgs, i, files, 0, files.length);\n-            break;\n+            files.add(aArgs[i]);\n         }\n     }\n     OutputStream out \u003d System.out;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(System.getProperties(), System.out));\n         c.addListener(listener);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n     } catch (IOException ex) {\n         System.out.println(\"I/O error occurred: \" + ex.getMessage());\n         ex.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    final int numErrs \u003d c.process(files);\n+    final int numErrs \u003d c.process((String[]) files.toArray(new String[files.size()]));\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5": {
      "type": "Ybodychange",
      "commitMessage": "Refactored Checker to not take a PrintStream. All errors are not logged to\nstandard output.\n",
      "commitDate": "2002/1/23 下午8:28",
      "commitName": "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/8/31 上午12:13",
      "commitNameOld": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 145.84,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    String[] files \u003d null;\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else {\n            files \u003d new String[aArgs.length - i];\n            System.arraycopy(aArgs, i, files, 0, files.length);\n            break;\n        }\n    }\n    OutputStream out \u003d System.out;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(System.getProperties(), System.out));\n        c.addListener(listener);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 38,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,53 +1,53 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     String format \u003d \"plain\";\n     String output \u003d null;\n     String[] files \u003d null;\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         if (\"-f\".equals(aArgs[i])) {\n             format \u003d aArgs[++i];\n         } else if (\"-o\".equals(aArgs[i])) {\n             output \u003d aArgs[++i];\n         } else {\n             files \u003d new String[aArgs.length - i];\n             System.arraycopy(aArgs, i, files, 0, files.length);\n             break;\n         }\n     }\n     OutputStream out \u003d System.out;\n     if (output !\u003d null) {\n         try {\n             out \u003d new FileOutputStream(output);\n         } catch (FileNotFoundException e) {\n             System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n             System.exit(1);\n         }\n     }\n     AuditListener listener \u003d null;\n     if (\"xml\".equals(format)) {\n         listener \u003d new XMLLogger(out);\n     } else if (\"plain\".equals(format)) {\n         listener \u003d new DefaultLogger(out);\n     } else {\n         System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n+        c \u003d new Checker(new Configuration(System.getProperties(), System.out));\n         c.addListener(listener);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n     } catch (IOException ex) {\n         System.out.println(\"I/O error occurred: \" + ex.getMessage());\n         ex.printStackTrace(System.out);\n         System.exit(1);\n     }\n     final int numErrs \u003d c.process(files);\n     c.destroy();\n     System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": {
      "type": "Ybodychange",
      "commitMessage": "started to incorporate logging events\n",
      "commitDate": "2001/8/31 上午12:13",
      "commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/8/5 下午10:12",
      "commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 25.08,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    String format \u003d \"plain\";\n    String output \u003d null;\n    String[] files \u003d null;\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        if (\"-f\".equals(aArgs[i])) {\n            format \u003d aArgs[++i];\n        } else if (\"-o\".equals(aArgs[i])) {\n            output \u003d aArgs[++i];\n        } else {\n            files \u003d new String[aArgs.length - i];\n            System.arraycopy(aArgs, i, files, 0, files.length);\n            break;\n        }\n    }\n    OutputStream out \u003d System.out;\n    if (output !\u003d null) {\n        try {\n            out \u003d new FileOutputStream(output);\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n            System.exit(1);\n        }\n    }\n    AuditListener listener \u003d null;\n    if (\"xml\".equals(format)) {\n        listener \u003d new XMLLogger(out);\n    } else if (\"plain\".equals(format)) {\n        listener \u003d new DefaultLogger(out);\n    } else {\n        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n        c.addListener(listener);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    final int numErrs \u003d c.process(files);\n    c.destroy();\n    System.exit(numErrs);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 38,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,23 +1,53 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n+    String format \u003d \"plain\";\n+    String output \u003d null;\n+    String[] files \u003d null;\n+    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n+        if (\"-f\".equals(aArgs[i])) {\n+            format \u003d aArgs[++i];\n+        } else if (\"-o\".equals(aArgs[i])) {\n+            output \u003d aArgs[++i];\n+        } else {\n+            files \u003d new String[aArgs.length - i];\n+            System.arraycopy(aArgs, i, files, 0, files.length);\n+            break;\n+        }\n+    }\n+    OutputStream out \u003d System.out;\n+    if (output !\u003d null) {\n+        try {\n+            out \u003d new FileOutputStream(output);\n+        } catch (FileNotFoundException e) {\n+            System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n+            System.exit(1);\n+        }\n+    }\n+    AuditListener listener \u003d null;\n+    if (\"xml\".equals(format)) {\n+        listener \u003d new XMLLogger(out);\n+    } else if (\"plain\".equals(format)) {\n+        listener \u003d new DefaultLogger(out);\n+    } else {\n+        System.out.println(\"Invalid format: (\" + format + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n+        usage();\n+    }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n+        c.addListener(listener);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n     } catch (IOException ex) {\n         System.out.println(\"I/O error occurred: \" + ex.getMessage());\n         ex.printStackTrace(System.out);\n         System.exit(1);\n     }\n-    int numErrors \u003d 0;\n-    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n-        numErrors +\u003d c.process(aArgs[i]);\n-    }\n+    final int numErrs \u003d c.process(files);\n     c.destroy();\n-    System.exit(numErrors);\n+    System.exit(numErrs);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": {
      "type": "Ybodychange",
      "commitMessage": "added support for caching\n",
      "commitDate": "2001/8/5 下午10:12",
      "commitName": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/6/29 下午3:21",
      "commitNameOld": "69138e40225407ef560fd9d06d2903de37c83c2c",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 37.29,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    int numErrors \u003d 0;\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        numErrors +\u003d c.process(aArgs[i]);\n    }\n    c.destroy();\n    System.exit(numErrors);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 35,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,22 +1,23 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n         c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n     } catch (IOException ex) {\n         System.out.println(\"I/O error occurred: \" + ex.getMessage());\n         ex.printStackTrace(System.out);\n         System.exit(1);\n     }\n     int numErrors \u003d 0;\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         numErrors +\u003d c.process(aArgs[i]);\n     }\n+    c.destroy();\n     System.exit(numErrors);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "69138e40225407ef560fd9d06d2903de37c83c2c": {
      "type": "Ybodychange",
      "commitMessage": "refactored to use the new Configuration class.\n",
      "commitDate": "2001/6/29 下午3:21",
      "commitName": "69138e40225407ef560fd9d06d2903de37c83c2c",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/6/28 下午9:10",
      "commitNameOld": "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    } catch (IOException ex) {\n        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n        ex.printStackTrace(System.out);\n        System.exit(1);\n    }\n    int numErrors \u003d 0;\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        numErrors +\u003d c.process(aArgs[i]);\n    }\n    System.exit(numErrors);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 35,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,18 +1,22 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(System.getProperties(), System.out);\n+        c \u003d new Checker(new Configuration(System.getProperties(), System.out), System.out);\n     } catch (RESyntaxException rese) {\n         System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n         rese.printStackTrace(System.out);\n         System.exit(1);\n+    } catch (IOException ex) {\n+        System.out.println(\"I/O error occurred: \" + ex.getMessage());\n+        ex.printStackTrace(System.out);\n+        System.exit(1);\n     }\n     int numErrors \u003d 0;\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         numErrors +\u003d c.process(aArgs[i]);\n     }\n     System.exit(numErrors);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9": {
      "type": "Ybodychange",
      "commitMessage": "changed for release 1.2\n",
      "commitDate": "2001/6/28 下午9:10",
      "commitName": "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "2001/6/22 下午9:24",
      "commitNameOld": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(System.getProperties(), System.out);\n    } catch (RESyntaxException rese) {\n        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.out);\n        System.exit(1);\n    }\n    int numErrors \u003d 0;\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        numErrors +\u003d c.process(aArgs[i]);\n    }\n    System.exit(numErrors);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 34,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n",
      "diff": "@@ -1,18 +1,18 @@\n public static void main(String[] aArgs) {\n     if (aArgs.length \u003d\u003d 0) {\n         usage();\n     }\n     Checker c \u003d null;\n     try {\n-        c \u003d new Checker(System.getProperties(), System.err);\n+        c \u003d new Checker(System.getProperties(), System.out);\n     } catch (RESyntaxException rese) {\n-        System.err.println(\"Unable to create an regexp object: \" + rese.getMessage());\n-        rese.printStackTrace(System.err);\n+        System.out.println(\"Unable to create an regexp object: \" + rese.getMessage());\n+        rese.printStackTrace(System.out);\n         System.exit(1);\n     }\n     int numErrors \u003d 0;\n     for (int i \u003d 0; i \u003c aArgs.length; i++) {\n         numErrors +\u003d c.process(aArgs[i]);\n     }\n     System.exit(numErrors);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": {
      "type": "Yintroduced",
      "commitMessage": "first cut\n",
      "commitDate": "2001/6/22 下午9:24",
      "commitName": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
      "commitAuthor": "Oliver Burn",
      "diff": "@@ -0,0 +1,18 @@\n+public static void main(String[] aArgs) {\n+    if (aArgs.length \u003d\u003d 0) {\n+        usage();\n+    }\n+    Checker c \u003d null;\n+    try {\n+        c \u003d new Checker(System.getProperties(), System.err);\n+    } catch (RESyntaxException rese) {\n+        System.err.println(\"Unable to create an regexp object: \" + rese.getMessage());\n+        rese.printStackTrace(System.err);\n+        System.exit(1);\n+    }\n+    int numErrors \u003d 0;\n+    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n+        numErrors +\u003d c.process(aArgs[i]);\n+    }\n+    System.exit(numErrors);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static void main(String[] aArgs) {\n    if (aArgs.length \u003d\u003d 0) {\n        usage();\n    }\n    Checker c \u003d null;\n    try {\n        c \u003d new Checker(System.getProperties(), System.err);\n    } catch (RESyntaxException rese) {\n        System.err.println(\"Unable to create an regexp object: \" + rese.getMessage());\n        rese.printStackTrace(System.err);\n        System.exit(1);\n    }\n    int numErrors \u003d 0;\n    for (int i \u003d 0; i \u003c aArgs.length; i++) {\n        numErrors +\u003d c.process(aArgs[i]);\n    }\n    System.exit(numErrors);\n}",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
      "functionStartLine": 34,
      "functionName": "main",
      "functionAnnotation": "",
      "functionDoc": "Loops over the files specified checking them for errors. The exit code\nis the number of errors found in all the files.\n\n@param aArgs the command line arguments\n"
    }
  }
}