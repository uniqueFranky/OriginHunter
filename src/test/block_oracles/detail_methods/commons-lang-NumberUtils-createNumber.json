{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "NumberUtils.java",
  "functionName": "createNumber",
  "functionId": "createNumber___str-String(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
  "functionStartLine": 450,
  "functionEndLine": 617,
  "numCommitsSeen": 123,
  "timeTaken": 4159,
  "changeHistory": [
    "b610707cd072f07efb816074a4844bb1b31e482c",
    "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
    "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
    "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
    "dfd69e038cc7035031d1807c4ade870d2a7e2ece",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
    "b877fb9abef4a19eec9cc7329acbd433648b8f7b",
    "45a6467088a08e447d7f2983551021b91c70ab49",
    "d1a45e9738de5b3e299bb51e987565dcce55fee6",
    "8a1042959df80c06dbfa83896594caa8e20ff9d6",
    "d80be57d6eecc99411a77ab9575e1991bb616abc",
    "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
    "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "d844d1eb5e5b530a82b77302f1f284fd2f924be3",
    "350cf8c2da08ccde6b4d71b19bb3df97256ea368",
    "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
    "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
    "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c",
    "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "5beb105d6b4188e6babefd89e19b06df1d71886c",
    "15360774099b2a7230e020751acdf6979b6e3f58",
    "073222372614fcff2f4824d46a817c44e4b03d09",
    "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
    "b73111983b7916b3944e2178d079f1326cd8df06",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
    "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25",
    "3b19309d76817dfacb40299b474ecbc27a471e11",
    "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb"
  ],
  "changeHistoryShort": {
    "b610707cd072f07efb816074a4844bb1b31e482c": "Ybodychange",
    "214cc7fd596b575ed07a7d7c1006b46d5c75613d": "Ybodychange",
    "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284": "Yexceptionschange",
    "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435": "Ybodychange",
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec": "Ydocchange",
    "dfd69e038cc7035031d1807c4ade870d2a7e2ece": "Ybodychange",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c": "Ybodychange",
    "b877fb9abef4a19eec9cc7329acbd433648b8f7b": "Ybodychange",
    "45a6467088a08e447d7f2983551021b91c70ab49": "Ybodychange",
    "d1a45e9738de5b3e299bb51e987565dcce55fee6": "Ybodychange",
    "8a1042959df80c06dbfa83896594caa8e20ff9d6": "Ybodychange",
    "d80be57d6eecc99411a77ab9575e1991bb616abc": "Ybodychange",
    "b3db6ed9efd0b8ed8a940f2735abb156030d10f9": "Ymultichange(Ybodychange,Ydocchange)",
    "ad43a49dabd5cc14e8ff4b91dbb03477063c1314": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "d844d1eb5e5b530a82b77302f1f284fd2f924be3": "Ybodychange",
    "350cf8c2da08ccde6b4d71b19bb3df97256ea368": "Ybodychange",
    "c7adc7e86f118a92ac4eee5a3c6775eec11af115": "Ymultichange(Ybodychange,Ydocchange)",
    "41326bf5266ecc6472bab28481b77cecd6f7fb5c": "Ymultichange(Ybodychange,Ydocchange)",
    "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c": "Ybodychange",
    "50c1fdecb4ed33ec1bb0d449f294c299d5369701": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": "Ybodychange",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "5beb105d6b4188e6babefd89e19b06df1d71886c": "Ybodychange",
    "15360774099b2a7230e020751acdf6979b6e3f58": "Ybodychange",
    "073222372614fcff2f4824d46a817c44e4b03d09": "Ybodychange",
    "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f": "Ybodychange",
    "b73111983b7916b3944e2178d079f1326cd8df06": "Ybodychange",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": "Ybodychange",
    "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25": "Ybodychange",
    "3b19309d76817dfacb40299b474ecbc27a471e11": "Ybodychange",
    "af6aba957f4dc4d19d5f295172b4ddc941ca1681": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b610707cd072f07efb816074a4844bb1b31e482c": {
      "type": "Ybodychange",
      "commitMessage": "removes unnecessary class reference of static method calls which are declared in the same class\n",
      "commitDate": "2018/6/20 下午7:28",
      "commitName": "b610707cd072f07efb816074a4844bb1b31e482c",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2018/6/20 下午6:05",
      "commitNameOld": "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
      "commitAuthorOld": "Igor Curdvanovschi",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,140 +1,140 @@\n public static Number createNumber(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n-                    final Float f \u003d NumberUtils.createFloat(str);\n+                    final Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n-                    final Double d \u003d NumberUtils.createDouble(str);\n+                    final Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         final Float f \u003d createFloat(str);\n         final Double d \u003d createDouble(str);\n         if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n             return f;\n         }\n         if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n             final BigDecimal b \u003d createBigDecimal(str);\n             if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                 return d;\n             }\n             return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "214cc7fd596b575ed07a7d7c1006b46d5c75613d": {
      "type": "Ybodychange",
      "commitMessage": "replaces \u0027size() \u003d\u003d 0\u0027 and \u0027length() \u003d\u003d 0\u0027 with \u0027isEmpty()\u0027\n",
      "commitDate": "2018/6/20 下午6:05",
      "commitName": "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2018/6/20 下午2:03",
      "commitNameOld": "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
      "commitAuthorOld": "Igor Curdvanovschi",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,140 +1,140 @@\n public static Number createNumber(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n-                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(str);\n                     if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(str);\n                     if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         final Float f \u003d createFloat(str);\n         final Double d \u003d createDouble(str);\n         if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n             return f;\n         }\n         if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n             final BigDecimal b \u003d createBigDecimal(str);\n             if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                 return d;\n             }\n             return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284": {
      "type": "Yexceptionschange",
      "commitMessage": "removes unchecked exceptions declared in \u0027throws\u0027 clause\n",
      "commitDate": "2018/6/20 下午2:03",
      "commitName": "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2018/3/11 上午9:16",
      "commitNameOld": "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 101.2,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,140 +1,140 @@\n-public static Number createNumber(final String str) throws NumberFormatException {\n+public static Number createNumber(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(str);\n                     if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(str);\n                     if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         final Float f \u003d createFloat(str);\n         final Double d \u003d createDouble(str);\n         if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n             return f;\n         }\n         if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n             final BigDecimal b \u003d createBigDecimal(str);\n             if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                 return d;\n             }\n             return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[NumberFormatException]",
        "newValue": "[]"
      }
    },
    "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435": {
      "type": "Ybodychange",
      "commitMessage": "[LANG-1385] NumberUtils.createNumber() throws\nStringIndexOutOfBoundsException instead of NumberFormatException.",
      "commitDate": "2018/3/11 上午9:16",
      "commitName": "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2018/2/11 下午7:08",
      "commitNameOld": "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
      "commitAuthorOld": "Piotr Kosmala",
      "daysBetweenCommits": 27.59,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,140 +1,140 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n-                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(str);\n                     if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(str);\n                     if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         final Float f \u003d createFloat(str);\n         final Double d \u003d createDouble(str);\n         if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n             return f;\n         }\n         if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n             final BigDecimal b \u003d createBigDecimal(str);\n             if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                 return d;\n             }\n             return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec": {
      "type": "Ydocchange",
      "commitMessage": "Make sure lines in files don\u0027t have trailing white spaces and remove all trailing white spaces\n",
      "commitDate": "2017/6/6 下午9:12",
      "commitName": "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2017/5/26 上午12:25",
      "commitNameOld": "6a688cf36e23aded8c9796b786e92144cb4a5830",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 11.87,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
        "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts\ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n"
      }
    },
    "dfd69e038cc7035031d1807c4ade870d2a7e2ece": {
      "type": "Ybodychange",
      "commitMessage": "Fix unbox warning. Show when we are unboxing.",
      "commitDate": "2016/11/19 上午5:38",
      "commitName": "dfd69e038cc7035031d1807c4ade870d2a7e2ece",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2016/10/24 上午1:55",
      "commitNameOld": "aadb9a31ed969fc72cc87d486ec02383faa5bd06",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 26.16,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,140 +1,140 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(str);\n                     if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(str);\n                     if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         final Float f \u003d createFloat(str);\n         final Double d \u003d createDouble(str);\n         if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n             return f;\n         }\n         if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n             final BigDecimal b \u003d createBigDecimal(str);\n-            if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n+            if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                 return d;\n             }\n             return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016/9/19 下午7:56",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016/9/12 上午1:00",
      "commitNameOld": "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 7.79,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,140 +1,140 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n-        if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n+        if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createBigInteger(str);\n         }\n-        if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n+        if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(str);\n-                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                    if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(str);\n-                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                    if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         final Float f \u003d createFloat(str);\n         final Double d \u003d createDouble(str);\n         if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n             return f;\n         }\n         if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n             final BigDecimal b \u003d createBigDecimal(str);\n             if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                 return d;\n             }\n             return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1018: Fix precision loss on NumberUtils.createNumber(String) (closes #156)\n",
      "commitDate": "2016/6/12 下午7:23",
      "commitName": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
      "commitAuthor": "Nick Manley",
      "commitDateOld": "2016/6/3 下午11:07",
      "commitNameOld": "faeaa303b903139f36c15751c8e48ef982222842",
      "commitAuthorOld": "Eric Wannemacher",
      "daysBetweenCommits": 8.84,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        final Double d \u003d createDouble(str);\n        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n            return f;\n        }\n        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n            final BigDecimal b \u003d createBigDecimal(str);\n            if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                return d;\n            }\n            return b;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,145 +1,140 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n-    int numDecimals \u003d 0;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n-        numDecimals \u003d dec.length();\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(str);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n-        if (numDecimals \u003c\u003d 7) {\n-            final Float f \u003d createFloat(str);\n-            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n-                return f;\n-            }\n+        final Float f \u003d createFloat(str);\n+        final Double d \u003d createDouble(str);\n+        if (!f.isInfinite() \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros) \u0026\u0026 f.toString().equals(d.toString())) {\n+            return f;\n         }\n-    } catch (final NumberFormatException nfe) {\n-    }\n-    try {\n-        if (numDecimals \u003c\u003d 16) {\n-            final Double d \u003d createDouble(str);\n-            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+        if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n+            final BigDecimal b \u003d createBigDecimal(str);\n+            if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                 return d;\n             }\n+            return b;\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b877fb9abef4a19eec9cc7329acbd433648b8f7b": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1205: NumberUtils.createNumber() behaves inconsistently with NumberUtils.isNumber()\nThis closes github #87 thanks to pbrose\n",
      "commitDate": "2016/4/24 上午11:35",
      "commitName": "b877fb9abef4a19eec9cc7329acbd433648b8f7b",
      "commitAuthor": "Chas Honton",
      "commitDateOld": "2016/2/26 下午12:52",
      "commitNameOld": "69e97c8b42b9ad0880618132a613466f4e4779d3",
      "commitAuthorOld": "Hen",
      "daysBetweenCommits": 57.95,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    int numDecimals \u003d 0;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n        numDecimals \u003d dec.length();\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(str);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        if (numDecimals \u003c\u003d 7) {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        if (numDecimals \u003c\u003d 16) {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,145 +1,145 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     int numDecimals \u003d 0;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d getMantissa(str, decPos);\n         numDecimals \u003d dec.length();\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d getMantissa(str, expPos);\n         } else {\n             mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n-                    final Float f \u003d NumberUtils.createFloat(numeric);\n+                    final Float f \u003d NumberUtils.createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n-                    final Double d \u003d NumberUtils.createDouble(numeric);\n+                    final Double d \u003d NumberUtils.createDouble(str);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         if (numDecimals \u003c\u003d 7) {\n             final Float f \u003d createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                 return f;\n             }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     try {\n         if (numDecimals \u003c\u003d 16) {\n             final Double d \u003d createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                 return d;\n             }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a6467088a08e447d7f2983551021b91c70ab49": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1087: NumberUtils#createNumber() returns positive BigDecimal when negative Float is expected. Thanks to Renat Zhilkibaev.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1663129 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015/3/2 上午12:48",
      "commitName": "45a6467088a08e447d7f2983551021b91c70ab49",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014/12/13 上午5:15",
      "commitNameOld": "05763470e5a067eb153533d47baa73174ad9bd46",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 78.81,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    int numDecimals \u003d 0;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d getMantissa(str, decPos);\n        numDecimals \u003d dec.length();\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d getMantissa(str, expPos);\n        } else {\n            mant \u003d getMantissa(str);\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        if (numDecimals \u003c\u003d 7) {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        if (numDecimals \u003c\u003d 16) {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,145 +1,145 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         char firstSigDigit \u003d 0;\n         for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n             firstSigDigit \u003d str.charAt(i);\n             if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                 pfxLen++;\n             } else {\n                 break;\n             }\n         }\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     int numDecimals \u003d 0;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n-        mant \u003d str.substring(0, decPos);\n+        mant \u003d getMantissa(str, decPos);\n         numDecimals \u003d dec.length();\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n-            mant \u003d str.substring(0, expPos);\n+            mant \u003d getMantissa(str, expPos);\n         } else {\n-            mant \u003d str;\n+            mant \u003d getMantissa(str);\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         if (numDecimals \u003c\u003d 7) {\n             final Float f \u003d createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                 return f;\n             }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     try {\n         if (numDecimals \u003c\u003d 16) {\n             final Double d \u003d createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                 return d;\n             }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d1a45e9738de5b3e299bb51e987565dcce55fee6": {
      "type": "Ybodychange",
      "commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1507169 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/7/26 上午9:03",
      "commitName": "d1a45e9738de5b3e299bb51e987565dcce55fee6",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013/5/19 下午6:22",
      "commitNameOld": "8a1042959df80c06dbfa83896594caa8e20ff9d6",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 67.61,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        char firstSigDigit \u003d 0;\n        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n            firstSigDigit \u003d str.charAt(i);\n            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n                pfxLen++;\n            } else {\n                break;\n            }\n        }\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    int numDecimals \u003d 0;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n        numDecimals \u003d dec.length();\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        if (numDecimals \u003c\u003d 7) {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        if (numDecimals \u003c\u003d 16) {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,136 +1,145 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n+        char firstSigDigit \u003d 0;\n+        for (int i \u003d pfxLen; i \u003c str.length(); i++) {\n+            firstSigDigit \u003d str.charAt(i);\n+            if (firstSigDigit \u003d\u003d \u00270\u0027) {\n+                pfxLen++;\n+            } else {\n+                break;\n+            }\n+        }\n         final int hexDigits \u003d str.length() - pfxLen;\n-        if (hexDigits \u003e 16) {\n+        if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createBigInteger(str);\n         }\n-        if (hexDigits \u003e 8) {\n+        if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     int numDecimals \u003d 0;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n         numDecimals \u003d dec.length();\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n         if (numDecimals \u003c\u003d 7) {\n             final Float f \u003d createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                 return f;\n             }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     try {\n         if (numDecimals \u003c\u003d 16) {\n             final Double d \u003d createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                 return d;\n             }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a1042959df80c06dbfa83896594caa8e20ff9d6": {
      "type": "Ybodychange",
      "commitMessage": "LANG-693 Method createNumber from NumberUtils doesn\u0027t work for floating point numbers other than Float\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1484263 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/5/19 下午6:22",
      "commitName": "8a1042959df80c06dbfa83896594caa8e20ff9d6",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013/3/28 上午12:29",
      "commitNameOld": "d80be57d6eecc99411a77ab9575e1991bb616abc",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 52.74,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    int numDecimals \u003d 0;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n        numDecimals \u003d dec.length();\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        if (numDecimals \u003c\u003d 7) {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        if (numDecimals \u003c\u003d 16) {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,130 +1,136 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n+    int numDecimals \u003d 0;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n+        numDecimals \u003d dec.length();\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n     if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n         exp \u003d str.substring(expPos + 1, str.length());\n     } else {\n         exp \u003d null;\n     }\n     if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n         try {\n             return createInteger(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         try {\n             return createLong(str);\n         } catch (final NumberFormatException nfe) {\n         }\n         return createBigInteger(str);\n     }\n     final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n     try {\n-        final Float f \u003d createFloat(str);\n-        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n-            return f;\n+        if (numDecimals \u003c\u003d 7) {\n+            final Float f \u003d createFloat(str);\n+            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                return f;\n+            }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     try {\n-        final Double d \u003d createDouble(str);\n-        if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n-            return d;\n+        if (numDecimals \u003c\u003d 16) {\n+            final Double d \u003d createDouble(str);\n+            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                return d;\n+            }\n         }\n     } catch (final NumberFormatException nfe) {\n     }\n     return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d80be57d6eecc99411a77ab9575e1991bb616abc": {
      "type": "Ybodychange",
      "commitMessage": "Document why double exponent (e and E) seems to work even though the index will be wrong\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461697 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/3/28 上午12:29",
      "commitName": "d80be57d6eecc99411a77ab9575e1991bb616abc",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013/3/27 下午11:52",
      "commitNameOld": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        final Double d \u003d createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {}
    },
    "b3db6ed9efd0b8ed8a940f2735abb156030d10f9": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-881 NumberUtils.createNumber() Javadoc says it does not work for octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461671 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/3/27 下午11:52",
      "commitName": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-881 NumberUtils.createNumber() Javadoc says it does not work for octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461671 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2013/3/27 下午11:52",
          "commitName": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2013/3/27 下午9:04",
          "commitNameOld": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 0.12,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        final Double d \u003d createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 450,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-881 NumberUtils.createNumber() Javadoc says it does not work for octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461671 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2013/3/27 下午11:52",
          "commitName": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2013/3/27 下午9:04",
          "commitNameOld": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 0.12,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        final Double d \u003d createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 450,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
            "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\nwill be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\nprefix is more than 8 - or BigInteger if there are more than 16 digits.\n\u003c/p\u003e\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nIntegral values with a leading {@code 0} will be interpreted as octal; the returned number will\nbe Integer, Long or BigDecimal as appropriate.\n\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n"
          }
        }
      ]
    },
    "ad43a49dabd5cc14e8ff4b91dbb03477063c1314": {
      "type": "Ybodychange",
      "commitMessage": "Statements unnecessarily nested within else clauses.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461559 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/3/27 下午9:04",
      "commitName": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/2/21 上午12:47",
      "commitNameOld": "99ff604efaee6c501efa62a910c0284f00761bec",
      "commitAuthorOld": "Thomas Neidhart",
      "daysBetweenCommits": 34.85,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n        exp \u003d str.substring(expPos + 1, str.length());\n    } else {\n        exp \u003d null;\n    }\n    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        }\n        return createBigInteger(str);\n    }\n    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n    try {\n        final Float f \u003d createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    try {\n        final Double d \u003d createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n    }\n    return createBigDecimal(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 446,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,132 +1,130 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     final int decPos \u003d str.indexOf(\u0027.\u0027);\n     final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         final String numeric \u003d str.substring(0, str.length() - 1);\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     final Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     final Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n-    } else {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n-            exp \u003d str.substring(expPos + 1, str.length());\n-        } else {\n-            exp \u003d null;\n-        }\n-        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n-            try {\n-                return createInteger(str);\n-            } catch (final NumberFormatException nfe) {\n-            }\n-            try {\n-                return createLong(str);\n-            } catch (final NumberFormatException nfe) {\n-            }\n-            return createBigInteger(str);\n-        } else {\n-            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n-            try {\n-                final Float f \u003d createFloat(str);\n-                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n-                    return f;\n-                }\n-            } catch (final NumberFormatException nfe) {\n-            }\n-            try {\n-                final Double d \u003d createDouble(str);\n-                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n-                    return d;\n-                }\n-            } catch (final NumberFormatException nfe) {\n-            }\n-            return createBigDecimal(str);\n-        }\n     }\n+    if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+        exp \u003d str.substring(expPos + 1, str.length());\n+    } else {\n+        exp \u003d null;\n+    }\n+    if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n+        try {\n+            return createInteger(str);\n+        } catch (final NumberFormatException nfe) {\n+        }\n+        try {\n+            return createLong(str);\n+        } catch (final NumberFormatException nfe) {\n+        }\n+        return createBigInteger(str);\n+    }\n+    final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+    try {\n+        final Float f \u003d createFloat(str);\n+        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+            return f;\n+        }\n+    } catch (final NumberFormatException nfe) {\n+    }\n+    try {\n+        final Double d \u003d createDouble(str);\n+        if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+            return d;\n+        }\n+    } catch (final NumberFormatException nfe) {\n+    }\n+    return createBigDecimal(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:09",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/1/22 下午3:07",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        final int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos \u003d str.indexOf(\u0027.\u0027);\n    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        final String numeric \u003d str.substring(0, str.length() - 1);\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    final Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    final Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                final Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (final NumberFormatException nfe) {\n            }\n            try {\n                final Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (final NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 446,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,132 +1,132 @@\n public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n-    for (String pfx : hex_prefixes) {\n+    for (final String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n-        int hexDigits \u003d str.length() - pfxLen;\n+        final int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n-    char lastChar \u003d str.charAt(str.length() - 1);\n+    final char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n-    int decPos \u003d str.indexOf(\u0027.\u0027);\n-    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n+    final int decPos \u003d str.indexOf(\u0027.\u0027);\n+    final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n-        String numeric \u003d str.substring(0, str.length() - 1);\n-        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+        final String numeric \u003d str.substring(0, str.length() - 1);\n+        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n-                    } catch (NumberFormatException nfe) {\n+                    } catch (final NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n-                    Float f \u003d NumberUtils.createFloat(numeric);\n+                    final Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) {\n+                } catch (final NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n-                    Double d \u003d NumberUtils.createDouble(numeric);\n+                    final Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n-                } catch (NumberFormatException nfe) {\n+                } catch (final NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n-                } catch (NumberFormatException e) {\n+                } catch (final NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n-            } catch (NumberFormatException nfe) {\n+            } catch (final NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n-            } catch (NumberFormatException nfe) {\n+            } catch (final NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n-            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n-                Float f \u003d createFloat(str);\n+                final Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n-            } catch (NumberFormatException nfe) {\n+            } catch (final NumberFormatException nfe) {\n             }\n             try {\n-                Double d \u003d createDouble(str);\n+                final Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n-            } catch (NumberFormatException nfe) {\n+            } catch (final NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:07",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012/11/13 下午9:21",
      "commitNameOld": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 69.74,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 446,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,132 +1,132 @@\n-public static Number createNumber(String str) throws NumberFormatException {\n+public static Number createNumber(final String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n     int pfxLen \u003d 0;\n     for (String pfx : hex_prefixes) {\n         if (str.startsWith(pfx)) {\n             pfxLen +\u003d pfx.length();\n             break;\n         }\n     }\n     if (pfxLen \u003e 0) {\n         int hexDigits \u003d str.length() - pfxLen;\n         if (hexDigits \u003e 16) {\n             return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[str-String]",
        "newValue": "[str-String(modifiers-final)]"
      }
    },
    "d844d1eb5e5b530a82b77302f1f284fd2f924be3": {
      "type": "Ybodychange",
      "commitMessage": "LANG-854 NumberUtils#createNumber - does not allow for hex numbers to be larger than Long\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1408537 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/11/13 上午9:39",
      "commitName": "d844d1eb5e5b530a82b77302f1f284fd2f924be3",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2012/11/13 上午8:59",
      "commitNameOld": "c1f9320476ab9e5f262fdf8a5b3e1ff70199aed8",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen \u003d 0;\n    for (String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen +\u003d pfx.length();\n            break;\n        }\n    }\n    if (pfxLen \u003e 0) {\n        int hexDigits \u003d str.length() - pfxLen;\n        if (hexDigits \u003e 16) {\n            return createBigInteger(str);\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 445,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,124 +1,132 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n-    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n-        int hexDigits \u003d str.length() - 2;\n-        if (str.startsWith(\"-\")) {\n-            hexDigits--;\n+    final String[] hex_prefixes \u003d { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n+    int pfxLen \u003d 0;\n+    for (String pfx : hex_prefixes) {\n+        if (str.startsWith(pfx)) {\n+            pfxLen +\u003d pfx.length();\n+            break;\n+        }\n+    }\n+    if (pfxLen \u003e 0) {\n+        int hexDigits \u003d str.length() - pfxLen;\n+        if (hexDigits \u003e 16) {\n+            return createBigInteger(str);\n         }\n         if (hexDigits \u003e 8) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "350cf8c2da08ccde6b4d71b19bb3df97256ea368": {
      "type": "Ybodychange",
      "commitMessage": "LANG-822: NumberUtils#createNumber - bad behaviour for leading \"--\" \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1407973 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/11/11 下午9:16",
      "commitName": "350cf8c2da08ccde6b4d71b19bb3df97256ea368",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2012/11/11 下午9:00",
      "commitNameOld": "a7b467a74cbe1160d676dc070a19d19764e132a3",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        int hexDigits \u003d str.length() - 2;\n        if (str.startsWith(\"-\")) {\n            hexDigits--;\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 445,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,127 +1,124 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n-    if (str.startsWith(\"--\")) {\n-        return null;\n-    }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n         int hexDigits \u003d str.length() - 2;\n         if (str.startsWith(\"-\")) {\n             hexDigits--;\n         }\n         if (hexDigits \u003e 8) {\n             return createLong(str);\n         }\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7adc7e86f118a92ac4eee5a3c6775eec11af115": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1384126 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/9/13 上午5:10",
      "commitName": "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1384126 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2012/9/13 上午5:10",
          "commitName": "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2011/11/10 上午12:11",
          "commitNameOld": "163731256b63f03cd2b676baac88fe7ad61b2a6f",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 308.21,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        int hexDigits \u003d str.length() - 2;\n        if (str.startsWith(\"-\")) {\n            hexDigits--;\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 445,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,120 +1,127 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n+        int hexDigits \u003d str.length() - 2;\n+        if (str.startsWith(\"-\")) {\n+            hexDigits--;\n+        }\n+        if (hexDigits \u003e 8) {\n+            return createLong(str);\n+        }\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1384126 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2012/9/13 上午5:10",
          "commitName": "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2011/11/10 上午12:11",
          "commitNameOld": "163731256b63f03cd2b676baac88fe7ad61b2a6f",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 308.21,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        int hexDigits \u003d str.length() - 2;\n        if (str.startsWith(\"-\")) {\n            hexDigits--;\n        }\n        if (hexDigits \u003e 8) {\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 445,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,120 +1,127 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n+        int hexDigits \u003d str.length() - 2;\n+        if (str.startsWith(\"-\")) {\n+            hexDigits--;\n+        }\n+        if (hexDigits \u003e 8) {\n+            return createLong(str);\n+        }\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
            "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\nprefix is more than 8.\nValues with leading \u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eThen, the value is examined for a type qualifier on the end, i.e. one of\n\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e.  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n"
          }
        }
      ]
    },
    "41326bf5266ecc6472bab28481b77cecd6f7fb5c": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-746 NumberUtils does not handle upper-case hex: 0X and -0X\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1160660 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/8/23 下午8:32",
      "commitName": "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-746 NumberUtils does not handle upper-case hex: 0X and -0X\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1160660 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2011/8/23 下午8:32",
          "commitName": "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2011/8/3 下午9:53",
          "commitNameOld": "f5026c122d042e316fe1ee6314de6e8cab2708c5",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 19.94,
          "commitsBetweenForRepo": 67,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 444,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,120 +1,120 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n-    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-746 NumberUtils does not handle upper-case hex: 0X and -0X\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1160660 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2011/8/23 下午8:32",
          "commitName": "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2011/8/3 下午9:53",
          "commitNameOld": "f5026c122d042e316fe1ee6314de6e8cab2708c5",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 19.94,
          "commitsBetweenForRepo": 67,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 444,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,120 +1,120 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n-    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             if (expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
            "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e (lower or upper case), it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string (or null if the input is null)\n@throws NumberFormatException if the value cannot be converted\n"
          }
        }
      ]
    },
    "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c": {
      "type": "Ybodychange",
      "commitMessage": "Adding NOPMD tags for various empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1089736 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/4/7 下午12:39",
      "commitName": "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2011/4/5 下午1:31",
      "commitNameOld": "3a0c152c22b6e96fc809fdee2d6ea5b816a139e6",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 444,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {}
    },
    "50c1fdecb4ed33ec1bb0d449f294c299d5369701": {
      "type": "Ybodychange",
      "commitMessage": "Making it so that NumberUtils.createNumber throws a NumberFormatException instead of a StringIndexOutOfBoundsException when Strings such as 1eE are passed in. Thanks to Ingo Heinrich\u0027s report and patch in LANG-638\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@981736 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/8/3 下午12:41",
      "commitName": "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010/2/25 上午9:28",
      "commitNameOld": "43fca0d7499c99f9e82e0ee2e52b81acdc954f2c",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 159.13,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            if (expPos \u003e str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 452,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,120 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n-            if (expPos \u003c decPos) {\n+            if (expPos \u003c decPos || expPos \u003e str.length()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n+            if (expPos \u003e str.length()) {\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n+            }\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": {
      "type": "Ybodychange",
      "commitMessage": "isNumber(String) and createNumber(String) both modified to support \"2.\". LANG-521\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@893088 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/22 下午2:52",
      "commitName": "26bc3fe010d5154d3ccac526ec22c429fc3af499",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:56",
      "commitNameOld": "c6e8f706dc7a236cc2a49f979d857ee92d0abd7c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,117 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n-    if (!Character.isDigit(lastChar)) {\n+    if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/math/NumberUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "5beb105d6b4188e6babefd89e19b06df1d71886c": {
      "type": "Ybodychange",
      "commitMessage": "Use Eclipse comment-style to suppress drop-thru warning\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@819700 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/9/29 上午4:07",
      "commitName": "5beb105d6b4188e6babefd89e19b06df1d71886c",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2009/6/25 下午3:09",
      "commitNameOld": "f3ac86a292acd3fc57a2100978f3d9d2705238d2",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 95.54,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {}
    },
    "15360774099b2a7230e020751acdf6979b6e3f58": {
      "type": "Ybodychange",
      "commitMessage": "Fixing LANG-300 (reported by Jeremy Lemaire) - 1L to 9L incorrectly throw exceptions when passed into NumberUtils.createNumber. Fixed in both the math.NumbersUtils and the deprecated NumberUtils classes. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488819 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/12/20 上午5:50",
      "commitName": "15360774099b2a7230e020751acdf6979b6e3f58",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006/11/6 下午12:02",
      "commitNameOld": "d8a6e05b5f23458ddd57ad838f43936520689ff7",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 43.74,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,117 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n-                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n+                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "073222372614fcff2f4824d46a817c44e4b03d09": {
      "type": "Ybodychange",
      "commitMessage": "removed empty statement from catch block that takes no action, using comment only to denote no action;\nadded super to empty constructors\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@209373 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/7/6 上午9:15",
      "commitName": "073222372614fcff2f4824d46a817c44e4b03d09",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2005/6/28 上午4:24",
      "commitNameOld": "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 8.2,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,125 +1,117 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n-                        ;\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                    ;\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                    ;\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n-                    ;\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f": {
      "type": "Ybodychange",
      "commitMessage": "added empty statement to empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@202043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/6/28 上午4:24",
      "commitName": "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2005/6/27 上午1:45",
      "commitNameOld": "b73111983b7916b3944e2178d079f1326cd8df06",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        ;\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    ;\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,124 +1,125 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n+                        ;\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     ;\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     ;\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                     ;\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b73111983b7916b3944e2178d079f1326cd8df06": {
      "type": "Ybodychange",
      "commitMessage": "corrected style issues (mostly empty blocks and missing javadocs)\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@201882 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/6/27 上午1:45",
      "commitName": "b73111983b7916b3944e2178d079f1326cd8df06",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2005/4/14 下午12:30",
      "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 73.55,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    ;\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,124 @@\n public static Number createNumber(String str) throws NumberFormatException {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (StringUtils.isBlank(str)) {\n         throw new NumberFormatException(\"A blank string is not a valid number\");\n     }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                    ;\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                    ;\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n+                    ;\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": {
      "type": "Ybodychange",
      "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/9/7 下午10:32",
      "commitName": "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2003/9/5 下午11:55",
      "commitNameOld": "69b8f445d74f22ba99a75c47a38d97d5e85248cc",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 334,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {}
    },
    "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25": {
      "type": "Ybodychange",
      "commitMessage": "Redo null/empty string checking for performance\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137522 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/29 上午5:37",
      "commitName": "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003/7/27 上午3:12",
      "commitNameOld": "3b19309d76817dfacb40299b474ecbc27a471e11",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 220,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,114 +1,117 @@\n public static Number createNumber(String str) throws NumberFormatException {\n-    if (!validateNumber(str)) {\n+    if (str \u003d\u003d null) {\n         return null;\n     }\n+    if (StringUtils.isBlank(str)) {\n+        throw new NumberFormatException(\"A blank string is not a valid number\");\n+    }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b19309d76817dfacb40299b474ecbc27a471e11": {
      "type": "Ybodychange",
      "commitMessage": "Fix http://nagoya.apache.org/bugzilla/show_bug.cgi?id\u003d21904 as suggested (but with the guard clause factored in a method.)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137520 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/27 上午3:12",
      "commitName": "3b19309d76817dfacb40299b474ecbc27a471e11",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2003/7/26 下午11:39",
      "commitNameOld": "9410b31864bc0bddb53779883dfb15763abb5ade",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (!validateNumber(str)) {\n        return null;\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 220,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,114 @@\n public static Number createNumber(String str) throws NumberFormatException {\n-    if (str \u003d\u003d null) {\n+    if (!validateNumber(str)) {\n         return null;\n     }\n-    if (str.length() \u003d\u003d 0) {\n-        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n-    }\n     if (str.startsWith(\"--\")) {\n         return null;\n     }\n     if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n         return createInteger(str);\n     }\n     char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d str.indexOf(\u0027.\u0027);\n     int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d str.substring(decPos + 1);\n         }\n         mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d str.substring(0, expPos);\n         } else {\n             mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af6aba957f4dc4d19d5f295172b4ddc941ca1681": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/21 上午12:03",
      "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/7/21 上午12:03",
          "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/7/15 上午6:25",
          "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 5.73,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
          "functionStartLine": 218,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,117 +1,117 @@\n-public static Number createNumber(String val) throws NumberFormatException {\n-    if (val \u003d\u003d null) {\n+public static Number createNumber(String str) throws NumberFormatException {\n+    if (str \u003d\u003d null) {\n         return null;\n     }\n-    if (val.length() \u003d\u003d 0) {\n+    if (str.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n-    if (val.startsWith(\"--\")) {\n+    if (str.startsWith(\"--\")) {\n         return null;\n     }\n-    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-        return createInteger(val);\n+    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        return createInteger(str);\n     }\n-    char lastChar \u003d val.charAt(val.length() - 1);\n+    char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n-    int decPos \u003d val.indexOf(\u0027.\u0027);\n-    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+    int decPos \u003d str.indexOf(\u0027.\u0027);\n+    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n-            dec \u003d val.substring(decPos + 1, expPos);\n+            dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n-            dec \u003d val.substring(decPos + 1);\n+            dec \u003d str.substring(decPos + 1);\n         }\n-        mant \u003d val.substring(0, decPos);\n+        mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n-            mant \u003d val.substring(0, expPos);\n+            mant \u003d str.substring(0, expPos);\n         } else {\n-            mant \u003d val;\n+            mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-            exp \u003d val.substring(expPos + 1, val.length() - 1);\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n-        String numeric \u003d val.substring(0, val.length() - 1);\n+        String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-            exp \u003d val.substring(expPos + 1, val.length());\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n-                return createInteger(val);\n+                return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n-                return createLong(val);\n+                return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n-            return createBigInteger(val);\n+            return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n-                Float f \u003d createFloat(val);\n+                Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n-                Double d \u003d createDouble(val);\n+                Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n-            return createBigDecimal(val);\n+            return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[val-String]",
            "newValue": "[str-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/7/21 上午12:03",
          "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/7/15 上午6:25",
          "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 5.73,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
          "functionStartLine": 218,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,117 +1,117 @@\n-public static Number createNumber(String val) throws NumberFormatException {\n-    if (val \u003d\u003d null) {\n+public static Number createNumber(String str) throws NumberFormatException {\n+    if (str \u003d\u003d null) {\n         return null;\n     }\n-    if (val.length() \u003d\u003d 0) {\n+    if (str.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n-    if (val.startsWith(\"--\")) {\n+    if (str.startsWith(\"--\")) {\n         return null;\n     }\n-    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-        return createInteger(val);\n+    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        return createInteger(str);\n     }\n-    char lastChar \u003d val.charAt(val.length() - 1);\n+    char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n-    int decPos \u003d val.indexOf(\u0027.\u0027);\n-    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+    int decPos \u003d str.indexOf(\u0027.\u0027);\n+    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n-            dec \u003d val.substring(decPos + 1, expPos);\n+            dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n-            dec \u003d val.substring(decPos + 1);\n+            dec \u003d str.substring(decPos + 1);\n         }\n-        mant \u003d val.substring(0, decPos);\n+        mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n-            mant \u003d val.substring(0, expPos);\n+            mant \u003d str.substring(0, expPos);\n         } else {\n-            mant \u003d val;\n+            mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-            exp \u003d val.substring(expPos + 1, val.length() - 1);\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n-        String numeric \u003d val.substring(0, val.length() - 1);\n+        String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-            exp \u003d val.substring(expPos + 1, val.length());\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n-                return createInteger(val);\n+                return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n-                return createLong(val);\n+                return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n-            return createBigInteger(val);\n+            return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n-                Float f \u003d createFloat(val);\n+                Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n-                Double d \u003d createDouble(val);\n+                Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n-            return createBigDecimal(val);\n+            return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/7/21 上午12:03",
          "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/7/15 上午6:25",
          "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 5.73,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar \u003d str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d str.indexOf(\u0027.\u0027);\n    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec \u003d str.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d str.substring(decPos + 1);\n        }\n        mant \u003d str.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d str.substring(0, expPos);\n        } else {\n            mant \u003d str;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d str.substring(0, str.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
          "functionStartLine": 218,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "@@ -1,117 +1,117 @@\n-public static Number createNumber(String val) throws NumberFormatException {\n-    if (val \u003d\u003d null) {\n+public static Number createNumber(String str) throws NumberFormatException {\n+    if (str \u003d\u003d null) {\n         return null;\n     }\n-    if (val.length() \u003d\u003d 0) {\n+    if (str.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n-    if (val.startsWith(\"--\")) {\n+    if (str.startsWith(\"--\")) {\n         return null;\n     }\n-    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-        return createInteger(val);\n+    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        return createInteger(str);\n     }\n-    char lastChar \u003d val.charAt(val.length() - 1);\n+    char lastChar \u003d str.charAt(str.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n-    int decPos \u003d val.indexOf(\u0027.\u0027);\n-    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+    int decPos \u003d str.indexOf(\u0027.\u0027);\n+    int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n-            dec \u003d val.substring(decPos + 1, expPos);\n+            dec \u003d str.substring(decPos + 1, expPos);\n         } else {\n-            dec \u003d val.substring(decPos + 1);\n+            dec \u003d str.substring(decPos + 1);\n         }\n-        mant \u003d val.substring(0, decPos);\n+        mant \u003d str.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n-            mant \u003d val.substring(0, expPos);\n+            mant \u003d str.substring(0, expPos);\n         } else {\n-            mant \u003d val;\n+            mant \u003d str;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-            exp \u003d val.substring(expPos + 1, val.length() - 1);\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n-        String numeric \u003d val.substring(0, val.length() - 1);\n+        String numeric \u003d str.substring(0, str.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n-                throw new NumberFormatException(val + \" is not a valid number.\");\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     } else {\n-        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-            exp \u003d val.substring(expPos + 1, val.length());\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n-                return createInteger(val);\n+                return createInteger(str);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n-                return createLong(val);\n+                return createLong(str);\n             } catch (NumberFormatException nfe) {\n             }\n-            return createBigInteger(val);\n+            return createBigInteger(str);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n-                Float f \u003d createFloat(val);\n+                Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n-                Double d \u003d createDouble(val);\n+                Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n-            return createBigDecimal(val);\n+            return createBigDecimal(str);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
            "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can represent the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if the string is \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis method does not trim the input string, i.e., strings with leading\nor trailing spaces will generate NumberFormatExceptions.\u003c/p\u003e\n\n@param str String containing a number, may be null\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n"
          }
        }
      ]
    },
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": {
      "type": "Yintroduced",
      "commitMessage": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/6/25 上午5:14",
      "commitName": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,117 @@\n+public static Number createNumber(String val) throws NumberFormatException {\n+    if (val \u003d\u003d null) {\n+        return null;\n+    }\n+    if (val.length() \u003d\u003d 0) {\n+        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+    }\n+    if (val.startsWith(\"--\")) {\n+        return null;\n+    }\n+    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n+        return createInteger(val);\n+    }\n+    char lastChar \u003d val.charAt(val.length() - 1);\n+    String mant;\n+    String dec;\n+    String exp;\n+    int decPos \u003d val.indexOf(\u0027.\u0027);\n+    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+    if (decPos \u003e -1) {\n+        if (expPos \u003e -1) {\n+            if (expPos \u003c decPos) {\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            }\n+            dec \u003d val.substring(decPos + 1, expPos);\n+        } else {\n+            dec \u003d val.substring(decPos + 1);\n+        }\n+        mant \u003d val.substring(0, decPos);\n+    } else {\n+        if (expPos \u003e -1) {\n+            mant \u003d val.substring(0, expPos);\n+        } else {\n+            mant \u003d val;\n+        }\n+        dec \u003d null;\n+    }\n+    if (!Character.isDigit(lastChar)) {\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n+            exp \u003d val.substring(expPos + 1, val.length() - 1);\n+        } else {\n+            exp \u003d null;\n+        }\n+        String numeric \u003d val.substring(0, val.length() - 1);\n+        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+        switch(lastChar) {\n+            case \u0027l\u0027:\n+            case \u0027L\u0027:\n+                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n+                    try {\n+                        return createLong(numeric);\n+                    } catch (NumberFormatException nfe) {\n+                    }\n+                    return createBigInteger(numeric);\n+                }\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            case \u0027f\u0027:\n+            case \u0027F\u0027:\n+                try {\n+                    Float f \u003d NumberUtils.createFloat(numeric);\n+                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+            case \u0027d\u0027:\n+            case \u0027D\u0027:\n+                try {\n+                    Double d \u003d NumberUtils.createDouble(numeric);\n+                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+                try {\n+                    return createBigDecimal(numeric);\n+                } catch (NumberFormatException e) {\n+                }\n+            default:\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+        }\n+    } else {\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n+            exp \u003d val.substring(expPos + 1, val.length());\n+        } else {\n+            exp \u003d null;\n+        }\n+        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n+            try {\n+                return createInteger(val);\n+            } catch (NumberFormatException nfe) {\n+            }\n+            try {\n+                return createLong(val);\n+            } catch (NumberFormatException nfe) {\n+            }\n+            return createBigInteger(val);\n+        } else {\n+            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+            try {\n+                Float f \u003d createFloat(val);\n+                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                    return f;\n+                }\n+            } catch (NumberFormatException nfe) {\n+            }\n+            try {\n+                Double d \u003d createDouble(val);\n+                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                    return d;\n+                }\n+            } catch (NumberFormatException nfe) {\n+            }\n+            return createBigDecimal(val);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 206,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n"
    }
  }
}