{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "RebaseCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
  "functionAnnotation": "@Override",
  "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n",
  "functionStartLine": 263,
  "functionEndLine": 379,
  "numCommitsSeen": 85,
  "timeTaken": 3294,
  "changeHistory": [
    "26c5d0e56a8c5adb2c93cda45e25175363798516",
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
    "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
    "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b",
    "f86a488e32906593903acb31a93a82bed8d87915",
    "591998c2d628ec4f6309caea826fab16a6de2adc",
    "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
    "979e3467112618cc787e161097986212eaaa4533",
    "18069ffe8cbede40cf2524922c262b67656e7021",
    "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
    "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
    "da9db6b20c6203dae3f828adbd14218ea063ad91",
    "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
    "60e01cff2f763a85ed24a706d26eb9f159ffa832",
    "0e9f1cf57dac274f92a6db38197e14b55b3277af",
    "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9",
    "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
    "84fb2b59d11418d2fa753d27de11775ddc18adde",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8",
    "b61d35e848e637ef85fde4ebe95d60ced171e963",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "edc1fee033a23189742cea1807d8029d1b77da00",
    "557ea857e3b5229379476f1ee4160fcf5b695bbd",
    "0b5ad24915824a8c999bb6951b131a958e418306",
    "a21e508a318664dac23701ca29d5f0b64d36a76a",
    "e8a1328d05aa55b7ace0d101e34b87422219c959",
    "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2",
    "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
    "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
    "45731756a56361a51e839e26d3b0bed1c06ee37a",
    "ad96546ca023c260ed7250c447f4c8abe168afd3",
    "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
    "e5b96a7848d680cf50123a44cbc147db91d798d3"
  ],
  "changeHistoryShort": {
    "26c5d0e56a8c5adb2c93cda45e25175363798516": "Ybodychange",
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": "Ydocchange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": "Yannotationchange",
    "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070": "Ybodychange",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": "Ybodychange",
    "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b": "Ybodychange",
    "f86a488e32906593903acb31a93a82bed8d87915": "Ybodychange",
    "591998c2d628ec4f6309caea826fab16a6de2adc": "Ybodychange",
    "ec0d78d0939ee8ce30bd349bd885186c13d3b645": "Ybodychange",
    "979e3467112618cc787e161097986212eaaa4533": "Ybodychange",
    "18069ffe8cbede40cf2524922c262b67656e7021": "Ybodychange",
    "cce2561e9fe2ce1cf60182f9d95c8537ce13de92": "Ybodychange",
    "765896febb4b63cfe2c37dc0a73c90c79dd1591b": "Ybodychange",
    "da9db6b20c6203dae3f828adbd14218ea063ad91": "Ybodychange",
    "c3873b584f81bc5be3fdea53e9e0e76271a9a854": "Ybodychange",
    "60e01cff2f763a85ed24a706d26eb9f159ffa832": "Ybodychange",
    "0e9f1cf57dac274f92a6db38197e14b55b3277af": "Ybodychange",
    "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9": "Ybodychange",
    "8eb4d926371edea2d58dc598e3ebcddacbdc326e": "Ybodychange",
    "84fb2b59d11418d2fa753d27de11775ddc18adde": "Ybodychange",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": "Ybodychange",
    "b61d35e848e637ef85fde4ebe95d60ced171e963": "Ymultichange(Yexceptionschange,Ydocchange)",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Yexceptionschange",
    "edc1fee033a23189742cea1807d8029d1b77da00": "Ybodychange",
    "557ea857e3b5229379476f1ee4160fcf5b695bbd": "Ybodychange",
    "0b5ad24915824a8c999bb6951b131a958e418306": "Ybodychange",
    "a21e508a318664dac23701ca29d5f0b64d36a76a": "Ybodychange",
    "e8a1328d05aa55b7ace0d101e34b87422219c959": "Ybodychange",
    "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2": "Ybodychange",
    "2a7cd0086bf1bd614478c5722eac5142326e6f2b": "Ybodychange",
    "6bca46e1683a07f18f00f6ad552eab79ab50bb88": "Ybodychange",
    "45731756a56361a51e839e26d3b0bed1c06ee37a": "Ybodychange",
    "ad96546ca023c260ed7250c447f4c8abe168afd3": "Ybodychange",
    "59e62ba7e10188c6170bd97ffbd9c8768d9745ea": "Ybodychange",
    "e5b96a7848d680cf50123a44cbc147db91d798d3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "26c5d0e56a8c5adb2c93cda45e25175363798516": {
      "type": "Ybodychange",
      "commitMessage": "RebaseCommand: Remove unnecessary fall through comments\n\nIt\u0027s easier to read a list of cases\n\n\tcase A:\n\tcase B:\n\tcase C:\n\t\t... do something ...;\n\t\tbreak;\n\nwithout intervening \"// fall through\" lines separating the cases.\n\nThis also makes it clearer that JGit uses \"$FALL-THROUGH$\", not \"fall\nthrough\", to suppress fallthrough warnings in switch statements.\nEclipse does not pay attention to the second comment style.\n\nChange-Id: I5279a727aee2868854d06bfcaac8cb8186b4299e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2018/8/5 上午5:04",
      "commitName": "26c5d0e56a8c5adb2c93cda45e25175363798516",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2018/3/14 上午5:16",
      "commitNameOld": "5c70be00856d5375485e6f062b6e1e09a606601f",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 143.99,
      "commitsBetweenForRepo": 211,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 263,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit annotations and api packages\n\nChange-Id: I2761ea91f8dfed16ea54e7a6646af03a30c15ec9\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/18 下午5:45",
      "commitName": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/9/30 下午7:01",
      "commitNameOld": "2bbe15abd412d62a6d5a9ccddda73920943cb6f0",
      "commitAuthorOld": "Dave Borowitz",
      "daysBetweenCommits": 78.95,
      "commitsBetweenForRepo": 135,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 263,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
        "newValue": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n"
      }
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/21 上午5:47",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/20 上午8:05",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 262,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,93 +1,93 @@\n @Override\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                 break;\n             case BEGIN:\n                 autoStash();\n                 if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                     org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                     if (status.hasUncommittedChanges()) {\n-                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n+                        List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n                         list.addAll(status.getUncommittedChanges());\n                         return RebaseResult.uncommittedChanges(list);\n                     }\n                 }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null) {\n                     autoStashApply();\n                     if (rebaseState.getDir().exists())\n                         FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                     return res;\n                 }\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": {
      "type": "Yannotationchange",
      "commitMessage": "Enable and fix \u0027Should be tagged with @Override\u0027 warning\n\nSet missingOverrideAnnotation\u003dwarning in Eclipse compiler preferences\nwhich enables the warning:\n\n  The method \u003cmethod\u003e of type \u003ctype\u003e should be tagged with @Override\n  since it actually overrides a superclass method\n\nJustification for this warning is described in:\n\n  http://stackoverflow.com/a/94411/381622\n\nEnabling this causes in excess of 1000 warnings across the entire\ncode-base. They are very easy to fix automatically with Eclipse\u0027s\n\"Quick Fix\" tool.\n\nFix all of them except 2 which cause compilation failure when the\nproject is built with mvn; add TODO comments on those for further\ninvestigation.\n\nChange-Id: I5772061041fd361fe93137fd8b0ad356e748a29c\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/20 上午8:05",
      "commitName": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2016/12/18 下午5:38",
      "commitNameOld": "82344bd7a234de3cb7fd3358d2ba355adb484181",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 63.6,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 262,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,92 +1,93 @@\n+@Override\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                 break;\n             case BEGIN:\n                 autoStash();\n                 if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                     org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                     if (status.hasUncommittedChanges()) {\n                         List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                         list.addAll(status.getUncommittedChanges());\n                         return RebaseResult.uncommittedChanges(list);\n                     }\n                 }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null) {\n                     autoStashApply();\n                     if (rebaseState.getDir().exists())\n                         FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                     return res;\n                 }\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070": {
      "type": "Ybodychange",
      "commitMessage": "RebaseCommand should ignore submodule modifications\n\nBefore a rebase happens the RebaseCommand checks that the working tree\nis clean. We don\u0027t want to start a rebase on a dirty working tree. If\nthe working tree is dirty a rebase should not be allowed. But\nRebaseCommand should ignore modifications done to submodules. E.g. if a\nsubmodules HEAD points to \u003cx\u003e but the root repository has in index that\nthe submodule should point to \u003cy\u003e then this should not prohibit a\nrebase. Also native git allows a rebase in this case. Since jgit\u0027s\nStatusCommand has learned to ignore submodule changes this is now used\nby the RebaseCommand to determine the repository state correctly.\n\nBug: 446922\nChange-Id: I487bf7484dca3f5501e6e514584e2871524eea19\n",
      "commitDate": "2014/11/3 下午5:32",
      "commitName": "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2014/9/4 下午5:35",
      "commitNameOld": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 60.0,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 260,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,92 +1,92 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                 break;\n             case BEGIN:\n                 autoStash();\n                 if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n-                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n+                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                     if (status.hasUncommittedChanges()) {\n                         List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                         list.addAll(status.getUncommittedChanges());\n                         return RebaseResult.uncommittedChanges(list);\n                     }\n                 }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null) {\n                     autoStashApply();\n                     if (rebaseState.getDir().exists())\n                         FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                     return res;\n                 }\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: Add --preserve-merges support\n\nWith --preserve-merges C Git re-does merges using the rewritten merge\nparents, discarding the old merge commit. For the common use-case of\npull with rebase this is unfortunate, as it loses the merge conflict\nresolution (and other fixes in the merge), which may have taken quite\nsome time to get right in the first place.\n\nTo overcome this we use a two-fold approach:\nIf any of the (non-first) merge parents of a merge were rewritten, we\nalso redo the merge, to include the (potential) new changes in those\ncommits.\nIf only the first parent was rewritten, i.e. we are merging a branch\nthat is otherwise unaffected by the rebase, we instead cherry-pick the\nmerge commit at hand. This is done with the --mainline 1 and --no-commit\noptions to apply the changes introduced by the merge. Then we set up an\nappropriate MERGE_HEAD and commit the result, thus effectively forging a\nmerge.\n\nApart from the approach taken to rebase merge commits, this\nimplementation closely follows C Git. As a result, both Git\nimplementations can continue rebases of each other.\n\nPreserving merges works for both interactive and non-interactive rebase,\nbut as in C Git it is easy do get undesired outcomes with interactive\nrebase.\n\nCommitCommand supports committing merges during rebase now.\n\nBug: 439421\nChange-Id: I4cf69b9d4ec6109d130ab8e3f42fcbdac25a13b2\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\n",
      "commitDate": "2014/7/16 上午7:00",
      "commitName": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
      "commitAuthor": "Konrad Kügler",
      "commitDateOld": "2014/5/16 下午3:01",
      "commitNameOld": "1350d27e904f7e016dd33cff01686e527b0d26ad",
      "commitAuthorOld": "Konrad Kügler",
      "daysBetweenCommits": 60.67,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 259,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,91 +1,92 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n+                preserveMerges \u003d rebaseState.getRewrittenDir().exists();\n                 break;\n             case BEGIN:\n                 autoStash();\n                 if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                     org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                     if (status.hasUncommittedChanges()) {\n                         List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                         list.addAll(status.getUncommittedChanges());\n                         return RebaseResult.uncommittedChanges(list);\n                     }\n                 }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null) {\n                     autoStashApply();\n                     if (rebaseState.getDir().exists())\n                         FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                     return res;\n                 }\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b": {
      "type": "Ybodychange",
      "commitMessage": "Fix fast forward rebase with rebase.autostash\u003dtrue\n\nThe folder .git/rebase-merge was not removed in this case. The\nrepository was then still in rebase state, but neither abort nor\ncontinue worked.\n\nBug: 425742\nChange-Id: I43cea6c9e5f3cef9d6b15643722fddecb40632d9\n",
      "commitDate": "2014/1/15 下午8:23",
      "commitName": "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/12/10 下午10:54",
      "commitNameOld": "e90438c0e867bd105334b75df3a6d640ef8dab01",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 35.9,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,89 +1,91 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 autoStash();\n                 if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                     org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                     if (status.hasUncommittedChanges()) {\n                         List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                         list.addAll(status.getUncommittedChanges());\n                         return RebaseResult.uncommittedChanges(list);\n                     }\n                 }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null) {\n                     autoStashApply();\n+                    if (rebaseState.getDir().exists())\n+                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                     return res;\n                 }\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f86a488e32906593903acb31a93a82bed8d87915": {
      "type": "Ybodychange",
      "commitMessage": "Implement rebase.autostash\n\nThis feature was introduced in native git with version 1.8.4.\n\nBug: 422951\nChange-Id: I42f194174d64d7ada6631e2156c2a7bf93b5e91c\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013/12/5 上午5:02",
      "commitName": "f86a488e32906593903acb31a93a82bed8d87915",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/12/2 下午4:45",
      "commitNameOld": "591998c2d628ec4f6309caea826fab16a6de2adc",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 2.51,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null) {\n                    autoStashApply();\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,86 +1,89 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n+                autoStash();\n                 if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                     org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                     if (status.hasUncommittedChanges()) {\n                         List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                         list.addAll(status.getUncommittedChanges());\n                         return RebaseResult.uncommittedChanges(list);\n                     }\n                 }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n-                if (res !\u003d null)\n+                if (res !\u003d null) {\n+                    autoStashApply();\n                     return res;\n+                }\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "591998c2d628ec4f6309caea826fab16a6de2adc": {
      "type": "Ybodychange",
      "commitMessage": "Do not allow non-ff-rebase if there are uncommitted changes\n\nWith this change jgit checks for uncommitted changes before a rebase is\nstarted. This is also done by native git. One reason is that an abort\nwould override such changes. The check is skipped for a non-interactive\nrebase when it will result in a fast-forward. In this case there can be\nonly checkout conflicts but no merge conflicts, so there cannot be an\nabort which overrides uncommitted changes.\n\nBug: 422352\nChange-Id: I1e0b59b2a4d80a686b67a6729e441924362b1236\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013/12/2 下午4:45",
      "commitName": "591998c2d628ec4f6309caea826fab16a6de2adc",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/11/29 下午4:34",
      "commitNameOld": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 229,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,78 +1,86 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n+                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n+                    org.eclipse.jgit.api.Status status \u003d Git.wrap(repo).status().call();\n+                    if (status.hasUncommittedChanges()) {\n+                        List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n+                        list.addAll(status.getUncommittedChanges());\n+                        return RebaseResult.uncommittedChanges(list);\n+                    }\n+                }\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec0d78d0939ee8ce30bd349bd885186c13d3b645": {
      "type": "Ybodychange",
      "commitMessage": "Use static factory methods instead of overloaded constructors\n\nChange-Id: Ib10e0798dcfb9f1b611caec393926c95eff4c2a2\n",
      "commitDate": "2013/11/29 下午4:34",
      "commitName": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/11/23 上午5:50",
      "commitNameOld": "8339a07e8314d6a40e15252bcc736a46c0aca0ea",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 6.45,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 229,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,78 +1,78 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     newHead \u003d null;\n     lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n             RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n             if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                 RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                 RebaseResult result \u003d processStep(newStep, false);\n                 if (result !\u003d null)\n                     return result;\n             }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             RebaseResult result \u003d processStep(step, true);\n             if (result !\u003d null) {\n                 return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n-        return new RebaseResult(cce.getConflictingPaths());\n+        return RebaseResult.conflicts(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "979e3467112618cc787e161097986212eaaa4533": {
      "type": "Ybodychange",
      "commitMessage": "Interactive Rebase: Do actions if there were conflicts\n\nIf a commit was marked for edit, reword, squash or fixup, but the\ninteractive rebase stopped because of a conflict, the step was not done\nafter conflict resolution. This is done now.\n\nChange-Id: If8e7ccc50469165744f2b8a53d180f9ba0f72330\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013/11/9 上午6:43",
      "commitName": "979e3467112618cc787e161097986212eaaa4533",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/11/6 下午4:43",
      "commitNameOld": "18069ffe8cbede40cf2524922c262b67656e7021",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead \u003d null;\n    lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result \u003d processStep(newStep, false);\n                if (result !\u003d null)\n                    return result;\n            }\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            RebaseResult result \u003d processStep(step, true);\n            if (result !\u003d null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 228,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,122 +1,78 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n-    RevCommit newHead \u003d null;\n-    boolean lastStepWasForward \u003d false;\n+    newHead \u003d null;\n+    lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n+            List\u003cRebaseTodoLine\u003e doneLines \u003d repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n+            RebaseTodoLine step \u003d doneLines.get(doneLines.size() - 1);\n+            if (newHead !\u003d null \u0026\u0026 step.getAction() !\u003d Action.PICK) {\n+                RebaseTodoLine newStep \u003d new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n+                RebaseResult result \u003d processStep(newStep, false);\n+                if (result !\u003d null)\n+                    return result;\n+            }\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n-        ObjectReader or \u003d repo.newObjectReader();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (steps.size() \u003d\u003d 0) {\n             return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n         }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n-            if (Action.COMMENT.equals(step.getAction()))\n-                continue;\n-            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n-            if (ids.size() !\u003d 1)\n-                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n-            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n-            if (monitor.isCancelled())\n-                return new RebaseResult(commitToPick, Status.STOPPED);\n-            try {\n-                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n-                newHead \u003d tryFastForward(commitToPick);\n-                lastStepWasForward \u003d newHead !\u003d null;\n-                if (!lastStepWasForward) {\n-                    String ourCommitName \u003d getOurCommitName();\n-                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n-                    switch(cherryPickResult.getStatus()) {\n-                        case FAILED:\n-                            if (operation \u003d\u003d Operation.BEGIN)\n-                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n-                            else\n-                                return stop(commitToPick, Status.STOPPED);\n-                        case CONFLICTING:\n-                            return stop(commitToPick, Status.STOPPED);\n-                        case OK:\n-                            newHead \u003d cherryPickResult.getNewHead();\n-                    }\n-                }\n-                boolean isSquash \u003d false;\n-                switch(step.getAction()) {\n-                    case PICK:\n-                        continue;\n-                    case REWORD:\n-                        String oldMessage \u003d commitToPick.getFullMessage();\n-                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n-                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n-                        continue;\n-                    case EDIT:\n-                        rebaseState.createFile(AMEND, commitToPick.name());\n-                        return stop(commitToPick, Status.EDIT);\n-                    case COMMENT:\n-                        break;\n-                    case SQUASH:\n-                        isSquash \u003d true;\n-                    case FIXUP:\n-                        resetSoftToParent();\n-                        RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n-                        File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n-                        File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n-                        if (isSquash \u0026\u0026 messageFixupFile.exists())\n-                            messageFixupFile.delete();\n-                        newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n-                }\n-            } finally {\n-                monitor.endTask();\n+            RebaseResult result \u003d processStep(step, true);\n+            if (result !\u003d null) {\n+                return result;\n             }\n         }\n         return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "18069ffe8cbede40cf2524922c262b67656e7021": {
      "type": "Ybodychange",
      "commitMessage": "Rebase interactive should finish if last step is edit\n\nWhen the last step was an edit step, rebase interactive did not finish\nafter continuing the rebase. Instead, it returned with the status\nFAST_FORWARD.\n\nChange-Id: Ib19857474ac089dfeaae665ad5e95c66c21099b0\n",
      "commitDate": "2013/11/6 下午4:43",
      "commitName": "18069ffe8cbede40cf2524922c262b67656e7021",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/11/6 上午1:05",
      "commitNameOld": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() \u003d\u003d 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick, Status.STOPPED);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick, Status.STOPPED);\n                        case CONFLICTING:\n                            return stop(commitToPick, Status.STOPPED);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                boolean isSquash \u003d false;\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick, Status.EDIT);\n                    case COMMENT:\n                        break;\n                    case SQUASH:\n                        isSquash \u003d true;\n                    case FIXUP:\n                        resetSoftToParent();\n                        RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n                        File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n                        File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n                        if (isSquash \u0026\u0026 messageFixupFile.exists())\n                            messageFixupFile.delete();\n                        newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,127 +1,122 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n+        if (steps.size() \u003d\u003d 0) {\n+            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n+        }\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             if (Action.COMMENT.equals(step.getAction()))\n                 continue;\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick, Status.STOPPED);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick, Status.STOPPED);\n                         case CONFLICTING:\n                             return stop(commitToPick, Status.STOPPED);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 boolean isSquash \u003d false;\n                 switch(step.getAction()) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         rebaseState.createFile(AMEND, commitToPick.name());\n                         return stop(commitToPick, Status.EDIT);\n                     case COMMENT:\n                         break;\n                     case SQUASH:\n                         isSquash \u003d true;\n                     case FIXUP:\n                         resetSoftToParent();\n                         RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n                         File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n                         File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n                         if (isSquash \u0026\u0026 messageFixupFile.exists())\n                             messageFixupFile.delete();\n                         newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n-        if (newHead !\u003d null) {\n-            String headName \u003d rebaseState.readFile(HEAD_NAME);\n-            updateHead(headName, newHead, upstreamCommit);\n-            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n-            if (lastStepWasForward)\n-                return RebaseResult.FAST_FORWARD_RESULT;\n-            return RebaseResult.OK_RESULT;\n-        }\n-        return RebaseResult.FAST_FORWARD_RESULT;\n+        return finishRebase(newHead, lastStepWasForward);\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cce2561e9fe2ce1cf60182f9d95c8537ce13de92": {
      "type": "Ybodychange",
      "commitMessage": "Add additional RebaseResult for editing commits\n\nWith the new RebaseResult.EDIT a client can now distinguish if rebase\nstopped due to a conflict or because the commit was marked for edit in\nan interactive rebase.\n\nChange-Id: I40f2311cf43ed5f290dcda65a7bd85ba770a85f5\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2013/11/6 上午1:05",
      "commitName": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2013/11/6 上午1:05",
      "commitNameOld": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
      "commitAuthorOld": "Tobias Pfeifer",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick, Status.STOPPED);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick, Status.STOPPED);\n                        case CONFLICTING:\n                            return stop(commitToPick, Status.STOPPED);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                boolean isSquash \u003d false;\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick, Status.EDIT);\n                    case COMMENT:\n                        break;\n                    case SQUASH:\n                        isSquash \u003d true;\n                    case FIXUP:\n                        resetSoftToParent();\n                        RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n                        File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n                        File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n                        if (isSquash \u0026\u0026 messageFixupFile.exists())\n                            messageFixupFile.delete();\n                        newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,127 +1,127 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         checkSteps(steps);\n         for (int i \u003d 0; i \u003c steps.size(); i++) {\n             RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             if (Action.COMMENT.equals(step.getAction()))\n                 continue;\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n-                return new RebaseResult(commitToPick);\n+                return new RebaseResult(commitToPick, Status.STOPPED);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n-                                return stop(commitToPick);\n+                                return stop(commitToPick, Status.STOPPED);\n                         case CONFLICTING:\n-                            return stop(commitToPick);\n+                            return stop(commitToPick, Status.STOPPED);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 boolean isSquash \u003d false;\n                 switch(step.getAction()) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         rebaseState.createFile(AMEND, commitToPick.name());\n-                        return stop(commitToPick);\n+                        return stop(commitToPick, Status.EDIT);\n                     case COMMENT:\n                         break;\n                     case SQUASH:\n                         isSquash \u003d true;\n                     case FIXUP:\n                         resetSoftToParent();\n                         RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n                         File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n                         File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n                         if (isSquash \u0026\u0026 messageFixupFile.exists())\n                             messageFixupFile.delete();\n                         newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d rebaseState.readFile(HEAD_NAME);\n             updateHead(headName, newHead, upstreamCommit);\n             FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "765896febb4b63cfe2c37dc0a73c90c79dd1591b": {
      "type": "Ybodychange",
      "commitMessage": "Add Squash/Fixup support for rebase interactive in RebaseCommand\n\nThe rebase command now supports squash and fixup. Both actions are not\nallowed as the first step of the rebase.\n\nIn JGit, before any rebase step is performed, the next commit is\nalready cherry-picked. This commit keeps that behaviour. In case of\nsquash or fixup a soft reset to the parent is perfomed afterwards.\n\nCQ: 7684\nBug: 396510\nChange-Id: I3c4190940b4d7f19860e223d647fc78705e57203\nSigned-off-by: Tobias Pfeifer \u003cto.pfeifer@web.de\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013/11/6 上午1:05",
      "commitName": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
      "commitAuthor": "Tobias Pfeifer",
      "commitDateOld": "2013/11/2 上午6:43",
      "commitNameOld": "da9db6b20c6203dae3f828adbd14218ea063ad91",
      "commitAuthorOld": "Tobias Pfeifer",
      "daysBetweenCommits": 3.76,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i \u003d 0; i \u003c steps.size(); i++) {\n            RebaseTodoLine step \u003d steps.get(i);\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                boolean isSquash \u003d false;\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                    case COMMENT:\n                        break;\n                    case SQUASH:\n                        isSquash \u003d true;\n                    case FIXUP:\n                        resetSoftToParent();\n                        RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n                        File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n                        File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n                        if (isSquash \u0026\u0026 messageFixupFile.exists())\n                            messageFixupFile.delete();\n                        newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,114 +1,127 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (stopAfterInitialization)\n                     return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n-        for (RebaseTodoLine step : steps) {\n+        checkSteps(steps);\n+        for (int i \u003d 0; i \u003c steps.size(); i++) {\n+            RebaseTodoLine step \u003d steps.get(i);\n             popSteps(1);\n             if (Action.COMMENT.equals(step.getAction()))\n                 continue;\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n+                boolean isSquash \u003d false;\n                 switch(step.getAction()) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         rebaseState.createFile(AMEND, commitToPick.name());\n                         return stop(commitToPick);\n                     case COMMENT:\n                         break;\n+                    case SQUASH:\n+                        isSquash \u003d true;\n+                    case FIXUP:\n+                        resetSoftToParent();\n+                        RebaseTodoLine nextStep \u003d (i \u003e\u003d steps.size() - 1 ? null : steps.get(i + 1));\n+                        File messageFixupFile \u003d rebaseState.getFile(MESSAGE_FIXUP);\n+                        File messageSquashFile \u003d rebaseState.getFile(MESSAGE_SQUASH);\n+                        if (isSquash \u0026\u0026 messageFixupFile.exists())\n+                            messageFixupFile.delete();\n+                        newHead \u003d doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d rebaseState.readFile(HEAD_NAME);\n             updateHead(headName, newHead, upstreamCommit);\n             FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da9db6b20c6203dae3f828adbd14218ea063ad91": {
      "type": "Ybodychange",
      "commitMessage": "Enable to prepare interactive rebase and then start it explicitly\n\nAdd Operation.PROCESS_STEPS to RebaseCommand to enable starting\ninteractive rebase explicitly after rebase steps have been configured.\n\nChange-Id: I2d6f0de82010ea6523fbce6fb4501e847bdcdddc\nSigned-off-by: Tobias Pfeifer \u003cto.pfeifer@web.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013/11/2 上午6:43",
      "commitName": "da9db6b20c6203dae3f828adbd14218ea063ad91",
      "commitAuthor": "Tobias Pfeifer",
      "commitDateOld": "2013/10/31 下午9:22",
      "commitNameOld": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 1.39,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        for (RebaseTodoLine step : steps) {\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                    case COMMENT:\n                        break;\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,111 +1,114 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n+            case PROCESS_STEPS:\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n+                if (stopAfterInitialization)\n+                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n         for (RebaseTodoLine step : steps) {\n             popSteps(1);\n             if (Action.COMMENT.equals(step.getAction()))\n                 continue;\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 switch(step.getAction()) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         rebaseState.createFile(AMEND, commitToPick.name());\n                         return stop(commitToPick);\n                     case COMMENT:\n                         break;\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d rebaseState.readFile(HEAD_NAME);\n             updateHead(headName, newHead, upstreamCommit);\n             FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3873b584f81bc5be3fdea53e9e0e76271a9a854": {
      "type": "Ybodychange",
      "commitMessage": "Enhance reading of git-rebase-todo formatted files\n\nReading and writing files formatted like the git-rebase-todo files was\nhidden in the RebaseCommand. Certain constructs (like leading tabs and\nspaces) have not been handled as in native git. Also the upcoming\nrebase interactive feature in EGit needs reading/writing these files\nindependently from a RebaseCommand.\n\nTherefore reading and writing those files has been moved to the\nRepository class. RebaseCommand gets smaller because of that and doesn\u0027t\nhave to deal with reading/writing files.\n\nAdditional tests for empty todo-list files, or files containing comments\nhave been added.\n\nChange-Id: I323f3619952fecdf28ddf50139a88e0bea34f5ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nAlso-by: Tobias Pfeifer \u003cto.pfeifer@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013/10/31 下午9:22",
      "commitName": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2013/9/30 上午4:17",
      "commitNameOld": "c6aba99668eab76c1b05e021719f8ef9a69c3ae9",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 31.71,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        for (RebaseTodoLine step : steps) {\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                    case COMMENT:\n                        break;\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 207,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,123 +1,111 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n-        List\u003cStep\u003e steps \u003d loadSteps();\n+        List\u003cRebaseTodoLine\u003e steps \u003d repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n-            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n-            fw.newLine();\n-            try {\n-                StringBuilder sb \u003d new StringBuilder();\n-                for (Step step : steps) {\n-                    sb.setLength(0);\n-                    sb.append(step.action.token);\n-                    sb.append(\" \");\n-                    sb.append(step.commit.name());\n-                    sb.append(\" \");\n-                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n-                    fw.write(sb.toString());\n-                    fw.newLine();\n-                }\n-            } finally {\n-                fw.close();\n-            }\n+            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n         }\n-        for (Step step : steps) {\n+        for (RebaseTodoLine step : steps) {\n             popSteps(1);\n-            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n+            if (Action.COMMENT.equals(step.getAction()))\n+                continue;\n+            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.getCommit());\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n-                switch(step.action) {\n+                switch(step.getAction()) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         rebaseState.createFile(AMEND, commitToPick.name());\n                         return stop(commitToPick);\n+                    case COMMENT:\n+                        break;\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d rebaseState.readFile(HEAD_NAME);\n             updateHead(headName, newHead, upstreamCommit);\n             FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60e01cff2f763a85ed24a706d26eb9f159ffa832": {
      "type": "Ybodychange",
      "commitMessage": "Update reflog like C Git during rebase (non-interactive)\n\nBug: 346350\nChange-Id: I119766a00bc52a810c51cffaa19207cb8555ca22\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2013/7/22 上午10:54",
      "commitName": "60e01cff2f763a85ed24a706d26eb9f159ffa832",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/3/17 上午6:32",
      "commitNameOld": "44ea46dd40d2411dfc615c14db92786730d977be",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 127.18,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 210,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,123 +1,123 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n                     upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n             fw.newLine();\n             try {\n                 StringBuilder sb \u003d new StringBuilder();\n                 for (Step step : steps) {\n                     sb.setLength(0);\n                     sb.append(step.action.token);\n                     sb.append(\" \");\n                     sb.append(step.commit.name());\n                     sb.append(\" \");\n                     sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                     fw.write(sb.toString());\n                     fw.newLine();\n                 }\n             } finally {\n                 fw.close();\n             }\n         }\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n-                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n+                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 switch(step.action) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         rebaseState.createFile(AMEND, commitToPick.name());\n                         return stop(commitToPick);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d rebaseState.readFile(HEAD_NAME);\n-            updateHead(headName, newHead);\n+            updateHead(headName, newHead, upstreamCommit);\n             FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e9f1cf57dac274f92a6db38197e14b55b3277af": {
      "type": "Ybodychange",
      "commitMessage": "Support aborting non-interactive rebase started from C Git\n\nContinuing is trickier, as .git/rebase-apply contains no message file\nand no git-rebase-todo.\n\nBug: 336820\nChange-Id: I4eb87c850078ca187b38b81cc91c92afb1176945\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013/3/17 上午6:32",
      "commitName": "0e9f1cf57dac274f92a6db38197e14b55b3277af",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2013/3/8 下午11:40",
      "commitNameOld": "3ad454497cdb6a917c00b01c735f5a469b8fb2ff",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d rebaseState.getFile(AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 210,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,123 +1,123 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n-                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n+                String upstreamCommitId \u003d rebaseState.readFile(ONTO);\n                 try {\n-                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n+                    upstreamCommitName \u003d rebaseState.readFile(ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n-            File amendFile \u003d new File(rebaseDir, AMEND);\n+            File amendFile \u003d rebaseState.getFile(AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n-            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n+            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n             fw.newLine();\n             try {\n                 StringBuilder sb \u003d new StringBuilder();\n                 for (Step step : steps) {\n                     sb.setLength(0);\n                     sb.append(step.action.token);\n                     sb.append(\" \");\n                     sb.append(step.commit.name());\n                     sb.append(\" \");\n                     sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                     fw.write(sb.toString());\n                     fw.newLine();\n                 }\n             } finally {\n                 fw.close();\n             }\n         }\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 switch(step.action) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n-                        createFile(rebaseDir, AMEND, commitToPick.name());\n+                        rebaseState.createFile(AMEND, commitToPick.name());\n                         return stop(commitToPick);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n-            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n+            String headName \u003d rebaseState.readFile(HEAD_NAME);\n             updateHead(headName, newHead);\n-            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n+            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (CheckoutConflictException cce) {\n         return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5": {
      "type": "Ybodychange",
      "commitMessage": "Improve handling of checkout conflicts\n\nThis converts a checkout conflict exception into a RebaseResult /\nMergeResult containing the conflicting paths, which enables EGit (or\nothers) to handle the situation in a user-friendly way\n\nChange-Id: I48d9bdcc1e98095576513a54a225a42409f301f3",
      "commitDate": "2013/1/12 上午9:32",
      "commitName": "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5",
      "commitAuthor": "Markus Duft",
      "commitDateOld": "2012/12/27 下午11:57",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 15.4,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d new File(rebaseDir, AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,121 +1,123 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                 try {\n                     upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d new File(rebaseDir, AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n             fw.newLine();\n             try {\n                 StringBuilder sb \u003d new StringBuilder();\n                 for (Step step : steps) {\n                     sb.setLength(0);\n                     sb.append(step.action.token);\n                     sb.append(\" \");\n                     sb.append(step.commit.name());\n                     sb.append(\" \");\n                     sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                     fw.write(sb.toString());\n                     fw.newLine();\n                 }\n             } finally {\n                 fw.close();\n             }\n         }\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 switch(step.action) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         createFile(rebaseDir, AMEND, commitToPick.name());\n                         return stop(commitToPick);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n+    } catch (CheckoutConflictException cce) {\n+        return new RebaseResult(cce.getConflictingPaths());\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012/12/27 下午11:57",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/12/6 上午7:16",
      "commitNameOld": "8d062dec0ca6815bd24457b02dbbc24f9dc143ee",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 21.69,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d new File(rebaseDir, AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "",
      "extendedDetails": {}
    },
    "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9": {
      "type": "Ybodychange",
      "commitMessage": "Commit message may not necessarily be in UTF-8\n\nTrying different encoding makes presentation nicer\nto user.\n\nChange-Id: I2d2c2a95d0b5cd709855d7a67cbc247478434d2f\n",
      "commitDate": "2012/11/27 下午3:34",
      "commitName": "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/11/20 上午12:02",
      "commitNameOld": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
      "commitAuthorOld": "Dariusz Luksza",
      "daysBetweenCommits": 7.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d new File(rebaseDir, AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,121 +1,121 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                 try {\n                     upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             File amendFile \u003d new File(rebaseDir, AMEND);\n             boolean amendExists \u003d amendFile.exists();\n             if (amendExists) {\n                 FileUtils.delete(amendFile);\n             }\n             if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n             fw.newLine();\n             try {\n                 StringBuilder sb \u003d new StringBuilder();\n                 for (Step step : steps) {\n                     sb.setLength(0);\n                     sb.append(step.action.token);\n                     sb.append(\" \");\n                     sb.append(step.commit.name());\n                     sb.append(\" \");\n-                    sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n+                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                     fw.write(sb.toString());\n                     fw.newLine();\n                 }\n             } finally {\n                 fw.close();\n             }\n         }\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 switch(step.action) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n                     case EDIT:\n                         createFile(rebaseDir, AMEND, commitToPick.name());\n                         return stop(commitToPick);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8eb4d926371edea2d58dc598e3ebcddacbdc326e": {
      "type": "Ybodychange",
      "commitMessage": "Add support for rebase interactive \u0027edit\u0027 command\n\nThe \u0027edit\u0027 command allows you to change arbitrary commit\ncontent and the message of any commit in the repository.\n\nBug: 394577\nChange-Id: I43a44782cdb10b29f13784fa75ab37fe5d4da01b\nSigned-off-by: Dariusz Luksza \u003cdariusz@luksza.org\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012/11/20 上午12:02",
      "commitName": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
      "commitAuthor": "Dariusz Luksza",
      "commitDateOld": "2012/11/19 下午11:40",
      "commitNameOld": "84fb2b59d11418d2fa753d27de11775ddc18adde",
      "commitAuthorOld": "Dariusz Luksza",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            File amendFile \u003d new File(rebaseDir, AMEND);\n            boolean amendExists \u003d amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 205,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,113 +1,121 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                 try {\n                     upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n-            if (newHead \u003d\u003d null) {\n+            File amendFile \u003d new File(rebaseDir, AMEND);\n+            boolean amendExists \u003d amendFile.exists();\n+            if (amendExists) {\n+                FileUtils.delete(amendFile);\n+            }\n+            if (newHead \u003d\u003d null \u0026\u0026 !amendExists) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         if (isInteractive()) {\n             interactiveHandler.prepareSteps(steps);\n             BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n             fw.newLine();\n             try {\n                 StringBuilder sb \u003d new StringBuilder();\n                 for (Step step : steps) {\n                     sb.setLength(0);\n                     sb.append(step.action.token);\n                     sb.append(\" \");\n                     sb.append(step.commit.name());\n                     sb.append(\" \");\n                     sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n                     fw.write(sb.toString());\n                     fw.newLine();\n                 }\n             } finally {\n                 fw.close();\n             }\n         }\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n                 switch(step.action) {\n                     case PICK:\n                         continue;\n                     case REWORD:\n                         String oldMessage \u003d commitToPick.getFullMessage();\n                         String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                         newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                         continue;\n+                    case EDIT:\n+                        createFile(rebaseDir, AMEND, commitToPick.name());\n+                        return stop(commitToPick);\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84fb2b59d11418d2fa753d27de11775ddc18adde": {
      "type": "Ybodychange",
      "commitMessage": "Add support for rebase interactive \u0027reword\u0027 command\n\n\u0027reword\u0027 command is used to change commit message of any\ncommit in git history.\n\nBug: 394575\nChange-Id: Ic974e76dfd923fd6f0cb8f07d1a6fbecd9abbf31\nSigned-off-by: Dariusz Luksza \u003cdariusz@luksza.org\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012/11/19 下午11:40",
      "commitName": "84fb2b59d11418d2fa753d27de11775ddc18adde",
      "commitAuthor": "Dariusz Luksza",
      "commitDateOld": "2012/8/27 上午6:54",
      "commitNameOld": "0264c313bae0308dadc4ed1db28f2f979a435451",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 84.7,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            if (newHead \u003d\u003d null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb \u003d new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage \u003d commitToPick.getFullMessage();\n                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 203,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,84 +1,113 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                 try {\n                     upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                 } catch (FileNotFoundException e) {\n                     upstreamCommitName \u003d upstreamCommitId;\n                 }\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             if (newHead \u003d\u003d null) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n+        if (isInteractive()) {\n+            interactiveHandler.prepareSteps(steps);\n+            BufferedWriter fw \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n+            fw.newLine();\n+            try {\n+                StringBuilder sb \u003d new StringBuilder();\n+                for (Step step : steps) {\n+                    sb.setLength(0);\n+                    sb.append(step.action.token);\n+                    sb.append(\" \");\n+                    sb.append(step.commit.name());\n+                    sb.append(\" \");\n+                    sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n+                    fw.write(sb.toString());\n+                    fw.newLine();\n+                }\n+            } finally {\n+                fw.close();\n+            }\n+        }\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     String ourCommitName \u003d getOurCommitName();\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n+                switch(step.action) {\n+                    case PICK:\n+                        continue;\n+                    case REWORD:\n+                        String oldMessage \u003d commitToPick.getFullMessage();\n+                        String newMessage \u003d interactiveHandler.modifyCommitMessage(oldMessage);\n+                        newHead \u003d new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n+                        continue;\n+                }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": {
      "type": "Ybodychange",
      "commitMessage": "Improve ours/theirs conflict markers for rebase, cherry-pick\n\nOn conflicts in rebase or cherry-pick, the conflict markers were like\nthis:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c OURS\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e THEIRS\n\nThis is technically correct, but it could be better.\n\nIt\u0027s especially confusing during a rebase, where the meaning of\nOURS/THEIRS is not obvious. The intuition is that \"ours\" is the commits\nthat \"I\" did before the rebase, but it\u0027s the other way around because of\nthe way rebase works. See various bug reports and stackoverflow\ndiscussions.\n\nWith this change, in the case of a cherry-pick while on master, the\nmarkers will be like this:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e bad1dea Message of the commit I\u0027m cherry-picking\n\nIn the case of a \"git rebase master\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nIt\u0027s not \"master\" because that would only be correct for the first\ncherry-pick during a rebase, after that, it\u0027s master + already\ncherry-picked commits.\n\nAnd in the case of a \"git pull --rebase\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on branch \u0027master\u0027 of git@example.org:repo\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nBug: 336819\nChange-Id: I1333a8dd170bb0077f491962013485efb6f2a926\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012/8/18 上午6:11",
      "commitName": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012/8/7 下午10:49",
      "commitNameOld": "993fcac2d34f113977c1ad7e0f83a2cc0f903f71",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 10.31,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName \u003d upstreamCommitId;\n                }\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            if (newHead \u003d\u003d null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    String ourCommitName \u003d getOurCommitName();\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 201,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
      "diff": "@@ -1,78 +1,84 @@\n public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n-                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n-                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n+                String upstreamCommitId \u003d readFile(rebaseDir, ONTO);\n+                try {\n+                    upstreamCommitName \u003d readFile(rebaseDir, ONTO_NAME);\n+                } catch (FileNotFoundException e) {\n+                    upstreamCommitName \u003d upstreamCommitId;\n+                }\n+                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitId));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             if (newHead \u003d\u003d null) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n-                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n+                    String ourCommitName \u003d getOurCommitName();\n+                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b61d35e848e637ef85fde4ebe95d60ced171e963": {
      "type": "Ymultichange(Yexceptionschange,Ydocchange)",
      "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012/6/5 下午10:55",
      "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012/6/5 下午10:55",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/6/1 上午3:52",
          "commitNameOld": "058c74d8adcfb5ef0eed203a64b7f9ff65e87c8c",
          "commitAuthorOld": "Kevin Sawicki",
          "daysBetweenCommits": 4.79,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            if (newHead \u003d\u003d null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
          "functionStartLine": 197,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
          "diff": "@@ -1,78 +1,78 @@\n-public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException {\n+public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             if (newHead \u003d\u003d null) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, NoHeadException, RefNotFoundException]",
            "newValue": "[GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012/6/5 下午10:55",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/6/1 上午3:52",
          "commitNameOld": "058c74d8adcfb5ef0eed203a64b7f9ff65e87c8c",
          "commitAuthorOld": "Kevin Sawicki",
          "daysBetweenCommits": 4.79,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            if (newHead \u003d\u003d null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
          "functionStartLine": 197,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n",
          "diff": "@@ -1,78 +1,78 @@\n-public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException {\n+public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             if (newHead \u003d\u003d null) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
            "newValue": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n@throws GitAPIException\n@throws WrongRepositoryStateException\n@throws NoHeadException\n@throws RefNotFoundException\n"
          }
        }
      ]
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Yexceptionschange",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012/5/31 上午4:08",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/4/2 下午5:36",
      "commitNameOld": "622232b936fee6d2f308947359b4bc09811ce556",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 58.44,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            if (newHead \u003d\u003d null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 193,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,78 +1,78 @@\n-public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n+public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n             if (newHead \u003d\u003d null) {\n                 return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n             }\n         }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException]",
        "newValue": "[GitAPIException, NoHeadException, RefNotFoundException]"
      }
    },
    "edc1fee033a23189742cea1807d8029d1b77da00": {
      "type": "Ybodychange",
      "commitMessage": "Fix rebase \u003e continue when nothing left to commit.\n\nIf after resolving all conflicts nothing is left to commit, return\nan according result, so that downstreams (EGit, ...) can behave like\ncgit, and display a nice message informing the user.\n\nCurrently, EGit displays a \"HEAD advanced fast forward\" message, which\nis absolutely not helpful at all.\n\nThis is the basic API revamping required to get that state communicated\nto the outside world (EGit).\n\nBug: 336812\nChange-Id: If2665005cf54a5b51c0fe80bad019fa42b0205af",
      "commitDate": "2012/3/9 下午8:56",
      "commitName": "edc1fee033a23189742cea1807d8029d1b77da00",
      "commitAuthor": "Markus Duft",
      "commitDateOld": "2012/3/7 上午5:43",
      "commitNameOld": "90d002c15fd2131b9f80fb9bb6f28bf691c00b5d",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 2.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE) {\n            newHead \u003d continueRebase();\n            if (newHead \u003d\u003d null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 193,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,74 +1,78 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort(RebaseResult.ABORTED_RESULT);\n-        if (operation \u003d\u003d Operation.CONTINUE)\n+        if (operation \u003d\u003d Operation.CONTINUE) {\n             newHead \u003d continueRebase();\n+            if (newHead \u003d\u003d null) {\n+                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n+            }\n+        }\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return RebaseResult.FAST_FORWARD_RESULT;\n             return RebaseResult.OK_RESULT;\n         }\n         return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "557ea857e3b5229379476f1ee4160fcf5b695bbd": {
      "type": "Ybodychange",
      "commitMessage": "Implement rebase ff for upstream branches with merge commits\n\nChange Ib9898fe0f982fa08e41f1dca9452c43de715fdb6 added support for\nthe \u0027cherry-pick\u0027 fast forward case where the upstream commit history\ndoes not include any merge commits.  This change adds support for the\ncase where merge commits exist and the local branch has no changes.\n\nBug: 344779\nChange-Id: If203ce5aa1b4e5d4d7982deb621b710e71f4ee10\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/5/19 上午12:40",
      "commitName": "557ea857e3b5229379476f1ee4160fcf5b695bbd",
      "commitAuthor": "Chris Aniszczyk",
      "commitDateOld": "2011/4/7 上午2:28",
      "commitNameOld": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 41.93,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 192,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,96 +1,74 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n-                    return abort(new RebaseResult(Status.ABORTED));\n+                    return abort(RebaseResult.ABORTED_RESULT);\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n-            return abort(new RebaseResult(Status.ABORTED));\n+            return abort(RebaseResult.ABORTED_RESULT);\n         if (operation \u003d\u003d Operation.CONTINUE)\n             newHead \u003d continueRebase();\n         if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             try {\n                 monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                 newHead \u003d tryFastForward(commitToPick);\n                 lastStepWasForward \u003d newHead !\u003d null;\n                 if (!lastStepWasForward) {\n                     CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                     switch(cherryPickResult.getStatus()) {\n                         case FAILED:\n                             if (operation \u003d\u003d Operation.BEGIN)\n                                 return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                             else\n                                 return stop(commitToPick);\n                         case CONFLICTING:\n                             return stop(commitToPick);\n                         case OK:\n                             newHead \u003d cherryPickResult.getNewHead();\n                     }\n                 }\n             } finally {\n                 monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n-            if (headName.startsWith(Constants.R_REFS)) {\n-                RefUpdate rup \u003d repo.updateRef(headName);\n-                rup.setNewObjectId(newHead);\n-                Result res \u003d rup.forceUpdate();\n-                switch(res) {\n-                    case FAST_FORWARD:\n-                    case FORCED:\n-                    case NO_CHANGE:\n-                        break;\n-                    default:\n-                        throw new JGitInternalException(\"Updating HEAD failed\");\n-                }\n-                rup \u003d repo.updateRef(Constants.HEAD);\n-                res \u003d rup.link(headName);\n-                switch(res) {\n-                    case FAST_FORWARD:\n-                    case FORCED:\n-                    case NO_CHANGE:\n-                        break;\n-                    default:\n-                        throw new JGitInternalException(\"Updating HEAD failed\");\n-                }\n-            }\n+            updateHead(headName, newHead);\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n-                return new RebaseResult(Status.FAST_FORWARD);\n-            return new RebaseResult(Status.OK);\n+                return RebaseResult.FAST_FORWARD_RESULT;\n+            return RebaseResult.OK_RESULT;\n         }\n-        return new RebaseResult(Status.UP_TO_DATE);\n+        return RebaseResult.FAST_FORWARD_RESULT;\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b5ad24915824a8c999bb6951b131a958e418306": {
      "type": "Ybodychange",
      "commitMessage": "Introduce FAILED result for RebaseCommand\n\nIn case an underlying cherry-pick fails due to uncommitted changes, a\nRebaseCommand shall fail and roll-back changes.\n\nChange-Id: Ic22eb047fb03ac2c8391f777036b7dbf22a1b061\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2011/3/24 下午7:24",
      "commitName": "0b5ad24915824a8c999bb6951b131a958e418306",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011/3/23 下午5:24",
      "commitNameOld": "a21e508a318664dac23701ca29d5f0b64d36a76a",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(new RebaseResult(Status.ABORTED));\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(new RebaseResult(Status.ABORTED));\n        if (operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        if (operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead \u003d tryFastForward(commitToPick);\n                lastStepWasForward \u003d newHead !\u003d null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation \u003d\u003d Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead \u003d cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res \u003d rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup \u003d repo.updateRef(Constants.HEAD);\n                res \u003d rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return new RebaseResult(Status.FAST_FORWARD);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 192,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,84 +1,96 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n-                    return abort();\n+                    return abort(new RebaseResult(Status.ABORTED));\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n-            return abort();\n-        if (this.operation \u003d\u003d Operation.CONTINUE)\n+            return abort(new RebaseResult(Status.ABORTED));\n+        if (operation \u003d\u003d Operation.CONTINUE)\n             newHead \u003d continueRebase();\n-        if (this.operation \u003d\u003d Operation.SKIP)\n+        if (operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n-            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n-            newHead \u003d tryFastForward(commitToPick);\n-            lastStepWasForward \u003d newHead !\u003d null;\n-            if (!lastStepWasForward)\n-                newHead \u003d new Git(repo).cherryPick().include(commitToPick).call().getNewHead();\n-            monitor.endTask();\n-            if (newHead \u003d\u003d null) {\n-                return stop(commitToPick);\n+            try {\n+                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n+                newHead \u003d tryFastForward(commitToPick);\n+                lastStepWasForward \u003d newHead !\u003d null;\n+                if (!lastStepWasForward) {\n+                    CherryPickResult cherryPickResult \u003d new Git(repo).cherryPick().include(commitToPick).call();\n+                    switch(cherryPickResult.getStatus()) {\n+                        case FAILED:\n+                            if (operation \u003d\u003d Operation.BEGIN)\n+                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n+                            else\n+                                return stop(commitToPick);\n+                        case CONFLICTING:\n+                            return stop(commitToPick);\n+                        case OK:\n+                            newHead \u003d cherryPickResult.getNewHead();\n+                    }\n+                }\n+            } finally {\n+                monitor.endTask();\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 Result res \u003d rup.forceUpdate();\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 res \u003d rup.link(headName);\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n             }\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return new RebaseResult(Status.FAST_FORWARD);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a21e508a318664dac23701ca29d5f0b64d36a76a": {
      "type": "Ybodychange",
      "commitMessage": "Introduce CherryPickResult\n\nIn order to distinguish cherry-pick failures caused by conflicts vs.\n\u0027abnormal failures\u0027 (e.g. due to unstaged changes or a dirty\nworktree), a CherryPickResult class is introduced and returned by\nCherryPickCommand.call() instead of a RevCommit. This new class is\nsimilar to MergeResult and RebaseResult. The CherryPickResult contains\nall necessary information, e.g. paths causing the cherry-pick (a merge\ncalled within, respectively) to fail. This allows callers to better\nreact on failures.\n\nChange-Id: I5db57b9259e82ed118e4bf4ec94463efe68b8c1f\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e",
      "commitDate": "2011/3/23 下午5:24",
      "commitName": "a21e508a318664dac23701ca29d5f0b64d36a76a",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011/1/31 下午7:12",
      "commitNameOld": "b15b9d5df25b375108ca125b31338df637454865",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 50.92,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        if (this.operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d tryFastForward(commitToPick);\n            lastStepWasForward \u003d newHead !\u003d null;\n            if (!lastStepWasForward)\n                newHead \u003d new Git(repo).cherryPick().include(commitToPick).call().getNewHead();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res \u003d rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup \u003d repo.updateRef(Constants.HEAD);\n                res \u003d rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return new RebaseResult(Status.FAST_FORWARD);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 192,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,84 +1,84 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n     boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             newHead \u003d continueRebase();\n         if (this.operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d tryFastForward(commitToPick);\n             lastStepWasForward \u003d newHead !\u003d null;\n             if (!lastStepWasForward)\n-                newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n+                newHead \u003d new Git(repo).cherryPick().include(commitToPick).call().getNewHead();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n                 return stop(commitToPick);\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 Result res \u003d rup.forceUpdate();\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 res \u003d rup.link(headName);\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n             }\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             if (lastStepWasForward)\n                 return new RebaseResult(Status.FAST_FORWARD);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e8a1328d05aa55b7ace0d101e34b87422219c959": {
      "type": "Ybodychange",
      "commitMessage": "RebaseCommand: detect and handle fast-forward properly\n\nThis bug was hidden by an incomplete test: the current Rebase\nimplementation using the \"git rebase -i\" pattern does not work\ncorrectly if fast-forwarding is involved. The reason for this is that\nthe log command does not return any commits in this case.\nIn addition, a check for already merged commits was introduced to\navoid spurious conflicts.\n\nChange-Id: Ib9898fe0f982fa08e41f1dca9452c43de715fdb6\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011/1/28 下午10:03",
      "commitName": "e8a1328d05aa55b7ace0d101e34b87422219c959",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2011/1/28 上午8:11",
      "commitNameOld": "38eec8f4a26935ba9e75bfbdde8a5682e05f338d",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.58,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    boolean lastStepWasForward \u003d false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        if (this.operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d tryFastForward(commitToPick);\n            lastStepWasForward \u003d newHead !\u003d null;\n            if (!lastStepWasForward)\n                newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res \u003d rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup \u003d repo.updateRef(Constants.HEAD);\n                res \u003d rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return new RebaseResult(Status.FAST_FORWARD);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 191,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,78 +1,84 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n+    boolean lastStepWasForward \u003d false;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             newHead \u003d continueRebase();\n         if (this.operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n-            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n+            newHead \u003d tryFastForward(commitToPick);\n+            lastStepWasForward \u003d newHead !\u003d null;\n+            if (!lastStepWasForward)\n+                newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n                 return stop(commitToPick);\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 Result res \u003d rup.forceUpdate();\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 res \u003d rup.link(headName);\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n             }\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n+            if (lastStepWasForward)\n+                return new RebaseResult(Status.FAST_FORWARD);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: abort on unknown/unsupported command in git-rebase-todo\n\nThis is needed to ensure interoperability with the command line: if\nthe git-rebase-todo file was created manually (by git rebase -i in the\ncommand line), and any commands other than pick are used (reword,\nedit, fixup, squash) JGit must abort as it does not understand these\ncommands yet.\nThe same is true if an unknown command is found (e.g. due to a typo);\nthis is the same behavior as shown by the command line.\n\nChange-Id: I2322014f69460361f7fc09da223e8a5c31f100dd\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010/12/10 下午4:44",
      "commitName": "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/12/10 上午2:22",
      "commitNameOld": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.6,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        if (this.operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res \u003d rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup \u003d repo.updateRef(Constants.HEAD);\n                res \u003d rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 189,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,80 +1,78 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             newHead \u003d continueRebase();\n         if (this.operation \u003d\u003d Operation.SKIP)\n             newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n-            if (step.action !\u003d Action.PICK)\n-                continue;\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n                 return stop(commitToPick);\n             }\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 Result res \u003d rup.forceUpdate();\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 res \u003d rup.link(headName);\n                 switch(res) {\n                     case FAST_FORWARD:\n                     case FORCED:\n                     case NO_CHANGE:\n                         break;\n                     default:\n                         throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n             }\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2a7cd0086bf1bd614478c5722eac5142326e6f2b": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: fix wrong update if original HEAD after Merge+Skip\n\nRebase would update the original HEAD to the wrong commit when\n\"skipping\" the last commit after a merged commit.\n\nIncludes a test for the specific situation.\n\nChange-Id: I087314b1834a3f11a4561f04ca5c21411d54d993\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010/12/10 上午2:22",
      "commitName": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/12/9 下午11:10",
      "commitNameOld": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        if (this.operation \u003d\u003d Operation.SKIP)\n            newHead \u003d checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        for (Step step : steps) {\n            if (step.action !\u003d Action.PICK)\n                continue;\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res \u003d rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup \u003d repo.updateRef(Constants.HEAD);\n                res \u003d rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 189,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,71 +1,80 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     RevCommit newHead \u003d null;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             newHead \u003d continueRebase();\n-        List\u003cStep\u003e steps \u003d loadSteps();\n-        if (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 !steps.isEmpty())\n-            checkoutCurrentHead();\n+        if (this.operation \u003d\u003d Operation.SKIP)\n+            newHead \u003d checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n-        int stepsToPop \u003d 0;\n+        List\u003cStep\u003e steps \u003d loadSteps();\n         for (Step step : steps) {\n             if (step.action !\u003d Action.PICK)\n                 continue;\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n                 return stop(commitToPick);\n             }\n-            stepsToPop++;\n         }\n-        if (newHead !\u003d null || steps.isEmpty()) {\n+        if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n-                if (newHead !\u003d null) {\n-                    rup.setNewObjectId(newHead);\n-                    rup.forceUpdate();\n+                rup.setNewObjectId(newHead);\n+                Result res \u003d rup.forceUpdate();\n+                switch(res) {\n+                    case FAST_FORWARD:\n+                    case FORCED:\n+                    case NO_CHANGE:\n+                        break;\n+                    default:\n+                        throw new JGitInternalException(\"Updating HEAD failed\");\n                 }\n                 rup \u003d repo.updateRef(Constants.HEAD);\n-                rup.link(headName);\n-            }\n-            if (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 steps.isEmpty()) {\n-                checkoutCurrentHead();\n+                res \u003d rup.link(headName);\n+                switch(res) {\n+                    case FAST_FORWARD:\n+                    case FORCED:\n+                    case NO_CHANGE:\n+                        break;\n+                    default:\n+                        throw new JGitInternalException(\"Updating HEAD failed\");\n+                }\n             }\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6bca46e1683a07f18f00f6ad552eab79ab50bb88": {
      "type": "Ybodychange",
      "commitMessage": "Implement rebase --continue and --skip\n\nFor --continue, the Rebase command asserts that there are no unmerged\npaths in the current repository. Then it checks if a commit is needed.\nIf yes, the commit message and author are taken from the author_script\nand message files, respectively, and a commit is performed before the\nnext step is applied.\nFor --skip, the workspace is reset to the current HEAD before applying\nthe next step.\n\nIncludes some tests and a refactoring that extracts Strings in the\ncode into constants.\n\n\nChange-Id: I72d9968535727046e737ec20e23239fe79976179\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010/12/9 下午11:10",
      "commitName": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/12/8 上午8:18",
      "commitNameOld": "45731756a56361a51e839e26d3b0bed1c06ee37a",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 1.62,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead \u003d null;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            newHead \u003d continueRebase();\n        List\u003cStep\u003e steps \u003d loadSteps();\n        if (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 !steps.isEmpty())\n            checkoutCurrentHead();\n        ObjectReader or \u003d repo.newObjectReader();\n        int stepsToPop \u003d 0;\n        for (Step step : steps) {\n            if (step.action !\u003d Action.PICK)\n                continue;\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead !\u003d null || steps.isEmpty()) {\n            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                if (newHead !\u003d null) {\n                    rup.setNewObjectId(newHead);\n                    rup.forceUpdate();\n                }\n                rup \u003d repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            if (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 steps.isEmpty()) {\n                checkoutCurrentHead();\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 189,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,66 +1,71 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n+    RevCommit newHead \u003d null;\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n-                String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n+                String upstreamCommitName \u003d readFile(rebaseDir, ONTO);\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n-            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n-        if (this.operation \u003d\u003d Operation.SKIP)\n-            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n-        RevCommit newHead \u003d null;\n+            newHead \u003d continueRebase();\n         List\u003cStep\u003e steps \u003d loadSteps();\n+        if (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 !steps.isEmpty())\n+            checkoutCurrentHead();\n         ObjectReader or \u003d repo.newObjectReader();\n         int stepsToPop \u003d 0;\n         for (Step step : steps) {\n             if (step.action !\u003d Action.PICK)\n                 continue;\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n                 return stop(commitToPick);\n             }\n             stepsToPop++;\n         }\n-        if (newHead !\u003d null) {\n-            String headName \u003d readFile(rebaseDir, \"head-name\");\n+        if (newHead !\u003d null || steps.isEmpty()) {\n+            String headName \u003d readFile(rebaseDir, HEAD_NAME);\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n-                rup.setNewObjectId(newHead);\n-                rup.forceUpdate();\n+                if (newHead !\u003d null) {\n+                    rup.setNewObjectId(newHead);\n+                    rup.forceUpdate();\n+                }\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 rup.link(headName);\n             }\n+            if (this.operation \u003d\u003d Operation.SKIP \u0026\u0026 steps.isEmpty()) {\n+                checkoutCurrentHead();\n+            }\n             FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45731756a56361a51e839e26d3b0bed1c06ee37a": {
      "type": "Ybodychange",
      "commitMessage": "[findbugs] Do not ignore exceptional return value\n\njava.io.File.delete() reports failure as an exceptional\nreturn value false. Fix the code which silently ignored\nthis exceptional return value. Also remove some duplicate\ndeletion helper methods.\n\nChange-Id: I80ed20ca1f07a2bc6e779957a4ad0c713789c5be\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2010/12/8 上午8:18",
      "commitName": "45731756a56361a51e839e26d3b0bed1c06ee37a",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2010/12/7 下午8:34",
      "commitNameOld": "ad96546ca023c260ed7250c447f4c8abe168afd3",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation \u003d\u003d Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead \u003d null;\n        List\u003cStep\u003e steps \u003d loadSteps();\n        ObjectReader or \u003d repo.newObjectReader();\n        int stepsToPop \u003d 0;\n        for (Step step : steps) {\n            if (step.action !\u003d Action.PICK)\n                continue;\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup \u003d repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,66 +1,66 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n         if (this.operation \u003d\u003d Operation.SKIP)\n             throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n         RevCommit newHead \u003d null;\n         List\u003cStep\u003e steps \u003d loadSteps();\n         ObjectReader or \u003d repo.newObjectReader();\n         int stepsToPop \u003d 0;\n         for (Step step : steps) {\n             if (step.action !\u003d Action.PICK)\n                 continue;\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n                 return stop(commitToPick);\n             }\n             stepsToPop++;\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, \"head-name\");\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 rup.forceUpdate();\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 rup.link(headName);\n             }\n-            deleteRecursive(rebaseDir);\n+            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad96546ca023c260ed7250c447f4c8abe168afd3": {
      "type": "Ybodychange",
      "commitMessage": "Rebase Interoperability third part: handle stop upon conflict\n\nThere are some files that need to exist so that the CLI can continue\nafter the rebase has been stopped due to conflicts\n\nChange-Id: I3cb4dc98609c059bf0cf9fd5f9e47a9c681cea2d\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010/12/7 下午8:34",
      "commitName": "ad96546ca023c260ed7250c447f4c8abe168afd3",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/12/1 下午10:10",
      "commitNameOld": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation \u003d\u003d Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead \u003d null;\n        List\u003cStep\u003e steps \u003d loadSteps();\n        ObjectReader or \u003d repo.newObjectReader();\n        int stepsToPop \u003d 0;\n        for (Step step : steps) {\n            if (step.action !\u003d Action.PICK)\n                continue;\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return stop(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup \u003d repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            deleteRecursive(rebaseDir);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 145,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,66 +1,66 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n         if (this.operation \u003d\u003d Operation.SKIP)\n             throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n         RevCommit newHead \u003d null;\n         List\u003cStep\u003e steps \u003d loadSteps();\n         ObjectReader or \u003d repo.newObjectReader();\n         int stepsToPop \u003d 0;\n         for (Step step : steps) {\n             if (step.action !\u003d Action.PICK)\n                 continue;\n             popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n-                return new RebaseResult(commitToPick);\n+                return stop(commitToPick);\n             }\n             stepsToPop++;\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, \"head-name\");\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 rup.forceUpdate();\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 rup.link(headName);\n             }\n             deleteRecursive(rebaseDir);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59e62ba7e10188c6170bd97ffbd9c8768d9745ea": {
      "type": "Ybodychange",
      "commitMessage": "Rebase Interoperability second part: fix \"pop steps\"\n\nIf the CLI stops a rebase upon conflict, the current\nstep is already popped from the git-rebase-todo and appended to the\n\"done\" file. The current implementation wrongly pops the step only\nafter successful cherry-pick.\n\nChange-Id: I8640dda0cbb2a5271ecf75fcbad69410122eeab6\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010/12/1 下午10:10",
      "commitName": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/12/1 下午10:08",
      "commitNameOld": "7aa1b85821e007c0243772273960069497284290",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation \u003d\u003d Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead \u003d null;\n        List\u003cStep\u003e steps \u003d loadSteps();\n        ObjectReader or \u003d repo.newObjectReader();\n        int stepsToPop \u003d 0;\n        for (Step step : steps) {\n            if (step.action !\u003d Action.PICK)\n                continue;\n            popSteps(1);\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                return new RebaseResult(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup \u003d repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            deleteRecursive(rebaseDir);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n",
      "diff": "@@ -1,66 +1,66 @@\n public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n     checkCallable();\n     checkParameters();\n     try {\n         switch(operation) {\n             case ABORT:\n                 try {\n                     return abort();\n                 } catch (IOException ioe) {\n                     throw new JGitInternalException(ioe.getMessage(), ioe);\n                 }\n             case SKIP:\n             case CONTINUE:\n                 String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                 this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                 break;\n             case BEGIN:\n                 RebaseResult res \u003d initFilesAndRewind();\n                 if (res !\u003d null)\n                     return res;\n         }\n         if (monitor.isCancelled())\n             return abort();\n         if (this.operation \u003d\u003d Operation.CONTINUE)\n             throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n         if (this.operation \u003d\u003d Operation.SKIP)\n             throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n         RevCommit newHead \u003d null;\n         List\u003cStep\u003e steps \u003d loadSteps();\n         ObjectReader or \u003d repo.newObjectReader();\n         int stepsToPop \u003d 0;\n         for (Step step : steps) {\n             if (step.action !\u003d Action.PICK)\n                 continue;\n+            popSteps(1);\n             Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n             if (ids.size() !\u003d 1)\n                 throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n             RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n             if (monitor.isCancelled())\n                 return new RebaseResult(commitToPick);\n             monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n             newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n             monitor.endTask();\n             if (newHead \u003d\u003d null) {\n-                popSteps(stepsToPop);\n                 return new RebaseResult(commitToPick);\n             }\n             stepsToPop++;\n         }\n         if (newHead !\u003d null) {\n             String headName \u003d readFile(rebaseDir, \"head-name\");\n             if (headName.startsWith(Constants.R_REFS)) {\n                 RefUpdate rup \u003d repo.updateRef(headName);\n                 rup.setNewObjectId(newHead);\n                 rup.forceUpdate();\n                 rup \u003d repo.updateRef(Constants.HEAD);\n                 rup.link(headName);\n             }\n             deleteRecursive(rebaseDir);\n             return new RebaseResult(Status.OK);\n         }\n         return new RebaseResult(Status.UP_TO_DATE);\n     } catch (IOException ioe) {\n         throw new JGitInternalException(ioe.getMessage(), ioe);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e5b96a7848d680cf50123a44cbc147db91d798d3": {
      "type": "Yintroduced",
      "commitMessage": "Initial implementation of a Rebase command\n\nThis is a first iteration to implement Rebase. At the moment, this\ndoes not implement --continue and --skip, so if the first\nconflict is found, the only option is to --abort the command.\n\nBug: 328217\nChange-Id: I24d60c0214e71e5572955f8261e10a42e9e95298\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010/11/22 下午11:58",
      "commitName": "e5b96a7848d680cf50123a44cbc147db91d798d3",
      "commitAuthor": "Mathias Kinzler",
      "diff": "@@ -0,0 +1,66 @@\n+public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n+    checkCallable();\n+    checkParameters();\n+    try {\n+        switch(operation) {\n+            case ABORT:\n+                try {\n+                    return abort();\n+                } catch (IOException ioe) {\n+                    throw new JGitInternalException(ioe.getMessage(), ioe);\n+                }\n+            case SKIP:\n+            case CONTINUE:\n+                String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n+                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n+                break;\n+            case BEGIN:\n+                RebaseResult res \u003d initFilesAndRewind();\n+                if (res !\u003d null)\n+                    return res;\n+        }\n+        if (monitor.isCancelled())\n+            return abort();\n+        if (this.operation \u003d\u003d Operation.CONTINUE)\n+            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n+        if (this.operation \u003d\u003d Operation.SKIP)\n+            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n+        RevCommit newHead \u003d null;\n+        List\u003cStep\u003e steps \u003d loadSteps();\n+        ObjectReader or \u003d repo.newObjectReader();\n+        int stepsToPop \u003d 0;\n+        for (Step step : steps) {\n+            if (step.action !\u003d Action.PICK)\n+                continue;\n+            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n+            if (ids.size() !\u003d 1)\n+                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n+            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n+            if (monitor.isCancelled())\n+                return new RebaseResult(commitToPick);\n+            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n+            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n+            monitor.endTask();\n+            if (newHead \u003d\u003d null) {\n+                popSteps(stepsToPop);\n+                return new RebaseResult(commitToPick);\n+            }\n+            stepsToPop++;\n+        }\n+        if (newHead !\u003d null) {\n+            String headName \u003d readFile(rebaseDir, \"head-name\");\n+            if (headName.startsWith(Constants.R_REFS)) {\n+                RefUpdate rup \u003d repo.updateRef(headName);\n+                rup.setNewObjectId(newHead);\n+                rup.forceUpdate();\n+                rup \u003d repo.updateRef(Constants.HEAD);\n+                rup.link(headName);\n+            }\n+            deleteRecursive(rebaseDir);\n+            return new RebaseResult(Status.OK);\n+        }\n+        return new RebaseResult(Status.UP_TO_DATE);\n+    } catch (IOException ioe) {\n+        throw new JGitInternalException(ioe.getMessage(), ioe);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName \u003d readFile(rebaseDir, \"onto\");\n                this.upstreamCommit \u003d walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res \u003d initFilesAndRewind();\n                if (res !\u003d null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation \u003d\u003d Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation \u003d\u003d Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead \u003d null;\n        List\u003cStep\u003e steps \u003d loadSteps();\n        ObjectReader or \u003d repo.newObjectReader();\n        int stepsToPop \u003d 0;\n        for (Step step : steps) {\n            if (step.action !\u003d Action.PICK)\n                continue;\n            Collection\u003cObjectId\u003e ids \u003d or.resolve(step.commit);\n            if (ids.size() !\u003d 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick \u003d walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead \u003d new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead \u003d\u003d null) {\n                popSteps(stepsToPop);\n                return new RebaseResult(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead !\u003d null) {\n            String headName \u003d readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup \u003d repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup \u003d repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            deleteRecursive(rebaseDir);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Rebase} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command. Don\u0027t call\nthis method twice on an instance.\n\n@return an object describing the result of this command\n"
    }
  }
}