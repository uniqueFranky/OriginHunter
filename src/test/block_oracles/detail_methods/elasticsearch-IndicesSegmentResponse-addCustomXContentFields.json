{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/elasticsearch/.git",
  "startCommitName": "767c69593c67befb843686de8ea51b7bc87728c9",
  "sourceFileName": "IndicesSegmentResponse.java",
  "functionName": "addCustomXContentFields",
  "functionId": "addCustomXContentFields___builder-XContentBuilder__params-Params",
  "sourceFilePath": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 105,
  "functionEndLine": 175,
  "numCommitsSeen": 32,
  "timeTaken": 7333,
  "changeHistory": [
    "b4c78019b02313bd1eaa61e0752ef3c2cf34f5a4",
    "4a8099c6962da1e68309e0e382d0e6198a3937c2",
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
    "22292e8d964d2b7239f0fc306ea91692bdbc8b1e",
    "f05af0a382a995cb254a851d2306f12c3da2cd1b",
    "88dd6ba430e729d473432076a6eba1f6cb85c136",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
    "f7f99b8dbfe4cc10612faceec8f82e03884f0d6d",
    "95ca06cf0945233686e92ccdb3354522ff05863c",
    "c093e90d517a3652d8b8f46c61a48097132a8cef",
    "6e19ca808056e3c69545a837180d23faa863fec7",
    "a3071540d7f245db5a55d30133bebe067ac9f7d4",
    "1fc37e59547ba544ab1a4677f2622c9e39b26313",
    "cc83c2f848be69a77f1275fe1ff5363dcdd4c955",
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
    "3eaf73a380000acef6b971fe09a7d1f38aa748d1",
    "b670a7f2a345aa2507714c1e8b61906c679c1107"
  ],
  "changeHistoryShort": {
    "b4c78019b02313bd1eaa61e0752ef3c2cf34f5a4": "Ybodychange",
    "4a8099c6962da1e68309e0e382d0e6198a3937c2": "Ymultichange(Yrename,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": "Yfilerename",
    "22292e8d964d2b7239f0fc306ea91692bdbc8b1e": "Ybodychange",
    "f05af0a382a995cb254a851d2306f12c3da2cd1b": "Ybodychange",
    "88dd6ba430e729d473432076a6eba1f6cb85c136": "Ybodychange",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": "Yfilerename",
    "f7f99b8dbfe4cc10612faceec8f82e03884f0d6d": "Ybodychange",
    "95ca06cf0945233686e92ccdb3354522ff05863c": "Ybodychange",
    "c093e90d517a3652d8b8f46c61a48097132a8cef": "Ybodychange",
    "6e19ca808056e3c69545a837180d23faa863fec7": "Ybodychange",
    "a3071540d7f245db5a55d30133bebe067ac9f7d4": "Ybodychange",
    "1fc37e59547ba544ab1a4677f2622c9e39b26313": "Ybodychange",
    "cc83c2f848be69a77f1275fe1ff5363dcdd4c955": "Ybodychange",
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": "Yfilerename",
    "3eaf73a380000acef6b971fe09a7d1f38aa748d1": "Ybodychange",
    "b670a7f2a345aa2507714c1e8b61906c679c1107": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b4c78019b02313bd1eaa61e0752ef3c2cf34f5a4": {
      "type": "Ybodychange",
      "commitMessage": "Remove all dependencies from XContentBuilder (#29225)\n\n* Remove all dependencies from XContentBuilder\r\n\r\nThis commit removes all of the non-JDK dependencies from XContentBuilder, with\r\nthe exception of `CollectionUtils.ensureNoSelfReferences`. It adds a third\r\nextension point around dealing with time-based fields and formatters to work\r\naround the Joda dependency.\r\n\r\nThis decoupling allows us to be able to move XContentBuilder to a separate lib\r\nso it can be available for things like the high level rest client.\r\n\r\nRelates to #28504",
      "commitDate": "2018/3/28 上午2:58",
      "commitName": "b4c78019b02313bd1eaa61e0752ef3c2cf34f5a4",
      "commitAuthor": "Lee Hinman",
      "commitDateOld": "2018/3/23 下午5:53",
      "commitNameOld": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
      "commitAuthorOld": "Yu",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.humanReadableField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSize());\n                    builder.humanReadableField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, new ByteSizeValue(segment.getMemoryInBytes()));\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n}",
      "path": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 105,
      "functionName": "addCustomXContentFields",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,64 +1,64 @@\n @Override\n protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n-                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n-                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n+                    builder.humanReadableField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSize());\n+                    builder.humanReadableField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, new ByteSizeValue(segment.getMemoryInBytes()));\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.getSegmentSort() !\u003d null) {\n                         toXContent(builder, segment.getSegmentSort());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                         builder.field(\"attributes\", segment.attributes);\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a8099c6962da1e68309e0e382d0e6198a3937c2": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it\u0027s rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse\u0027s subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
      "commitDate": "2018/3/23 下午5:53",
      "commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
      "commitAuthor": "Yu",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it\u0027s rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse\u0027s subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
          "commitDate": "2018/3/23 下午5:53",
          "commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
          "commitAuthor": "Yu",
          "commitDateOld": "2018/3/21 上午1:39",
          "commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
          "commitAuthorOld": "Lee Hinman",
          "daysBetweenCommits": 2.68,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n}",
          "path": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
          "functionStartLine": 105,
          "functionName": "addCustomXContentFields",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,65 +1,64 @@\n @Override\n-public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.getSegmentSort() !\u003d null) {\n                         toXContent(builder, segment.getSegmentSort());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                         builder.field(\"attributes\", segment.attributes);\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n-    return builder;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "toXContent",
            "newValue": "addCustomXContentFields"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it\u0027s rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse\u0027s subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
          "commitDate": "2018/3/23 下午5:53",
          "commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
          "commitAuthor": "Yu",
          "commitDateOld": "2018/3/21 上午1:39",
          "commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
          "commitAuthorOld": "Lee Hinman",
          "daysBetweenCommits": 2.68,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n}",
          "path": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
          "functionStartLine": 105,
          "functionName": "addCustomXContentFields",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,65 +1,64 @@\n @Override\n-public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.getSegmentSort() !\u003d null) {\n                         toXContent(builder, segment.getSegmentSort());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                         builder.field(\"attributes\", segment.attributes);\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n-    return builder;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "XContentBuilder",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it\u0027s rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse\u0027s subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
          "commitDate": "2018/3/23 下午5:53",
          "commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
          "commitAuthor": "Yu",
          "commitDateOld": "2018/3/21 上午1:39",
          "commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
          "commitAuthorOld": "Lee Hinman",
          "daysBetweenCommits": 2.68,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n}",
          "path": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
          "functionStartLine": 105,
          "functionName": "addCustomXContentFields",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,65 +1,64 @@\n @Override\n-public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.getSegmentSort() !\u003d null) {\n                         toXContent(builder, segment.getSegmentSort());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                         builder.field(\"attributes\", segment.attributes);\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n-    return builder;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it\u0027s rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse\u0027s subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
          "commitDate": "2018/3/23 下午5:53",
          "commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
          "commitAuthor": "Yu",
          "commitDateOld": "2018/3/21 上午1:39",
          "commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
          "commitAuthorOld": "Lee Hinman",
          "daysBetweenCommits": 2.68,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n}",
          "path": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
          "functionStartLine": 105,
          "functionName": "addCustomXContentFields",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,65 +1,64 @@\n @Override\n-public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.getSegmentSort() !\u003d null) {\n                         toXContent(builder, segment.getSegmentSort());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                         builder.field(\"attributes\", segment.attributes);\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n-    return builder;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
      "type": "Yfilerename",
      "commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
      "commitDate": "2018/1/12 上午2:30",
      "commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthor": "Tim Brooks",
      "commitDateOld": "2018/1/12 上午12:31",
      "commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 105,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
        "newPath": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java"
      }
    },
    "22292e8d964d2b7239f0fc306ea91692bdbc8b1e": {
      "type": "Ybodychange",
      "commitMessage": "Add segment attributes to the `_segments` API. (#26157)\n\nThis contains information about whether high compression was enabled for instance.\r\n\r\nCloses #26130",
      "commitDate": "2017/8/17 上午1:01",
      "commitName": "22292e8d964d2b7239f0fc306ea91692bdbc8b1e",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": "2017/8/9 下午10:53",
      "commitNameOld": "dfbaf90951c5eaa7fd40a956f24b042aa11a2e23",
      "commitAuthorOld": "Colin Goodheart-Smithe",
      "daysBetweenCommits": 7.09,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n                        builder.field(\"attributes\", segment.attributes);\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 105,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,62 +1,65 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.getSegmentSort() !\u003d null) {\n                         toXContent(builder, segment.getSegmentSort());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n+                    if (segment.attributes !\u003d null \u0026\u0026 segment.attributes.isEmpty() \u003d\u003d false) {\n+                        builder.field(\"attributes\", segment.attributes);\n+                    }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f05af0a382a995cb254a851d2306f12c3da2cd1b": {
      "type": "Ybodychange",
      "commitMessage": "Enable index-time sorting (#24055)\n\nThis change adds an index setting to define how the documents should be sorted inside each Segment.\r\nIt allows any numeric, date, boolean or keyword field inside a mapping to be used to sort the index on disk.\r\nIt is not allowed to use a `nested` fields inside an index that defines an index sorting since `nested` fields relies on the original sort of the index.\r\nThis change does not add early termination capabilities in the search layer. This will be added in a follow up.\r\n\r\nRelates #6720",
      "commitDate": "2017/4/19 下午8:36",
      "commitName": "f05af0a382a995cb254a851d2306f12c3da2cd1b",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": "2016/4/19 上午5:32",
      "commitNameOld": "523b071836be9c9b954c9e45a026311c83483c05",
      "commitAuthorOld": "Ryan Ernst",
      "daysBetweenCommits": 365.63,
      "commitsBetweenForRepo": 4978,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.getSegmentSort() !\u003d null) {\n                        toXContent(builder, segment.getSegmentSort());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 105,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,62 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n+                    if (segment.getSegmentSort() !\u003d null) {\n+                        toXContent(builder, segment.getSegmentSort());\n+                    }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88dd6ba430e729d473432076a6eba1f6cb85c136": {
      "type": "Ybodychange",
      "commitMessage": "Rest: Remove \u0027case\u0027 parameter from rest apis\n\nThe current api allows for choosing which \"case\" response json keys are\nwritten in. This has the options of camelCase or underscore. camelCase\nis going to be deprecated from the query apis. However, with the case\napi, it is not necessary to deprecate, as users who were using it in 2.x\ncan transition completely on 2.x before upgrading by simply using\nthe underscore option.\n\nThis change removes the \u0027case\u0027 option from rest apis.\n\nsee #8988\n",
      "commitDate": "2016/4/15 下午2:07",
      "commitName": "88dd6ba430e729d473432076a6eba1f6cb85c136",
      "commitAuthor": "Ryan Ernst",
      "commitDateOld": "2016/1/28 下午3:40",
      "commitNameOld": "2a137b554825a5f848cfaff6311d7c298fd76fe7",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 77.94,
      "commitsBetweenForRepo": 1398,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex());\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 101,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n-        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n+        builder.startObject(indexSegments.getIndex());\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     if (segment.ramTree !\u003d null) {\n                         builder.startArray(Fields.RAM_TREE);\n                         for (Accountable child : segment.ramTree.getChildResources()) {\n                             toXContent(builder, child);\n                         }\n                         builder.endArray();\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": {
      "type": "Yfilerename",
      "commitMessage": "create core module\n",
      "commitDate": "2015/6/5 下午7:12",
      "commitName": "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2015/6/5 下午7:11",
      "commitNameOld": "7ccc193a666e2ae888e7ac93d677a2143e5e07c3",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 102,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
        "newPath": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java"
      }
    },
    "f7f99b8dbfe4cc10612faceec8f82e03884f0d6d": {
      "type": "Ybodychange",
      "commitMessage": "Stats: Added verbose option to segments api, with full ram tree as first\nadditional element per segment.\n\nThis commit adds a verbose flag to the _segments api.  Currently the\nonly additional information returned when set to true is the full\nram tree from lucene for each segment.\n",
      "commitDate": "2015/1/7 上午2:04",
      "commitName": "f7f99b8dbfe4cc10612faceec8f82e03884f0d6d",
      "commitAuthor": "Ryan Ernst",
      "commitDateOld": "2014/1/7 下午6:22",
      "commitNameOld": "10ec2e948a2f1426a5058ca3b2c2e39952f141d8",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 364.32,
      "commitsBetweenForRepo": 3611,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    if (segment.ramTree !\u003d null) {\n                        builder.startArray(Fields.RAM_TREE);\n                        for (Accountable child : segment.ramTree.getChildResources()) {\n                            toXContent(builder, child);\n                        }\n                        builder.endArray();\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 103,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,59 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n+                    if (segment.ramTree !\u003d null) {\n+                        builder.startArray(Fields.RAM_TREE);\n+                        for (Accountable child : segment.ramTree.getChildResources()) {\n+                            toXContent(builder, child);\n+                        }\n+                        builder.endArray();\n+                    }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95ca06cf0945233686e92ccdb3354522ff05863c": {
      "type": "Ybodychange",
      "commitMessage": "Add the memory used on segment/segments stats\nThe memory used for the Lucene index (term dict, bloom filter, ...) can now be reported per segment using the segments API, and on the segments flag on node/indices stats\ncloses #4512\n",
      "commitDate": "2013/12/19 上午5:21",
      "commitName": "95ca06cf0945233686e92ccdb3354522ff05863c",
      "commitAuthor": "Shay Banon",
      "commitDateOld": "2013/10/14 下午5:04",
      "commitNameOld": "c093e90d517a3652d8b8f46c61a48097132a8cef",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 65.51,
      "commitsBetweenForRepo": 579,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 99,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,51 +1,52 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n+                    builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     if (segment.getMergeId() !\u003d null) {\n                         builder.field(Fields.MERGE_ID, segment.getMergeId());\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c093e90d517a3652d8b8f46c61a48097132a8cef": {
      "type": "Ybodychange",
      "commitMessage": "Segments API: Support merge id on segments (groups segments being merged)\nReturn a merge_id element in each segment of the segments API, allowing to group segments that are being merged as part of a single merge and indicate which ones are being merged now.\ncloses #3904\n",
      "commitDate": "2013/10/14 下午5:04",
      "commitName": "c093e90d517a3652d8b8f46c61a48097132a8cef",
      "commitAuthor": "Shay Banon",
      "commitDateOld": "2013/8/27 下午5:48",
      "commitNameOld": "6e19ca808056e3c69545a837180d23faa863fec7",
      "commitAuthorOld": "Luca Cavanna",
      "daysBetweenCommits": 47.97,
      "commitsBetweenForRepo": 416,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    if (segment.getMergeId() !\u003d null) {\n                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 99,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,51 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                     builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n+                    if (segment.getMergeId() !\u003d null) {\n+                        builder.field(Fields.MERGE_ID, segment.getMergeId());\n+                    }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e19ca808056e3c69545a837180d23faa863fec7": {
      "type": "Ybodychange",
      "commitMessage": "Fixed order of parameters when calling byteSizeField and timeValueField methods (introduced with #3432 - support for human readable flag)\n",
      "commitDate": "2013/8/27 下午5:48",
      "commitName": "6e19ca808056e3c69545a837180d23faa863fec7",
      "commitAuthor": "Luca Cavanna",
      "commitDateOld": "2013/8/6 下午10:08",
      "commitNameOld": "a3071540d7f245db5a55d30133bebe067ac9f7d4",
      "commitAuthorOld": "Luca Cavanna",
      "daysBetweenCommits": 20.82,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 99,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n-                    builder.byteSizeField(Fields.SIZE, Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n+                    builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a3071540d7f245db5a55d30133bebe067ac9f7d4": {
      "type": "Ybodychange",
      "commitMessage": "Added support for readable_format parameter when printing out time and size values\n\nThe following are the API affected by this change and support now the readable_format flag (default false when not specified):\n- indices segments\n- indices stats\n- indices status\n- cluster nodes stats\n- cluster nodes info\n\nCloses #3432\n",
      "commitDate": "2013/8/6 下午10:08",
      "commitName": "a3071540d7f245db5a55d30133bebe067ac9f7d4",
      "commitAuthor": "Luca Cavanna",
      "commitDateOld": "2013/3/28 下午10:34",
      "commitNameOld": "1fc37e59547ba544ab1a4677f2622c9e39b26313",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 130.98,
      "commitsBetweenForRepo": 575,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.byteSizeField(Fields.SIZE, Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 99,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,48 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.getName());\n                     builder.field(Fields.GENERATION, segment.getGeneration());\n                     builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n-                    builder.field(Fields.SIZE, segment.getSize().toString());\n-                    builder.field(Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n+                    builder.byteSizeField(Fields.SIZE, Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n                     builder.field(Fields.COMMITTED, segment.isCommitted());\n                     builder.field(Fields.SEARCH, segment.isSearch());\n                     if (segment.getVersion() !\u003d null) {\n                         builder.field(Fields.VERSION, segment.getVersion());\n                     }\n                     if (segment.isCompound() !\u003d null) {\n                         builder.field(Fields.COMPOUND, segment.isCompound());\n                     }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1fc37e59547ba544ab1a4677f2622c9e39b26313": {
      "type": "Ybodychange",
      "commitMessage": "Segments API: Add version \u0026 compound for each segment\ncloses #2823\n",
      "commitDate": "2013/3/28 下午10:34",
      "commitName": "1fc37e59547ba544ab1a4677f2622c9e39b26313",
      "commitAuthor": "Shay Banon",
      "commitDateOld": "2013/2/19 上午12:09",
      "commitNameOld": "cc83c2f848be69a77f1275fe1ff5363dcdd4c955",
      "commitAuthorOld": "David Pilato",
      "daysBetweenCommits": 37.93,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.getName());\n                    builder.field(Fields.GENERATION, segment.getGeneration());\n                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                    builder.field(Fields.SIZE, segment.getSize().toString());\n                    builder.field(Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.isCommitted());\n                    builder.field(Fields.SEARCH, segment.isSearch());\n                    if (segment.getVersion() !\u003d null) {\n                        builder.field(Fields.VERSION, segment.getVersion());\n                    }\n                    if (segment.isCompound() !\u003d null) {\n                        builder.field(Fields.COMPOUND, segment.isCompound());\n                    }\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 99,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,43 +1,49 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : getIndices().values()) {\n         builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                 if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n-                    builder.startObject(segment.name());\n-                    builder.field(Fields.GENERATION, segment.generation());\n-                    builder.field(Fields.NUM_DOCS, segment.numDocs());\n-                    builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n-                    builder.field(Fields.SIZE, segment.size().toString());\n-                    builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n-                    builder.field(Fields.COMMITTED, segment.committed());\n-                    builder.field(Fields.SEARCH, segment.search());\n+                    builder.startObject(segment.getName());\n+                    builder.field(Fields.GENERATION, segment.getGeneration());\n+                    builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n+                    builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n+                    builder.field(Fields.SIZE, segment.getSize().toString());\n+                    builder.field(Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n+                    builder.field(Fields.COMMITTED, segment.isCommitted());\n+                    builder.field(Fields.SEARCH, segment.isSearch());\n+                    if (segment.getVersion() !\u003d null) {\n+                        builder.field(Fields.VERSION, segment.getVersion());\n+                    }\n+                    if (segment.isCompound() !\u003d null) {\n+                        builder.field(Fields.COMPOUND, segment.isCompound());\n+                    }\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc83c2f848be69a77f1275fe1ff5363dcdd4c955": {
      "type": "Ybodychange",
      "commitMessage": "refactoring getter/setters\n\nFixes #2657\n",
      "commitDate": "2013/2/19 上午12:09",
      "commitName": "cc83c2f848be69a77f1275fe1ff5363dcdd4c955",
      "commitAuthor": "David Pilato",
      "commitDateOld": "2011/12/6 上午8:43",
      "commitNameOld": "6a71eab51f6d7e7a436d8986df3685c7e0774bd3",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 440.64,
      "commitsBetweenForRepo": 1362,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : getIndices().values()) {\n        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.name());\n                    builder.field(Fields.GENERATION, segment.generation());\n                    builder.field(Fields.NUM_DOCS, segment.numDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                    builder.field(Fields.SIZE, segment.size().toString());\n                    builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.committed());\n                    builder.field(Fields.SEARCH, segment.search());\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 99,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,43 +1,43 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n-    for (IndexSegments indexSegments : indices().values()) {\n-        builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n+    for (IndexSegments indexSegments : getIndices().values()) {\n+        builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n-            builder.startArray(Integer.toString(indexSegment.shardId().id()));\n+            builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n-                builder.field(Fields.STATE, shardSegments.shardRouting().state());\n-                builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n-                builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n-                if (shardSegments.shardRouting().relocatingNodeId() !\u003d null) {\n-                    builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n+                builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n+                builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n+                builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n+                if (shardSegments.getShardRouting().relocatingNodeId() !\u003d null) {\n+                    builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n-                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.numberOfCommitted());\n-                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.numberOfSearch());\n+                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n+                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.name());\n                     builder.field(Fields.GENERATION, segment.generation());\n                     builder.field(Fields.NUM_DOCS, segment.numDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                     builder.field(Fields.SIZE, segment.size().toString());\n                     builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                     builder.field(Fields.COMMITTED, segment.committed());\n                     builder.field(Fields.SEARCH, segment.search());\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": {
      "type": "Yfilerename",
      "commitMessage": "first cleanup phase, move to single src\n",
      "commitDate": "2011/12/6 上午6:59",
      "commitName": "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
      "commitAuthor": "Shay Banon",
      "commitDateOld": "2011/12/6 上午3:00",
      "commitNameOld": "473b0f4dff504690754acc0f00967c275bf322a8",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : indices().values()) {\n        builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.shardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.shardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n                if (shardSegments.shardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.numberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.numberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.name());\n                    builder.field(Fields.GENERATION, segment.generation());\n                    builder.field(Fields.NUM_DOCS, segment.numDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                    builder.field(Fields.SIZE, segment.size().toString());\n                    builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.committed());\n                    builder.field(Fields.SEARCH, segment.search());\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 100,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
        "newPath": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java"
      }
    },
    "3eaf73a380000acef6b971fe09a7d1f38aa748d1": {
      "type": "Ybodychange",
      "commitMessage": "Add number of committed and number of search segments to the segments API response\n",
      "commitDate": "2011/9/15 上午1:48",
      "commitName": "3eaf73a380000acef6b971fe09a7d1f38aa748d1",
      "commitAuthor": "Shay Banon",
      "commitDateOld": "2011/6/26 上午5:20",
      "commitNameOld": "b670a7f2a345aa2507714c1e8b61906c679c1107",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 80.85,
      "commitsBetweenForRepo": 367,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : indices().values()) {\n        builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.shardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.shardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n                if (shardSegments.shardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.numberOfCommitted());\n                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.numberOfSearch());\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.name());\n                    builder.field(Fields.GENERATION, segment.generation());\n                    builder.field(Fields.NUM_DOCS, segment.numDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                    builder.field(Fields.SIZE, segment.size().toString());\n                    builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.committed());\n                    builder.field(Fields.SEARCH, segment.search());\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 100,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,43 @@\n @Override\n public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n     builder.startObject(Fields.INDICES);\n     for (IndexSegments indexSegments : indices().values()) {\n         builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n         builder.startObject(Fields.SHARDS);\n         for (IndexShardSegments indexSegment : indexSegments) {\n             builder.startArray(Integer.toString(indexSegment.shardId().id()));\n             for (ShardSegments shardSegments : indexSegment) {\n                 builder.startObject();\n                 builder.startObject(Fields.ROUTING);\n                 builder.field(Fields.STATE, shardSegments.shardRouting().state());\n                 builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n                 builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n                 if (shardSegments.shardRouting().relocatingNodeId() !\u003d null) {\n                     builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n                 }\n                 builder.endObject();\n+                builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.numberOfCommitted());\n+                builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.numberOfSearch());\n                 builder.startObject(Fields.SEGMENTS);\n                 for (Segment segment : shardSegments) {\n                     builder.startObject(segment.name());\n                     builder.field(Fields.GENERATION, segment.generation());\n                     builder.field(Fields.NUM_DOCS, segment.numDocs());\n                     builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                     builder.field(Fields.SIZE, segment.size().toString());\n                     builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                     builder.field(Fields.COMMITTED, segment.committed());\n                     builder.field(Fields.SEARCH, segment.search());\n                     builder.endObject();\n                 }\n                 builder.endObject();\n                 builder.endObject();\n             }\n             builder.endArray();\n         }\n         builder.endObject();\n         builder.endObject();\n     }\n     builder.endObject();\n     return builder;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b670a7f2a345aa2507714c1e8b61906c679c1107": {
      "type": "Yintroduced",
      "commitMessage": "Indices Segments API: Internal segments info of shard level Lucene indices, closes #1064.\n",
      "commitDate": "2011/6/26 上午5:20",
      "commitName": "b670a7f2a345aa2507714c1e8b61906c679c1107",
      "commitAuthor": "kimchy",
      "diff": "@@ -0,0 +1,41 @@\n+@Override\n+public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+    builder.startObject(Fields.INDICES);\n+    for (IndexSegments indexSegments : indices().values()) {\n+        builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n+        builder.startObject(Fields.SHARDS);\n+        for (IndexShardSegments indexSegment : indexSegments) {\n+            builder.startArray(Integer.toString(indexSegment.shardId().id()));\n+            for (ShardSegments shardSegments : indexSegment) {\n+                builder.startObject();\n+                builder.startObject(Fields.ROUTING);\n+                builder.field(Fields.STATE, shardSegments.shardRouting().state());\n+                builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n+                builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n+                if (shardSegments.shardRouting().relocatingNodeId() !\u003d null) {\n+                    builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n+                }\n+                builder.endObject();\n+                builder.startObject(Fields.SEGMENTS);\n+                for (Segment segment : shardSegments) {\n+                    builder.startObject(segment.name());\n+                    builder.field(Fields.GENERATION, segment.generation());\n+                    builder.field(Fields.NUM_DOCS, segment.numDocs());\n+                    builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n+                    builder.field(Fields.SIZE, segment.size().toString());\n+                    builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n+                    builder.field(Fields.COMMITTED, segment.committed());\n+                    builder.field(Fields.SEARCH, segment.search());\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+                builder.endObject();\n+            }\n+            builder.endArray();\n+        }\n+        builder.endObject();\n+        builder.endObject();\n+    }\n+    builder.endObject();\n+    return builder;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n    builder.startObject(Fields.INDICES);\n    for (IndexSegments indexSegments : indices().values()) {\n        builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n        builder.startObject(Fields.SHARDS);\n        for (IndexShardSegments indexSegment : indexSegments) {\n            builder.startArray(Integer.toString(indexSegment.shardId().id()));\n            for (ShardSegments shardSegments : indexSegment) {\n                builder.startObject();\n                builder.startObject(Fields.ROUTING);\n                builder.field(Fields.STATE, shardSegments.shardRouting().state());\n                builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n                builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n                if (shardSegments.shardRouting().relocatingNodeId() !\u003d null) {\n                    builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n                }\n                builder.endObject();\n                builder.startObject(Fields.SEGMENTS);\n                for (Segment segment : shardSegments) {\n                    builder.startObject(segment.name());\n                    builder.field(Fields.GENERATION, segment.generation());\n                    builder.field(Fields.NUM_DOCS, segment.numDocs());\n                    builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                    builder.field(Fields.SIZE, segment.size().toString());\n                    builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                    builder.field(Fields.COMMITTED, segment.committed());\n                    builder.field(Fields.SEARCH, segment.search());\n                    builder.endObject();\n                }\n                builder.endObject();\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        builder.endObject();\n        builder.endObject();\n    }\n    builder.endObject();\n    return builder;\n}",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
      "functionStartLine": 100,
      "functionName": "toXContent",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}