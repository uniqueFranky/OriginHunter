{
  "origin": "codeshovel",
  "repositoryName": "lucene-solr",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/lucene-solr/.git",
  "startCommitName": "38bf976cd4b9e324c21664bd7ae3d554df803705",
  "sourceFileName": "MemoryIndex.java",
  "functionName": "storeDocValues",
  "functionId": "storeDocValues___info-Info__docValuesType-DocValuesType__docValuesValue-Object",
  "sourceFilePath": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 515,
  "functionEndLine": 566,
  "numCommitsSeen": 110,
  "timeTaken": 2522,
  "changeHistory": [
    "e7a0a12926c399758a4021715a7419e22e59dab6",
    "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
    "a2d927667418d17a1f5f31a193092d5b04a4219e",
    "cf3eea26406692306505d2606d7ff73ee3634c30"
  ],
  "changeHistoryShort": {
    "e7a0a12926c399758a4021715a7419e22e59dab6": "Ybodychange",
    "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a": "Ybodychange",
    "a2d927667418d17a1f5f31a193092d5b04a4219e": "Ybodychange",
    "cf3eea26406692306505d2606d7ff73ee3634c30": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e7a0a12926c399758a4021715a7419e22e59dab6": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-8335: Enforce soft-deletes field up-front\n\nSoft deletes field must be marked as such once it\u0027s introduced\nand can\u0027t be changed after the fact.\n\nCo-authored-by: Nhat Nguyen \u003cnhat.nguyen@elastic.co\u003e\n",
      "commitDate": "2018/6/4 下午2:28",
      "commitName": "e7a0a12926c399758a4021715a7419e22e59dab6",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2018/6/2 下午7:47",
      "commitNameOld": "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField());\n    } else if (existingDocValuesType !\u003d docValuesType) {\n        throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch(docValuesType) {\n        case NUMERIC:\n            if (info.numericProducer.dvLongValues !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n            info.numericProducer.count++;\n            break;\n        case SORTED_NUMERIC:\n            if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                info.numericProducer.dvLongValues \u003d new long[4];\n            }\n            info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n            info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n            break;\n        case BINARY:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED_SET:\n            if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            }\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        default:\n            throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n}",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,47 @@\n private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName \u003d info.fieldInfo.name;\n     DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n-        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes());\n+        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField());\n     } else if (existingDocValuesType !\u003d docValuesType) {\n         throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch(docValuesType) {\n         case NUMERIC:\n             if (info.numericProducer.dvLongValues !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n             info.numericProducer.count++;\n             break;\n         case SORTED_NUMERIC:\n             if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                 info.numericProducer.dvLongValues \u003d new long[4];\n             }\n             info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n             info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n             break;\n         case BINARY:\n             if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         case SORTED:\n             if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         case SORTED_SET:\n             if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                 info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             }\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         default:\n             throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"LUCENE-8335: Enforce soft-deletes field up-front.\"\n\nThis reverts commit a2d927667418d17a1f5f31a193092d5b04a4219e.\n",
      "commitDate": "2018/6/2 下午7:47",
      "commitName": "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2018/6/2 下午7:14",
      "commitNameOld": "a2d927667418d17a1f5f31a193092d5b04a4219e",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes());\n    } else if (existingDocValuesType !\u003d docValuesType) {\n        throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch(docValuesType) {\n        case NUMERIC:\n            if (info.numericProducer.dvLongValues !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n            info.numericProducer.count++;\n            break;\n        case SORTED_NUMERIC:\n            if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                info.numericProducer.dvLongValues \u003d new long[4];\n            }\n            info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n            info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n            break;\n        case BINARY:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED_SET:\n            if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            }\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        default:\n            throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n}",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,47 @@\n private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName \u003d info.fieldInfo.name;\n     DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n-        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField());\n+        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes());\n     } else if (existingDocValuesType !\u003d docValuesType) {\n         throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch(docValuesType) {\n         case NUMERIC:\n             if (info.numericProducer.dvLongValues !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n             info.numericProducer.count++;\n             break;\n         case SORTED_NUMERIC:\n             if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                 info.numericProducer.dvLongValues \u003d new long[4];\n             }\n             info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n             info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n             break;\n         case BINARY:\n             if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         case SORTED:\n             if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         case SORTED_SET:\n             if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                 info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             }\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         default:\n             throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d927667418d17a1f5f31a193092d5b04a4219e": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-8335: Enforce soft-deletes field up-front.\n\nSoft deletes field must be marked as such once it\u0027s introduced\nand can\u0027t be changed after the fact.\n",
      "commitDate": "2018/6/2 下午7:14",
      "commitName": "a2d927667418d17a1f5f31a193092d5b04a4219e",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2018/5/2 下午8:49",
      "commitNameOld": "af680af77f3f80c779e038a0ad8a136c9dcb9f5d",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 30.93,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "actualSource": "private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField());\n    } else if (existingDocValuesType !\u003d docValuesType) {\n        throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch(docValuesType) {\n        case NUMERIC:\n            if (info.numericProducer.dvLongValues !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n            info.numericProducer.count++;\n            break;\n        case SORTED_NUMERIC:\n            if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                info.numericProducer.dvLongValues \u003d new long[4];\n            }\n            info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n            info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n            break;\n        case BINARY:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED_SET:\n            if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            }\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        default:\n            throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n}",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,47 @@\n private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName \u003d info.fieldInfo.name;\n     DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n-        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes());\n+        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField());\n     } else if (existingDocValuesType !\u003d docValuesType) {\n         throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch(docValuesType) {\n         case NUMERIC:\n             if (info.numericProducer.dvLongValues !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n             info.numericProducer.count++;\n             break;\n         case SORTED_NUMERIC:\n             if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                 info.numericProducer.dvLongValues \u003d new long[4];\n             }\n             info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n             info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n             break;\n         case BINARY:\n             if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         case SORTED:\n             if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                 throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n             }\n             info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         case SORTED_SET:\n             if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                 info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n             }\n             info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n             break;\n         default:\n             throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cf3eea26406692306505d2606d7ff73ee3634c30": {
      "type": "Yintroduced",
      "commitMessage": "LUCENE-7091: Added doc values support to memory index\n",
      "commitDate": "2016/3/15 下午4:57",
      "commitName": "cf3eea26406692306505d2606d7ff73ee3634c30",
      "commitAuthor": "Martijn van Groningen",
      "diff": "@@ -0,0 +1,47 @@\n+private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n+    String fieldName \u003d info.fieldInfo.name;\n+    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n+    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n+        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes());\n+    } else if (existingDocValuesType !\u003d docValuesType) {\n+        throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n+    }\n+    switch(docValuesType) {\n+        case NUMERIC:\n+            if (info.numericProducer.dvLongValues !\u003d null) {\n+                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+            }\n+            info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n+            info.numericProducer.count++;\n+            break;\n+        case SORTED_NUMERIC:\n+            if (info.numericProducer.dvLongValues \u003d\u003d null) {\n+                info.numericProducer.dvLongValues \u003d new long[4];\n+            }\n+            info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n+            info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n+            break;\n+        case BINARY:\n+            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n+                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+            }\n+            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n+            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+            break;\n+        case SORTED:\n+            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n+                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+            }\n+            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n+            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+            break;\n+        case SORTED_SET:\n+            if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n+                info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n+            }\n+            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+            break;\n+        default:\n+            throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n        info.fieldInfo \u003d new FieldInfo(info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(), info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(), info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes());\n    } else if (existingDocValuesType !\u003d docValuesType) {\n        throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch(docValuesType) {\n        case NUMERIC:\n            if (info.numericProducer.dvLongValues !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.numericProducer.dvLongValues \u003d new long[] { (long) docValuesValue };\n            info.numericProducer.count++;\n            break;\n        case SORTED_NUMERIC:\n            if (info.numericProducer.dvLongValues \u003d\u003d null) {\n                info.numericProducer.dvLongValues \u003d new long[4];\n            }\n            info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n            info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n            break;\n        case BINARY:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED:\n            if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n                throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n            }\n            info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        case SORTED_SET:\n            if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n                info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n            }\n            info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n            break;\n        default:\n            throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n}",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}