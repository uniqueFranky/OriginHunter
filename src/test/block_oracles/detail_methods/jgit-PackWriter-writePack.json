{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "PackWriter.java",
  "functionName": "writePack",
  "functionId": "writePack___compressMonitor-ProgressMonitor__writeMonitor-ProgressMonitor__packStream-OutputStream",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
  "functionAnnotation": "",
  "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after\n{@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set, Set)} or\n{@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws java.io.IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link org.eclipse.jgit.transport.ObjectCountCallback} .\n",
  "functionStartLine": 1106,
  "functionEndLine": 1190,
  "numCommitsSeen": 175,
  "timeTaken": 4082,
  "changeHistory": [
    "783dbf1b03cdabc5a8db63c9ac10fae164e6cf41",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
    "4bb523475d44ec1c4d9b4f92944a359aef99894c",
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
    "9cbe2228376808239b7e9efb5d7424d6762b3982",
    "53be446f6a0a9776c5fd0d507fe11b14d79104c2",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "6e5c71b358e9b9b883f24f073e869ff6affe5bf4",
    "bc90ce7788e77af11552799cecf65edeb97e3b7c",
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
    "f32b8612433e499090c76ded014dd5e94322b786",
    "1421106d7627eb2c55b97b70d105b5ba1e26a2c0",
    "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
    "1b6a549ff350673402f797fe7f878175e2b5ba30",
    "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
    "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b",
    "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
    "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
    "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267",
    "65f9a6e58bd9296cbbe1cffc7cf079fd65991686",
    "a468cb57c2f2fbd8da163f002b505255ea768244",
    "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0",
    "14f99dc29d67fa4d2cb227ab906c5c8379499f6b",
    "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
    "461b012e9565af8174e5b9d2b2c3a582011ce77e",
    "71f168fcd77ec100d68233d3d467f770304f6eb8",
    "28ba4747bc166243ecff86cdc7460cbc969a8eb4",
    "b85af06324644e699bd2cc7e2047ae1f65f35db5",
    "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3",
    "1a06179ea707ab088b6543df77be5cf0ea44c497",
    "21f76c2a69836ec618c82eb9305656dcec70befb",
    "a00377a7e23dbde315598ee20f61c45d031e159a",
    "dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33",
    "074055d747026c47040d0306585863ad5d428860",
    "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
    "6b62e53b607630b6c00411741972838ced552f4d",
    "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
    "a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4",
    "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1",
    "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
    "ece88b99eb2ea6541b667aa066573184c25b6a8b",
    "2156aa894cefbabd322fc405138c306bb4e939cd",
    "1a6964c8274c50f0253db75f010d78ef0e739343"
  ],
  "changeHistoryShort": {
    "783dbf1b03cdabc5a8db63c9ac10fae164e6cf41": "Ydocchange",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": "Ydocchange",
    "4bb523475d44ec1c4d9b4f92944a359aef99894c": "Ydocchange",
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": "Ybodychange",
    "9cbe2228376808239b7e9efb5d7424d6762b3982": "Ydocchange",
    "53be446f6a0a9776c5fd0d507fe11b14d79104c2": "Ymultichange(Ybodychange,Ydocchange)",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "6e5c71b358e9b9b883f24f073e869ff6affe5bf4": "Ybodychange",
    "bc90ce7788e77af11552799cecf65edeb97e3b7c": "Ybodychange",
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c": "Ybodychange",
    "f32b8612433e499090c76ded014dd5e94322b786": "Yfilerename",
    "1421106d7627eb2c55b97b70d105b5ba1e26a2c0": "Ybodychange",
    "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1": "Ybodychange",
    "1b6a549ff350673402f797fe7f878175e2b5ba30": "Ybodychange",
    "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003": "Ybodychange",
    "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b": "Ybodychange",
    "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17": "Ybodychange",
    "bb1956e647d2f48ef36ef98a7f22120fdad0b37c": "Ybodychange",
    "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267": "Ybodychange",
    "65f9a6e58bd9296cbbe1cffc7cf079fd65991686": "Ybodychange",
    "a468cb57c2f2fbd8da163f002b505255ea768244": "Ybodychange",
    "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0": "Ybodychange",
    "14f99dc29d67fa4d2cb227ab906c5c8379499f6b": "Ybodychange",
    "c8c4524b6b36c1d97e715de9e1ff1aa18763a390": "Ybodychange",
    "461b012e9565af8174e5b9d2b2c3a582011ce77e": "Ybodychange",
    "71f168fcd77ec100d68233d3d467f770304f6eb8": "Ybodychange",
    "28ba4747bc166243ecff86cdc7460cbc969a8eb4": "Ybodychange",
    "b85af06324644e699bd2cc7e2047ae1f65f35db5": "Ybodychange",
    "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3": "Ybodychange",
    "1a06179ea707ab088b6543df77be5cf0ea44c497": "Ybodychange",
    "21f76c2a69836ec618c82eb9305656dcec70befb": "Ymultichange(Ybodychange,Ydocchange)",
    "a00377a7e23dbde315598ee20f61c45d031e159a": "Ydocchange",
    "dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33": "Ybodychange",
    "074055d747026c47040d0306585863ad5d428860": "Ybodychange",
    "4569d77e13c7bbf0c7466cbc57d0eefd117cb206": "Ymultichange(Ybodychange,Ydocchange)",
    "6b62e53b607630b6c00411741972838ced552f4d": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "f288c27e465a91e80b53c4100c0d9b2f2341a9aa": "Ybodychange",
    "a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4": "Ybodychange",
    "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1": "Ybodychange",
    "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066": "Yfilerename",
    "ece88b99eb2ea6541b667aa066573184c25b6a8b": "Ybodychange",
    "2156aa894cefbabd322fc405138c306bb4e939cd": "Ymultichange(Ybodychange,Ydocchange)",
    "1a6964c8274c50f0253db75f010d78ef0e739343": "Yintroduced"
  },
  "changeHistoryDetails": {
    "783dbf1b03cdabc5a8db63c9ac10fae164e6cf41": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit storage/pack package\n\nChange-Id: Id1b7d392e1bb36079edaf16450e73a044a318e7e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/19 下午8:39",
      "commitName": "783dbf1b03cdabc5a8db63c9ac10fae164e6cf41",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/11/11 上午7:41",
      "commitNameOld": "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07",
      "commitAuthorOld": "Jonathan Tan",
      "daysBetweenCommits": 38.54,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1076,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after\n{@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set, Set)} or\n{@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws java.io.IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link org.eclipse.jgit.transport.ObjectCountCallback} .\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after\n{@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set, Set)} or\n{@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by {@link ObjectCountCallback}\n            .\n",
        "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after\n{@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set, Set)} or\n{@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws java.io.IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link org.eclipse.jgit.transport.ObjectCountCallback} .\n"
      }
    },
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": {
      "type": "Ydocchange",
      "commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter\u0027s \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from \u003c700 to \u003e10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2017/5/19 上午6:25",
      "commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2017/5/4 上午6:02",
      "commitNameOld": "8f7d0a4fbe8862e71d900b0585c97407037ef9a5",
      "commitAuthorOld": "Zhen Chen",
      "daysBetweenCommits": 15.02,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1037,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after\n{@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set, Set)} or\n{@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by {@link ObjectCountCallback}\n            .\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after {@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set)}\nor {@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by {@link ObjectCountCallback}\n            .\n",
        "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after\n{@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set, Set)} or\n{@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by {@link ObjectCountCallback}\n            .\n"
      }
    },
    "4bb523475d44ec1c4d9b4f92944a359aef99894c": {
      "type": "Ydocchange",
      "commitMessage": "PackWriter: shed memory while creating bitmaps\n\nOnce bitmap creation begins the internal maps required for packing are\nno longer necessary.  On a repository with 5.2M objects this can save\nmore than 438 MiB of memory by allowing the ObjectToPack instances to\nget garbage collected away.\n\nDownside is the PackWriter cannot be used for any further opertions\nexcept to write the bitmap index.  This is an acceptable trade-off as\nin practice nobody uses the PackWriter after the bitmaps are built.\n\nChange-Id: Ibfaf84b22fa0590896a398ff659a91fcf03d7128\n",
      "commitDate": "2015/8/14 上午1:13",
      "commitName": "4bb523475d44ec1c4d9b4f92944a359aef99894c",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2015/6/17 上午1:08",
      "commitNameOld": "8b20f2c89030591b645a9e349d6f94c065ace0e6",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 58.0,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 947,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after {@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set)}\nor {@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by {@link ObjectCountCallback}\n            .\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link ObjectCountCallback}.\n",
        "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nCalled after {@link #preparePack(ProgressMonitor, ObjectWalk, Set, Set)}\nor {@link #preparePack(ProgressMonitor, Set, Set)}.\n\u003cp\u003e\nPerforms delta search if enabled and writes the pack stream.\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by {@link ObjectCountCallback}\n            .\n"
      }
    },
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": {
      "type": "Ybodychange",
      "commitMessage": "Introduce PostUploadHook to replace UploadPackLogger\n\nUploadPackLogger is incorrectly named--it can be used to trigger any\npost upload action, such as GC/compaction. This change introduces\nPostUploadHook/PostUploadHookChain to replace\nUploadPackLogger/UploadPackLoggerChain and deprecates the latter.\n\nIt also introduces PackStatistics as a replacement for\nPackWriter.Statistics, since the latter is not public API.\nIt changes PackWriter to use PackStatistics and reimplements\nPackWriter.Statistics to delegate to PackStatistics.\n\nChange-Id: Ic51df1613e471f568ffee25ae67e118425b38986\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015/6/13 上午4:56",
      "commitName": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015/6/10 上午8:20",
      "commitNameOld": "9cbe2228376808239b7e9efb5d7424d6762b3982",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 2.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 935,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link ObjectCountCallback}.\n",
      "diff": "@@ -1,63 +1,63 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     crc32 \u003d new CRC32();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     if (callback !\u003d null)\n         callback.setObjectCount(objCnt);\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     try {\n         out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n         out.flush();\n         writeObjects(out);\n         if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n-            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n+            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                 if (typeStat \u003d\u003d null)\n                     continue;\n                 stats.thinPackBytes +\u003d typeStat.bytes;\n             }\n         }\n         stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n         for (CachedPack pack : cachedPacks) {\n             long deltaCnt \u003d pack.getDeltaCount();\n             stats.reusedObjects +\u003d pack.getObjectCount();\n             stats.reusedDeltas +\u003d deltaCnt;\n             stats.totalDeltas +\u003d deltaCnt;\n             reuseSupport.copyPackAsIs(out, pack);\n         }\n         writeChecksum(out);\n         out.flush();\n     } finally {\n         stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n         stats.depth \u003d depth;\n-        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n+        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n             stats.reusedObjects +\u003d typeStat.reusedObjects;\n             stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n             stats.totalDeltas +\u003d typeStat.cntDeltas;\n         }\n     }\n     stats.totalBytes \u003d out.length();\n     reader.close();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9cbe2228376808239b7e9efb5d7424d6762b3982": {
      "type": "Ydocchange",
      "commitMessage": "Fix public API issues introduced in I1baeedcc6946.\n\nMove ObjectCountCallback and WriteAbortedException to package\norg.eclipse.jgit.transport, so that they\u0027ll become public API.\n\nChange-Id: I95e3cfaa49f3f7371e794d5c253cf6981f87cae0\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015/6/10 上午8:20",
      "commitName": "9cbe2228376808239b7e9efb5d7424d6762b3982",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015/6/10 上午7:26",
      "commitNameOld": "65ceb23c8163e14e2fcf558d4eedc313e6db7b8f",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 934,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link ObjectCountCallback}.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link PackWriter.ObjectCountCallback}.\n",
        "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link ObjectCountCallback}.\n"
      }
    },
    "53be446f6a0a9776c5fd0d507fe11b14d79104c2": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Callback in PackWriter \u0026 BundleWriter.\n\nAdded callback in PackWriter and BundleWriter for the caller to get the\ncount of objects to write, and a chance to abort the write operation.\n\nChange-Id: I1baeedcc6946b1093652de4a707fe597a577e526\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015/6/10 上午5:11",
      "commitName": "53be446f6a0a9776c5fd0d507fe11b14d79104c2",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Callback in PackWriter \u0026 BundleWriter.\n\nAdded callback in PackWriter and BundleWriter for the caller to get the\ncount of objects to write, and a chance to abort the write operation.\n\nChange-Id: I1baeedcc6946b1093652de4a707fe597a577e526\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
          "commitDate": "2015/6/10 上午5:11",
          "commitName": "53be446f6a0a9776c5fd0d507fe11b14d79104c2",
          "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
          "commitDateOld": "2015/6/3 上午10:49",
          "commitNameOld": "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
          "commitAuthorOld": "Terry Parker",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 954,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link PackWriter.ObjectCountCallback}.\n",
          "diff": "@@ -1,61 +1,63 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     crc32 \u003d new CRC32();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n+    if (callback !\u003d null)\n+        callback.setObjectCount(objCnt);\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     try {\n         out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n         out.flush();\n         writeObjects(out);\n         if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n             for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                 if (typeStat \u003d\u003d null)\n                     continue;\n                 stats.thinPackBytes +\u003d typeStat.bytes;\n             }\n         }\n         stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n         for (CachedPack pack : cachedPacks) {\n             long deltaCnt \u003d pack.getDeltaCount();\n             stats.reusedObjects +\u003d pack.getObjectCount();\n             stats.reusedDeltas +\u003d deltaCnt;\n             stats.totalDeltas +\u003d deltaCnt;\n             reuseSupport.copyPackAsIs(out, pack);\n         }\n         writeChecksum(out);\n         out.flush();\n     } finally {\n         stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n         stats.depth \u003d depth;\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n             stats.reusedObjects +\u003d typeStat.reusedObjects;\n             stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n             stats.totalDeltas +\u003d typeStat.cntDeltas;\n         }\n     }\n     stats.totalBytes \u003d out.length();\n     reader.close();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Callback in PackWriter \u0026 BundleWriter.\n\nAdded callback in PackWriter and BundleWriter for the caller to get the\ncount of objects to write, and a chance to abort the write operation.\n\nChange-Id: I1baeedcc6946b1093652de4a707fe597a577e526\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
          "commitDate": "2015/6/10 上午5:11",
          "commitName": "53be446f6a0a9776c5fd0d507fe11b14d79104c2",
          "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
          "commitDateOld": "2015/6/3 上午10:49",
          "commitNameOld": "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
          "commitAuthorOld": "Terry Parker",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    if (callback !\u003d null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 954,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link PackWriter.ObjectCountCallback}.\n",
          "diff": "@@ -1,61 +1,63 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     crc32 \u003d new CRC32();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n+    if (callback !\u003d null)\n+        callback.setObjectCount(objCnt);\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     try {\n         out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n         out.flush();\n         writeObjects(out);\n         if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n             for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                 if (typeStat \u003d\u003d null)\n                     continue;\n                 stats.thinPackBytes +\u003d typeStat.bytes;\n             }\n         }\n         stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n         for (CachedPack pack : cachedPacks) {\n             long deltaCnt \u003d pack.getDeltaCount();\n             stats.reusedObjects +\u003d pack.getObjectCount();\n             stats.reusedDeltas +\u003d deltaCnt;\n             stats.totalDeltas +\u003d deltaCnt;\n             reuseSupport.copyPackAsIs(out, pack);\n         }\n         writeChecksum(out);\n         out.flush();\n     } finally {\n         stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n         stats.depth \u003d depth;\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n             stats.reusedObjects +\u003d typeStat.reusedObjects;\n             stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n             stats.totalDeltas +\u003d typeStat.cntDeltas;\n         }\n     }\n     stats.totalBytes \u003d out.length();\n     reader.close();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
            "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n@throws WriteAbortedException\n            the write operation is aborted by\n            {@link PackWriter.ObjectCountCallback}.\n"
          }
        }
      ]
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/21 上午6:01",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015/5/11 上午1:45",
      "commitNameOld": "53e39094bf012a4f5b3fe5557219707cb7b0f010",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 10.18,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 910,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     crc32 \u003d new CRC32();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     try {\n         out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n         out.flush();\n         writeObjects(out);\n         if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n             for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                 if (typeStat \u003d\u003d null)\n                     continue;\n                 stats.thinPackBytes +\u003d typeStat.bytes;\n             }\n         }\n         stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n         for (CachedPack pack : cachedPacks) {\n             long deltaCnt \u003d pack.getDeltaCount();\n             stats.reusedObjects +\u003d pack.getObjectCount();\n             stats.reusedDeltas +\u003d deltaCnt;\n             stats.totalDeltas +\u003d deltaCnt;\n             reuseSupport.copyPackAsIs(out, pack);\n         }\n         writeChecksum(out);\n         out.flush();\n     } finally {\n         stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n         stats.depth \u003d depth;\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n             stats.reusedObjects +\u003d typeStat.reusedObjects;\n             stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n             stats.totalDeltas +\u003d typeStat.cntDeltas;\n         }\n     }\n     stats.totalBytes \u003d out.length();\n-    reader.release();\n+    reader.close();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e5c71b358e9b9b883f24f073e869ff6affe5bf4": {
      "type": "Ybodychange",
      "commitMessage": "Remove validate support when reusing cached pack\n\nCached packs are only used when writing over the network or to\na bundle file and reuse validation is always disabled in these\ntwo contexts. The client/consumer of the stream will be SHA-1\nchecksumming every object.\n\nReuse validation is most critical during local GC to avoid silently\nignoring corruption by stopping as soon as a problem is found and\nleaving everything alone for the end-user to debug and salvage.\nCached packs are not supported during local GC as the bitmap rebuild\nlogic does not support including a cached pack in the result.\n\nStrip out the validation and force PackWriter to always disable the\ncached pack feature if reuseValidation is enabled.\n\nChange-Id: If0d7baf2ae1bf1f7e71bf773151302c9f7887039\n",
      "commitDate": "2015/4/25 上午2:31",
      "commitName": "6e5c71b358e9b9b883f24f073e869ff6affe5bf4",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2015/2/9 下午9:11",
      "commitNameOld": "77030a5e94a90cfae223acc477c216603cf3f149",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 74.22,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.release();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 990,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     crc32 \u003d new CRC32();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     try {\n         out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n         out.flush();\n         writeObjects(out);\n         if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n             for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                 if (typeStat \u003d\u003d null)\n                     continue;\n                 stats.thinPackBytes +\u003d typeStat.bytes;\n             }\n         }\n         stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n         for (CachedPack pack : cachedPacks) {\n             long deltaCnt \u003d pack.getDeltaCount();\n             stats.reusedObjects +\u003d pack.getObjectCount();\n             stats.reusedDeltas +\u003d deltaCnt;\n             stats.totalDeltas +\u003d deltaCnt;\n-            reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n+            reuseSupport.copyPackAsIs(out, pack);\n         }\n         writeChecksum(out);\n         out.flush();\n     } finally {\n         stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n         stats.depth \u003d depth;\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n             stats.reusedObjects +\u003d typeStat.reusedObjects;\n             stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n             stats.totalDeltas +\u003d typeStat.cntDeltas;\n         }\n     }\n     stats.totalBytes \u003d out.length();\n     reader.release();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bc90ce7788e77af11552799cecf65edeb97e3b7c": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Report more stats during partial writes\n\nIt can be useful for a server operator to know how long a pack\nwriter spent writing out objects, even if the request aborts and\nnever finishes.\n\nRecord more of the stats data inside of a finally block, to\nensure these can be included into the server\u0027s monitoring.\n\nChange-Id: I00858aa393a948f8e742e64ae4c00953eadaef95\n",
      "commitDate": "2014/9/5 上午3:45",
      "commitName": "bc90ce7788e77af11552799cecf65edeb97e3b7c",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2014/3/30 上午1:34",
      "commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 159.09,
      "commitsBetweenForRepo": 212,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat \u003d\u003d null)\n                    continue;\n                stats.thinPackBytes +\u003d typeStat.bytes;\n            }\n        }\n        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt \u003d pack.getDeltaCount();\n            stats.reusedObjects +\u003d pack.getObjectCount();\n            stats.reusedDeltas +\u003d deltaCnt;\n            stats.totalDeltas +\u003d deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n        stats.depth \u003d depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n            stats.reusedObjects +\u003d typeStat.reusedObjects;\n            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n            stats.totalDeltas +\u003d typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes \u003d out.length();\n    reader.release();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 990,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,58 +1,61 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     crc32 \u003d new CRC32();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n-    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n-    out.flush();\n-    writeObjects(out);\n-    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n+    try {\n+        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n+        out.flush();\n+        writeObjects(out);\n+        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n+            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n+                if (typeStat \u003d\u003d null)\n+                    continue;\n+                stats.thinPackBytes +\u003d typeStat.bytes;\n+            }\n+        }\n+        stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n+        for (CachedPack pack : cachedPacks) {\n+            long deltaCnt \u003d pack.getDeltaCount();\n+            stats.reusedObjects +\u003d pack.getObjectCount();\n+            stats.reusedDeltas +\u003d deltaCnt;\n+            stats.totalDeltas +\u003d deltaCnt;\n+            reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n+        }\n+        writeChecksum(out);\n+        out.flush();\n+    } finally {\n+        stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n+        stats.depth \u003d depth;\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n-            stats.thinPackBytes +\u003d typeStat.bytes;\n+            typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n+            stats.reusedObjects +\u003d typeStat.reusedObjects;\n+            stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n+            stats.totalDeltas +\u003d typeStat.cntDeltas;\n         }\n     }\n-    for (CachedPack pack : cachedPacks) {\n-        long deltaCnt \u003d pack.getDeltaCount();\n-        stats.reusedObjects +\u003d pack.getObjectCount();\n-        stats.reusedDeltas +\u003d deltaCnt;\n-        stats.totalDeltas +\u003d deltaCnt;\n-        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n-    }\n-    writeChecksum(out);\n-    out.flush();\n-    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n-    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n-    stats.depth \u003d depth;\n-    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n-        if (typeStat \u003d\u003d null)\n-            continue;\n-        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n-        stats.reusedObjects +\u003d typeStat.reusedObjects;\n-        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n-        stats.totalDeltas +\u003d typeStat.cntDeltas;\n-    }\n     reader.release();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c": {
      "type": "Ybodychange",
      "commitMessage": "Disable CRC32 computation when no PackIndex will be created\n\nIf a server is streaming 3GiB worth of pack data to a client there\nis no reason to compute the CRC32 checksum on the objects. The\nCRC32 code computed by PackWriter is used only in the new index\ncreated by writeIndex(), which is never invoked for the native Git\nnetwork protocols.\n\nObject reuse may still compute its own CRC32 to verify the data\nbeing copied from an existing pack has not been corrupted. This\ncheck is done by the ObjectReader that implements ObjectReuseAsIs\nand has no relationship to the CRC32 being skipped during output.\n\nChange-Id: I05626f2e0d6ce19119b57d8a27193922636d60a7\n",
      "commitDate": "2013/4/11 上午3:58",
      "commitName": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/4/11 上午2:34",
      "commitNameOld": "d0a533762586ce331a8f967042fa209c847c3c8d",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 \u003d new CRC32();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    stats.depth \u003d depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 988,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,57 +1,58 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n-    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n+    crc32 \u003d new CRC32();\n+    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     stats.depth \u003d depth;\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f32b8612433e499090c76ded014dd5e94322b786": {
      "type": "Yfilerename",
      "commitMessage": "JGit 3.0: move internal classes into an internal subpackage\n\nThis breaks all existing callers once. Applications are not supposed\nto build against the internal storage API unless they can accept API\nchurn and make necessary updates as versions change.\n\nChange-Id: I2ab1327c202ef2003565e1b0770a583970e432e9\n",
      "commitDate": "2013/3/19 上午12:30",
      "commitName": "f32b8612433e499090c76ded014dd5e94322b786",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/3/18 下午10:35",
      "commitNameOld": "462bbc052e766ee9ea585cd4366165a8dac86496",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    stats.depth \u003d depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 964,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
        "newPath": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java"
      }
    },
    "1421106d7627eb2c55b97b70d105b5ba1e26a2c0": {
      "type": "Ybodychange",
      "commitMessage": "Use long for more object counts in PackWriter\n\nPacks can contain up to 2^32-1 objects, which exceeds the range of a\nJava int. Try harder to accept higher object counts in some cases by\nusing long more often when we are working with the object count value.\n\nThis is a trivial refactoring, we may have to make even more changes\nto the object handling code to support more than 2^31-1 objects.\n\nChange-Id: I8cd8146e97cd1c738ad5b48fa9e33804982167e7\n",
      "commitDate": "2011/11/19 上午7:55",
      "commitName": "1421106d7627eb2c55b97b70d105b5ba1e26a2c0",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/11/19 上午7:55",
      "commitNameOld": "41a18d57bcaf3bb7eb4bcee5c1d53a222d07316b",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    stats.depth \u003d depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 856,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,57 +1,57 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n-    beginPhase(PackingPhase.WRITING, writeMonitor, (int) objCnt);\n+    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     stats.depth \u003d depth;\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n     endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1": {
      "type": "Ybodychange",
      "commitMessage": "Add an object encapsulating the state of a PackWriter\n\nExposes essentially the same state machine to the programmer as is\nexposed to the client via a ProgressMonitor, using a wrapper around\nbeginTask()/endTask().\n\nChange-Id: Ic3622b4acea65d2b9b3551c668806981fa7293e3\n",
      "commitDate": "2011/11/15 上午2:27",
      "commitName": "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
      "commitAuthor": "Dave Borowitz",
      "commitDateOld": "2011/9/15 上午6:34",
      "commitNameOld": "1b6a549ff350673402f797fe7f878175e2b5ba30",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 60.83,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    stats.depth \u003d depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 805,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,57 +1,57 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n-    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n+    beginPhase(PackingPhase.WRITING, writeMonitor, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     stats.depth \u003d depth;\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n-    writeMonitor.endTask();\n+    endPhase(writeMonitor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1b6a549ff350673402f797fe7f878175e2b5ba30": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Export more statistics\n\nExport the shallow pack information, and also a handy function to\nsum up the total times.  Include the time writing out the index file,\nif it was created.\n\nChange-Id: I7f60ae6848455a357b25feedb23743bbf6c153cf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/9/15 上午6:34",
      "commitName": "1b6a549ff350673402f797fe7f878175e2b5ba30",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/8/22 上午5:04",
      "commitNameOld": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "commitAuthorOld": "Matt Fischer",
      "daysBetweenCommits": 24.06,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    stats.depth \u003d depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 771,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,56 +1,57 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     excludeInPacks \u003d null;\n     excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n+    stats.depth \u003d depth;\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: support excluding objects already in other packs\n\nThis can be useful when implementing garbage collection and there\nare packs that should not be copied, such as huge packs that have\na sibling \".keep\" file alongside of them.\n\nCallers driving PackWriter need to initialize the list of packs not\nto include objects from by passing each index to excludeObjects().\n\nChange-Id: Id7f34df69df97be406bcae184308e92b0e8690fd\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/8/22 上午4:59",
      "commitName": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/8/17 上午3:18",
      "commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 5.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    excludeInPacks \u003d null;\n    excludeInPackLast \u003d null;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 740,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,54 +1,56 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n+    excludeInPacks \u003d null;\n+    excludeInPackLast \u003d null;\n     boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n     if (compressMonitor instanceof BatchingProgressMonitor) {\n         long delay \u003d 1000;\n         if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n             delay \u003d 500;\n         ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n     }\n     if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Skip progress messages on fast operations\n\nIf the \"Finding sources\" phase will complete in \u003c1 second with no\ndelta compression enabled, don\u0027t bother showing the progress meter for\nthis phase.  Small repositories on the local filesystem tend to rip\nthrough this phase always subsecond and the ProgressMonitor display\ncan actually slow the operation down.\n\nIf delta compression is enabled, there are two phases that may run\nvery quickly. Set the timer to 500 milliseconds instead, reducing the\nrisk that the user has to wait longer than 1 second before any sort of\noutput from the packer occurs.\n\nChange-Id: I58110f17e2a5ffa0134f9768b94804d16bbb8399\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/7/29 上午1:22",
      "commitName": "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/4/2 上午5:40",
      "commitNameOld": "8ac65d33ed7a94f77cb066271669feebf9b882fc",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 117.82,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay \u003d 1000;\n        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n            delay \u003d 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 636,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,47 +1,54 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n-    if (reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty()))\n+    boolean needSearchForReuse \u003d reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n+    if (compressMonitor instanceof BatchingProgressMonitor) {\n+        long delay \u003d 1000;\n+        if (needSearchForReuse \u0026\u0026 config.isDeltaCompress())\n+            delay \u003d 500;\n+        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n+    }\n+    if (needSearchForReuse)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Speed up pruning of objects from cached packs\n\nDuring object enumeration for the thin pack, very few objects come\nout that are duplicated with the cached pack. Typically these are\nonly cases where a blob or tree was cherry-picked forward, got a\ncopy or rename, or was reverted... all relatively infrequent events.\n\nSpeed up pruning of the thin pack object list by combining the phase\nwith the object representation selection. Implementers should already\nbe offering to reuse the object from the cached pack if it is stored\nthere, at which point the implementation can perform a very fast type\nof containment test using the cached pack\u0027s identity rather than yet\nanother index lookup.  For the local disk case this is probably not a\nbig improvement, but it does help on the DHT implementation where the\ntwo passes combined into one reduces latency.\n\nChange-Id: I6a07fc75d9075bf6233e967360b6546f9e9a2b33\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/4/2 上午5:40",
      "commitName": "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/19 上午2:31",
      "commitNameOld": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 14.13,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty()))\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 627,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,47 +1,47 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n-    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n+    if (reuseSupport !\u003d null \u0026\u0026 (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty()))\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n         for (Statistics.ObjectType typeStat : stats.objectTypes) {\n             if (typeStat \u003d\u003d null)\n                 continue;\n             stats.thinPackBytes +\u003d typeStat.bytes;\n         }\n     }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     for (Statistics.ObjectType typeStat : stats.objectTypes) {\n         if (typeStat \u003d\u003d null)\n             continue;\n         typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n         stats.reusedObjects +\u003d typeStat.reusedObjects;\n         stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n         stats.totalDeltas +\u003d typeStat.cntDeltas;\n     }\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bb1956e647d2f48ef36ef98a7f22120fdad0b37c": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Collect stats by object type\n\nFrequently enough I\u0027m wondering how much of a pack is commits vs.\ntrees, and the total line doesn\u0027t really tell us this because its\na gross total from the pack. Computing the counts per object type\nis simple during packing, as PackWriter already has everything in\nmemory broken up by object type.  Its virtually free to get these\nvalues and track them.\n\nChange-Id: Id5e6b1902ea909c72f103a0fbca5d8bc316f9ab3\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/3/19 上午2:31",
      "commitName": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/14 下午11:01",
      "commitNameOld": "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 4.15,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat \u003d\u003d null)\n                continue;\n            stats.thinPackBytes +\u003d typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat \u003d\u003d null)\n            continue;\n        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n        stats.reusedObjects +\u003d typeStat.reusedObjects;\n        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n        stats.totalDeltas +\u003d typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 634,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,36 +1,47 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n-    long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n-    long headerEnd \u003d out.length();\n     writeObjects(out);\n-    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n-        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n+    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n+        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n+            if (typeStat \u003d\u003d null)\n+                continue;\n+            stats.thinPackBytes +\u003d typeStat.bytes;\n+        }\n+    }\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n+    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n+        if (typeStat \u003d\u003d null)\n+            continue;\n+        typeStat.cntDeltas +\u003d typeStat.reusedDeltas;\n+        stats.reusedObjects +\u003d typeStat.reusedObjects;\n+        stats.reusedDeltas +\u003d typeStat.reusedDeltas;\n+        stats.totalDeltas +\u003d typeStat.cntDeltas;\n+    }\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Rename getObjectsNumber to getObjectCount\n\nThis better matches with PackFile and CachedPack\u0027s methods\nthat return the same value.\n\nChange-Id: Idb9b7c71d2048dd2344a62c2cde20b4e34529ab7\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/3/14 下午11:01",
      "commitName": "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/14 下午11:01",
      "commitNameOld": "65f9a6e58bd9296cbbe1cffc7cf079fd65991686",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    long headerStart \u003d out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd \u003d out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 632,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,36 +1,36 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n-    long objCnt \u003d getObjectsNumber();\n+    long objCnt \u003d getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     long headerEnd \u003d out.length();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n         stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "65f9a6e58bd9296cbbe1cffc7cf079fd65991686": {
      "type": "Ybodychange",
      "commitMessage": "Fix dumb transport push\n\nPackWriter incorrectly returned 0 from getObjectsNumber() when the\npack has not been written yet. This caused dumb transports like\namazon-s3:// and sftp:// to abort early and never write out a pack,\nunder the assumption that the pack had no objects.\n\nUntil the pack header is written to the output stream, compute the\ncurrent object count each time it is requested. Once the header is\nstarted, use the object count from the stats object.\n\nChange-Id: I041a2368ae0cfe6f649ec28658d41a6355933900\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/3/14 下午11:01",
      "commitName": "65f9a6e58bd9296cbbe1cffc7cf079fd65991686",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/14 上午7:39",
      "commitNameOld": "bd970007be5c07375b9915033992de9a167e8196",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.64,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d getObjectsNumber();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    long headerStart \u003d out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd \u003d out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 632,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,38 +1,36 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n-    long objCnt \u003d 0;\n-    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n-    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n+    long objCnt \u003d getObjectsNumber();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     long headerEnd \u003d out.length();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n         stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a468cb57c2f2fbd8da163f002b505255ea768244": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Validate reused cached packs\n\nIf object reuse validation is enabled, the output pack is going to\nprobably be stored locally.  When reusing an existing cached pack\nto save object enumeration costs, ensure the cached pack has not\nbeen corrupted by checking its SHA-1 trailer.  If it has, writing\nwill abort and the output pack won\u0027t be complete.  This prevents\nanyone from trying to use the output pack, and catches corruption\nbefore it can be carried any further.\n\nChange-Id: If89d0d4e429d9f4c86f14de6c0020902705153e6\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/3/3 上午4:49",
      "commitName": "a468cb57c2f2fbd8da163f002b505255ea768244",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/3 上午4:23",
      "commitNameOld": "1b2062fe37b43e59e40e360139e03e1221fa5b6b",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d 0;\n    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    long headerStart \u003d out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd \u003d out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 623,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,38 +1,38 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d 0;\n     for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n     for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     long headerEnd \u003d out.length();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n         stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n     for (CachedPack pack : cachedPacks) {\n         long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         stats.reusedDeltas +\u003d deltaCnt;\n         stats.totalDeltas +\u003d deltaCnt;\n-        reuseSupport.copyPackAsIs(out, pack);\n+        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Correct total delta count when reusing pack\n\nIf the CachedPack knows its delta count, we need to increment both\nthe totalDeltas and reusedDeltas fields of the stats object.\n\nChange-Id: I70113609c22476ce7f1e4d9a92f486e9b0f59e44\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/19 上午9:36",
      "commitName": "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/19 上午9:36",
      "commitNameOld": "4275c4c1cffeffae6b12eb6aa2df957c23107b48",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d 0;\n    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    long headerStart \u003d out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd \u003d out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt \u003d pack.getDeltaCount();\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d deltaCnt;\n        stats.totalDeltas +\u003d deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 554,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,36 +1,38 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d 0;\n     for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n     for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     long headerEnd \u003d out.length();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n         stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n     for (CachedPack pack : cachedPacks) {\n+        long deltaCnt \u003d pack.getDeltaCount();\n         stats.reusedObjects +\u003d pack.getObjectCount();\n-        stats.reusedDeltas +\u003d pack.getDeltaCount();\n+        stats.reusedDeltas +\u003d deltaCnt;\n+        stats.totalDeltas +\u003d deltaCnt;\n         reuseSupport.copyPackAsIs(out, pack);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14f99dc29d67fa4d2cb227ab906c5c8379499f6b": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Try for accurate delta reuse on cached pack\n\nIf a cached pack is used, it might know how many deltas are contained\nwithin it.  Record that count as part of our reusedDeltas field\nfor the stats line we show clients.\n\nChange-Id: I1c61fb817305a95eeac654cccf132cba20b2339c\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/16 上午8:32",
      "commitName": "14f99dc29d67fa4d2cb227ab906c5c8379499f6b",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/14 上午5:43",
      "commitNameOld": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d 0;\n    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    long headerStart \u003d out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd \u003d out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        stats.reusedDeltas +\u003d pack.getDeltaCount();\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 554,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,35 +1,36 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d 0;\n     for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n     for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     long writeStart \u003d System.currentTimeMillis();\n     long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     long headerEnd \u003d out.length();\n     writeObjects(out);\n     if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n         stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n     for (CachedPack pack : cachedPacks) {\n         stats.reusedObjects +\u003d pack.getObjectCount();\n+        stats.reusedDeltas +\u003d pack.getDeltaCount();\n         reuseSupport.copyPackAsIs(out, pack);\n     }\n     writeChecksum(out);\n     out.flush();\n     stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n     stats.totalBytes \u003d out.length();\n     stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8c4524b6b36c1d97e715de9e1ff1aa18763a390": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Expose PackWriter activity to a logger\n\nThe UploadPackLogger interface allows applications that embed\nGitServlet or otherwise use UploadPack to service clients to\ntrack and log how PackWriter was used, and what it sent.  This\nprovides more granularity into the request activity than might\nbe available from the HTTP server logs, helping administrators\nto better understand utilization and Git server performance.\n\nChange-Id: I1d36b060eb3385339d5f986e68192789ef70fc4e\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/14 上午5:43",
      "commitName": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/14 上午5:43",
      "commitNameOld": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d 0;\n    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart \u003d System.currentTimeMillis();\n    long headerStart \u003d out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd \u003d out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n    stats.totalBytes \u003d out.length();\n    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 554,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,26 +1,35 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     long objCnt \u003d 0;\n     for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n     for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n     stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n+    long writeStart \u003d System.currentTimeMillis();\n+    long headerStart \u003d out.length();\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n+    long headerEnd \u003d out.length();\n     writeObjects(out);\n+    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n+        stats.thinPackBytes \u003d out.length() - (headerEnd - headerStart);\n     for (CachedPack pack : cachedPacks) {\n         stats.reusedObjects +\u003d pack.getObjectCount();\n         reuseSupport.copyPackAsIs(out, pack);\n     }\n     writeChecksum(out);\n+    out.flush();\n+    stats.timeWriting \u003d System.currentTimeMillis() - writeStart;\n+    stats.totalBytes \u003d out.length();\n+    stats.reusedPacks \u003d Collections.unmodifiableList(cachedPacks);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "461b012e9565af8174e5b9d2b2c3a582011ce77e": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Support reuse of entire packs\n\nThe most expensive part of packing a repository for transport to\nanother system is enumerating all of the objects in the repository.\nOnce this gets to the size of the linux-2.6 repository (1.8 million\nobjects), enumeration can take several CPU minutes and costs a lot\nof temporary working set memory.\n\nTeach PackWriter to efficiently reuse an existing \"cached pack\"\nby answering a clone request with a thin pack followed by a larger\ncached pack appended to the end.  This requires the repository\nowner to first construct the cached pack by hand, and record the\ntip commits inside of $GIT_DIR/objects/info/cached-packs:\n\n  cd $GIT_DIR\n  root\u003d$(git rev-parse master)\n  tmp\u003dobjects/.tmp-$$\n  names\u003d$(echo $root | git pack-objects --keep-true-parents --revs $tmp)\n  for n in $names; do\n    chmod a-w $tmp-$n.pack $tmp-$n.idx\n    touch objects/pack/pack-$n.keep\n    mv $tmp-$n.pack objects/pack/pack-$n.pack\n    mv $tmp-$n.idx objects/pack/pack-$n.idx\n  done\n\n  (echo \"+ $root\";\n   for n in $names; do echo \"P $n\"; done;\n   echo) \u003e\u003eobjects/info/cached-packs\n\n  git repack -a -d\n\nWhen a clone request needs to include $root, the corresponding\ncached pack will be copied as-is, rather than enumerating all of\nthe objects that are reachable from $root.\n\nFor a linux-2.6 kernel repository that should be about 376 MiB,\nthe above process creates two packs of 368 MiB and 38 MiB[1].\nThis is a local disk usage increase of ~26 MiB, due to reduced\ndelta compression between the large cached pack and the smaller\nrecent activity pack.  The overhead is similar to 1 full copy of\nthe compressed project sources.\n\nWith this cached pack in hand, JGit daemon completes a clone request\nin 1m17s less time, but a slightly larger data transfer (+2.39 MiB):\n\n  Before:\n    remote: Counting objects: 1861830, done\n    remote: Finding sources: 100% (1861830/1861830)\n    remote: Getting sizes: 100% (88243/88243)\n    remote: Compressing objects: 100% (88184/88184)\n    Receiving objects: 100% (1861830/1861830), 376.01 MiB | 19.01 MiB/s, done.\n    remote: Total 1861830 (delta 4706), reused 1851053 (delta 1553844)\n    Resolving deltas: 100% (1564621/1564621), done.\n\n    real  3m19.005s\n\n  After:\n    remote: Counting objects: 1601, done\n    remote: Counting objects: 1828460, done\n    remote: Finding sources: 100% (50475/50475)\n    remote: Getting sizes: 100% (18843/18843)\n    remote: Compressing objects: 100% (7585/7585)\n    remote: Total 1861830 (delta 2407), reused 1856197 (delta 37510)\n    Receiving objects: 100% (1861830/1861830), 378.40 MiB | 31.31 MiB/s, done.\n    Resolving deltas: 100% (1559477/1559477), done.\n\n    real 2m2.938s\n\nRepository owners can periodically refresh their cached packs by\nrepacking their repository, folding all newer objects into a larger\ncached pack.  Since repacking is already considered to be a normal\nGit maintenance activity, this isn\u0027t a very big burden.\n\n[1] In this test $root was set back about two weeks.\n\nChange-Id: Ib87131d5c4b5e8c5cacb0f4fe16ff4ece554734b\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/4 上午5:20",
      "commitName": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/3 上午9:17",
      "commitNameOld": "71f168fcd77ec100d68233d3d467f770304f6eb8",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt \u003d 0;\n    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    for (CachedPack pack : cachedPacks) {\n        stats.reusedObjects +\u003d pack.getObjectCount();\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 521,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,20 +1,26 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n-    int objCnt \u003d getObjectsNumber();\n+    long objCnt \u003d 0;\n+    for (List\u003cObjectToPack\u003e list : objectsLists) objCnt +\u003d list.size();\n+    for (CachedPack pack : cachedPacks) objCnt +\u003d pack.getObjectCount();\n     stats.totalObjects \u003d objCnt;\n-    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n+    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n+    for (CachedPack pack : cachedPacks) {\n+        stats.reusedObjects +\u003d pack.getObjectCount();\n+        reuseSupport.copyPackAsIs(out, pack);\n+    }\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71f168fcd77ec100d68233d3d467f770304f6eb8": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Display totals after sending objects\n\nCGit pack-objects displays a totals line after the pack data\nwas fully written.  This can be useful to understand some of\nthe decisions made by the packer, and has been a great tool\nfor helping to debug some of that code.\n\nTrack some of the basic values, and send it to the client when\npacking is done:\n\n  remote: Counting objects: 1826776, done\n  remote: Finding sources: 100% (55121/55121)\n  remote: Getting sizes: 100% (25654/25654)\n  remote: Compressing objects: 100% (11434/11434)\n  remote: Total 1861830 (delta 3926), reused 1854705 (delta 38306)\n  Receiving objects: 100% (1861830/1861830), 386.03 MiB | 30.32 MiB/s, done.\n\nChange-Id: If3b039017a984ed5d5ae80940ce32bda93652df5\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/3 上午9:17",
      "commitName": "71f168fcd77ec100d68233d3d467f770304f6eb8",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/1 下午11:12",
      "commitNameOld": "13bcf05a9ea2d4943faef2c879aac65d37517eb6",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 1.42,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    stats.totalObjects \u003d objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 488,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,19 +1,20 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     int objCnt \u003d getObjectsNumber();\n+    stats.totalObjects \u003d objCnt;\n     writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "28ba4747bc166243ecff86cdc7460cbc969a8eb4": {
      "type": "Ybodychange",
      "commitMessage": "Allow ObjectReuseAsIs to have more control over write ordering\n\nThe reuse system used by an object database may be able to benefit\nfrom knowing what objects are coming next, and even improve data\nthroughput by delaying (or moving up) objects that are stored near\neach other in the source database.\n\nPushing the iteration down into the reuse code makes it possible\nfor a smarter implementation to aggregate reuse.  But for the\nstandard pack file format on disk we don\u0027t bother, its quite\nefficient already.\n\nChange-Id: I64f0048ca7071a8b44950d6c2a5dfbca3be6bba6\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/8/21 上午8:59",
      "commitName": "28ba4747bc166243ecff86cdc7460cbc969a8eb4",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/8/21 上午8:41",
      "commitNameOld": "f048af3fd19547d3692f5df968571ffd7556b688",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 486,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,19 +1,19 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     int objCnt \u003d getObjectsNumber();\n     writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n-    writeObjects(writeMonitor, out);\n+    writeObjects(out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b85af06324644e699bd2cc7e2047ae1f65f35db5": {
      "type": "Ybodychange",
      "commitMessage": "Allow object reuse selection to occur in parallel\n\nObjectReader implementations may wish to use multiple threads in\norder to evaluate object reuse faster.  Let the reader make that\ndecision by passing the iteration down into the reader.\n\nBecause the work is pushed into the reader, it may need to locate a\ngiven ObjectToPack given its ObjectId.  This can easily occur if the\nreader has sent a list of ObjectIds to the object database and gets\nback information keyed only by ObjectId, without the ObjectToPack\nhandle.  Expose lookup using the PackWriter\u0027s own internal map,\nso the reader doesn\u0027t need to build a redundant copy to track the\nassocation of ObjectId back to ObjectToPack.\n\nChange-Id: I0c536405a55034881fb5db92a2d2a99534faed34\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/8/21 上午8:41",
      "commitName": "b85af06324644e699bd2cc7e2047ae1f65f35db5",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/8/21 上午8:41",
      "commitNameOld": "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 482,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,19 +1,19 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse();\n+        searchForReuse(compressMonitor);\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     int objCnt \u003d getObjectsNumber();\n     writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     out.flush();\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3": {
      "type": "Ybodychange",
      "commitMessage": "Flush the pack header as soon as its ready\n\nWhen the output stream is deeply buffered (e.g. 1 MiB or more in\nan HTTP servlet on some containers) trying to kick out the header\nearlier will prevent the client from stalling hard while the first\n1 MiB is received and it can process the pack header.  Forcing a\nflush here lets the client see the header and start its progress\nmonitor for \"Receiving objects: (1/N)\" so the user knows there\nis still activity occurring, even though the buffering may cause\nthere to be some lag as the buffer fills up on the sending side.\n\nChange-Id: I3edf39e8f703fe87a738dc236d426b194db85e3a\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/8/21 上午8:41",
      "commitName": "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/7/29 上午3:13",
      "commitNameOld": "1a06179ea707ab088b6543df77be5cf0ea44c497",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 23.23,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 471,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,18 +1,19 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n     if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     int objCnt \u003d getObjectsNumber();\n     writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n+    out.flush();\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a06179ea707ab088b6543df77be5cf0ea44c497": {
      "type": "Ybodychange",
      "commitMessage": "Move PackWriter configuration to PackConfig\n\nThis refactoring permits applications to configure global per-process\nsettings for all packing and easily pass it through to per-request\nPackWriters, ensuring that the process configuration overrides the\nrepository specific settings.\n\nFor example this might help in a daemon environment where the server\nwants to cap the resources used to serve a dynamic upload pack\nrequest, even though the repository\u0027s own pack.* settings might be\nconfigured to be more aggressive.  This allows fast but less bandwidth\nefficient serving of clients, while still retaining good compression\nthrough a cron managed `git gc`.\n\nChange-Id: I58cc5e01b48924b1a99f79aa96c8150cdfc50846\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/29 上午3:13",
      "commitName": "1a06179ea707ab088b6543df77be5cf0ea44c497",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/7/29 上午1:50",
      "commitNameOld": "1b783d037091266b035e1727db6b6ce7a397ef63",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 471,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,18 +1,18 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n-    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n+    if ((reuseDeltas || config.isReuseObjects()) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n-    if (deltaCompress)\n+    if (config.isDeltaCompress())\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     int objCnt \u003d getObjectsNumber();\n     writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n     out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "21f76c2a69836ec618c82eb9305656dcec70befb": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Remove static progress task names from PackWriter\n\nThese need to be dynamic based on the current thread\u0027s environment\nat time of execution in order to be properly localized for the end\nuser that will be seeing these messages.\n\nChange-Id: I4976f462cfe606edd2761c0e36b2f6b20f63d53c\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/29 上午1:50",
      "commitName": "21f76c2a69836ec618c82eb9305656dcec70befb",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Remove static progress task names from PackWriter\n\nThese need to be dynamic based on the current thread\u0027s environment\nat time of execution in order to be properly localized for the end\nuser that will be seeing these messages.\n\nChange-Id: I4976f462cfe606edd2761c0e36b2f6b20f63d53c\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/7/29 上午1:50",
          "commitName": "21f76c2a69836ec618c82eb9305656dcec70befb",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/7/28 上午12:40",
          "commitNameOld": "a00377a7e23dbde315598ee20f61c45d031e159a",
          "commitAuthorOld": "Robin Stocker",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 837,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,17 +1,18 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n     if (deltaCompress)\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n-    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n+    int objCnt \u003d getObjectsNumber();\n+    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n+    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Remove static progress task names from PackWriter\n\nThese need to be dynamic based on the current thread\u0027s environment\nat time of execution in order to be properly localized for the end\nuser that will be seeing these messages.\n\nChange-Id: I4976f462cfe606edd2761c0e36b2f6b20f63d53c\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/7/29 上午1:50",
          "commitName": "21f76c2a69836ec618c82eb9305656dcec70befb",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/7/28 上午12:40",
          "commitNameOld": "a00377a7e23dbde315598ee20f61c45d031e159a",
          "commitAuthorOld": "Robin Stocker",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt \u003d getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 837,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,17 +1,18 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n     if (deltaCompress)\n         searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n-    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n+    int objCnt \u003d getObjectsNumber();\n+    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n+    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@link #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@link #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
            "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n"
          }
        }
      ]
    },
    "a00377a7e23dbde315598ee20f61c45d031e159a": {
      "type": "Ydocchange",
      "commitMessage": "Fix Javadoc warnings\n\nThere were some broken links, incorrect uses of @value, an invalid\ntag and an outdated comment.\n\nChange-Id: I22886bcc869a4b62bd606ebed40669f7b4723664\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/28 上午12:40",
      "commitName": "a00377a7e23dbde315598ee20f61c45d031e159a",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2010/7/10 上午10:19",
      "commitNameOld": "97341949171dcdd7d6c30f3eef89ee2c63d8eb34",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 17.6,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 862,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@link #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@link #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
        "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@link #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@link #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n"
      }
    },
    "dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33": {
      "type": "Ybodychange",
      "commitMessage": "Implement delta generation during packing\n\nPackWriter now produces new deltas if there is not a suitable delta\navailable for reuse from an existing pack file.  This permits JGit to\nsend less data on the wire by sending a delta relative to an object\nthe other side already has, instead of sending the whole object.\n\nThe delta searching algorithm is similar in style to what C Git\nuses, but apparently has some differences (see below for more on).\nBriefly, objects that should be considered for delta compression are\npushed onto a list.  This list is then sorted by a rough similarity\nscore, which is derived from the path name the object was discovered\nat in the repository during object counting.  The list is then\nwalked in order.\n\nAt each position in the list, up to $WINDOW objects prior to it\nare attempted as delta bases.  Each object in the window is tried,\nand the shortest delta instruction sequence selects the base object.\nSome rough rules are used to prevent pathological behavior during\nthis matching phase, like skipping pairings of objects that are\nnot similar enough in size.\n\nPackWriter intentionally excludes commits and annotated tags from\nthis new delta search phase.  In the JGit repository only 28 out\nof 2600+ commits can be delta compressed by C Git.  As the commit\ncount tends to be a fair percentage of the total number of objects\nin the repository, and they generally do not delta compress well,\nskipping over them can improve performance with little increase in\nthe output pack size.\n\nBecause this implementation was rebuilt from scratch based on my own\nmemory of how the packing algorithm has evolved over the years in\nC Git, PackWriter, DeltaWindow, and DeltaEncoder don\u0027t use exactly\nthe same rules everywhere, and that leads JGit to produce different\n(but logically equivalent) pack files.\n\n  Repository | Pack Size (bytes)                | Packing Time\n             | JGit     - CGit     \u003d Difference | JGit / CGit\n  -----------+----------------------------------+-----------------\n   git       | 25094348 - 24322890 \u003d +771458    | 59.434s / 59.133s\n   jgit      |  5669515 -  5709046 \u003d - 39531    |  6.654s /  6.806s\n   linux-2.6 |     389M -     386M \u003d +3M        |  20m02s / 18m01s\n\nFor the above tests pack.threads was set to 1, window size\u003d10,\ndelta depth\u003d50, and delta and object reuse was disabled for both\nimplementations.  Both implementations were reading from an already\nfully packed repository on local disk.  The running time reported\nis after 1 warm-up run of the tested implementation.\n\nPackWriter is writing 771 KiB more data on git.git, 3M more on\nlinux-2.6, but is actually 39.5 KiB smaller on jgit.git.  Being\nlarger by less than 0.7% on linux-2.6 isn\u0027t bad, nor is taking an\nextra 2 minutes to pack.  On the running time side, JGit is at a\nmajor disadvantage because linux-2.6 doesn\u0027t fit into the default\nWindowCache of 20M, while C Git is able to mmap the entire pack and\nhave it available instantly in physical memory (assuming hot cache).\n\nCGit also has a feature where it caches deltas that were created\nduring the compression phase, and uses those cached deltas during\nthe writing phase.  PackWriter does not implement this (yet),\nand therefore must create every delta twice.  This could easily\naccount for the increased running time we are seeing.\n\nChange-Id: I6292edc66c2e95fbe45b519b65fdb3918068889c\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/10 上午10:14",
      "commitName": "dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/7/10 上午10:12",
      "commitNameOld": "074055d747026c47040d0306585863ad5d428860",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 715,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,15 +1,17 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n+    if (deltaCompress)\n+        searchForDeltas(compressMonitor);\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "074055d747026c47040d0306585863ad5d428860": {
      "type": "Ybodychange",
      "commitMessage": "debug-show-packdelta:  Dump a pack delta to the console\n\nThis is a horribly crude application, it doesn\u0027t even verify that\nthe object its dumping is delta encoded.  Its method of getting the\ndelta is pretty abusive to the public PackWriter API, because right\nnow we don\u0027t want to expose the real internal low-level methods\nactually required to do this.\n\nChange-Id: I437a17ceb98708b5603a2061126eb251e82f4ed4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/10 上午10:12",
      "commitName": "074055d747026c47040d0306585863ad5d428860",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/7/10 上午10:06",
      "commitNameOld": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 709,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,15 +1,15 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n-    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n+    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, this);\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4569d77e13c7bbf0c7466cbc57d0eefd117cb206": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Correctly classify the compressing objects phase\n\nSearching for reuse candidates should be fast compared to actually\ndoing delta compression.  So pull the progress monitor out of this\nphase and rename it back to identify the compressing objects state.\n\nChange-Id: I5eb80919f21c1251e0e3420ff7774126f1f79b27\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/10 上午10:06",
      "commitName": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Correctly classify the compressing objects phase\n\nSearching for reuse candidates should be fast compared to actually\ndoing delta compression.  So pull the progress monitor out of this\nphase and rename it back to identify the compressing objects state.\n\nChange-Id: I5eb80919f21c1251e0e3420ff7774126f1f79b27\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/7/10 上午10:06",
          "commitName": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/7/10 上午10:02",
          "commitNameOld": "6730f9e3c830d997d1731bf36414e626bda42ad8",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 709,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,15 +1,15 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse(compressMonitor);\n+        searchForReuse();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Correctly classify the compressing objects phase\n\nSearching for reuse candidates should be fast compared to actually\ndoing delta compression.  So pull the progress monitor out of this\nphase and rename it back to identify the compressing objects state.\n\nChange-Id: I5eb80919f21c1251e0e3420ff7774126f1f79b27\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/7/10 上午10:06",
          "commitName": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/7/10 上午10:02",
          "commitNameOld": "6730f9e3c830d997d1731bf36414e626bda42ad8",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 709,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,15 +1,15 @@\n public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n     if (compressMonitor \u003d\u003d null)\n         compressMonitor \u003d NullProgressMonitor.INSTANCE;\n     if (writeMonitor \u003d\u003d null)\n         writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse(compressMonitor);\n+        searchForReuse();\n     final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n     writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
            "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #COMPRESSING_OBJECTS_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n"
          }
        }
      ]
    },
    "6b62e53b607630b6c00411741972838ced552f4d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/29 上午2:47",
      "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/6/29 上午2:47",
          "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/6/29 上午2:47",
          "commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 585,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,11 +1,15 @@\n-public void writePack(OutputStream packStream) throws IOException {\n+public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n+    if (compressMonitor \u003d\u003d null)\n+        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n+    if (writeMonitor \u003d\u003d null)\n+        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse();\n-    final PackOutputStream out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+        searchForReuse(compressMonitor);\n+    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-    writeObjects(out);\n+    writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[packStream-OutputStream]",
            "newValue": "[compressMonitor-ProgressMonitor, writeMonitor-ProgressMonitor, packStream-OutputStream]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/6/29 上午2:47",
          "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/6/29 上午2:47",
          "commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 585,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,11 +1,15 @@\n-public void writePack(OutputStream packStream) throws IOException {\n+public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n+    if (compressMonitor \u003d\u003d null)\n+        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n+    if (writeMonitor \u003d\u003d null)\n+        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse();\n-    final PackOutputStream out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+        searchForReuse(compressMonitor);\n+    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-    writeObjects(out);\n+    writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/6/29 上午2:47",
          "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/6/29 上午2:47",
          "commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor \u003d\u003d null)\n        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n    if (writeMonitor \u003d\u003d null)\n        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse(compressMonitor);\n    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 585,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,11 +1,15 @@\n-public void writePack(OutputStream packStream) throws IOException {\n+public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n+    if (compressMonitor \u003d\u003d null)\n+        compressMonitor \u003d NullProgressMonitor.INSTANCE;\n+    if (writeMonitor \u003d\u003d null)\n+        writeMonitor \u003d NullProgressMonitor.INSTANCE;\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse();\n-    final PackOutputStream out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+        searchForReuse(compressMonitor);\n+    final PackOutputStream out \u003d new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-    writeObjects(out);\n+    writeObjects(writeMonitor, out);\n     writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
            "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param compressMonitor progress monitor to report object compression work.\n@param writeMonitor progress monitor to report the number of objects written.\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n"
          }
        }
      ]
    },
    "f288c27e465a91e80b53c4100c0d9b2f2341a9aa": {
      "type": "Ybodychange",
      "commitMessage": "Pass the PackOutputStream down the call stack\n\nRather than storing this in an instance member, pass it down the\ncalling stack.  Its cleaner, we don\u0027t have to poke the stream as\na temporary field, and then unset it.\n\nChange-Id: I0fd323371bc12edb10f0493bf11885d7057aeb13\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/29 上午2:47",
      "commitName": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/29 上午2:47",
      "commitNameOld": "1ad2feb7b3d48d8bfedfdd03ee6ca4f599041476",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    final PackOutputStream out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 610,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,12 +1,11 @@\n public void writePack(OutputStream packStream) throws IOException {\n     if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n-    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+    final PackOutputStream out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-    writeObjects();\n-    writeChecksum();\n-    out \u003d null;\n+    writeObjects(out);\n+    writeChecksum(out);\n     reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4": {
      "type": "Ybodychange",
      "commitMessage": "Ensure ObjectReader used by PackWriter is released\n\nThe ObjectReader API demands that we release the reader when we are\ndone with it.  PackWriter contains a reader, which it uses for the\nentire packing session.  Expose the release of the reader through\na release method on the writer.\n\nThis still doesn\u0027t address the RevWalk and TreeWalk users, who\ndon\u0027t correctly release their reader.  But its a small step in the\nright direction.\n\nChange-Id: I5cb0b5c1b432434a799fceb21b86479e09b84a0a\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/29 上午1:25",
      "commitName": "a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/29 上午1:16",
      "commitNameOld": "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects();\n    writeChecksum();\n    out \u003d null;\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 612,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,16 +1,12 @@\n public void writePack(OutputStream packStream) throws IOException {\n-    try {\n-        if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-            searchForReuse();\n-        out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n-        int cnt \u003d getObjectsNumber();\n-        writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, cnt);\n-        out.writeFileHeader(PACK_VERSION_GENERATED, cnt);\n-        writeObjects();\n-        writeChecksum();\n-        writeMonitor.endTask();\n-    } finally {\n-        out \u003d null;\n-        reader.release();\n-    }\n+    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n+        searchForReuse();\n+    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n+    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n+    writeObjects();\n+    writeChecksum();\n+    out \u003d null;\n+    reader.release();\n+    writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1": {
      "type": "Ybodychange",
      "commitMessage": "Ensure PackWriter releases its ObjectReader\n\nChange-Id: I3f8af29066cc5a2132dc4a75c9654d97800f2f18\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/29 上午1:16",
      "commitName": "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/27 上午9:51",
      "commitNameOld": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 1.64,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    try {\n        if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n            searchForReuse();\n        out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n        int cnt \u003d getObjectsNumber();\n        writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, cnt);\n        out.writeFileHeader(PACK_VERSION_GENERATED, cnt);\n        writeObjects();\n        writeChecksum();\n        writeMonitor.endTask();\n    } finally {\n        out \u003d null;\n        reader.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 612,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,12 +1,16 @@\n public void writePack(OutputStream packStream) throws IOException {\n-    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n-        searchForReuse();\n-    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n-    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-    writeObjects();\n-    writeChecksum();\n-    out \u003d null;\n-    reader.release();\n-    writeMonitor.endTask();\n+    try {\n+        if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n+            searchForReuse();\n+        out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+        int cnt \u003d getObjectsNumber();\n+        writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, cnt);\n+        out.writeFileHeader(PACK_VERSION_GENERATED, cnt);\n+        writeObjects();\n+        writeChecksum();\n+        writeMonitor.endTask();\n+    } finally {\n+        out \u003d null;\n+        reader.release();\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066": {
      "type": "Yfilerename",
      "commitMessage": "Move PackWriter over to storage.pack.PackWriter\n\nSimilar to what we did with the file code, move the pack writer\ninto its own package so the related classes and their package\nprivate methods are hidden from the rest of the library.\n\nChange-Id: Ic1b5c7c8c8d266e90c910d8d68dfc8e93586854f\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/27 上午9:51",
      "commitName": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/27 上午9:50",
      "commitNameOld": "71aace52f7bfc36c65c92ab54c6f020dffc873ab",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects();\n    writeChecksum();\n    out \u003d null;\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 612,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
        "newPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java"
      }
    },
    "ece88b99eb2ea6541b667aa066573184c25b6a8b": {
      "type": "Ybodychange",
      "commitMessage": "Redo PackWriter object reuse output\n\nOutput of selected reuses is refactored to use a new ObjectReuseAsIs\ninterface that extends the ObjectReader.  This interface allows the\nreader to control how it performs the reuse into the output stream,\nbut also allows it to throw an exception to request the writer to\nfind a different candidate representation.\n\nThe PackFile reuse code was overhauled, cleaning up the APIs so they\naren\u0027t exposed in the object loader, but instead are now a single\nmethod on the PackFile itself.  The reuse algorithm was changed to do\na data verification pass, followed by the copy pass to the output.\nThis permits us to work around a corrupt object in a pack file by\nseeking another copy of that object when this one is bad.\n\nThe reuse code was also optimized for the common case, where the\nin-pack representation is under 16 KiB.  In these smaller cases\ndata is sent to the pack writer more directly, avoiding some copying.\n\nChange-Id: I6350c2b444118305e8446ce1dfd049259832bcca\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/27 上午5:46",
      "commitName": "ece88b99eb2ea6541b667aa066573184c25b6a8b",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/27 上午5:16",
      "commitNameOld": "bf4ffff07fb5be4a405ca13ae8baa13dee693b10",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n        searchForReuse();\n    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects();\n    writeChecksum();\n    out \u003d null;\n    reader.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
      "functionStartLine": 601,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
      "diff": "@@ -1,11 +1,12 @@\n public void writePack(OutputStream packStream) throws IOException {\n-    if (reuseDeltas || reuseObjects)\n+    if ((reuseDeltas || reuseObjects) \u0026\u0026 reuseSupport !\u003d null)\n         searchForReuse();\n-    out \u003d new PackOutputStream(packStream);\n+    out \u003d new PackOutputStream(packStream, isDeltaBaseAsOffset());\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-    writeHeader();\n+    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n     writeObjects();\n     writeChecksum();\n-    windowCursor.release();\n+    out \u003d null;\n+    reader.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2156aa894cefbabd322fc405138c306bb4e939cd": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Reduce multi-level buffered streams in transport code\n\nSome transports actually provide stream buffering on their own,\nwithout needing to be wrapped up inside of a BufferedInputStream in\norder to smooth out system calls to read or write.  A great example\nof this is the JSch SSH client, or the Apache MINA SSHD server.\nBoth use custom buffering to packetize the streams into the encrypted\nSSH channel, and wrapping them up inside of a BufferedInputStream\nor BufferedOutputStream is relatively pointless.\n\nOur SideBandOutputStream implementation also provides some fairly\nlarge buffering, equal to one complete side-band packet on the main\ndata channel.  Wrapping that inside of a BufferedOutputStream just to\nsmooth out small writes from PackWriter causes extra data copies, and\nprovides no advantage.  We can save some memory and some CPU cycles\nby letting PackWriter dump directly into the SideBandOutputStream\u0027s\ninternal buffer array.\n\nInstead we push the buffering streams down to be as close to the\nnetwork socket (or operating system pipe) as possible.  This allows\nus to smooth out the smaller reads/writes from pkt-line messages\nduring advertisement and negotation, but avoid copying altogether\nwhen the stream switches to larger writes over a side band channel.\n\nChange-Id: I2f6f16caee64783c77d3dd1b2a41b3cc0c64c159\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/3/13 上午8:08",
      "commitName": "2156aa894cefbabd322fc405138c306bb4e939cd",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Reduce multi-level buffered streams in transport code\n\nSome transports actually provide stream buffering on their own,\nwithout needing to be wrapped up inside of a BufferedInputStream in\norder to smooth out system calls to read or write.  A great example\nof this is the JSch SSH client, or the Apache MINA SSHD server.\nBoth use custom buffering to packetize the streams into the encrypted\nSSH channel, and wrapping them up inside of a BufferedInputStream\nor BufferedOutputStream is relatively pointless.\n\nOur SideBandOutputStream implementation also provides some fairly\nlarge buffering, equal to one complete side-band packet on the main\ndata channel.  Wrapping that inside of a BufferedOutputStream just to\nsmooth out small writes from PackWriter causes extra data copies, and\nprovides no advantage.  We can save some memory and some CPU cycles\nby letting PackWriter dump directly into the SideBandOutputStream\u0027s\ninternal buffer array.\n\nInstead we push the buffering streams down to be as close to the\nnetwork socket (or operating system pipe) as possible.  This allows\nus to smooth out the smaller reads/writes from pkt-line messages\nduring advertisement and negotation, but avoid copying altogether\nwhen the stream switches to larger writes over a side band channel.\n\nChange-Id: I2f6f16caee64783c77d3dd1b2a41b3cc0c64c159\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/3/13 上午8:08",
          "commitName": "2156aa894cefbabd322fc405138c306bb4e939cd",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2009/9/30 上午7:47",
          "commitNameOld": "1a6964c8274c50f0253db75f010d78ef0e739343",
          "commitAuthorOld": "Git Development Community",
          "daysBetweenCommits": 164.01,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if (reuseDeltas || reuseObjects)\n        searchForReuse();\n    out \u003d new PackOutputStream(packStream);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    writeHeader();\n    writeObjects();\n    writeChecksum();\n    windowCursor.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
          "functionStartLine": 586,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,14 +1,11 @@\n public void writePack(OutputStream packStream) throws IOException {\n     if (reuseDeltas || reuseObjects)\n         searchForReuse();\n-    if (!(packStream instanceof BufferedOutputStream))\n-        packStream \u003d new BufferedOutputStream(packStream);\n     out \u003d new PackOutputStream(packStream);\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     writeHeader();\n     writeObjects();\n     writeChecksum();\n-    out.flush();\n     windowCursor.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Reduce multi-level buffered streams in transport code\n\nSome transports actually provide stream buffering on their own,\nwithout needing to be wrapped up inside of a BufferedInputStream in\norder to smooth out system calls to read or write.  A great example\nof this is the JSch SSH client, or the Apache MINA SSHD server.\nBoth use custom buffering to packetize the streams into the encrypted\nSSH channel, and wrapping them up inside of a BufferedInputStream\nor BufferedOutputStream is relatively pointless.\n\nOur SideBandOutputStream implementation also provides some fairly\nlarge buffering, equal to one complete side-band packet on the main\ndata channel.  Wrapping that inside of a BufferedOutputStream just to\nsmooth out small writes from PackWriter causes extra data copies, and\nprovides no advantage.  We can save some memory and some CPU cycles\nby letting PackWriter dump directly into the SideBandOutputStream\u0027s\ninternal buffer array.\n\nInstead we push the buffering streams down to be as close to the\nnetwork socket (or operating system pipe) as possible.  This allows\nus to smooth out the smaller reads/writes from pkt-line messages\nduring advertisement and negotation, but avoid copying altogether\nwhen the stream switches to larger writes over a side band channel.\n\nChange-Id: I2f6f16caee64783c77d3dd1b2a41b3cc0c64c159\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/3/13 上午8:08",
          "commitName": "2156aa894cefbabd322fc405138c306bb4e939cd",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2009/9/30 上午7:47",
          "commitNameOld": "1a6964c8274c50f0253db75f010d78ef0e739343",
          "commitAuthorOld": "Git Development Community",
          "daysBetweenCommits": 164.01,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if (reuseDeltas || reuseObjects)\n        searchForReuse();\n    out \u003d new PackOutputStream(packStream);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    writeHeader();\n    writeObjects();\n    writeChecksum();\n    windowCursor.release();\n    writeMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
          "functionStartLine": 586,
          "functionName": "writePack",
          "functionAnnotation": "",
          "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
          "diff": "@@ -1,14 +1,11 @@\n public void writePack(OutputStream packStream) throws IOException {\n     if (reuseDeltas || reuseObjects)\n         searchForReuse();\n-    if (!(packStream instanceof BufferedOutputStream))\n-        packStream \u003d new BufferedOutputStream(packStream);\n     out \u003d new PackOutputStream(packStream);\n     writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n     writeHeader();\n     writeObjects();\n     writeChecksum();\n-    out.flush();\n     windowCursor.release();\n     writeMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. If the stream is not buffered it\n           will be buffered by the writer. Caller is responsible for\n           closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n",
            "newValue": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. The stream should be buffered by\n           the caller. The caller is responsible for closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n"
          }
        }
      ]
    },
    "1a6964c8274c50f0253db75f010d78ef0e739343": {
      "type": "Yintroduced",
      "commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2009/9/30 上午7:47",
      "commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
      "commitAuthor": "Git Development Community",
      "diff": "@@ -0,0 +1,14 @@\n+public void writePack(OutputStream packStream) throws IOException {\n+    if (reuseDeltas || reuseObjects)\n+        searchForReuse();\n+    if (!(packStream instanceof BufferedOutputStream))\n+        packStream \u003d new BufferedOutputStream(packStream);\n+    out \u003d new PackOutputStream(packStream);\n+    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n+    writeHeader();\n+    writeObjects();\n+    writeChecksum();\n+    out.flush();\n+    windowCursor.release();\n+    writeMonitor.endTask();\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void writePack(OutputStream packStream) throws IOException {\n    if (reuseDeltas || reuseObjects)\n        searchForReuse();\n    if (!(packStream instanceof BufferedOutputStream))\n        packStream \u003d new BufferedOutputStream(packStream);\n    out \u003d new PackOutputStream(packStream);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    writeHeader();\n    writeObjects();\n    writeChecksum();\n    out.flush();\n    windowCursor.release();\n    writeMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
      "functionStartLine": 589,
      "functionName": "writePack",
      "functionAnnotation": "",
      "functionDoc": "Write the prepared pack to the supplied stream.\n\u003cp\u003e\nAt first, this method collects and sorts objects to pack, then deltas\nsearch is performed if set up accordingly, finally pack stream is\nwritten. {@link ProgressMonitor} tasks {@value #SEARCHING_REUSE_PROGRESS}\n(only if reuseDeltas or reuseObjects is enabled) and\n{@value #WRITING_OBJECTS_PROGRESS} are updated during packing.\n\u003c/p\u003e\n\u003cp\u003e\nAll reused objects data checksum (Adler32/CRC32) is computed and\nvalidated against existing checksum.\n\u003c/p\u003e\n\n@param packStream output stream of pack data. If the stream is not buffered it\n           will be buffered by the writer. Caller is responsible for\n           closing the stream.\n@throws IOException\n            an error occurred reading a local object\u0027s data to include in\n            the pack, or writing compressed object data to the output\n            stream.\n"
    }
  }
}