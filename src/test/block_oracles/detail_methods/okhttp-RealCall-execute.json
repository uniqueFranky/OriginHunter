{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "RealCall.java",
  "functionName": "execute",
  "functionId": "$execute",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/RealCall.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 144,
  "functionEndLine": 166,
  "numCommitsSeen": 118,
  "timeTaken": 2184,
  "changeHistory": [
    "9b0d19f913465483d0942558eb21e37868040050",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
    "7489193d5953bfba8c892e5aa98624e4ec73dbde",
    "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
    "c6a578ec7696430ecf5a4d4fd8f49c39b105b471",
    "576408374d58a3e9a63714b6f7761cb42a315102",
    "4f24a30c12032b7033884a630696014afd3e77cb",
    "8ff37250310e8d2f9e73293199b3b6e42ec45b0f",
    "38d570a6b28664b398cfa50c5c243c3631cde997",
    "fb700e20af6fa71a20656cd240df4df3c8f15976",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b",
    "9631227619ffe9497c67d92d20428682e5df8862",
    "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab",
    "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
    "b72c9567df964696afdf4335b9456c28d017afde",
    "40c2e6aec09d139a4e96b45856020a5b324b01ef",
    "36cff8b86438a3b0f3bd3e701b374a1404a9168d",
    "83e42cb9288896f88c934faa116b89165b3b9689",
    "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
    "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b",
    "53b9f84cb694a6267373b1fdd6d2144a6f05b68b",
    "c3e8a5d326f026ba6af20d0bf7da41c005ff1915",
    "63d4dfaaa622d4cce72a09cdeead267afa3453a6",
    "0b677ac70d37f9064d3a0c0914794f60f66d64be",
    "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
    "749a65b776c8fc4b39b6463695980275da34da51",
    "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
    "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
    "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
    "9417fa5c2e84580411e0fa4905b1f109e2d49533",
    "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
    "0ef26ad2e9e6b28a181ebc128f96671cff295043",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
    "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722",
    "350c43b6fe02401a73f967d9ef322061638b372a",
    "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0"
  ],
  "changeHistoryShort": {
    "9b0d19f913465483d0942558eb21e37868040050": "Ybodychange",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": "Ybodychange",
    "7489193d5953bfba8c892e5aa98624e4ec73dbde": "Ybodychange",
    "51ca7c55da6fac733eb08a613c1c614ad2e66b5f": "Ybodychange",
    "c6a578ec7696430ecf5a4d4fd8f49c39b105b471": "Ybodychange",
    "576408374d58a3e9a63714b6f7761cb42a315102": "Ybodychange",
    "4f24a30c12032b7033884a630696014afd3e77cb": "Ybodychange",
    "8ff37250310e8d2f9e73293199b3b6e42ec45b0f": "Ybodychange",
    "38d570a6b28664b398cfa50c5c243c3631cde997": "Ybodychange",
    "fb700e20af6fa71a20656cd240df4df3c8f15976": "Ymovefromfile",
    "c9a89876de476983f273edbf108c365127c18c5e": "Ymovefromfile",
    "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b": "Ybodychange",
    "9631227619ffe9497c67d92d20428682e5df8862": "Ybodychange",
    "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab": "Ybodychange",
    "6184a7f5cf2a1d97072aaccb9fc00e08003848e3": "Ybodychange",
    "b72c9567df964696afdf4335b9456c28d017afde": "Ybodychange",
    "40c2e6aec09d139a4e96b45856020a5b324b01ef": "Ybodychange",
    "36cff8b86438a3b0f3bd3e701b374a1404a9168d": "Ybodychange",
    "83e42cb9288896f88c934faa116b89165b3b9689": "Ybodychange",
    "aa7e7a751c8e0096e18f792f3a737ed21d265ead": "Ybodychange",
    "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b": "Ybodychange",
    "53b9f84cb694a6267373b1fdd6d2144a6f05b68b": "Ybodychange",
    "c3e8a5d326f026ba6af20d0bf7da41c005ff1915": "Ybodychange",
    "63d4dfaaa622d4cce72a09cdeead267afa3453a6": "Ymovefromfile",
    "0b677ac70d37f9064d3a0c0914794f60f66d64be": "Ybodychange",
    "112dcc40900d503ea7e416e0da0a8fd9b08a9c17": "Ybodychange",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": "Ybodychange",
    "749a65b776c8fc4b39b6463695980275da34da51": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yannotationchange,Ydocchange)",
    "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a": "Ybodychange",
    "f3a450bf4f0e9428cf8b3c2780236162bbeb803a": "Ybodychange",
    "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa": "Ymultichange(Ybodychange,Ydocchange)",
    "9417fa5c2e84580411e0fa4905b1f109e2d49533": "Ybodychange",
    "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b": "Ybodychange",
    "0ef26ad2e9e6b28a181ebc128f96671cff295043": "Ybodychange",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": "Ybodychange",
    "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722": "Ybodychange",
    "350c43b6fe02401a73f967d9ef322061638b372a": "Ybodychange",
    "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f": "Ybodychange",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9b0d19f913465483d0942558eb21e37868040050": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t call callEnd until after the responseBody is done (#3551)\n\n",
      "commitDate": "2017/8/30 下午1:14",
      "commitName": "9b0d19f913465483d0942558eb21e37868040050",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017/8/30 上午4:14",
      "commitNameOld": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            eventListener.callFailed(RealCall.this, e);\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 144,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,24 +1,23 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.callEnd(RealCall.this);\n     } catch (IOException e) {\n         if (signalledCallback) {\n             Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             eventListener.callFailed(RealCall.this, e);\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": {
      "type": "Ybodychange",
      "commitMessage": "Move all failures into connectFailed and callFailed. (#3550)\n\nI think applications might be simple by tracking successful events\r\nseparately from failure events.",
      "commitDate": "2017/8/30 上午4:14",
      "commitName": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017/8/14 下午10:29",
      "commitNameOld": "7489193d5953bfba8c892e5aa98624e4ec73dbde",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 15.24,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n        eventListener.callEnd(RealCall.this);\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            eventListener.callFailed(RealCall.this, e);\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 145,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,24 +1,24 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.callEnd(RealCall.this, null);\n+        eventListener.callEnd(RealCall.this);\n     } catch (IOException e) {\n         if (signalledCallback) {\n             Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-            eventListener.callEnd(RealCall.this, e);\n+            eventListener.callFailed(RealCall.this, e);\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7489193d5953bfba8c892e5aa98624e4ec73dbde": {
      "type": "Ybodychange",
      "commitMessage": "Rename fetchStart/fetchEnd to callStart/callEnd. (#3522)\n\n",
      "commitDate": "2017/8/14 下午10:29",
      "commitName": "7489193d5953bfba8c892e5aa98624e4ec73dbde",
      "commitAuthor": "Dave Roberge",
      "commitDateOld": "2017/8/6 上午4:25",
      "commitNameOld": "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
      "commitAuthorOld": "Yuri Schimke",
      "daysBetweenCommits": 8.75,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n        eventListener.callEnd(RealCall.this, null);\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            eventListener.callEnd(RealCall.this, e);\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 145,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,24 +1,24 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.fetchEnd(RealCall.this, null);\n+        eventListener.callEnd(RealCall.this, null);\n     } catch (IOException e) {\n         if (signalledCallback) {\n             Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-            eventListener.fetchEnd(RealCall.this, e);\n+            eventListener.callEnd(RealCall.this, e);\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51ca7c55da6fac733eb08a613c1c614ad2e66b5f": {
      "type": "Ybodychange",
      "commitMessage": "Complete EventListener (#3476)\n\n\r\n\r\n* more docs\r\n\r\n* cleanup\r\n\r\n* log events\r\n\r\n* check end events and connectionReleased\r\n\r\n* change connectEnd signature\r\n\r\n* move response body events to codec\r\n\r\n* revert small changes\r\n\r\n* revert incidental change\r\n",
      "commitDate": "2017/8/6 上午4:25",
      "commitName": "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
      "commitAuthor": "Yuri Schimke",
      "commitDateOld": "2017/7/24 上午6:59",
      "commitNameOld": "1d8233ddb7a0dfa490a340a06433909148f21610",
      "commitAuthorOld": "ericaschulz",
      "daysBetweenCommits": 12.89,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n        eventListener.fetchEnd(RealCall.this, null);\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            eventListener.fetchEnd(RealCall.this, e);\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 145,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,24 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n+        eventListener.fetchEnd(RealCall.this, null);\n     } catch (IOException e) {\n         if (signalledCallback) {\n             Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n+            eventListener.fetchEnd(RealCall.this, e);\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6a578ec7696430ecf5a4d4fd8f49c39b105b471": {
      "type": "Ybodychange",
      "commitMessage": "Move core interceptors into top level classes.\n\nNo behavior changes here.\n",
      "commitDate": "2016/6/26 上午7:13",
      "commitName": "c6a578ec7696430ecf5a4d4fd8f49c39b105b471",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/6/26 上午6:04",
      "commitNameOld": "15a5bc40a4520d935bbc02a3552f51dda77fcc9c",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 114,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain();\n-        if (canceled) {\n+        if (retryAndFollowUpInterceptor.isCanceled()) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "576408374d58a3e9a63714b6f7761cb42a315102": {
      "type": "Ybodychange",
      "commitMessage": "Begin to fold together parts of RealCall and HttpEngine.\n\nPreviously we had an awkward, arbitrary separation because RealCall contained\nthe stuff that wasn\u0027t in HttpURLConnection, and HttpEngine contained everything\nthat was shared.\n\nIt was also awkward because HttpEngine could be interrupted in various parts\nof the HttpURLConnection flow: after connecting, while transmitting the request\nbody, etc. With this change we no longer need to handle API calls while we\u0027re\nin these intermediate states, which means we can reduce the scope of certain\nthings from fields to local variables.\n\nThere\u0027s still a way to go here but this is more easy wins.\n",
      "commitDate": "2016/6/24 上午10:54",
      "commitName": "576408374d58a3e9a63714b6f7761cb42a315102",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/6/22 上午4:18",
      "commitNameOld": "0f5c5c6431cfe7e5227d90fc08e822cd3b2cec9f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.28,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 117,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n-        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n+        Response response \u003d getResponseWithInterceptorChain();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f24a30c12032b7033884a630696014afd3e77cb": {
      "type": "Ybodychange",
      "commitMessage": "Make logging more consistent throughout OkHttp.\n\nAvoid using System.out.\n\nUse the best logging implementation on the host platform. On Java this is\njava.util.logging. On Android it\u0027s Android.util.Log.\n\nCloses https://github.com/square/okhttp/issues/2505\n",
      "commitDate": "2016/5/8 上午9:08",
      "commitName": "4f24a30c12032b7033884a630696014afd3e77cb",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/4/21 下午8:52",
      "commitNameOld": "047b56833ccd293ab8f9b1f61460d6d4cc1075da",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 16.51,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 124,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(RealCall.this, response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n-            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+            Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8ff37250310e8d2f9e73293199b3b6e42ec45b0f": {
      "type": "Ybodychange",
      "commitMessage": "Change Callback to take a Call.\n\nThis makes it much easier to test if the call was canceled.\n\nNote that the Call\u0027s request is always the original user request.\nThis is different than the previous request that was passed in, as\nthat could have been the follow up to a redirect.\n",
      "commitDate": "2016/1/12 上午7:40",
      "commitName": "8ff37250310e8d2f9e73293199b3b6e42ec45b0f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/1/2 上午1:12",
      "commitNameOld": "38d570a6b28664b398cfa50c5c243c3631cde997",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 10.27,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(RealCall.this, response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(RealCall.this, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 124,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n             signalledCallback \u003d true;\n-            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n+            responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n-            responseCallback.onResponse(response);\n+            responseCallback.onResponse(RealCall.this, response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-            Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n-            responseCallback.onFailure(request, e);\n+            responseCallback.onFailure(RealCall.this, e);\n         }\n     } finally {\n         client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "38d570a6b28664b398cfa50c5c243c3631cde997": {
      "type": "Ybodychange",
      "commitMessage": "Drop get and set prefixes in OkHttpClient, OkHttpClient.Builder\n",
      "commitDate": "2016/1/2 上午1:12",
      "commitName": "38d570a6b28664b398cfa50c5c243c3631cde997",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/1/1 下午11:55",
      "commitNameOld": "71ec4917b51faeba98db149739576feb51b4d505",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.dispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 124,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,23 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n             responseCallback.onFailure(request, e);\n         }\n     } finally {\n-        client.getDispatcher().finished(this);\n+        client.dispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb700e20af6fa71a20656cd240df4df3c8f15976": {
      "type": "Ymovefromfile",
      "commitMessage": "Make call an interface, and introduce Call.Factory.\n\nMore documentation forthcoming.\n",
      "commitDate": "2015/12/24 上午4:55",
      "commitName": "fb700e20af6fa71a20656cd240df4df3c8f15976",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/23 上午11:15",
      "commitNameOld": "6aff563d5a730d49ced0663235b16331d6716f15",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/RealCall.java",
      "functionStartLine": 122,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/okhttp3/Call.java",
        "newPath": "okhttp/src/main/java/okhttp3/RealCall.java",
        "oldMethodName": "execute",
        "newMethodName": "execute"
      }
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Ymovefromfile",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015/12/16 下午2:34",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/16 上午10:36",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/Call.java",
      "functionStartLine": 168,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
        "newPath": "okhttp/src/main/java/okhttp3/Call.java",
        "oldMethodName": "execute",
        "newMethodName": "execute"
      }
    },
    "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b": {
      "type": "Ybodychange",
      "commitMessage": "Make AsyncCall handle interceptors that throws an IOException\n\nThis closes #1801\n",
      "commitDate": "2015/10/21 下午1:41",
      "commitName": "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b",
      "commitAuthor": "Nicklas Ansman Giertz",
      "commitDateOld": "2015/8/3 上午9:01",
      "commitNameOld": "4c90a2e04a83646597a506a80b5a885d5c515bf0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 79.19,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 159,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,23 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-            responseCallback.onFailure(engine.getRequest(), e);\n+            Request request \u003d engine \u003d\u003d null ? originalRequest : engine.getRequest();\n+            responseCallback.onFailure(request, e);\n         }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9631227619ffe9497c67d92d20428682e5df8862": {
      "type": "Ybodychange",
      "commitMessage": "Add a web socket call concept for connecting.\n\nSimilar to HTTP and Call, the WebSocketCall is a representation of a pending HTTP request and subsequent upgrade to speak web sockets. Upon synchronous execution you are handed a WebSocket instance for synchronous writing and also pass in a WebSocketListener for async callbacks due to reading.\n\nThe API changes in this commits also generalize WebSocket such that it\u0027s agnostic to being a client or server peer.\n",
      "commitDate": "2015/1/1 下午3:13",
      "commitName": "9631227619ffe9497c67d92d20428682e5df8862",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014/12/31 上午1:14",
      "commitNameOld": "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(engine.getRequest(), e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 159,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n-        Response response \u003d getResponseWithInterceptorChain();\n+        Response response \u003d getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             responseCallback.onFailure(engine.getRequest(), e);\n         }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab": {
      "type": "Ybodychange",
      "commitMessage": "Move cache writing out of the transport.\n\nThis is necessary to unblock network interceptors, where the interceptor\nmay elect to rewrite the response body. If we\u0027ve already cached the\noriginal response body, we\u0027re too late.\n",
      "commitDate": "2014/12/22 上午10:21",
      "commitName": "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/12/9 上午2:25",
      "commitNameOld": "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 13.33,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(engine.getRequest(), e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 156,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponseWithInterceptorChain();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-            responseCallback.onFailure(originalRequest, e);\n+            responseCallback.onFailure(engine.getRequest(), e);\n         }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6184a7f5cf2a1d97072aaccb9fc00e08003848e3": {
      "type": "Ybodychange",
      "commitMessage": "Initial implementation of interceptors.\n\nI\u0027m anticipating implementing interceptors at two independent parts\nof the API. The first is high-level interceptors, that intercept\nbefore the socket connection has been established.\n\nThe second set of interceptors will only execute for requests that\nrequire a socket connection. Those are forthcoming.\n",
      "commitDate": "2014/12/9 上午2:25",
      "commitName": "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/12/1 上午6:12",
      "commitNameOld": "986b6b65bac1d825b1c09079625f50dbd67a1e32",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponseWithInterceptorChain();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(originalRequest, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 156,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,22 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n-        Response response \u003d getResponse(false);\n+        Response response \u003d getResponseWithInterceptorChain();\n         if (canceled) {\n             signalledCallback \u003d true;\n-            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n+            responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n-            engine.releaseConnection();\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-            responseCallback.onFailure(request, e);\n+            responseCallback.onFailure(originalRequest, e);\n         }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b72c9567df964696afdf4335b9456c28d017afde": {
      "type": "Ybodychange",
      "commitMessage": "Hook up the web socket reader and writer together.\n\nAdd a simple real-world recipe which talks to an echo server.\n",
      "commitDate": "2014/11/5 下午3:29",
      "commitName": "b72c9567df964696afdf4335b9456c28d017afde",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014/11/3 上午1:48",
      "commitNameOld": "5991ab1ecb9ea0b31826bab38ec855a893475562",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.57,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse(false);\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            engine.releaseConnection();\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 161,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,23 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n-        Response response \u003d getResponse();\n+        Response response \u003d getResponse(false);\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             engine.releaseConnection();\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n             logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             responseCallback.onFailure(request, e);\n         }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "40c2e6aec09d139a4e96b45856020a5b324b01ef": {
      "type": "Ybodychange",
      "commitMessage": "Use one logger for all logging.\n\nThere was a concurrency problem in CallTest where multiple calls to\nLogger.getLogger() didn\u0027t return the same instance, leading to failures\nin the test.\n",
      "commitDate": "2014/10/26 下午11:48",
      "commitName": "40c2e6aec09d139a4e96b45856020a5b324b01ef",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/10/26 上午10:50",
      "commitNameOld": "9cc7a5219f8f88bec35a073feab96abab4a9b42f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            engine.releaseConnection();\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 157,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,23 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             engine.releaseConnection();\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback) {\n-            Logger.getLogger(OkHttpClient.class.getName()).log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+            logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n             responseCallback.onFailure(request, e);\n         }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "36cff8b86438a3b0f3bd3e701b374a1404a9168d": {
      "type": "Ybodychange",
      "commitMessage": "Log uncaught IOExceptions instead of rethrowing them.\n\nThe application layer can handle these with a try/catch block in their\nonResponse method if desired.\n\nThis prevents a crash for applications that haven\u0027t deliberately configured\ntheir uncaught exception handlers.\n\nCloses https://github.com/square/okhttp/issues/1049\n",
      "commitDate": "2014/10/26 上午6:34",
      "commitName": "36cff8b86438a3b0f3bd3e701b374a1404a9168d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/10/12 上午10:27",
      "commitNameOld": "83090befcca69b44c257b96afb519ca66282ca63",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 13.84,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            engine.releaseConnection();\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback) {\n            Logger.getLogger(OkHttpClient.class.getName()).log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n            responseCallback.onFailure(request, e);\n        }\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 153,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,23 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             engine.releaseConnection();\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n-        if (signalledCallback)\n-            throw new RuntimeException(e);\n-        responseCallback.onFailure(request, e);\n+        if (signalledCallback) {\n+            Logger.getLogger(OkHttpClient.class.getName()).log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+        } else {\n+            responseCallback.onFailure(request, e);\n+        }\n     } finally {\n         client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "83e42cb9288896f88c934faa116b89165b3b9689": {
      "type": "Ybodychange",
      "commitMessage": "Make it possible to mock OkHttpClient and Call.\n\nCloses https://github.com/square/okhttp/issues/956\n",
      "commitDate": "2014/6/30 下午1:46",
      "commitName": "83e42cb9288896f88c934faa116b89165b3b9689",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/6/11 上午7:45",
      "commitNameOld": "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 19.25,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            engine.releaseConnection();\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            throw new RuntimeException(e);\n        responseCallback.onFailure(request, e);\n    } finally {\n        client.getDispatcher().finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             engine.releaseConnection();\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback)\n             throw new RuntimeException(e);\n         responseCallback.onFailure(request, e);\n     } finally {\n-        dispatcher.finished(this);\n+        client.getDispatcher().finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aa7e7a751c8e0096e18f792f3a737ed21d265ead": {
      "type": "Ybodychange",
      "commitMessage": "Keep the response body alive after the callback.\n",
      "commitDate": "2014/6/11 上午7:45",
      "commitName": "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/6/8 下午11:29",
      "commitNameOld": "baba1c090dde4d2e40479d9178bdcecafa76daa5",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.34,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            engine.releaseConnection();\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            throw new RuntimeException(e);\n        responseCallback.onFailure(request, e);\n    } finally {\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n+            engine.releaseConnection();\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback)\n             throw new RuntimeException(e);\n         responseCallback.onFailure(request, e);\n     } finally {\n-        engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t lose uncaught exceptions.\n",
      "commitDate": "2014/5/27 下午9:33",
      "commitName": "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/5/20 上午11:18",
      "commitNameOld": "ed70981925e64fd0cb593d09bdd401ea4ea19848",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 7.43,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            throw new RuntimeException(e);\n        responseCallback.onFailure(request, e);\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n             responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback)\n-            return;\n+            throw new RuntimeException(e);\n         responseCallback.onFailure(request, e);\n     } finally {\n         engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53b9f84cb694a6267373b1fdd6d2144a6f05b68b": {
      "type": "Ybodychange",
      "commitMessage": "Remove Failure wrapper type.\n",
      "commitDate": "2014/5/20 上午4:15",
      "commitName": "53b9f84cb694a6267373b1fdd6d2144a6f05b68b",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014/5/10 下午11:20",
      "commitNameOld": "84312bd93f895641f90900952dba6bb48d0b247e",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 9.21,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            return;\n        responseCallback.onFailure(request, e);\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 140,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n-            responseCallback.onFailure(new Failure.Builder().request(request).exception(new IOException(\"Canceled\")).build());\n+            responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback)\n             return;\n-        responseCallback.onFailure(new Failure.Builder().request(request).exception(e).build());\n+        responseCallback.onFailure(request, e);\n     } finally {\n         engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3e8a5d326f026ba6af20d0bf7da41c005ff1915": {
      "type": "Ybodychange",
      "commitMessage": "Use IOE for canceled streams.\n",
      "commitDate": "2014/4/26 上午6:21",
      "commitName": "c3e8a5d326f026ba6af20d0bf7da41c005ff1915",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014/4/26 上午5:30",
      "commitNameOld": "38ea820a73eb318254e9722653aac8878598c266",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(new Failure.Builder().request(request).exception(new IOException(\"Canceled\")).build());\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            return;\n        responseCallback.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 137,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n @Override\n protected void execute() {\n     boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n             signalledCallback \u003d true;\n-            responseCallback.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n+            responseCallback.onFailure(new Failure.Builder().request(request).exception(new IOException(\"Canceled\")).build());\n         } else {\n             signalledCallback \u003d true;\n             responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n         if (signalledCallback)\n             return;\n         responseCallback.onFailure(new Failure.Builder().request(request).exception(e).build());\n     } finally {\n         engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63d4dfaaa622d4cce72a09cdeead267afa3453a6": {
      "type": "Ymovefromfile",
      "commitMessage": "Merge Job into Call. CallTest \u003d AsyncApiTest + SyncApiTest.\n",
      "commitDate": "2014/4/26 上午2:13",
      "commitName": "63d4dfaaa622d4cce72a09cdeead267afa3453a6",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014/4/25 下午11:18",
      "commitNameOld": "f4c83e8eb86ac4afb224f91cd68bd9650351fe64",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            return;\n        responseCallback.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
      "functionStartLine": 139,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
        "oldMethodName": "execute",
        "newMethodName": "execute"
      }
    },
    "0b677ac70d37f9064d3a0c0914794f60f66d64be": {
      "type": "Ybodychange",
      "commitMessage": "Introduce Call for async invocations.\n",
      "commitDate": "2014/4/25 下午12:25",
      "commitName": "0b677ac70d37f9064d3a0c0914794f60f66d64be",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014/4/23 下午12:55",
      "commitNameOld": "5b6f64a46220911466350202ae974f167497225a",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.98,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledCallback \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledCallback \u003d true;\n            responseCallback.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n        } else {\n            signalledCallback \u003d true;\n            responseCallback.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledCallback)\n            return;\n        responseCallback.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 62,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n @Override\n protected void execute() {\n-    boolean signalledReceiver \u003d false;\n+    boolean signalledCallback \u003d false;\n     try {\n         Response response \u003d getResponse();\n         if (canceled) {\n-            signalledReceiver \u003d true;\n-            responseReceiver.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n+            signalledCallback \u003d true;\n+            responseCallback.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n         } else {\n-            signalledReceiver \u003d true;\n-            responseReceiver.onResponse(response);\n+            signalledCallback \u003d true;\n+            responseCallback.onResponse(response);\n         }\n     } catch (IOException e) {\n-        if (signalledReceiver)\n+        if (signalledCallback)\n             return;\n-        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+        responseCallback.onFailure(new Failure.Builder().request(request).exception(e).build());\n     } finally {\n         engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "112dcc40900d503ea7e416e0da0a8fd9b08a9c17": {
      "type": "Ybodychange",
      "commitMessage": "Clarified behavior of AsyncApi when a request is canceled, including its implied disconnect.\n",
      "commitDate": "2014/4/22 下午11:39",
      "commitName": "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
      "commitAuthor": "Adrian Cole",
      "commitDateOld": "2014/4/22 下午12:14",
      "commitNameOld": "9146c579dd9110d0028144c59515da9be1ce7108",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.48,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    boolean signalledReceiver \u003d false;\n    try {\n        Response response \u003d getResponse();\n        if (canceled) {\n            signalledReceiver \u003d true;\n            responseReceiver.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n        } else {\n            signalledReceiver \u003d true;\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        if (signalledReceiver)\n            return;\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 62,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,21 @@\n @Override\n protected void execute() {\n+    boolean signalledReceiver \u003d false;\n     try {\n         Response response \u003d getResponse();\n-        if (response !\u003d null \u0026\u0026 !canceled) {\n+        if (canceled) {\n+            signalledReceiver \u003d true;\n+            responseReceiver.onFailure(new Failure.Builder().request(request).exception(new CancellationException(\"Canceled\")).build());\n+        } else {\n+            signalledReceiver \u003d true;\n             responseReceiver.onResponse(response);\n         }\n     } catch (IOException e) {\n+        if (signalledReceiver)\n+            return;\n         responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n     } finally {\n         engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
      "type": "Ybodychange",
      "commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit\u0027s told.\n",
      "commitDate": "2014/2/16 上午7:44",
      "commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/14 下午12:10",
      "commitNameOld": "8972a94aee5b1a8732b4f8246c6ce43fd9e5e1cb",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 32.82,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.close();\n        dispatcher.finished(this);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 71,
      "functionName": "execute",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n @Override\n protected void execute() {\n     try {\n         Response response \u003d getResponse();\n         if (response !\u003d null \u0026\u0026 !canceled) {\n             responseReceiver.onResponse(response);\n         }\n     } catch (IOException e) {\n         responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n     } finally {\n-        engine.release(true);\n+        engine.close();\n         dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "749a65b776c8fc4b39b6463695980275da34da51": {
      "type": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
      "commitDate": "2014/1/12 下午10:47",
      "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014/1/12 下午10:47",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/8 上午11:41",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.release(true);\n        dispatcher.finished(this);\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,14 @@\n-private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-    while (true) {\n-        if (canceled)\n-            return null;\n-        Request.Body body \u003d request.body();\n-        if (body !\u003d null) {\n-            MediaType contentType \u003d body.contentType();\n-            if (contentType \u003d\u003d null)\n-                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            Request.Builder requestBuilder \u003d request.newBuilder();\n-            requestBuilder.header(\"Content-Type\", contentType.toString());\n-            long contentLength \u003d body.contentLength();\n-            if (contentLength !\u003d -1) {\n-                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-                requestBuilder.removeHeader(\"Transfer-Encoding\");\n-            } else {\n-                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-                requestBuilder.removeHeader(\"Content-Length\");\n-            }\n-            request \u003d requestBuilder.build();\n+@Override\n+protected void execute() {\n+    try {\n+        Response response \u003d getResponse();\n+        if (response !\u003d null \u0026\u0026 !canceled) {\n+            responseReceiver.onResponse(response);\n         }\n-        engine \u003d new HttpEngine(client, request, false, connection, null);\n-        engine.sendRequest();\n-        if (body !\u003d null) {\n-            body.writeTo(engine.getRequestBody());\n-        }\n-        engine.readResponse();\n-        Response response \u003d engine.getResponse();\n-        Request redirect \u003d processResponse(engine, response);\n-        if (redirect \u003d\u003d null) {\n-            engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n-        }\n-        if (!sameConnection(request, redirect)) {\n-            engine.automaticallyReleaseConnectionToPool();\n-        }\n-        engine.release(false);\n-        connection \u003d engine.getConnection();\n-        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n-        request \u003d redirect;\n+    } catch (IOException e) {\n+        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+    } finally {\n+        engine.release(true);\n+        dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Response",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014/1/12 下午10:47",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/8 上午11:41",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.release(true);\n        dispatcher.finished(this);\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,14 @@\n-private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-    while (true) {\n-        if (canceled)\n-            return null;\n-        Request.Body body \u003d request.body();\n-        if (body !\u003d null) {\n-            MediaType contentType \u003d body.contentType();\n-            if (contentType \u003d\u003d null)\n-                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            Request.Builder requestBuilder \u003d request.newBuilder();\n-            requestBuilder.header(\"Content-Type\", contentType.toString());\n-            long contentLength \u003d body.contentLength();\n-            if (contentLength !\u003d -1) {\n-                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-                requestBuilder.removeHeader(\"Transfer-Encoding\");\n-            } else {\n-                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-                requestBuilder.removeHeader(\"Content-Length\");\n-            }\n-            request \u003d requestBuilder.build();\n+@Override\n+protected void execute() {\n+    try {\n+        Response response \u003d getResponse();\n+        if (response !\u003d null \u0026\u0026 !canceled) {\n+            responseReceiver.onResponse(response);\n         }\n-        engine \u003d new HttpEngine(client, request, false, connection, null);\n-        engine.sendRequest();\n-        if (body !\u003d null) {\n-            body.writeTo(engine.getRequestBody());\n-        }\n-        engine.readResponse();\n-        Response response \u003d engine.getResponse();\n-        Request redirect \u003d processResponse(engine, response);\n-        if (redirect \u003d\u003d null) {\n-            engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n-        }\n-        if (!sameConnection(request, redirect)) {\n-            engine.automaticallyReleaseConnectionToPool();\n-        }\n-        engine.release(false);\n-        connection \u003d engine.getConnection();\n-        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n-        request \u003d redirect;\n+    } catch (IOException e) {\n+        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+    } finally {\n+        engine.release(true);\n+        dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014/1/12 下午10:47",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/8 上午11:41",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.release(true);\n        dispatcher.finished(this);\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,14 @@\n-private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-    while (true) {\n-        if (canceled)\n-            return null;\n-        Request.Body body \u003d request.body();\n-        if (body !\u003d null) {\n-            MediaType contentType \u003d body.contentType();\n-            if (contentType \u003d\u003d null)\n-                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            Request.Builder requestBuilder \u003d request.newBuilder();\n-            requestBuilder.header(\"Content-Type\", contentType.toString());\n-            long contentLength \u003d body.contentLength();\n-            if (contentLength !\u003d -1) {\n-                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-                requestBuilder.removeHeader(\"Transfer-Encoding\");\n-            } else {\n-                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-                requestBuilder.removeHeader(\"Content-Length\");\n-            }\n-            request \u003d requestBuilder.build();\n+@Override\n+protected void execute() {\n+    try {\n+        Response response \u003d getResponse();\n+        if (response !\u003d null \u0026\u0026 !canceled) {\n+            responseReceiver.onResponse(response);\n         }\n-        engine \u003d new HttpEngine(client, request, false, connection, null);\n-        engine.sendRequest();\n-        if (body !\u003d null) {\n-            body.writeTo(engine.getRequestBody());\n-        }\n-        engine.readResponse();\n-        Response response \u003d engine.getResponse();\n-        Request redirect \u003d processResponse(engine, response);\n-        if (redirect \u003d\u003d null) {\n-            engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n-        }\n-        if (!sameConnection(request, redirect)) {\n-            engine.automaticallyReleaseConnectionToPool();\n-        }\n-        engine.release(false);\n-        connection \u003d engine.getConnection();\n-        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n-        request \u003d redirect;\n+    } catch (IOException e) {\n+        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+    } finally {\n+        engine.release(true);\n+        dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014/1/12 下午10:47",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/8 上午11:41",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.release(true);\n        dispatcher.finished(this);\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,14 @@\n-private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-    while (true) {\n-        if (canceled)\n-            return null;\n-        Request.Body body \u003d request.body();\n-        if (body !\u003d null) {\n-            MediaType contentType \u003d body.contentType();\n-            if (contentType \u003d\u003d null)\n-                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            Request.Builder requestBuilder \u003d request.newBuilder();\n-            requestBuilder.header(\"Content-Type\", contentType.toString());\n-            long contentLength \u003d body.contentLength();\n-            if (contentLength !\u003d -1) {\n-                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-                requestBuilder.removeHeader(\"Transfer-Encoding\");\n-            } else {\n-                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-                requestBuilder.removeHeader(\"Content-Length\");\n-            }\n-            request \u003d requestBuilder.build();\n+@Override\n+protected void execute() {\n+    try {\n+        Response response \u003d getResponse();\n+        if (response !\u003d null \u0026\u0026 !canceled) {\n+            responseReceiver.onResponse(response);\n         }\n-        engine \u003d new HttpEngine(client, request, false, connection, null);\n-        engine.sendRequest();\n-        if (body !\u003d null) {\n-            body.writeTo(engine.getRequestBody());\n-        }\n-        engine.readResponse();\n-        Response response \u003d engine.getResponse();\n-        Request redirect \u003d processResponse(engine, response);\n-        if (redirect \u003d\u003d null) {\n-            engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n-        }\n-        if (!sameConnection(request, redirect)) {\n-            engine.automaticallyReleaseConnectionToPool();\n-        }\n-        engine.release(false);\n-        connection \u003d engine.getConnection();\n-        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n-        request \u003d redirect;\n+    } catch (IOException e) {\n+        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+    } finally {\n+        engine.release(true);\n+        dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014/1/12 下午10:47",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/8 上午11:41",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.release(true);\n        dispatcher.finished(this);\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,14 @@\n-private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-    while (true) {\n-        if (canceled)\n-            return null;\n-        Request.Body body \u003d request.body();\n-        if (body !\u003d null) {\n-            MediaType contentType \u003d body.contentType();\n-            if (contentType \u003d\u003d null)\n-                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            Request.Builder requestBuilder \u003d request.newBuilder();\n-            requestBuilder.header(\"Content-Type\", contentType.toString());\n-            long contentLength \u003d body.contentLength();\n-            if (contentLength !\u003d -1) {\n-                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-                requestBuilder.removeHeader(\"Transfer-Encoding\");\n-            } else {\n-                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-                requestBuilder.removeHeader(\"Content-Length\");\n-            }\n-            request \u003d requestBuilder.build();\n+@Override\n+protected void execute() {\n+    try {\n+        Response response \u003d getResponse();\n+        if (response !\u003d null \u0026\u0026 !canceled) {\n+            responseReceiver.onResponse(response);\n         }\n-        engine \u003d new HttpEngine(client, request, false, connection, null);\n-        engine.sendRequest();\n-        if (body !\u003d null) {\n-            body.writeTo(engine.getRequestBody());\n-        }\n-        engine.readResponse();\n-        Response response \u003d engine.getResponse();\n-        Request redirect \u003d processResponse(engine, response);\n-        if (redirect \u003d\u003d null) {\n-            engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n-        }\n-        if (!sameConnection(request, redirect)) {\n-            engine.automaticallyReleaseConnectionToPool();\n-        }\n-        engine.release(false);\n-        connection \u003d engine.getConnection();\n-        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n-        request \u003d redirect;\n+    } catch (IOException e) {\n+        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+    } finally {\n+        engine.release(true);\n+        dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
          "commitDate": "2014/1/12 下午10:47",
          "commitName": "749a65b776c8fc4b39b6463695980275da34da51",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/8 上午11:41",
          "commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.46,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected void execute() {\n    try {\n        Response response \u003d getResponse();\n        if (response !\u003d null \u0026\u0026 !canceled) {\n            responseReceiver.onResponse(response);\n        }\n    } catch (IOException e) {\n        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n    } finally {\n        engine.release(true);\n        dispatcher.finished(this);\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 71,
          "functionName": "execute",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,14 @@\n-private Response execute() throws IOException {\n-    Connection connection \u003d null;\n-    Response redirectedBy \u003d null;\n-    while (true) {\n-        if (canceled)\n-            return null;\n-        Request.Body body \u003d request.body();\n-        if (body !\u003d null) {\n-            MediaType contentType \u003d body.contentType();\n-            if (contentType \u003d\u003d null)\n-                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            Request.Builder requestBuilder \u003d request.newBuilder();\n-            requestBuilder.header(\"Content-Type\", contentType.toString());\n-            long contentLength \u003d body.contentLength();\n-            if (contentLength !\u003d -1) {\n-                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-                requestBuilder.removeHeader(\"Transfer-Encoding\");\n-            } else {\n-                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-                requestBuilder.removeHeader(\"Content-Length\");\n-            }\n-            request \u003d requestBuilder.build();\n+@Override\n+protected void execute() {\n+    try {\n+        Response response \u003d getResponse();\n+        if (response !\u003d null \u0026\u0026 !canceled) {\n+            responseReceiver.onResponse(response);\n         }\n-        engine \u003d new HttpEngine(client, request, false, connection, null);\n-        engine.sendRequest();\n-        if (body !\u003d null) {\n-            body.writeTo(engine.getRequestBody());\n-        }\n-        engine.readResponse();\n-        Response response \u003d engine.getResponse();\n-        Request redirect \u003d processResponse(engine, response);\n-        if (redirect \u003d\u003d null) {\n-            engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n-        }\n-        if (!sameConnection(request, redirect)) {\n-            engine.automaticallyReleaseConnectionToPool();\n-        }\n-        engine.release(false);\n-        connection \u003d engine.getConnection();\n-        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n-        request \u003d redirect;\n+    } catch (IOException e) {\n+        responseReceiver.onFailure(new Failure.Builder().request(request).exception(e).build());\n+    } finally {\n+        engine.release(true);\n+        dispatcher.finished(this);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Performs the request and returns the response. May return null if this job\nwas canceled.\n",
            "newValue": ""
          }
        }
      ]
    },
    "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a": {
      "type": "Ybodychange",
      "commitMessage": "Cleanup when a job finishes, cleanly or otherwise.\n\nThis also names the job thread.\n",
      "commitDate": "2014/1/8 上午11:41",
      "commitName": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/6 上午8:28",
      "commitNameOld": "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.13,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        if (canceled)\n            return null;\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        engine \u003d new HttpEngine(client, request, false, connection, null);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response response \u003d engine.getResponse();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        }\n        if (!sameConnection(request, redirect)) {\n            engine.automaticallyReleaseConnectionToPool();\n        }\n        engine.release(false);\n        connection \u003d engine.getConnection();\n        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 93,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "Performs the request and returns the response. May return null if this job\nwas canceled.\n",
      "diff": "@@ -1,44 +1,44 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         if (canceled)\n             return null;\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n                 requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n                 requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n-        HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n+        engine \u003d new HttpEngine(client, request, false, connection, null);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response response \u003d engine.getResponse();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         }\n         if (!sameConnection(request, redirect)) {\n             engine.automaticallyReleaseConnectionToPool();\n         }\n         engine.release(false);\n         connection \u003d engine.getConnection();\n         redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f3a450bf4f0e9428cf8b3c2780236162bbeb803a": {
      "type": "Ybodychange",
      "commitMessage": "Code to handle redirect limits in the async API.\n",
      "commitDate": "2014/1/6 上午8:28",
      "commitName": "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/5 下午11:06",
      "commitNameOld": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        if (canceled)\n            return null;\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response response \u003d engine.getResponse();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        }\n        if (!sameConnection(request, redirect)) {\n            engine.automaticallyReleaseConnectionToPool();\n        }\n        engine.release(false);\n        connection \u003d engine.getConnection();\n        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 90,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "Performs the request and returns the response. May return null if this job\nwas canceled.\n",
      "diff": "@@ -1,41 +1,44 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         if (canceled)\n             return null;\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n                 requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n                 requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n         HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response response \u003d engine.getResponse();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         }\n+        if (!sameConnection(request, redirect)) {\n+            engine.automaticallyReleaseConnectionToPool();\n+        }\n         engine.release(false);\n-        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n+        connection \u003d engine.getConnection();\n         redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Implement simple limits in the dispatcher.\n\nThis adds Dispatcher to the public API so that application\ncode can tweak the policy.\n",
      "commitDate": "2014/1/5 下午11:06",
      "commitName": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Implement simple limits in the dispatcher.\n\nThis adds Dispatcher to the public API so that application\ncode can tweak the policy.\n",
          "commitDate": "2014/1/5 下午11:06",
          "commitName": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/4 上午6:36",
          "commitNameOld": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 1.69,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        if (canceled)\n            return null;\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response response \u003d engine.getResponse();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        }\n        engine.release(false);\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n        request \u003d redirect;\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 88,
          "functionName": "execute",
          "functionAnnotation": "",
          "functionDoc": "Performs the request and returns the response. May return null if this job\nwas canceled.\n",
          "diff": "@@ -1,39 +1,41 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n+        if (canceled)\n+            return null;\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n                 requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n                 requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n-        HttpEngine engine \u003d newEngine(connection);\n+        HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response response \u003d engine.getResponse();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         }\n         engine.release(false);\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Implement simple limits in the dispatcher.\n\nThis adds Dispatcher to the public API so that application\ncode can tweak the policy.\n",
          "commitDate": "2014/1/5 下午11:06",
          "commitName": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
          "commitAuthor": "jwilson",
          "commitDateOld": "2014/1/4 上午6:36",
          "commitNameOld": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 1.69,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        if (canceled)\n            return null;\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response response \u003d engine.getResponse();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        }\n        engine.release(false);\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n        request \u003d redirect;\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
          "functionStartLine": 88,
          "functionName": "execute",
          "functionAnnotation": "",
          "functionDoc": "Performs the request and returns the response. May return null if this job\nwas canceled.\n",
          "diff": "@@ -1,39 +1,41 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n+        if (canceled)\n+            return null;\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n                 requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n                 requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n-        HttpEngine engine \u003d newEngine(connection);\n+        HttpEngine engine \u003d new HttpEngine(client, request, false, connection, null);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response response \u003d engine.getResponse();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         }\n         engine.release(false);\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Performs the request and returns the response. May return null if this job\nwas canceled.\n"
          }
        }
      ]
    },
    "9417fa5c2e84580411e0fa4905b1f109e2d49533": {
      "type": "Ybodychange",
      "commitMessage": "Another round of header APIs cleanup.\n\nThis promotes Headers to a public API from the internal package.\nIt moves some of its methods to OkHeaders, which has been renamed\nfrom SyntheticHeaders.\n\nMaking the Headers class public API makes it possible to remove\nmore exotic APIs from Request and Response like the APIs to track\nheaders by index rather than by name.\n",
      "commitDate": "2014/1/4 上午6:36",
      "commitName": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/3 下午1:52",
      "commitNameOld": "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d newEngine(connection);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response response \u003d engine.getResponse();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        }\n        engine.release(false);\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 72,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,39 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n-                requestBuilder.setContentLength(contentLength);\n+                requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n                 requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n         HttpEngine engine \u003d newEngine(connection);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response response \u003d engine.getResponse();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n-            return response.newBuilder().body(new Dispatcher.RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n+            return response.newBuilder().body(new RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         }\n         engine.release(false);\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b": {
      "type": "Ybodychange",
      "commitMessage": "Make redirects work with the async API.\n",
      "commitDate": "2014/1/3 下午1:52",
      "commitName": "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/2 下午11:23",
      "commitNameOld": "0ef26ad2e9e6b28a181ebc128f96671cff295043",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.6,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.setContentLength(contentLength);\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d newEngine(connection);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response response \u003d engine.getResponse();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response.newBuilder().body(new Dispatcher.RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        }\n        engine.release(false);\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 70,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,39 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n                 requestBuilder.setContentLength(contentLength);\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n                 requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n         HttpEngine engine \u003d newEngine(connection);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n-        Response engineResponse \u003d engine.getResponse();\n-        Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n+        Response response \u003d engine.getResponse();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n-            return response;\n+            return response.newBuilder().body(new Dispatcher.RealResponseBody(response, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         }\n+        engine.release(false);\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n-        redirectedBy \u003d response;\n+        redirectedBy \u003d response.newBuilder().redirectedBy(redirectedBy).build();\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ef26ad2e9e6b28a181ebc128f96671cff295043": {
      "type": "Ybodychange",
      "commitMessage": "Remove some \u0027implementation detail\u0027 headers from the public API.\n\nApplication code doesn\u0027t need to worry about headers like\n\u0027Connection\u0027 or \u0027Transfer-Encoding\u0027, so don\u0027t include them\nin the API.\n",
      "commitDate": "2014/1/2 下午11:23",
      "commitName": "0ef26ad2e9e6b28a181ebc128f96671cff295043",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/1 下午11:30",
      "commitNameOld": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.setContentLength(contentLength);\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d newEngine(connection);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response engineResponse \u003d engine.getResponse();\n        Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response;\n        }\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response;\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 70,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,39 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             Request.Builder requestBuilder \u003d request.newBuilder();\n             requestBuilder.header(\"Content-Type\", contentType.toString());\n             long contentLength \u003d body.contentLength();\n             if (contentLength !\u003d -1) {\n                 requestBuilder.setContentLength(contentLength);\n                 requestBuilder.removeHeader(\"Transfer-Encoding\");\n             } else {\n-                requestBuilder.setChunked();\n+                requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n                 requestBuilder.removeHeader(\"Content-Length\");\n             }\n             request \u003d requestBuilder.build();\n         }\n         HttpEngine engine \u003d newEngine(connection);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response engineResponse \u003d engine.getResponse();\n         Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response;\n         }\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response;\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": {
      "type": "Ybodychange",
      "commitMessage": "Kill the Policy interface.\n\nThis interface was necessary while cleaning up the delicate\nintertwined relationship between HttpURLConnection and HttpEngine.\nWith this change HttpEngine no longer has a reverse dependency\non HttpURLConnection.\n",
      "commitDate": "2014/1/1 下午11:30",
      "commitName": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/12/31 下午2:15",
      "commitNameOld": "60f20dc23cb08d598d605f51f7526725ec42abd9",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.39,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            Request.Builder requestBuilder \u003d request.newBuilder();\n            requestBuilder.header(\"Content-Type\", contentType.toString());\n            long contentLength \u003d body.contentLength();\n            if (contentLength !\u003d -1) {\n                requestBuilder.setContentLength(contentLength);\n                requestBuilder.removeHeader(\"Transfer-Encoding\");\n            } else {\n                requestBuilder.setChunked();\n                requestBuilder.removeHeader(\"Content-Length\");\n            }\n            request \u003d requestBuilder.build();\n        }\n        HttpEngine engine \u003d newEngine(connection);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response engineResponse \u003d engine.getResponse();\n        Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response;\n        }\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response;\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 70,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,31 +1,39 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            if (request.header(\"Content-Type\") \u003d\u003d null) {\n-                request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n+            Request.Builder requestBuilder \u003d request.newBuilder();\n+            requestBuilder.header(\"Content-Type\", contentType.toString());\n+            long contentLength \u003d body.contentLength();\n+            if (contentLength !\u003d -1) {\n+                requestBuilder.setContentLength(contentLength);\n+                requestBuilder.removeHeader(\"Transfer-Encoding\");\n+            } else {\n+                requestBuilder.setChunked();\n+                requestBuilder.removeHeader(\"Content-Length\");\n             }\n+            request \u003d requestBuilder.build();\n         }\n         HttpEngine engine \u003d newEngine(connection);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         Response engineResponse \u003d engine.getResponse();\n         Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response;\n         }\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response;\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722": {
      "type": "Ybodychange",
      "commitMessage": "Combine Request+RequestHeaders and Response+ResponseHeaders.\n\nThis cleans up a lot of the unnecessary moving parts in\nHttpEngine. That class is still stuck with some complexity\naround request and response bodies, but it\u0027s getting better.\n\nWe\u0027re also stuck escalating the visibility of a lot of\nmembers in Request and Response. I\u0027ve got some ideas on\nhow to fix this; that\u0027ll have to wait for a follow up.\n",
      "commitDate": "2013/12/31 上午6:08",
      "commitName": "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/12/30 上午10:17",
      "commitNameOld": "350c43b6fe02401a73f967d9ef322061638b372a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            if (request.header(\"Content-Type\") \u003d\u003d null) {\n                request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n            }\n        }\n        HttpEngine engine \u003d newEngine(connection);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        Response engineResponse \u003d engine.getResponse();\n        Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response;\n        }\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response;\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 102,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,31 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             if (request.header(\"Content-Type\") \u003d\u003d null) {\n                 request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n             }\n         }\n         HttpEngine engine \u003d newEngine(connection);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n-        int responseCode \u003d engine.getResponseCode();\n-        Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n-        Response response \u003d new Response.Builder(request, responseCode).handshake(engine.getHandshake()).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n+        Response engineResponse \u003d engine.getResponse();\n+        Response response \u003d engineResponse.newBuilder().body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody())).redirectedBy(redirectedBy).build();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response;\n         }\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response;\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "350c43b6fe02401a73f967d9ef322061638b372a": {
      "type": "Ybodychange",
      "commitMessage": "Make RawHeaders, RequestHeaders and ResponseHeaders immutable.\n\nThis introduces a new, poorly-named class ResponseStrategy\nthat pulls some code out of ResponseHeaders. That was necessary\nbecause the old method mutated itself and its parameters in\nplace.\n\nObvious follow-up for this is to combine ResponseHeaders with\nResponse, and RequestHeaders with Response.\n",
      "commitDate": "2013/12/30 上午10:17",
      "commitName": "350c43b6fe02401a73f967d9ef322061638b372a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/12/30 上午7:57",
      "commitNameOld": "30ecba897fb624df201f0a014b54a604418a0e73",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            if (request.header(\"Content-Type\") \u003d\u003d null) {\n                request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n            }\n        }\n        HttpEngine engine \u003d newEngine(connection);\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        int responseCode \u003d engine.getResponseCode();\n        Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n        Response response \u003d new Response.Builder(request, responseCode).handshake(engine.getHandshake()).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response;\n        }\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response;\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 102,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n-        HttpEngine engine \u003d newEngine(connection);\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n-            if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n-                engine.getRequestHeaders().setContentType(contentType.toString());\n+            if (request.header(\"Content-Type\") \u003d\u003d null) {\n+                request \u003d request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n             }\n         }\n+        HttpEngine engine \u003d newEngine(connection);\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         int responseCode \u003d engine.getResponseCode();\n         Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n         Response response \u003d new Response.Builder(request, responseCode).handshake(engine.getHandshake()).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response;\n         }\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response;\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f": {
      "type": "Ybodychange",
      "commitMessage": "Introduce Handshake as a value object.\n\nI needed a non-terrible way to provide the HTTPS handshake\ninformation to the async API. Previously we were passing the\nlive socket around, which was leaky and gross.\n\nThis creates a new value object that captures the relevant\nbits of the handshake. We can use it in the response, the\nconnection, and also in the cache. It\u0027s plausible that in\nthe future we can use it to allow the application to block\nrequests if the handshake is insufficient.\n",
      "commitDate": "2013/12/29 下午1:35",
      "commitName": "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/12/29 上午9:24",
      "commitNameOld": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        HttpEngine engine \u003d newEngine(connection);\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n                engine.getRequestHeaders().setContentType(contentType.toString());\n            }\n        }\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        int responseCode \u003d engine.getResponseCode();\n        Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n        Response response \u003d new Response.Builder(request, responseCode).handshake(engine.getHandshake()).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response;\n        }\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response;\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 107,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n private Response execute() throws IOException {\n     Connection connection \u003d null;\n     Response redirectedBy \u003d null;\n     while (true) {\n         HttpEngine engine \u003d newEngine(connection);\n         Request.Body body \u003d request.body();\n         if (body !\u003d null) {\n             MediaType contentType \u003d body.contentType();\n             if (contentType \u003d\u003d null)\n                 throw new IllegalStateException(\"contentType \u003d\u003d null\");\n             if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n                 engine.getRequestHeaders().setContentType(contentType.toString());\n             }\n         }\n         engine.sendRequest();\n         if (body !\u003d null) {\n             body.writeTo(engine.getRequestBody());\n         }\n         engine.readResponse();\n         int responseCode \u003d engine.getResponseCode();\n         Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n-        Response response \u003d new Response.Builder(request, responseCode).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n+        Response response \u003d new Response.Builder(request, responseCode).handshake(engine.getHandshake()).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n         Request redirect \u003d processResponse(engine, response);\n         if (redirect \u003d\u003d null) {\n             engine.automaticallyReleaseConnectionToPool();\n             return response;\n         }\n         connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n         redirectedBy \u003d response;\n         request \u003d redirect;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": {
      "type": "Yintroduced",
      "commitMessage": "Define async APIs and switch Job to use HttpEngine directly.\n\nUsing HttpEngine directly introduces some duplicated code with\nHttpURLConnection. It also breaks the response cache. I think\nthis is the best route going forward; and eventually we could\ninvert this relationship to have HttpURLConnection depending on\nJob directly rather than vice versa.\n",
      "commitDate": "2013/12/29 上午9:24",
      "commitName": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
      "commitAuthor": "jwilson",
      "diff": "@@ -0,0 +1,32 @@\n+private Response execute() throws IOException {\n+    Connection connection \u003d null;\n+    Response redirectedBy \u003d null;\n+    while (true) {\n+        HttpEngine engine \u003d newEngine(connection);\n+        Request.Body body \u003d request.body();\n+        if (body !\u003d null) {\n+            MediaType contentType \u003d body.contentType();\n+            if (contentType \u003d\u003d null)\n+                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n+            if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n+                engine.getRequestHeaders().setContentType(contentType.toString());\n+            }\n+        }\n+        engine.sendRequest();\n+        if (body !\u003d null) {\n+            body.writeTo(engine.getRequestBody());\n+        }\n+        engine.readResponse();\n+        int responseCode \u003d engine.getResponseCode();\n+        Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n+        Response response \u003d new Response.Builder(request, responseCode).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n+        Request redirect \u003d processResponse(engine, response);\n+        if (redirect \u003d\u003d null) {\n+            engine.automaticallyReleaseConnectionToPool();\n+            return response;\n+        }\n+        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n+        redirectedBy \u003d response;\n+        request \u003d redirect;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Response execute() throws IOException {\n    Connection connection \u003d null;\n    Response redirectedBy \u003d null;\n    while (true) {\n        HttpEngine engine \u003d newEngine(connection);\n        Request.Body body \u003d request.body();\n        if (body !\u003d null) {\n            MediaType contentType \u003d body.contentType();\n            if (contentType \u003d\u003d null)\n                throw new IllegalStateException(\"contentType \u003d\u003d null\");\n            if (engine.getRequestHeaders().getContentType() \u003d\u003d null) {\n                engine.getRequestHeaders().setContentType(contentType.toString());\n            }\n        }\n        engine.sendRequest();\n        if (body !\u003d null) {\n            body.writeTo(engine.getRequestBody());\n        }\n        engine.readResponse();\n        int responseCode \u003d engine.getResponseCode();\n        Dispatcher.RealResponseBody responseBody \u003d new Dispatcher.RealResponseBody(engine.getResponseHeaders(), engine.getResponseBody());\n        Response response \u003d new Response.Builder(request, responseCode).rawHeaders(engine.getResponseHeaders().getHeaders()).body(responseBody).redirectedBy(redirectedBy).build();\n        Request redirect \u003d processResponse(engine, response);\n        if (redirect \u003d\u003d null) {\n            engine.automaticallyReleaseConnectionToPool();\n            return response;\n        }\n        connection \u003d sameConnection(request, redirect) ? engine.getConnection() : null;\n        redirectedBy \u003d response;\n        request \u003d redirect;\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
      "functionStartLine": 107,
      "functionName": "execute",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}