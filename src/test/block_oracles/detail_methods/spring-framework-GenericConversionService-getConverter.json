{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "GenericConversionService.java",
  "functionName": "getConverter",
  "functionId": "getConverter___sourceType-TypeDescriptor__targetType-TypeDescriptor",
  "sourceFilePath": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
  "functionAnnotation": "@Nullable",
  "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion,\nor {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
  "functionStartLine": 253,
  "functionEndLine": 272,
  "numCommitsSeen": 197,
  "timeTaken": 3891,
  "changeHistory": [
    "87598f48e41d483745aba56cbf4e998c6f6d680c",
    "22670b7fad9ecdbf4de2ae1c7a112aae123352ff",
    "222eec58cde4ac87a6de2cbbf2deb63ef70baea3",
    "4dc289592d0072c7472ab455522362f8db42b4a7",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "33b53b7cca7ec2667d57d320d888c51e48b09ed6",
    "b6e82048fc838ebbb2e58288eeda0c14119d38b9",
    "c84cccf06dad4e3f11cd529ab16a5655bf723820",
    "27b04036a9e6e7434bf3ef0942b417aa16b90574",
    "902938e95f19b7547421064720b016ba49e3c02e",
    "bf03d0d56f9fcfc4757bd3ab35e40c3f528fe710",
    "010e72c35a65ce5ff77cdee3e4dcfbe6ef0e3498",
    "d85dc01e282d0e215cf6db0f8b45eb04eecf3eca",
    "f0de1c3069aea81a529555e5045ab44f553f586c",
    "0a78287a8f0c0e80481fdaa586e9341d95f0a79e",
    "0f5074db2b5fd37f25976449d6e270ccd47fab93",
    "49bf85baaaccbd69753cc85c77744c0774493d1d",
    "871fc14fbbfe528d1d91a6dede52fc28795de887",
    "01e900c33a2f4be526cd24000acdbf3f5c8ee27b",
    "6ce33dba7564a71c5ccca6696f3c20083a1e34d0",
    "67c02f6c35cc94625381ed7debd7bf89932c8d05",
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
    "31441627de02bcc4ac2dcf307809b3c94b642e7b",
    "33c19b8b14b534ba423c9cee51c90536daa6e119",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
    "b33be88c9da6182aa2141b0ba773d5a2b4cd59bf",
    "6f74369cb34910de299a84ad7272e4fe3f527d4e",
    "9a261470ade2f556b4c36c7feca69c50216ebfed",
    "ebb203a25155f822e0eec8719b7f2327fcd664c0",
    "0ef0ff60f0b08b521ddc8fc093b38d7c9eb98326"
  ],
  "changeHistoryShort": {
    "87598f48e41d483745aba56cbf4e998c6f6d680c": "Yannotationchange",
    "22670b7fad9ecdbf4de2ae1c7a112aae123352ff": "Ydocchange",
    "222eec58cde4ac87a6de2cbbf2deb63ef70baea3": "Ydocchange",
    "4dc289592d0072c7472ab455522362f8db42b4a7": "Ymultichange(Ybodychange,Ydocchange)",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "33b53b7cca7ec2667d57d320d888c51e48b09ed6": "Ybodychange",
    "b6e82048fc838ebbb2e58288eeda0c14119d38b9": "Ybodychange",
    "c84cccf06dad4e3f11cd529ab16a5655bf723820": "Ybodychange",
    "27b04036a9e6e7434bf3ef0942b417aa16b90574": "Ybodychange",
    "902938e95f19b7547421064720b016ba49e3c02e": "Ybodychange",
    "bf03d0d56f9fcfc4757bd3ab35e40c3f528fe710": "Ymultichange(Ybodychange,Ydocchange)",
    "010e72c35a65ce5ff77cdee3e4dcfbe6ef0e3498": "Ydocchange",
    "d85dc01e282d0e215cf6db0f8b45eb04eecf3eca": "Ybodychange",
    "f0de1c3069aea81a529555e5045ab44f553f586c": "Ybodychange",
    "0a78287a8f0c0e80481fdaa586e9341d95f0a79e": "Ybodychange",
    "0f5074db2b5fd37f25976449d6e270ccd47fab93": "Ymultichange(Ybodychange,Ydocchange)",
    "49bf85baaaccbd69753cc85c77744c0774493d1d": "Ydocchange",
    "871fc14fbbfe528d1d91a6dede52fc28795de887": "Ybodychange",
    "01e900c33a2f4be526cd24000acdbf3f5c8ee27b": "Ymultichange(Ybodychange,Ydocchange)",
    "6ce33dba7564a71c5ccca6696f3c20083a1e34d0": "Ybodychange",
    "67c02f6c35cc94625381ed7debd7bf89932c8d05": "Ybodychange",
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d": "Ymultichange(Yparameterchange,Ybodychange)",
    "31441627de02bcc4ac2dcf307809b3c94b642e7b": "Yparameterchange",
    "33c19b8b14b534ba423c9cee51c90536daa6e119": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
    "b33be88c9da6182aa2141b0ba773d5a2b4cd59bf": "Ybodychange",
    "6f74369cb34910de299a84ad7272e4fe3f527d4e": "Yfilerename",
    "9a261470ade2f556b4c36c7feca69c50216ebfed": "Yfilerename",
    "ebb203a25155f822e0eec8719b7f2327fcd664c0": "Ymultichange(Yparameterchange,Ybodychange)",
    "0ef0ff60f0b08b521ddc8fc093b38d7c9eb98326": "Yintroduced"
  },
  "changeHistoryDetails": {
    "87598f48e41d483745aba56cbf4e998c6f6d680c": {
      "type": "Yannotationchange",
      "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/5/27 下午2:57",
      "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2016/12/13 上午5:49",
      "commitNameOld": "e49813f2c4c6bb645c0990b3bd0fc290fc7c9f8e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 165.38,
      "commitsBetweenForRepo": 1013,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nprotected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    }\n    converter \u003d this.converters.find(sourceType, targetType);\n    if (converter \u003d\u003d null) {\n        converter \u003d getDefaultConverter(sourceType, targetType);\n    }\n    if (converter !\u003d null) {\n        this.converterCache.put(key, converter);\n        return converter;\n    }\n    this.converterCache.put(key, NO_MATCH);\n    return null;\n}",
      "path": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 252,
      "functionName": "getConverter",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion,\nor {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "@@ -1,17 +1,18 @@\n+@Nullable\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n         return (converter !\u003d NO_MATCH ? converter : null);\n     }\n     converter \u003d this.converters.find(sourceType, targetType);\n     if (converter \u003d\u003d null) {\n         converter \u003d getDefaultConverter(sourceType, targetType);\n     }\n     if (converter !\u003d null) {\n         this.converterCache.put(key, converter);\n         return converter;\n     }\n     this.converterCache.put(key, NO_MATCH);\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Nullable"
      }
    },
    "22670b7fad9ecdbf4de2ae1c7a112aae123352ff": {
      "type": "Ydocchange",
      "commitMessage": "Fixed addConverterFactory assertion\n",
      "commitDate": "2015/3/25 上午7:42",
      "commitName": "22670b7fad9ecdbf4de2ae1c7a112aae123352ff",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/9/17 上午8:35",
      "commitNameOld": "15320db41424f3ebbc920bfad217d04c4370d6f1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 188.96,
      "commitsBetweenForRepo": 777,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    }\n    converter \u003d this.converters.find(sourceType, targetType);\n    if (converter \u003d\u003d null) {\n        converter \u003d getDefaultConverter(sourceType, targetType);\n    }\n    if (converter !\u003d null) {\n        this.converterCache.put(key, converter);\n        return converter;\n    }\n    this.converterCache.put(key, NO_MATCH);\n    return null;\n}",
      "path": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 251,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion,\nor {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if\nno suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
        "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion,\nor {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n"
      }
    },
    "222eec58cde4ac87a6de2cbbf2deb63ef70baea3": {
      "type": "Ydocchange",
      "commitMessage": "Review and polish pull request #132\n\nContent:\n\n - Rename Conditional{Conversion\u003d\u003eConverter}\n - Add @since tags where appropriate\n - Update Apache date headers to read 2002-2012 (not just 2012)\n - Correct minor Javadoc typo\n\nStyle:\n\n - Polish line breaks / whitespace\n - Use wildcard static imports where appropriate\n\nIssue: SPR-9566, SPR-9692, SPR-9928, SPR-9927\n",
      "commitDate": "2012/10/30 下午4:14",
      "commitName": "222eec58cde4ac87a6de2cbbf2deb63ef70baea3",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/10/30 下午4:13",
      "commitNameOld": "a27d1a28ffb69aed618869d3815a3af7120effa2",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    }\n    converter \u003d this.converters.find(sourceType, targetType);\n    if (converter \u003d\u003d null) {\n        converter \u003d getDefaultConverter(sourceType, targetType);\n    }\n    if (converter !\u003d null) {\n        this.converterCache.put(key, converter);\n        return converter;\n    }\n    this.converterCache.put(key, NO_MATCH);\n    return null;\n}",
      "path": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 220,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if\nno suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
        "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if\nno suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n"
      }
    },
    "4dc289592d0072c7472ab455522362f8db42b4a7": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Refactor GenericConversionService\n\nRefactor internal workings of GenericConversionService in order to\nbetter support future enhancements. This commit should not affect\nexisting behavior.\n\nIssue: SPR-9927\n",
      "commitDate": "2012/10/30 下午4:13",
      "commitName": "4dc289592d0072c7472ab455522362f8db42b4a7",
      "commitAuthor": "Phillip Webb",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Refactor GenericConversionService\n\nRefactor internal workings of GenericConversionService in order to\nbetter support future enhancements. This commit should not affect\nexisting behavior.\n\nIssue: SPR-9927\n",
          "commitDate": "2012/10/30 下午4:13",
          "commitName": "4dc289592d0072c7472ab455522362f8db42b4a7",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2012/10/27 上午5:09",
          "commitNameOld": "01272fb0e60b781a8f47ea849b25d144151ac4fb",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 3.46,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    }\n    converter \u003d this.converters.find(sourceType, targetType);\n    if (converter \u003d\u003d null) {\n        converter \u003d getDefaultConverter(sourceType, targetType);\n    }\n    if (converter !\u003d null) {\n        this.converterCache.put(key, converter);\n        return converter;\n    }\n    this.converterCache.put(key, NO_MATCH);\n    return null;\n}",
          "path": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 196,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
          "diff": "@@ -1,19 +1,17 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n         return (converter !\u003d NO_MATCH ? converter : null);\n-    } else {\n-        converter \u003d findConverterForClassPair(sourceType, targetType);\n-        if (converter \u003d\u003d null) {\n-            converter \u003d getDefaultConverter(sourceType, targetType);\n-        }\n-        if (converter !\u003d null) {\n-            this.converterCache.put(key, converter);\n-            return converter;\n-        } else {\n-            this.converterCache.put(key, NO_MATCH);\n-            return null;\n-        }\n     }\n+    converter \u003d this.converters.find(sourceType, targetType);\n+    if (converter \u003d\u003d null) {\n+        converter \u003d getDefaultConverter(sourceType, targetType);\n+    }\n+    if (converter !\u003d null) {\n+        this.converterCache.put(key, converter);\n+        return converter;\n+    }\n+    this.converterCache.put(key, NO_MATCH);\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Refactor GenericConversionService\n\nRefactor internal workings of GenericConversionService in order to\nbetter support future enhancements. This commit should not affect\nexisting behavior.\n\nIssue: SPR-9927\n",
          "commitDate": "2012/10/30 下午4:13",
          "commitName": "4dc289592d0072c7472ab455522362f8db42b4a7",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2012/10/27 上午5:09",
          "commitNameOld": "01272fb0e60b781a8f47ea849b25d144151ac4fb",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 3.46,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    }\n    converter \u003d this.converters.find(sourceType, targetType);\n    if (converter \u003d\u003d null) {\n        converter \u003d getDefaultConverter(sourceType, targetType);\n    }\n    if (converter !\u003d null) {\n        this.converterCache.put(key, converter);\n        return converter;\n    }\n    this.converterCache.put(key, NO_MATCH);\n    return null;\n}",
          "path": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 196,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
          "diff": "@@ -1,19 +1,17 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n         return (converter !\u003d NO_MATCH ? converter : null);\n-    } else {\n-        converter \u003d findConverterForClassPair(sourceType, targetType);\n-        if (converter \u003d\u003d null) {\n-            converter \u003d getDefaultConverter(sourceType, targetType);\n-        }\n-        if (converter !\u003d null) {\n-            this.converterCache.put(key, converter);\n-            return converter;\n-        } else {\n-            this.converterCache.put(key, NO_MATCH);\n-            return null;\n-        }\n     }\n+    converter \u003d this.converters.find(sourceType, targetType);\n+    if (converter \u003d\u003d null) {\n+        converter \u003d getDefaultConverter(sourceType, targetType);\n+    }\n+    if (converter !\u003d null) {\n+        this.converterCache.put(key, converter);\n+        return converter;\n+    }\n+    this.converterCache.put(key, NO_MATCH);\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
            "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or {@code null} if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n"
          }
        }
      ]
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter \u003d\u003d null) {\n            converter \u003d getDefaultConverter(sourceType, targetType);\n        }\n        if (converter !\u003d null) {\n            this.converterCache.put(key, converter);\n            return converter;\n        } else {\n            this.converterCache.put(key, NO_MATCH);\n            return null;\n        }\n    }\n}",
      "path": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 237,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
        "newPath": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java"
      }
    },
    "33b53b7cca7ec2667d57d320d888c51e48b09ed6": {
      "type": "Ybodychange",
      "commitMessage": "alignment with 3.0.7 backports (SPR-8674)\n",
      "commitDate": "2011/12/2 上午2:51",
      "commitName": "33b53b7cca7ec2667d57d320d888c51e48b09ed6",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/10/6 下午10:17",
      "commitNameOld": "00a726b09890726d12b13e7b300825b4aa8064ea",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 56.19,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return (converter !\u003d NO_MATCH ? converter : null);\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter \u003d\u003d null) {\n            converter \u003d getDefaultConverter(sourceType, targetType);\n        }\n        if (converter !\u003d null) {\n            this.converterCache.put(key, converter);\n            return converter;\n        } else {\n            this.converterCache.put(key, NO_MATCH);\n            return null;\n        }\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 237,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "@@ -1,19 +1,19 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n-        return converter !\u003d NO_MATCH ? converter : null;\n+        return (converter !\u003d NO_MATCH ? converter : null);\n     } else {\n         converter \u003d findConverterForClassPair(sourceType, targetType);\n         if (converter \u003d\u003d null) {\n             converter \u003d getDefaultConverter(sourceType, targetType);\n         }\n         if (converter !\u003d null) {\n             this.converterCache.put(key, converter);\n             return converter;\n         } else {\n             this.converterCache.put(key, NO_MATCH);\n             return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6e82048fc838ebbb2e58288eeda0c14119d38b9": {
      "type": "Ybodychange",
      "commitMessage": "removed GenericConversionService logging in order to avoid toString side effects (and to avoid isTraceEnabled overhead; SPR-8297)\n",
      "commitDate": "2011/8/5 上午1:22",
      "commitName": "b6e82048fc838ebbb2e58288eeda0c14119d38b9",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/6/6 上午2:36",
      "commitNameOld": "a40f6585b465671203dea286774584ba25da5a42",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 59.95,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        return converter !\u003d NO_MATCH ? converter : null;\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter \u003d\u003d null) {\n            converter \u003d getDefaultConverter(sourceType, targetType);\n        }\n        if (converter !\u003d null) {\n            this.converterCache.put(key, converter);\n            return converter;\n        } else {\n            this.converterCache.put(key, NO_MATCH);\n            return null;\n        }\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 234,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "@@ -1,28 +1,19 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n-        if (logger.isTraceEnabled()) {\n-            logger.trace(\"Matched cached converter \" + converter);\n-        }\n         return converter !\u003d NO_MATCH ? converter : null;\n     } else {\n         converter \u003d findConverterForClassPair(sourceType, targetType);\n         if (converter \u003d\u003d null) {\n             converter \u003d getDefaultConverter(sourceType, targetType);\n         }\n         if (converter !\u003d null) {\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"Caching matched Converter under key \" + key);\n-            }\n             this.converterCache.put(key, converter);\n             return converter;\n         } else {\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"Caching Converter [NO_MATCH] result under key \" + key);\n-            }\n             this.converterCache.put(key, NO_MATCH);\n             return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c84cccf06dad4e3f11cd529ab16a5655bf723820": {
      "type": "Ybodychange",
      "commitMessage": "revised TypeDescriptor NULL and element/mapKey/mapValue type semantics\n",
      "commitDate": "2011/6/5 下午12:43",
      "commitName": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/4 下午1:38",
      "commitNameOld": "5db1687d29c4b23d05f061ab7fb3450111314050",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Matched cached converter \" + converter);\n        }\n        return converter !\u003d NO_MATCH ? converter : null;\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter \u003d\u003d null) {\n            converter \u003d getDefaultConverter(sourceType, targetType);\n        }\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching matched Converter under key \" + key);\n            }\n            this.converterCache.put(key, converter);\n            return converter;\n        } else {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching Converter [NO_MATCH] result under key \" + key);\n            }\n            this.converterCache.put(key, NO_MATCH);\n            return null;\n        }\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 228,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "@@ -1,32 +1,28 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"Matched cached converter \" + converter);\n         }\n-        return (converter !\u003d NO_MATCH ? converter : null);\n+        return converter !\u003d NO_MATCH ? converter : null;\n     } else {\n         converter \u003d findConverterForClassPair(sourceType, targetType);\n+        if (converter \u003d\u003d null) {\n+            converter \u003d getDefaultConverter(sourceType, targetType);\n+        }\n         if (converter !\u003d null) {\n             if (logger.isTraceEnabled()) {\n-                logger.trace(\"Caching under \" + key);\n+                logger.trace(\"Caching matched Converter under key \" + key);\n             }\n             this.converterCache.put(key, converter);\n             return converter;\n-        }\n-        converter \u003d getDefaultConverter(sourceType, targetType);\n-        if (converter !\u003d null) {\n+        } else {\n             if (logger.isTraceEnabled()) {\n-                logger.trace(\"Caching under \" + key);\n+                logger.trace(\"Caching Converter [NO_MATCH] result under key \" + key);\n             }\n-            this.converterCache.put(key, converter);\n-            return converter;\n+            this.converterCache.put(key, NO_MATCH);\n+            return null;\n         }\n-        if (logger.isTraceEnabled()) {\n-            logger.trace(\"Caching NO_MATCH under \" + key);\n-        }\n-        this.converterCache.put(key, NO_MATCH);\n-        return null;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "27b04036a9e6e7434bf3ef0942b417aa16b90574": {
      "type": "Ybodychange",
      "commitMessage": "ConversionService is able to deal with empty collections and nested collections (fixed regression; SPR-7289, SPR-7293); ConversionService properly handles nested Resource arrays in Map values (fixed regression; SPR-7295); ConversionService does not accidentally use copy constructor for same type (SPR-7304)\n",
      "commitDate": "2010/6/24 上午1:29",
      "commitName": "27b04036a9e6e7434bf3ef0942b417aa16b90574",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/6/15 下午5:35",
      "commitNameOld": "7b189d11243a3632af948a86e8e7d981b0890b9b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 8.33,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Matched cached converter \" + converter);\n        }\n        return (converter !\u003d NO_MATCH ? converter : null);\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            this.converterCache.put(key, converter);\n            return converter;\n        }\n        converter \u003d getDefaultConverter(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            this.converterCache.put(key, converter);\n            return converter;\n        }\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Caching NO_MATCH under \" + key);\n        }\n        this.converterCache.put(key, NO_MATCH);\n        return null;\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 240,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "@@ -1,32 +1,32 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n     GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"Matched cached converter \" + converter);\n         }\n-        return converter !\u003d NO_MATCH ? converter : null;\n+        return (converter !\u003d NO_MATCH ? converter : null);\n     } else {\n         converter \u003d findConverterForClassPair(sourceType, targetType);\n         if (converter !\u003d null) {\n             if (logger.isTraceEnabled()) {\n                 logger.trace(\"Caching under \" + key);\n             }\n             this.converterCache.put(key, converter);\n             return converter;\n         }\n         converter \u003d getDefaultConverter(sourceType, targetType);\n         if (converter !\u003d null) {\n             if (logger.isTraceEnabled()) {\n                 logger.trace(\"Caching under \" + key);\n             }\n             this.converterCache.put(key, converter);\n             return converter;\n         }\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"Caching NO_MATCH under \" + key);\n         }\n         this.converterCache.put(key, NO_MATCH);\n         return null;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "902938e95f19b7547421064720b016ba49e3c02e": {
      "type": "Ybodychange",
      "commitMessage": "smarter guessing of the element type (SPR-7283)\n",
      "commitDate": "2010/6/15 上午6:58",
      "commitName": "902938e95f19b7547421064720b016ba49e3c02e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/5/26 下午9:58",
      "commitNameOld": "15321197878f7b863976393a1b2cf89ba0469083",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.37,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d this.converterCache.get(key);\n    if (converter !\u003d null) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Matched cached converter \" + converter);\n        }\n        return converter !\u003d NO_MATCH ? converter : null;\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            this.converterCache.put(key, converter);\n            return converter;\n        }\n        converter \u003d getDefaultConverter(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            this.converterCache.put(key, converter);\n            return converter;\n        }\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Caching NO_MATCH under \" + key);\n        }\n        this.converterCache.put(key, NO_MATCH);\n        return null;\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 234,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
      "diff": "@@ -1,32 +1,32 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n-    GenericConverter converter \u003d converterCache.get(key);\n+    GenericConverter converter \u003d this.converterCache.get(key);\n     if (converter !\u003d null) {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Matched cached converter \" + converter);\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Matched cached converter \" + converter);\n         }\n         return converter !\u003d NO_MATCH ? converter : null;\n     } else {\n         converter \u003d findConverterForClassPair(sourceType, targetType);\n         if (converter !\u003d null) {\n             if (logger.isTraceEnabled()) {\n                 logger.trace(\"Caching under \" + key);\n             }\n-            converterCache.put(key, converter);\n+            this.converterCache.put(key, converter);\n             return converter;\n         }\n         converter \u003d getDefaultConverter(sourceType, targetType);\n         if (converter !\u003d null) {\n             if (logger.isTraceEnabled()) {\n                 logger.trace(\"Caching under \" + key);\n             }\n-            converterCache.put(key, converter);\n+            this.converterCache.put(key, converter);\n             return converter;\n         }\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"Caching NO_MATCH under \" + key);\n         }\n-        converterCache.put(key, NO_MATCH);\n+        this.converterCache.put(key, NO_MATCH);\n         return null;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf03d0d56f9fcfc4757bd3ab35e40c3f528fe710": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "converter caching\n",
      "commitDate": "2010/4/19 上午5:43",
      "commitName": "bf03d0d56f9fcfc4757bd3ab35e40c3f528fe710",
      "commitAuthor": "Keith Donald",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "converter caching\n",
          "commitDate": "2010/4/19 上午5:43",
          "commitName": "bf03d0d56f9fcfc4757bd3ab35e40c3f528fe710",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2010/4/17 下午2:28",
          "commitNameOld": "b9aeba23ef82b4c69d740462b190b6e1ad24c3b6",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.64,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d converterCache.get(key);\n    if (converter !\u003d null) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Matched cached converter \" + converter);\n        }\n        return converter !\u003d NO_MATCH ? converter : null;\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            converterCache.put(key, converter);\n            return converter;\n        }\n        converter \u003d getDefaultConverter(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            converterCache.put(key, converter);\n            return converter;\n        }\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Caching NO_MATCH under \" + key);\n        }\n        converterCache.put(key, NO_MATCH);\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 244,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
          "diff": "@@ -1,8 +1,32 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n-    GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n+    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n+    GenericConverter converter \u003d converterCache.get(key);\n     if (converter !\u003d null) {\n-        return converter;\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Matched cached converter \" + converter);\n+        }\n+        return converter !\u003d NO_MATCH ? converter : null;\n     } else {\n-        return getDefaultConverter(sourceType, targetType);\n+        converter \u003d findConverterForClassPair(sourceType, targetType);\n+        if (converter !\u003d null) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Caching under \" + key);\n+            }\n+            converterCache.put(key, converter);\n+            return converter;\n+        }\n+        converter \u003d getDefaultConverter(sourceType, targetType);\n+        if (converter !\u003d null) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Caching under \" + key);\n+            }\n+            converterCache.put(key, converter);\n+            return converter;\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Caching NO_MATCH under \" + key);\n+        }\n+        converterCache.put(key, NO_MATCH);\n+        return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "converter caching\n",
          "commitDate": "2010/4/19 上午5:43",
          "commitName": "bf03d0d56f9fcfc4757bd3ab35e40c3f528fe710",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2010/4/17 下午2:28",
          "commitNameOld": "b9aeba23ef82b4c69d740462b190b6e1ad24c3b6",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.64,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n    GenericConverter converter \u003d converterCache.get(key);\n    if (converter !\u003d null) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Matched cached converter \" + converter);\n        }\n        return converter !\u003d NO_MATCH ? converter : null;\n    } else {\n        converter \u003d findConverterForClassPair(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            converterCache.put(key, converter);\n            return converter;\n        }\n        converter \u003d getDefaultConverter(sourceType, targetType);\n        if (converter !\u003d null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Caching under \" + key);\n            }\n            converterCache.put(key, converter);\n            return converter;\n        }\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Caching NO_MATCH under \" + key);\n        }\n        converterCache.put(key, NO_MATCH);\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 244,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n",
          "diff": "@@ -1,8 +1,32 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n-    GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n+    ConverterCacheKey key \u003d new ConverterCacheKey(sourceType, targetType);\n+    GenericConverter converter \u003d converterCache.get(key);\n     if (converter !\u003d null) {\n-        return converter;\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Matched cached converter \" + converter);\n+        }\n+        return converter !\u003d NO_MATCH ? converter : null;\n     } else {\n-        return getDefaultConverter(sourceType, targetType);\n+        converter \u003d findConverterForClassPair(sourceType, targetType);\n+        if (converter !\u003d null) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Caching under \" + key);\n+            }\n+            converterCache.put(key, converter);\n+            return converter;\n+        }\n+        converter \u003d getDefaultConverter(sourceType, targetType);\n+        if (converter !\u003d null) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Caching under \" + key);\n+            }\n+            converterCache.put(key, converter);\n+            return converter;\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Caching NO_MATCH under \" + key);\n+        }\n+        converterCache.put(key, NO_MATCH);\n+        return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert\nbetween sourceType and targetType. Subclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
            "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter cache.\nOn a cache miss, then performs an exhaustive search for a matching converter.\nIf no converter matches, returns the default converter.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n@see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n"
          }
        }
      ]
    },
    "010e72c35a65ce5ff77cdee3e4dcfbe6ef0e3498": {
      "type": "Ydocchange",
      "commitMessage": "GenericConversionService prefers matches against inherited interfaces over superclasses (SPR-6297)\n",
      "commitDate": "2009/12/10 上午12:16",
      "commitName": "010e72c35a65ce5ff77cdee3e4dcfbe6ef0e3498",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/11/27 上午9:34",
      "commitNameOld": "cc0bd730eb3baf47bbdf031499e8b2832dd2ced3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 12.61,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n    if (converter !\u003d null) {\n        return converter;\n    } else {\n        return getDefaultConverter(sourceType, targetType);\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 185,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert\nbetween sourceType and targetType. Subclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
        "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\n\u003cp\u003eReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert\nbetween sourceType and targetType. Subclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n"
      }
    },
    "d85dc01e282d0e215cf6db0f8b45eb04eecf3eca": {
      "type": "Ybodychange",
      "commitMessage": "moved generic converter to spi; added entity converter; removed various service impls in favor of service factory\n",
      "commitDate": "2009/11/19 下午5:10",
      "commitName": "d85dc01e282d0e215cf6db0f8b45eb04eecf3eca",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/11/12 下午2:57",
      "commitNameOld": "70fe75384d9e387de6ae7abf1d513ed9e4cfc03a",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 7.09,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n    if (converter !\u003d null) {\n        return converter;\n    } else {\n        return getDefaultConverter(sourceType, targetType);\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 172,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
      "diff": "@@ -1,10 +1,8 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n     if (converter !\u003d null) {\n         return converter;\n-    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n-        return this.parentConverterAdapter;\n     } else {\n         return getDefaultConverter(sourceType, targetType);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0de1c3069aea81a529555e5045ab44f553f586c": {
      "type": "Ybodychange",
      "commitMessage": "revised matchable converter lookup algorithm; added conversion service bean container tests\n",
      "commitDate": "2009/11/5 下午10:52",
      "commitName": "f0de1c3069aea81a529555e5045ab44f553f586c",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/11/5 上午6:53",
      "commitNameOld": "9ec337b736cb0dc1b087f1070fff34e11b8ccd08",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n    if (converter !\u003d null) {\n        return converter;\n    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n        return this.parentConverterAdapter;\n    } else {\n        return getDefaultConverter(sourceType, targetType);\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 270,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
      "diff": "@@ -1,11 +1,10 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n-    MatchableConverters matchable \u003d findMatchableConvertersForClassPair(sourceType.getObjectType(), targetType.getObjectType());\n-    GenericConverter converter \u003d matchConverter(matchable, sourceType, targetType);\n+    GenericConverter converter \u003d findConverterForClassPair(sourceType, targetType);\n     if (converter !\u003d null) {\n         return converter;\n     } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n         return this.parentConverterAdapter;\n     } else {\n         return getDefaultConverter(sourceType, targetType);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a78287a8f0c0e80481fdaa586e9341d95f0a79e": {
      "type": "Ybodychange",
      "commitMessage": "formatters now plugged into unified type conversion api with formatter specific registry spi\n",
      "commitDate": "2009/11/4 上午8:08",
      "commitName": "0a78287a8f0c0e80481fdaa586e9341d95f0a79e",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/10/31 上午2:44",
      "commitNameOld": "913bc03a3b65d1aabf89dd4fe58310416dee495e",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 4.23,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    MatchableConverters matchable \u003d findMatchableConvertersForClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    GenericConverter converter \u003d matchConverter(matchable, sourceType, targetType);\n    if (converter !\u003d null) {\n        return converter;\n    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n        return this.parentConverterAdapter;\n    } else {\n        return getDefaultConverter(sourceType, targetType);\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 246,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
      "diff": "@@ -1,10 +1,11 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n-    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n+    MatchableConverters matchable \u003d findMatchableConvertersForClassPair(sourceType.getObjectType(), targetType.getObjectType());\n+    GenericConverter converter \u003d matchConverter(matchable, sourceType, targetType);\n     if (converter !\u003d null) {\n         return converter;\n     } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n         return this.parentConverterAdapter;\n     } else {\n         return getDefaultConverter(sourceType, targetType);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0f5074db2b5fd37f25976449d6e270ccd47fab93": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "spel mapping, polish\n",
      "commitDate": "2009/10/7 上午5:31",
      "commitName": "0f5074db2b5fd37f25976449d6e270ccd47fab93",
      "commitAuthor": "Keith Donald",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "spel mapping, polish\n",
          "commitDate": "2009/10/7 上午5:31",
          "commitName": "0f5074db2b5fd37f25976449d6e270ccd47fab93",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/10/4 下午12:13",
          "commitNameOld": "e7c8f1ef8b87b7763b9c27caf3e028321d5c5b62",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 2.72,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n        return this.parentConverterAdapter;\n    } else {\n        return getDefaultConverter(sourceType, targetType);\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 226,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
          "diff": "@@ -1,14 +1,10 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n     if (converter !\u003d null) {\n         return converter;\n     } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n         return this.parentConverterAdapter;\n     } else {\n-        if (sourceType.isAssignableTo(targetType)) {\n-            return NO_OP_CONVERTER;\n-        } else {\n-            return null;\n-        }\n+        return getDefaultConverter(sourceType, targetType);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "spel mapping, polish\n",
          "commitDate": "2009/10/7 上午5:31",
          "commitName": "0f5074db2b5fd37f25976449d6e270ccd47fab93",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/10/4 下午12:13",
          "commitNameOld": "e7c8f1ef8b87b7763b9c27caf3e028321d5c5b62",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 2.72,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n        return this.parentConverterAdapter;\n    } else {\n        return getDefaultConverter(sourceType, targetType);\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 226,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
          "diff": "@@ -1,14 +1,10 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n     if (converter !\u003d null) {\n         return converter;\n     } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n         return this.parentConverterAdapter;\n     } else {\n-        if (sourceType.isAssignableTo(targetType)) {\n-            return NO_OP_CONVERTER;\n-        } else {\n-            return null;\n-        }\n+        return getDefaultConverter(sourceType, targetType);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
            "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n"
          }
        }
      ]
    },
    "49bf85baaaccbd69753cc85c77744c0774493d1d": {
      "type": "Ydocchange",
      "commitMessage": "factored out common resolveTypeArgument(s) method to GenericTypeResolver\n",
      "commitDate": "2009/9/24 下午8:51",
      "commitName": "49bf85baaaccbd69753cc85c77744c0774493d1d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/9/24 上午2:25",
      "commitNameOld": "7a6dafd5ad99e16dc20a116d3ee83836b959db76",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n        return this.parentConverterAdapter;\n    } else {\n        if (sourceType.isAssignableTo(targetType)) {\n            return NO_OP_CONVERTER;\n        } else {\n            return null;\n        }\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 232,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent(GenericConversionService) parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
        "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n"
      }
    },
    "871fc14fbbfe528d1d91a6dede52fc28795de887": {
      "type": "Ybodychange",
      "commitMessage": "restored parent property to accept ConversionService instead of GenericConversionService\n",
      "commitDate": "2009/9/22 下午9:37",
      "commitName": "871fc14fbbfe528d1d91a6dede52fc28795de887",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/9/22 上午6:35",
      "commitNameOld": "e9416db4722cae44cfe82276e625a62c519c16a4",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n        return this.parentConverterAdapter;\n    } else {\n        if (sourceType.isAssignableTo(targetType)) {\n            return NO_OP_CONVERTER;\n        } else {\n            return null;\n        }\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 241,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent(GenericConversionService) parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
      "diff": "@@ -1,15 +1,14 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n     if (converter !\u003d null) {\n         return converter;\n-    }\n-    if (this.parent !\u003d null) {\n-        return this.parent.getConverter(sourceType, targetType);\n+    } else if (this.parent !\u003d null \u0026\u0026 this.parent.canConvert(sourceType, targetType)) {\n+        return this.parentConverterAdapter;\n     } else {\n         if (sourceType.isAssignableTo(targetType)) {\n             return NO_OP_CONVERTER;\n         } else {\n             return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01e900c33a2f4be526cd24000acdbf3f5c8ee27b": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "documented hooks\n",
      "commitDate": "2009/9/22 上午6:24",
      "commitName": "01e900c33a2f4be526cd24000acdbf3f5c8ee27b",
      "commitAuthor": "Keith Donald",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "documented hooks\n",
          "commitDate": "2009/9/22 上午6:24",
          "commitName": "01e900c33a2f4be526cd24000acdbf3f5c8ee27b",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/22 上午5:32",
          "commitNameOld": "a6e28f4eb5822892133bc4bdd32d12f42a8c00ed",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    }\n    if (this.parent !\u003d null) {\n        return this.parent.getConverter(sourceType, targetType);\n    } else {\n        if (sourceType.isAssignableTo(targetType)) {\n            return NO_OP_CONVERTER;\n        } else {\n            return null;\n        }\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 227,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent(GenericConversionService) parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
          "diff": "@@ -1,15 +1,15 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n     if (converter !\u003d null) {\n         return converter;\n     }\n     if (this.parent !\u003d null) {\n         return this.parent.getConverter(sourceType, targetType);\n     } else {\n         if (sourceType.isAssignableTo(targetType)) {\n             return NO_OP_CONVERTER;\n         } else {\n-            throw new ConverterNotFoundException(sourceType, targetType);\n+            return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "documented hooks\n",
          "commitDate": "2009/9/22 上午6:24",
          "commitName": "01e900c33a2f4be526cd24000acdbf3f5c8ee27b",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/22 上午5:32",
          "commitNameOld": "a6e28f4eb5822892133bc4bdd32d12f42a8c00ed",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    }\n    if (this.parent !\u003d null) {\n        return this.parent.getConverter(sourceType, targetType);\n    } else {\n        if (sourceType.isAssignableTo(targetType)) {\n            return NO_OP_CONVERTER;\n        } else {\n            return null;\n        }\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 227,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent(GenericConversionService) parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n",
          "diff": "@@ -1,15 +1,15 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n     GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n     if (converter !\u003d null) {\n         return converter;\n     }\n     if (this.parent !\u003d null) {\n         return this.parent.getConverter(sourceType, targetType);\n     } else {\n         if (sourceType.isAssignableTo(targetType)) {\n             return NO_OP_CONVERTER;\n         } else {\n-            throw new ConverterNotFoundException(sourceType, targetType);\n+            return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Hook method to lookup the converter for a given sourceType/targetType pair.\nFirst queries this ConversionService\u0027s converter map.\nIf no suitable Converter is found, and a {@link #setParent(GenericConversionService) parent} is set, then queries the parent.\nIf still no suitable Converter is found, returns a NO_OP Converter if the sourceType and targetType are assignable.\nReturns \u003ccode\u003enull\u003c/code\u003e if this ConversionService simply cannot convert between sourceType and targetType.\nSubclasses may override.\n\n@param sourceType the source type to convert from\n@param targetType the target type to convert to\n@return the generic converter that will perform the conversion, or \u003ccode\u003enull\u003c/code\u003e if no suitable converter was found\n"
          }
        }
      ]
    },
    "6ce33dba7564a71c5ccca6696f3c20083a1e34d0": {
      "type": "Ybodychange",
      "commitMessage": "getConverter calls now throw exception and query parent\n",
      "commitDate": "2009/9/22 上午5:24",
      "commitName": "6ce33dba7564a71c5ccca6696f3c20083a1e34d0",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/9/21 下午1:39",
      "commitNameOld": "17f7796d42d9a579bbb841e4d68ad0dd602da294",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter !\u003d null) {\n        return converter;\n    }\n    if (this.parent !\u003d null) {\n        return this.parent.getConverter(sourceType, targetType);\n    } else {\n        if (sourceType.isAssignableTo(targetType)) {\n            return NO_OP_CONVERTER;\n        } else {\n            throw new ConverterNotFoundException(sourceType, targetType);\n        }\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 197,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,3 +1,15 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n-    return findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n+    GenericConverter converter \u003d findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n+    if (converter !\u003d null) {\n+        return converter;\n+    }\n+    if (this.parent !\u003d null) {\n+        return this.parent.getConverter(sourceType, targetType);\n+    } else {\n+        if (sourceType.isAssignableTo(targetType)) {\n+            return NO_OP_CONVERTER;\n+        } else {\n+            throw new ConverterNotFoundException(sourceType, targetType);\n+        }\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67c02f6c35cc94625381ed7debd7bf89932c8d05": {
      "type": "Ybodychange",
      "commitMessage": "generic converter revising\n",
      "commitDate": "2009/9/21 下午1:14",
      "commitName": "67c02f6c35cc94625381ed7debd7bf89932c8d05",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/9/19 上午7:02",
      "commitNameOld": "48bc060a77bb02caf319d1ad9aa618a1bfac7d1c",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 2.26,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    return findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 200,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,11 +1,3 @@\n protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n-    GenericConverter converter \u003d matchConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n-    if (converter \u003d\u003d null) {\n-        for (GenericConverter matchableConverter : this.matchableConverters) {\n-            if (matchableConverter.canConvert(sourceType, targetType)) {\n-                return matchableConverter;\n-            }\n-        }\n-    }\n-    return converter;\n+    return findConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "refined generic converter concept\n",
      "commitDate": "2009/9/19 上午3:57",
      "commitName": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
      "commitAuthor": "Keith Donald",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "refined generic converter concept\n",
          "commitDate": "2009/9/19 上午3:57",
          "commitName": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/18 下午10:30",
          "commitNameOld": "8e800f03226747a12adc235ca80bd94513b67ca8",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d matchConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter \u003d\u003d null) {\n        for (GenericConverter matchableConverter : this.matchableConverters) {\n            if (matchableConverter.canConvert(sourceType, targetType)) {\n                return matchableConverter;\n            }\n        }\n    }\n    return converter;\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 186,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,39 +1,11 @@\n-protected GenericConverter getConverter(Class sourceType, TypeDescriptor targetType) {\n-    if (sourceType.isInterface()) {\n-        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(sourceType);\n-        while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d classQueue.removeLast();\n-            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n-            GenericConverter converter \u003d getConverter(converters, targetType);\n-            if (converter !\u003d null) {\n-                return converter;\n-            }\n-            Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (Class ifc : interfaces) {\n-                classQueue.addFirst(ifc);\n+protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n+    GenericConverter converter \u003d matchConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n+    if (converter \u003d\u003d null) {\n+        for (GenericConverter matchableConverter : this.matchableConverters) {\n+            if (matchableConverter.canConvert(sourceType, targetType)) {\n+                return matchableConverter;\n             }\n         }\n-        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n-        return getConverter(objectConverters, targetType);\n-    } else {\n-        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(sourceType);\n-        while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d classQueue.removeLast();\n-            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n-            GenericConverter converter \u003d getConverter(converters, targetType);\n-            if (converter !\u003d null) {\n-                return converter;\n-            }\n-            if (currentClass.getSuperclass() !\u003d null) {\n-                classQueue.addFirst(currentClass.getSuperclass());\n-            }\n-            Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (Class ifc : interfaces) {\n-                classQueue.addFirst(ifc);\n-            }\n-        }\n-        return null;\n     }\n+    return converter;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[sourceType-Class, targetType-TypeDescriptor]",
            "newValue": "[sourceType-TypeDescriptor, targetType-TypeDescriptor]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "refined generic converter concept\n",
          "commitDate": "2009/9/19 上午3:57",
          "commitName": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/18 下午10:30",
          "commitNameOld": "8e800f03226747a12adc235ca80bd94513b67ca8",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n    GenericConverter converter \u003d matchConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n    if (converter \u003d\u003d null) {\n        for (GenericConverter matchableConverter : this.matchableConverters) {\n            if (matchableConverter.canConvert(sourceType, targetType)) {\n                return matchableConverter;\n            }\n        }\n    }\n    return converter;\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 186,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,39 +1,11 @@\n-protected GenericConverter getConverter(Class sourceType, TypeDescriptor targetType) {\n-    if (sourceType.isInterface()) {\n-        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(sourceType);\n-        while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d classQueue.removeLast();\n-            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n-            GenericConverter converter \u003d getConverter(converters, targetType);\n-            if (converter !\u003d null) {\n-                return converter;\n-            }\n-            Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (Class ifc : interfaces) {\n-                classQueue.addFirst(ifc);\n+protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n+    GenericConverter converter \u003d matchConverterByClassPair(sourceType.getObjectType(), targetType.getObjectType());\n+    if (converter \u003d\u003d null) {\n+        for (GenericConverter matchableConverter : this.matchableConverters) {\n+            if (matchableConverter.canConvert(sourceType, targetType)) {\n+                return matchableConverter;\n             }\n         }\n-        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n-        return getConverter(objectConverters, targetType);\n-    } else {\n-        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(sourceType);\n-        while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d classQueue.removeLast();\n-            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n-            GenericConverter converter \u003d getConverter(converters, targetType);\n-            if (converter !\u003d null) {\n-                return converter;\n-            }\n-            if (currentClass.getSuperclass() !\u003d null) {\n-                classQueue.addFirst(currentClass.getSuperclass());\n-            }\n-            Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (Class ifc : interfaces) {\n-                classQueue.addFirst(ifc);\n-            }\n-        }\n-        return null;\n     }\n+    return converter;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "31441627de02bcc4ac2dcf307809b3c94b642e7b": {
      "type": "Yparameterchange",
      "commitMessage": "updated formatter conversion service adapter to work with type descriptor\n",
      "commitDate": "2009/9/18 上午3:48",
      "commitName": "31441627de02bcc4ac2dcf307809b3c94b642e7b",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/9/18 上午3:24",
      "commitNameOld": "33c19b8b14b534ba423c9cee51c90536daa6e119",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected GenericConverter getConverter(Class sourceType, TypeDescriptor targetType) {\n    if (sourceType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n        return getConverter(objectConverters, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 180,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,39 @@\n-protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n+protected GenericConverter getConverter(Class sourceType, TypeDescriptor targetType) {\n     if (sourceType.isInterface()) {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n             Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n             GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n         Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n         return getConverter(objectConverters, targetType);\n     } else {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n             Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n             GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[sourceType-Class\u003c?\u003e, targetType-Class\u003c?\u003e]",
        "newValue": "[sourceType-Class, targetType-TypeDescriptor]"
      }
    },
    "33c19b8b14b534ba423c9cee51c90536daa6e119": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Converter system implementation cleanup and tidying; wip\n",
      "commitDate": "2009/9/18 上午3:24",
      "commitName": "33c19b8b14b534ba423c9cee51c90536daa6e119",
      "commitAuthor": "Keith Donald",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Converter system implementation cleanup and tidying; wip\n",
          "commitDate": "2009/9/18 上午3:24",
          "commitName": "33c19b8b14b534ba423c9cee51c90536daa6e119",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/17 上午3:24",
          "commitNameOld": "1c6965132f05ab9d127157d637728bddce5d0b39",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n    if (sourceType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n        return getConverter(objectConverters, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 184,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,39 @@\n-private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n-    if (targetType.isInterface()) {\n+protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n+    if (sourceType.isInterface()) {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverter(converters, Object.class, targetType);\n+        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n+        return getConverter(objectConverters, targetType);\n     } else {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[converters-Map\u003cClass,Object\u003e, targetType-Class\u003c?\u003e]",
            "newValue": "[sourceType-Class\u003c?\u003e, targetType-Class\u003c?\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Converter system implementation cleanup and tidying; wip\n",
          "commitDate": "2009/9/18 上午3:24",
          "commitName": "33c19b8b14b534ba423c9cee51c90536daa6e119",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/17 上午3:24",
          "commitNameOld": "1c6965132f05ab9d127157d637728bddce5d0b39",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n    if (sourceType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n        return getConverter(objectConverters, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 184,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,39 @@\n-private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n-    if (targetType.isInterface()) {\n+protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n+    if (sourceType.isInterface()) {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverter(converters, Object.class, targetType);\n+        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n+        return getConverter(objectConverters, targetType);\n     } else {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Converter",
            "newValue": "GenericConverter"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Converter system implementation cleanup and tidying; wip\n",
          "commitDate": "2009/9/18 上午3:24",
          "commitName": "33c19b8b14b534ba423c9cee51c90536daa6e119",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/17 上午3:24",
          "commitNameOld": "1c6965132f05ab9d127157d637728bddce5d0b39",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n    if (sourceType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n        return getConverter(objectConverters, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 184,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,39 @@\n-private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n-    if (targetType.isInterface()) {\n+protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n+    if (sourceType.isInterface()) {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverter(converters, Object.class, targetType);\n+        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n+        return getConverter(objectConverters, targetType);\n     } else {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Converter system implementation cleanup and tidying; wip\n",
          "commitDate": "2009/9/18 上午3:24",
          "commitName": "33c19b8b14b534ba423c9cee51c90536daa6e119",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/9/17 上午3:24",
          "commitNameOld": "1c6965132f05ab9d127157d637728bddce5d0b39",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n    if (sourceType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n        return getConverter(objectConverters, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(sourceType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n            GenericConverter converter \u003d getConverter(converters, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 184,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,39 @@\n-private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n-    if (targetType.isInterface()) {\n+protected GenericConverter getConverter(Class\u003c?\u003e sourceType, Class\u003c?\u003e targetType) {\n+    if (sourceType.isInterface()) {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverter(converters, Object.class, targetType);\n+        Map\u003cClass, GenericConverter\u003e objectConverters \u003d getConvertersForSource(Object.class);\n+        return getConverter(objectConverters, targetType);\n     } else {\n         LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n-        classQueue.addFirst(targetType);\n+        classQueue.addFirst(sourceType);\n         while (!classQueue.isEmpty()) {\n             Class currentClass \u003d classQueue.removeLast();\n-            Converter converter \u003d getConverter(converters, currentClass, targetType);\n+            Map\u003cClass, GenericConverter\u003e converters \u003d getConvertersForSource(currentClass);\n+            GenericConverter converter \u003d getConverter(converters, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n             for (Class ifc : interfaces) {\n                 classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
      "type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
      "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
      "commitDate": "2009/8/9 上午8:46",
      "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
          "commitDate": "2009/8/9 上午8:46",
          "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/8/9 上午4:37",
          "commitNameOld": "e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n    if (targetType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Converter converter \u003d getConverter(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return getConverter(converters, Object.class, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Converter converter \u003d getConverter(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 407,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,36 @@\n-private Converter getConverter(Map converters, Class targetType) {\n+private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n     if (targetType.isInterface()) {\n-        LinkedList classQueue \u003d new LinkedList();\n+        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(targetType);\n         while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d (Class) classQueue.removeLast();\n-            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            Class currentClass \u003d classQueue.removeLast();\n+            Converter converter \u003d getConverter(converters, currentClass, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n-                classQueue.addFirst(interfaces[i]);\n+            for (Class ifc : interfaces) {\n+                classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverterImpl(converters, Object.class, targetType);\n+        return getConverter(converters, Object.class, targetType);\n     } else {\n-        LinkedList classQueue \u003d new LinkedList();\n+        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(targetType);\n         while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d (Class) classQueue.removeLast();\n-            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            Class currentClass \u003d classQueue.removeLast();\n+            Converter converter \u003d getConverter(converters, currentClass, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n-                classQueue.addFirst(interfaces[i]);\n+            for (Class ifc : interfaces) {\n+                classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericTypeConverter.java",
            "newPath": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
          "commitDate": "2009/8/9 上午8:46",
          "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/8/9 上午4:37",
          "commitNameOld": "e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n    if (targetType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Converter converter \u003d getConverter(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return getConverter(converters, Object.class, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Converter converter \u003d getConverter(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 407,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,36 @@\n-private Converter getConverter(Map converters, Class targetType) {\n+private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n     if (targetType.isInterface()) {\n-        LinkedList classQueue \u003d new LinkedList();\n+        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(targetType);\n         while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d (Class) classQueue.removeLast();\n-            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            Class currentClass \u003d classQueue.removeLast();\n+            Converter converter \u003d getConverter(converters, currentClass, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n-                classQueue.addFirst(interfaces[i]);\n+            for (Class ifc : interfaces) {\n+                classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverterImpl(converters, Object.class, targetType);\n+        return getConverter(converters, Object.class, targetType);\n     } else {\n-        LinkedList classQueue \u003d new LinkedList();\n+        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(targetType);\n         while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d (Class) classQueue.removeLast();\n-            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            Class currentClass \u003d classQueue.removeLast();\n+            Converter converter \u003d getConverter(converters, currentClass, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n-                classQueue.addFirst(interfaces[i]);\n+            for (Class ifc : interfaces) {\n+                classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
          "commitDate": "2009/8/9 上午8:46",
          "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/8/9 上午4:37",
          "commitNameOld": "e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n    if (targetType.isInterface()) {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Converter converter \u003d getConverter(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return getConverter(converters, Object.class, targetType);\n    } else {\n        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d classQueue.removeLast();\n            Converter converter \u003d getConverter(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (Class ifc : interfaces) {\n                classQueue.addFirst(ifc);\n            }\n        }\n        return null;\n    }\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
          "functionStartLine": 407,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,36 +1,36 @@\n-private Converter getConverter(Map converters, Class targetType) {\n+private Converter getConverter(Map\u003cClass, Object\u003e converters, Class\u003c?\u003e targetType) {\n     if (targetType.isInterface()) {\n-        LinkedList classQueue \u003d new LinkedList();\n+        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(targetType);\n         while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d (Class) classQueue.removeLast();\n-            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            Class currentClass \u003d classQueue.removeLast();\n+            Converter converter \u003d getConverter(converters, currentClass, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n-                classQueue.addFirst(interfaces[i]);\n+            for (Class ifc : interfaces) {\n+                classQueue.addFirst(ifc);\n             }\n         }\n-        return getConverterImpl(converters, Object.class, targetType);\n+        return getConverter(converters, Object.class, targetType);\n     } else {\n-        LinkedList classQueue \u003d new LinkedList();\n+        LinkedList\u003cClass\u003e classQueue \u003d new LinkedList\u003cClass\u003e();\n         classQueue.addFirst(targetType);\n         while (!classQueue.isEmpty()) {\n-            Class currentClass \u003d (Class) classQueue.removeLast();\n-            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            Class currentClass \u003d classQueue.removeLast();\n+            Converter converter \u003d getConverter(converters, currentClass, targetType);\n             if (converter !\u003d null) {\n                 return converter;\n             }\n             if (currentClass.getSuperclass() !\u003d null) {\n                 classQueue.addFirst(currentClass.getSuperclass());\n             }\n             Class[] interfaces \u003d currentClass.getInterfaces();\n-            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n-                classQueue.addFirst(interfaces[i]);\n+            for (Class ifc : interfaces) {\n+                classQueue.addFirst(ifc);\n             }\n         }\n         return null;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[converters-Map, targetType-Class]",
            "newValue": "[converters-Map\u003cClass,Object\u003e, targetType-Class\u003c?\u003e]"
          }
        }
      ]
    },
    "b33be88c9da6182aa2141b0ba773d5a2b4cd59bf": {
      "type": "Ybodychange",
      "commitMessage": "tests passing again\n",
      "commitDate": "2009/5/16 上午5:31",
      "commitName": "b33be88c9da6182aa2141b0ba773d5a2b4cd59bf",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/5/16 上午4:32",
      "commitNameOld": "46c9a003eb1e0230aef78f2433203b75bc9934bb",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Converter getConverter(Map converters, Class targetType) {\n    if (targetType.isInterface()) {\n        LinkedList classQueue \u003d new LinkedList();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d (Class) classQueue.removeLast();\n            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n                classQueue.addFirst(interfaces[i]);\n            }\n        }\n        return getConverterImpl(converters, Object.class, targetType);\n    } else {\n        LinkedList classQueue \u003d new LinkedList();\n        classQueue.addFirst(targetType);\n        while (!classQueue.isEmpty()) {\n            Class currentClass \u003d (Class) classQueue.removeLast();\n            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n            if (converter !\u003d null) {\n                return converter;\n            }\n            if (currentClass.getSuperclass() !\u003d null) {\n                classQueue.addFirst(currentClass.getSuperclass());\n            }\n            Class[] interfaces \u003d currentClass.getInterfaces();\n            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n                classQueue.addFirst(interfaces[i]);\n            }\n        }\n        return null;\n    }\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericTypeConverter.java",
      "functionStartLine": 308,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,3 +1,36 @@\n private Converter getConverter(Map converters, Class targetType) {\n-    return (Converter) converters.get(targetType);\n+    if (targetType.isInterface()) {\n+        LinkedList classQueue \u003d new LinkedList();\n+        classQueue.addFirst(targetType);\n+        while (!classQueue.isEmpty()) {\n+            Class currentClass \u003d (Class) classQueue.removeLast();\n+            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            if (converter !\u003d null) {\n+                return converter;\n+            }\n+            Class[] interfaces \u003d currentClass.getInterfaces();\n+            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n+                classQueue.addFirst(interfaces[i]);\n+            }\n+        }\n+        return getConverterImpl(converters, Object.class, targetType);\n+    } else {\n+        LinkedList classQueue \u003d new LinkedList();\n+        classQueue.addFirst(targetType);\n+        while (!classQueue.isEmpty()) {\n+            Class currentClass \u003d (Class) classQueue.removeLast();\n+            Converter converter \u003d getConverterImpl(converters, currentClass, targetType);\n+            if (converter !\u003d null) {\n+                return converter;\n+            }\n+            if (currentClass.getSuperclass() !\u003d null) {\n+                classQueue.addFirst(currentClass.getSuperclass());\n+            }\n+            Class[] interfaces \u003d currentClass.getInterfaces();\n+            for (int i \u003d 0; i \u003c interfaces.length; i++) {\n+                classQueue.addFirst(interfaces[i]);\n+            }\n+        }\n+        return null;\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f74369cb34910de299a84ad7272e4fe3f527d4e": {
      "type": "Yfilerename",
      "commitMessage": "polish\n",
      "commitDate": "2009/5/16 上午1:28",
      "commitName": "6f74369cb34910de299a84ad7272e4fe3f527d4e",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/5/16 上午1:01",
      "commitNameOld": "acf17381b9d37de98619f54ea1e150e76d6e15aa",
      "commitAuthorOld": "Ben Hale",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Converter getConverter(Map converters, Class targetType) {\n    return (Converter) converters.get(targetType);\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericTypeConverter.java",
      "functionStartLine": 287,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
        "newPath": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericTypeConverter.java"
      }
    },
    "9a261470ade2f556b4c36c7feca69c50216ebfed": {
      "type": "Yfilerename",
      "commitMessage": "converter system refactoring from community input\n",
      "commitDate": "2009/5/15 上午5:36",
      "commitName": "9a261470ade2f556b4c36c7feca69c50216ebfed",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/5/14 上午4:52",
      "commitNameOld": "a1793457b212bae29cf521661d26cc3155e30d94",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Converter getConverter(Map converters, Class targetType) {\n    return (Converter) converters.get(targetType);\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
      "functionStartLine": 267,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.core/src/main/java/org/springframework/core/convert/service/GenericConversionService.java",
        "newPath": "org.springframework.core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java"
      }
    },
    "ebb203a25155f822e0eec8719b7f2327fcd664c0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "removed custom converter for m3 to add back in rc1; also ensure type descriptor get type always returns wrapper types if primitive\n",
      "commitDate": "2009/4/10 下午11:57",
      "commitName": "ebb203a25155f822e0eec8719b7f2327fcd664c0",
      "commitAuthor": "Keith Donald",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "removed custom converter for m3 to add back in rc1; also ensure type descriptor get type always returns wrapper types if primitive\n",
          "commitDate": "2009/4/10 下午11:57",
          "commitName": "ebb203a25155f822e0eec8719b7f2327fcd664c0",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/4/9 上午6:10",
          "commitNameOld": "9ce71f67ffe94aa46542c8d32e04efbaae96eb87",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.74,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "private Converter getConverter(Map converters, Class targetType) {\n    return (Converter) converters.get(targetType);\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/service/GenericConversionService.java",
          "functionStartLine": 356,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,3 +1,3 @@\n-private Converter getConverter(Map converters, Class targetClass) {\n-    return (Converter) converters.get(targetClass);\n+private Converter getConverter(Map converters, Class targetType) {\n+    return (Converter) converters.get(targetType);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[converters-Map, targetClass-Class]",
            "newValue": "[converters-Map, targetType-Class]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "removed custom converter for m3 to add back in rc1; also ensure type descriptor get type always returns wrapper types if primitive\n",
          "commitDate": "2009/4/10 下午11:57",
          "commitName": "ebb203a25155f822e0eec8719b7f2327fcd664c0",
          "commitAuthor": "Keith Donald",
          "commitDateOld": "2009/4/9 上午6:10",
          "commitNameOld": "9ce71f67ffe94aa46542c8d32e04efbaae96eb87",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 1.74,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "private Converter getConverter(Map converters, Class targetType) {\n    return (Converter) converters.get(targetType);\n}",
          "path": "org.springframework.core/src/main/java/org/springframework/core/convert/service/GenericConversionService.java",
          "functionStartLine": 356,
          "functionName": "getConverter",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,3 +1,3 @@\n-private Converter getConverter(Map converters, Class targetClass) {\n-    return (Converter) converters.get(targetClass);\n+private Converter getConverter(Map converters, Class targetType) {\n+    return (Converter) converters.get(targetType);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "0ef0ff60f0b08b521ddc8fc093b38d7c9eb98326": {
      "type": "Yintroduced",
      "commitMessage": "super converter implementation\n",
      "commitDate": "2009/3/8 下午4:47",
      "commitName": "0ef0ff60f0b08b521ddc8fc093b38d7c9eb98326",
      "commitAuthor": "Keith Donald",
      "diff": "@@ -0,0 +1,3 @@\n+private Converter getConverter(Map converters, Class targetClass) {\n+    return (Converter) converters.get(targetClass);\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Converter getConverter(Map converters, Class targetClass) {\n    return (Converter) converters.get(targetClass);\n}",
      "path": "org.springframework.core/src/main/java/org/springframework/core/convert/service/GenericConversionService.java",
      "functionStartLine": 333,
      "functionName": "getConverter",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}