{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/elasticsearch/.git",
  "startCommitName": "767c69593c67befb843686de8ea51b7bc87728c9",
  "sourceFileName": "IndicesService.java",
  "functionName": "verifyIndexMetadata",
  "functionId": "verifyIndexMetadata___metaData-IndexMetaData__metaDataUpdate-IndexMetaData",
  "sourceFilePath": "server/src/main/java/org/elasticsearch/indices/IndicesService.java",
  "functionAnnotation": "",
  "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
  "functionStartLine": 550,
  "functionEndLine": 568,
  "numCommitsSeen": 353,
  "timeTaken": 7576,
  "changeHistory": [
    "700d9ecc953fa30df0d12d086f0e9d9322446459",
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
    "8f873620ee5a22008a97d29ca4fa448790cf8f0d",
    "63af03a1042a6ae1ed333aaabcd9cfc3a9fc3fec",
    "6418f89feb55970c04474e3cced6ff1031725e39",
    "ef0e3db0de6928ddca70d18e929223980f283fe1",
    "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
    "8127a06b2ec40fd5f31a6915143386dd853abc2b"
  ],
  "changeHistoryShort": {
    "700d9ecc953fa30df0d12d086f0e9d9322446459": "Ybodychange",
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": "Yfilerename",
    "8f873620ee5a22008a97d29ca4fa448790cf8f0d": "Ybodychange",
    "63af03a1042a6ae1ed333aaabcd9cfc3a9fc3fec": "Ybodychange",
    "6418f89feb55970c04474e3cced6ff1031725e39": "Ymultichange(Yparameterchange,Ybodychange)",
    "ef0e3db0de6928ddca70d18e929223980f283fe1": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "4fb1c4fe5ad7017d60b2b6aae08f55f407805386": "Ybodychange",
    "8127a06b2ec40fd5f31a6915143386dd853abc2b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "700d9ecc953fa30df0d12d086f0e9d9322446459": {
      "type": "Ybodychange",
      "commitMessage": "Remove the `update_all_types` option. (#28288)\n\nThis option is not useful in 7.x since no indices may have more than one type\r\nanymore.\r\n\r\n",
      "commitDate": "2018/1/22 下午7:03",
      "commitName": "700d9ecc953fa30df0d12d086f0e9d9322446459",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": "2018/1/12 上午2:30",
      "commitNameOld": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthorOld": "Tim Brooks",
      "daysBetweenCommits": 10.69,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY);\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
      "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java",
      "functionStartLine": 487,
      "functionName": "verifyIndexMetadata",
      "functionAnnotation": "",
      "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
      "diff": "@@ -1,18 +1,18 @@\n public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n         final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n-        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n+        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY);\n         if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n             service.updateMetaData(metaDataUpdate);\n         }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
      "type": "Yfilerename",
      "commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
      "commitDate": "2018/1/12 上午2:30",
      "commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthor": "Tim Brooks",
      "commitDateOld": "2018/1/12 上午12:31",
      "commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
      "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java",
      "functionStartLine": 487,
      "functionName": "verifyIndexMetadata",
      "functionAnnotation": "",
      "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
        "newPath": "server/src/main/java/org/elasticsearch/indices/IndicesService.java"
      }
    },
    "8f873620ee5a22008a97d29ca4fa448790cf8f0d": {
      "type": "Ybodychange",
      "commitMessage": "Inline global checkpoints\n\nToday we rely on background syncs to relay the global checkpoint under\r\nthe mandate of the primary to its replicas. This means that the global\r\ncheckpoint on a replica can lag far behind the primary. The commit moves\r\nto inlining global checkpoints with replication requests. When a\r\nreplication operation is performed, the primary will send the latest\r\nglobal checkpoint inline with the replica requests. This keeps the\r\nreplicas closer in-sync with the primary.\r\n\r\nHowever, consider a replication request that is not followed by another\r\nreplication request for an indefinite period of time. When the replicas\r\nrespond to the primary with their local checkpoint, the primary will\r\nadvance its global checkpoint. During this indefinite period of time,\r\nthe replicas will not be notified of the advanced global\r\ncheckpoint. This necessitates a need for another sync. To achieve this,\r\nwe perform a global checkpoint sync when a shard falls idle.\r\n\r\nRelates #24513\r\n",
      "commitDate": "2017/5/10 上午3:08",
      "commitName": "8f873620ee5a22008a97d29ca4fa448790cf8f0d",
      "commitAuthor": "Jason Tedor",
      "commitDateOld": "2017/4/12 上午1:26",
      "commitNameOld": "5cace8e48aa3d9a9e5a82e31a8110cfad8998aef",
      "commitAuthorOld": "Lee Hinman",
      "daysBetweenCommits": 28.07,
      "commitsBetweenForRepo": 325,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
      "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
      "functionStartLine": 471,
      "functionName": "verifyIndexMetadata",
      "functionAnnotation": "",
      "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
      "diff": "@@ -1,19 +1,18 @@\n public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n-        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList(), s -\u003e {\n-        });\n+        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n         if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n             service.updateMetaData(metaDataUpdate);\n         }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63af03a1042a6ae1ed333aaabcd9cfc3a9fc3fec": {
      "type": "Ybodychange",
      "commitMessage": "Atomic mapping updates across types (#22220)\n\nThis commit makes mapping updates atomic when multiple types in an index are updated. Mappings for an index are now applied in a single atomic operation, which also allows to optimize some of the cross-type updates and checks.",
      "commitDate": "2016/12/19 下午9:39",
      "commitName": "63af03a1042a6ae1ed333aaabcd9cfc3a9fc3fec",
      "commitAuthor": "Yannick Welsch",
      "commitDateOld": "2016/12/16 上午12:06",
      "commitNameOld": "b6cbcc49ba590ead3cd6d95953eabe22f7d47fef",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 3.9,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList(), s -\u003e {\n        });\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
      "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
      "functionStartLine": 477,
      "functionName": "verifyIndexMetadata",
      "functionAnnotation": "",
      "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
      "diff": "@@ -1,21 +1,19 @@\n public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n         final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList(), s -\u003e {\n         });\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n-        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n-            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n-        }\n+        service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n         if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n             service.updateMetaData(metaDataUpdate);\n         }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6418f89feb55970c04474e3cced6ff1031725e39": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Remove NodeServicesProvider\n\nInstead provide services where they are needed. The class worked\nwell as a temporary measure to easy removal of guice from the index\nlevel but now we can remove it entirely.\n\n-1 @Inject annotation\n",
      "commitDate": "2016/10/8 下午7:35",
      "commitName": "6418f89feb55970c04474e3cced6ff1031725e39",
      "commitAuthor": "Nik Everett",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Remove NodeServicesProvider\n\nInstead provide services where they are needed. The class worked\nwell as a temporary measure to easy removal of guice from the index\nlevel but now we can remove it entirely.\n\n-1 @Inject annotation\n",
          "commitDate": "2016/10/8 下午7:35",
          "commitName": "6418f89feb55970c04474e3cced6ff1031725e39",
          "commitAuthor": "Nik Everett",
          "commitDateOld": "2016/10/5 下午6:22",
          "commitNameOld": "a008959f7a1b9fbe970a9631a96c73ac7a1458df",
          "commitAuthorOld": "Simon Willnauer",
          "daysBetweenCommits": 3.05,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
          "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
          "functionStartLine": 431,
          "functionName": "verifyIndexMetadata",
          "functionAnnotation": "",
          "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
          "diff": "@@ -1,20 +1,20 @@\n-public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n+public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n-        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n             service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n         }\n         if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n             service.updateMetaData(metaDataUpdate);\n         }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[nodeServicesProvider-NodeServicesProvider(modifiers-final), metaData-IndexMetaData, metaDataUpdate-IndexMetaData]",
            "newValue": "[metaData-IndexMetaData, metaDataUpdate-IndexMetaData]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove NodeServicesProvider\n\nInstead provide services where they are needed. The class worked\nwell as a temporary measure to easy removal of guice from the index\nlevel but now we can remove it entirely.\n\n-1 @Inject annotation\n",
          "commitDate": "2016/10/8 下午7:35",
          "commitName": "6418f89feb55970c04474e3cced6ff1031725e39",
          "commitAuthor": "Nik Everett",
          "commitDateOld": "2016/10/5 下午6:22",
          "commitNameOld": "a008959f7a1b9fbe970a9631a96c73ac7a1458df",
          "commitAuthorOld": "Simon Willnauer",
          "daysBetweenCommits": 3.05,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
          "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
          "functionStartLine": 431,
          "functionName": "verifyIndexMetadata",
          "functionAnnotation": "",
          "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
          "diff": "@@ -1,20 +1,20 @@\n-public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n+public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n-        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+        final IndexService service \u003d createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n             service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n         }\n         if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n             service.updateMetaData(metaDataUpdate);\n         }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ef0e3db0de6928ddca70d18e929223980f283fe1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
      "commitDate": "2016/6/28 下午9:35",
      "commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
      "commitAuthor": "Jim Ferenczi",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
          "commitDate": "2016/6/28 下午9:35",
          "commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
          "commitAuthor": "Jim Ferenczi",
          "commitDateOld": "2016/6/27 下午11:18",
          "commitNameOld": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
          "commitAuthorOld": "Simon Willnauer",
          "daysBetweenCommits": 0.93,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
          "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
          "functionStartLine": 420,
          "functionName": "verifyIndexMetadata",
          "functionAnnotation": "",
          "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
          "diff": "@@ -1,18 +1,20 @@\n-public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n         final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n             service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n         }\n-        service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n+        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n+            service.updateMetaData(metaDataUpdate);\n+        }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[nodeServicesProvider-NodeServicesProvider(modifiers-final), metaData-IndexMetaData]",
            "newValue": "[nodeServicesProvider-NodeServicesProvider(modifiers-final), metaData-IndexMetaData, metaDataUpdate-IndexMetaData]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
          "commitDate": "2016/6/28 下午9:35",
          "commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
          "commitAuthor": "Jim Ferenczi",
          "commitDateOld": "2016/6/27 下午11:18",
          "commitNameOld": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
          "commitAuthorOld": "Simon Willnauer",
          "daysBetweenCommits": 0.93,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
          "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
          "functionStartLine": 420,
          "functionName": "verifyIndexMetadata",
          "functionAnnotation": "",
          "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
          "diff": "@@ -1,18 +1,20 @@\n-public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n         final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n             service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n         }\n-        service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n+        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n+            service.updateMetaData(metaDataUpdate);\n+        }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
          "commitDate": "2016/6/28 下午9:35",
          "commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
          "commitAuthor": "Jim Ferenczi",
          "commitDateOld": "2016/6/27 下午11:18",
          "commitNameOld": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
          "commitAuthorOld": "Simon Willnauer",
          "daysBetweenCommits": 0.93,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n            service.updateMetaData(metaDataUpdate);\n        }\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
          "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
          "functionStartLine": 420,
          "functionName": "verifyIndexMetadata",
          "functionAnnotation": "",
          "functionDoc": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n",
          "diff": "@@ -1,18 +1,20 @@\n-public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n         final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n         closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n             service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n         }\n-        service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n+        if (metaData.equals(metaDataUpdate) \u003d\u003d false) {\n+            service.updateMetaData(metaDataUpdate);\n+        }\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "This method verifies that the given {@link IndexMetaData} holds sane values to create an {@link IndexService}. This method will throw an\nexception if the creation fails. The created {@link IndexService} will not be registered and will be closed immediately.\n",
            "newValue": "This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}.\nThis method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}.\nThis method will throw an exception if the creation or the update fails.\nThe created {@link IndexService} will not be registered and will be closed immediately.\n"
          }
        }
      ]
    },
    "4fb1c4fe5ad7017d60b2b6aae08f55f407805386": {
      "type": "Ybodychange",
      "commitMessage": "Validate settings against dynamic updaters on the master (#19088)\n\nToday all settings are only validated against their validators\r\nthat are available when settings are registered. Yet, some settings updaters\r\nhave validators that are dynamic ie. their validation depends on other variables\r\nthat are only available at runtime. We do not run those validators when settings\r\nare updated causing index updates to fail on the data nodes instead of on the master.\r\n\r\nRelates to #19046",
      "commitDate": "2016/6/27 下午11:18",
      "commitName": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2016/6/23 下午3:30",
      "commitNameOld": "04da1bda0ddb42a66c6b8481a544f24647bd0ce4",
      "commitAuthorOld": "Tanguy Leroux",
      "daysBetweenCommits": 4.32,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
      "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
      "functionStartLine": 418,
      "functionName": "verifyIndexMetadata",
      "functionAnnotation": "",
      "functionDoc": "This method verifies that the given {@link IndexMetaData} holds sane values to create an {@link IndexService}. This method will throw an\nexception if the creation fails. The created {@link IndexService} will not be registered and will be closed immediately.\n",
      "diff": "@@ -1,17 +1,18 @@\n public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n     final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n     try {\n         IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n         });\n         closeables.add(indicesFieldDataCache);\n         IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n         closeables.add(indicesQueryCache);\n         final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n         for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n             service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n         }\n-        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n+        service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n     } finally {\n         IOUtils.close(closeables);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8127a06b2ec40fd5f31a6915143386dd853abc2b": {
      "type": "Yintroduced",
      "commitMessage": "Recover broken IndexMetaData as closed\n\nToday if something is wrong with the IndexMetaData we detect it very\nlate and most of the time if that happens we already allocated the index\nand get endless loops and full log files on data-nodes. This change tries\nto verify IndexService creattion during initial state recovery on the master\nand if the recovery fails the index is imported as `closed` and won\u0027t be allocated\nat all.\n\nCloses #17187\n",
      "commitDate": "2016/3/22 上午5:50",
      "commitName": "8127a06b2ec40fd5f31a6915143386dd853abc2b",
      "commitAuthor": "Simon Willnauer",
      "diff": "@@ -0,0 +1,17 @@\n+public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n+    try {\n+        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n+        });\n+        closeables.add(indicesFieldDataCache);\n+        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n+        closeables.add(indicesQueryCache);\n+        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n+            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n+        }\n+        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n+    } finally {\n+        IOUtils.close(closeables);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n    final List\u003cCloseable\u003e closeables \u003d new ArrayList\u003c\u003e();\n    try {\n        IndicesFieldDataCache indicesFieldDataCache \u003d new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {\n        });\n        closeables.add(indicesFieldDataCache);\n        IndicesQueryCache indicesQueryCache \u003d new IndicesQueryCache(settings);\n        closeables.add(indicesQueryCache);\n        final IndexService service \u003d createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n        for (ObjectCursor\u003cMappingMetaData\u003e typeMapping : metaData.getMappings().values()) {\n            service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(), MapperService.MergeReason.MAPPING_RECOVERY, true);\n        }\n        closeables.add(() -\u003e service.close(\"metadata verification\", false));\n    } finally {\n        IOUtils.close(closeables);\n    }\n}",
      "path": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
      "functionStartLine": 394,
      "functionName": "verifyIndexMetadata",
      "functionAnnotation": "",
      "functionDoc": "This method verifies that the given {@link IndexMetaData} holds sane values to create an {@link IndexService}. This method will throw an\nexception if the creation fails. The created {@link IndexService} will not be registered and will be closed immediately.\n"
    }
  }
}