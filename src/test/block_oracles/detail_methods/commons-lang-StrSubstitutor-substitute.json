{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "StrSubstitutor.java",
  "functionName": "substitute",
  "functionId": "substitute___buf-StrBuilder(modifiers-final)__offset-int(modifiers-final)__length-int(modifiers-final)__priorVariables-List__String__",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
  "functionAnnotation": "",
  "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
  "functionStartLine": 758,
  "functionEndLine": 892,
  "numCommitsSeen": 54,
  "timeTaken": 1747,
  "changeHistory": [
    "4f82195afdc4279c05826fc20f8642bfdaaafec3",
    "e55aaa5706f031df2e8d68bdf088604c79944246",
    "93b1808e523c252098139c37ee5b23324e855b4a",
    "1d97f23c08d8dbf889e976f9248d37173dbadb95",
    "abc5dda962fe00fba27f98807ca70439a37a3746",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "371e866442f46131cc38a9a5018e1703f52f9b60",
    "6f6eddbf3a41fa2838f062fee7724a69b86206df",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "654fb75d80a63fa551ced73c3b652f4120573590",
    "927e7361037fa495cafece987c1c7d54b7e8128b",
    "4bfa1f6cb94c368ffa4febc3a2236886ced2290f"
  ],
  "changeHistoryShort": {
    "4f82195afdc4279c05826fc20f8642bfdaaafec3": "Ybodychange",
    "e55aaa5706f031df2e8d68bdf088604c79944246": "Ybodychange",
    "93b1808e523c252098139c37ee5b23324e855b4a": "Ybodychange",
    "1d97f23c08d8dbf889e976f9248d37173dbadb95": "Ybodychange",
    "abc5dda962fe00fba27f98807ca70439a37a3746": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "371e866442f46131cc38a9a5018e1703f52f9b60": "Ybodychange",
    "6f6eddbf3a41fa2838f062fee7724a69b86206df": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "654fb75d80a63fa551ced73c3b652f4120573590": "Ymultichange(Yparameterchange,Ybodychange)",
    "927e7361037fa495cafece987c1c7d54b7e8128b": "Ybodychange",
    "4bfa1f6cb94c368ffa4febc3a2236886ced2290f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4f82195afdc4279c05826fc20f8642bfdaaafec3": {
      "type": "Ybodychange",
      "commitMessage": "Remove redundant type arguments.",
      "commitDate": "2016/10/24 上午1:52",
      "commitName": "4f82195afdc4279c05826fc20f8642bfdaaafec3",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2016/9/11 下午10:07",
      "commitNameOld": "ecf6de89ba1a6542c68194e95d14ea944b6c92b7",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 42.16,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n    final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n    final char escape \u003d getEscapeChar();\n    final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n    final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n    final boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                if (preserveEscapes) {\n                    pos++;\n                    continue;\n                }\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                final int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            final int endPos \u003d pos;\n                            String varName \u003d varNameExpr;\n                            String varDefaultValue \u003d null;\n                            if (valueDelimMatcher !\u003d null) {\n                                final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen \u003d 0;\n                                for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                    if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                        break;\n                                    }\n                                    if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                        varName \u003d varNameExpr.substring(0, i);\n                                        varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003c\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue \u003d\u003d null) {\n                                varValue \u003d varDefaultValue;\n                            }\n                            if (varValue !\u003d null) {\n                                final int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos +\u003d endMatchLen;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 753,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,103 +1,103 @@\n private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n     final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n     final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n     final char escape \u003d getEscapeChar();\n     final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n     final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n     final boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 if (preserveEscapes) {\n                     pos++;\n                     continue;\n                 }\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 final int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (substitutionInVariablesEnabled) {\n                                 final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                 substitute(bufName, 0, bufName.length());\n                                 varNameExpr \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             final int endPos \u003d pos;\n                             String varName \u003d varNameExpr;\n                             String varDefaultValue \u003d null;\n                             if (valueDelimMatcher !\u003d null) {\n                                 final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                 int valueDelimiterMatchLen \u003d 0;\n                                 for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                     if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                         break;\n                                     }\n                                     if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                         varName \u003d varNameExpr.substring(0, i);\n                                         varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                         break;\n                                     }\n                                 }\n                             }\n                             if (priorVariables \u003d\u003d null) {\n-                                priorVariables \u003d new ArrayList\u003cString\u003e();\n+                                priorVariables \u003d new ArrayList\u003c\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue \u003d\u003d null) {\n                                 varValue \u003d varDefaultValue;\n                             }\n                             if (varValue !\u003d null) {\n                                 final int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                         nestedVarCount--;\n                         pos +\u003d endMatchLen;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e55aaa5706f031df2e8d68bdf088604c79944246": {
      "type": "Ybodychange",
      "commitMessage": "StrSubstitutor can preserve escapes\n\nStrSubstitutor can now optionally preserve the escape character for an\nescaped reference, which is useful when substitution takes place in\nmultiple phases and some references are intentionally unresolved.  Prior\nto this change, an unresolved reference `${a}` and an escaped reference\n`$${a}` may result in the same string `${a}`, making it impossible for\nan additional substitution phase to distinguish between escaped\nreferences and non-escaped references.\n",
      "commitDate": "2016/2/26 上午9:02",
      "commitName": "e55aaa5706f031df2e8d68bdf088604c79944246",
      "commitAuthor": "Samuel Karp",
      "commitDateOld": "2015/5/6 上午3:12",
      "commitNameOld": "740c0f95fbd99cb7c07bcf7c54bc077c3ab27bd1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 296.24,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n    final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n    final char escape \u003d getEscapeChar();\n    final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n    final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n    final boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                if (preserveEscapes) {\n                    pos++;\n                    continue;\n                }\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                final int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            final int endPos \u003d pos;\n                            String varName \u003d varNameExpr;\n                            String varDefaultValue \u003d null;\n                            if (valueDelimMatcher !\u003d null) {\n                                final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen \u003d 0;\n                                for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                    if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                        break;\n                                    }\n                                    if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                        varName \u003d varNameExpr.substring(0, i);\n                                        varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue \u003d\u003d null) {\n                                varValue \u003d varDefaultValue;\n                            }\n                            if (varValue !\u003d null) {\n                                final int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos +\u003d endMatchLen;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 753,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,99 +1,103 @@\n private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n     final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n     final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n     final char escape \u003d getEscapeChar();\n     final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n     final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n     final boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n+                if (preserveEscapes) {\n+                    pos++;\n+                    continue;\n+                }\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 final int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (substitutionInVariablesEnabled) {\n                                 final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                 substitute(bufName, 0, bufName.length());\n                                 varNameExpr \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             final int endPos \u003d pos;\n                             String varName \u003d varNameExpr;\n                             String varDefaultValue \u003d null;\n                             if (valueDelimMatcher !\u003d null) {\n                                 final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                 int valueDelimiterMatchLen \u003d 0;\n                                 for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                     if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                         break;\n                                     }\n                                     if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                         varName \u003d varNameExpr.substring(0, i);\n                                         varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                         break;\n                                     }\n                                 }\n                             }\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue \u003d\u003d null) {\n                                 varValue \u003d varDefaultValue;\n                             }\n                             if (varValue !\u003d null) {\n                                 final int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                         nestedVarCount--;\n                         pos +\u003d endMatchLen;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "93b1808e523c252098139c37ee5b23324e855b4a": {
      "type": "Ybodychange",
      "commitMessage": "Statement unnecessarily nested within else clause.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1606063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/6/27 下午8:34",
      "commitName": "93b1808e523c252098139c37ee5b23324e855b4a",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2014/6/27 下午8:22",
      "commitNameOld": "96c30e248d6d27a1df8e26be14aa10c633168cdb",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n    final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n    final char escape \u003d getEscapeChar();\n    final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n    final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n    final boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                final int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            final int endPos \u003d pos;\n                            String varName \u003d varNameExpr;\n                            String varDefaultValue \u003d null;\n                            if (valueDelimMatcher !\u003d null) {\n                                final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen \u003d 0;\n                                for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                    if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                        break;\n                                    }\n                                    if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                        varName \u003d varNameExpr.substring(0, i);\n                                        varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue \u003d\u003d null) {\n                                varValue \u003d varDefaultValue;\n                            }\n                            if (varValue !\u003d null) {\n                                final int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos +\u003d endMatchLen;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 750,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,100 +1,99 @@\n private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n     final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n     final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n     final char escape \u003d getEscapeChar();\n     final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n     final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n     final boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 final int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (substitutionInVariablesEnabled) {\n                                 final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                 substitute(bufName, 0, bufName.length());\n                                 varNameExpr \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             final int endPos \u003d pos;\n                             String varName \u003d varNameExpr;\n                             String varDefaultValue \u003d null;\n                             if (valueDelimMatcher !\u003d null) {\n                                 final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                 int valueDelimiterMatchLen \u003d 0;\n                                 for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                     if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                         break;\n                                     }\n                                     if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                         varName \u003d varNameExpr.substring(0, i);\n                                         varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                         break;\n                                     }\n                                 }\n                             }\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue \u003d\u003d null) {\n                                 varValue \u003d varDefaultValue;\n                             }\n                             if (varValue !\u003d null) {\n                                 final int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n-                        } else {\n-                            nestedVarCount--;\n-                            pos +\u003d endMatchLen;\n                         }\n+                        nestedVarCount--;\n+                        pos +\u003d endMatchLen;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d97f23c08d8dbf889e976f9248d37173dbadb95": {
      "type": "Ybodychange",
      "commitMessage": "It\u0027s confusing to re-use field names locally\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1533551 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/10/19 上午12:49",
      "commitName": "1d97f23c08d8dbf889e976f9248d37173dbadb95",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013/9/30 上午2:06",
      "commitNameOld": "a328fd00a7092768758c0a76d68eeebaf8116440",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 18.95,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n    final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n    final char escape \u003d getEscapeChar();\n    final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n    final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n    final boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                final int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            final int endPos \u003d pos;\n                            String varName \u003d varNameExpr;\n                            String varDefaultValue \u003d null;\n                            if (valueDelimMatcher !\u003d null) {\n                                final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen \u003d 0;\n                                for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                    if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                        break;\n                                    }\n                                    if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                        varName \u003d varNameExpr.substring(0, i);\n                                        varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue \u003d\u003d null) {\n                                varValue \u003d varDefaultValue;\n                            }\n                            if (varValue !\u003d null) {\n                                final int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        } else {\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 740,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,100 +1,100 @@\n private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n-    final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n-    final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n+    final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n+    final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n     final char escape \u003d getEscapeChar();\n-    final StrMatcher valueDelimiterMatcher \u003d getValueDelimiterMatcher();\n+    final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n     final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n     final boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n-        final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+        final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 final int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n-                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n+                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n-                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                    endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (substitutionInVariablesEnabled) {\n                                 final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                 substitute(bufName, 0, bufName.length());\n                                 varNameExpr \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             final int endPos \u003d pos;\n                             String varName \u003d varNameExpr;\n                             String varDefaultValue \u003d null;\n-                            if (valueDelimiterMatcher !\u003d null) {\n+                            if (valueDelimMatcher !\u003d null) {\n                                 final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                 int valueDelimiterMatchLen \u003d 0;\n                                 for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n-                                    if (!substitutionInVariablesEnabled \u0026\u0026 prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n+                                    if (!substitutionInVariablesEnabled \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                         break;\n                                     }\n-                                    if ((valueDelimiterMatchLen \u003d valueDelimiterMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n+                                    if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                         varName \u003d varNameExpr.substring(0, i);\n                                         varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                         break;\n                                     }\n                                 }\n                             }\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue \u003d\u003d null) {\n                                 varValue \u003d varDefaultValue;\n                             }\n                             if (varValue !\u003d null) {\n                                 final int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         } else {\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abc5dda962fe00fba27f98807ca70439a37a3746": {
      "type": "Ybodychange",
      "commitMessage": "[LANG-893] StrSubstitutor now supports the declaration of default values for the variables to be replaced. Thanks to Woonsan Ko for the patch.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1524541 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/9/19 上午3:35",
      "commitName": "abc5dda962fe00fba27f98807ca70439a37a3746",
      "commitAuthor": "Oliver Heger",
      "commitDateOld": "2013/5/31 上午12:36",
      "commitNameOld": "8b494b784dca4de7d79c58e0f00dd4756c04cf89",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 111.12,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    final char escape \u003d getEscapeChar();\n    final StrMatcher valueDelimiterMatcher \u003d getValueDelimiterMatcher();\n    final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n    final boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                final int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            final int endPos \u003d pos;\n                            String varName \u003d varNameExpr;\n                            String varDefaultValue \u003d null;\n                            if (valueDelimiterMatcher !\u003d null) {\n                                final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen \u003d 0;\n                                for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                    if (!substitutionInVariablesEnabled \u0026\u0026 prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                        break;\n                                    }\n                                    if ((valueDelimiterMatchLen \u003d valueDelimiterMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                        varName \u003d varNameExpr.substring(0, i);\n                                        varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue \u003d\u003d null) {\n                                varValue \u003d varDefaultValue;\n                            }\n                            if (varValue !\u003d null) {\n                                final int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        } else {\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 738,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,79 +1,100 @@\n private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n     final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     final char escape \u003d getEscapeChar();\n+    final StrMatcher valueDelimiterMatcher \u003d getValueDelimiterMatcher();\n+    final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n     final boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 final int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n-                    if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n+                    if (substitutionInVariablesEnabled \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n-                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n-                            if (isEnableSubstitutionInVariables()) {\n-                                final StrBuilder bufName \u003d new StrBuilder(varName);\n+                            String varNameExpr \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n+                            if (substitutionInVariablesEnabled) {\n+                                final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                 substitute(bufName, 0, bufName.length());\n-                                varName \u003d bufName.toString();\n+                                varNameExpr \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             final int endPos \u003d pos;\n+                            String varName \u003d varNameExpr;\n+                            String varDefaultValue \u003d null;\n+                            if (valueDelimiterMatcher !\u003d null) {\n+                                final char[] varNameExprChars \u003d varNameExpr.toCharArray();\n+                                int valueDelimiterMatchLen \u003d 0;\n+                                for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n+                                    if (!substitutionInVariablesEnabled \u0026\u0026 prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n+                                        break;\n+                                    }\n+                                    if ((valueDelimiterMatchLen \u003d valueDelimiterMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n+                                        varName \u003d varNameExpr.substring(0, i);\n+                                        varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n+                                        break;\n+                                    }\n+                                }\n+                            }\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n-                            final String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n+                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n+                            if (varValue \u003d\u003d null) {\n+                                varValue \u003d varDefaultValue;\n+                            }\n                             if (varValue !\u003d null) {\n                                 final int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         } else {\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:09",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/1/22 下午3:07",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    final char escape \u003d getEscapeChar();\n    final boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                final int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (isEnableSubstitutionInVariables()) {\n                                final StrBuilder bufName \u003d new StrBuilder(varName);\n                                substitute(bufName, 0, bufName.length());\n                                varName \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            final int endPos \u003d pos;\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            final String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                final int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        } else {\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 578,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,79 +1,79 @@\n private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n-    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n-    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n-    char escape \u003d getEscapeChar();\n-    boolean top \u003d priorVariables \u003d\u003d null;\n+    final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n+    final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n+    final char escape \u003d getEscapeChar();\n+    final boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n-        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+        final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n-                int startPos \u003d pos;\n+                final int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (isEnableSubstitutionInVariables()) {\n-                                StrBuilder bufName \u003d new StrBuilder(varName);\n+                                final StrBuilder bufName \u003d new StrBuilder(varName);\n                                 substitute(bufName, 0, bufName.length());\n                                 varName \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n-                            int endPos \u003d pos;\n+                            final int endPos \u003d pos;\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n-                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n+                            final String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue !\u003d null) {\n-                                int varLen \u003d varValue.length();\n+                                final int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         } else {\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:07",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011/11/10 上午1:53",
      "commitNameOld": "371e866442f46131cc38a9a5018e1703f52f9b60",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 439.55,
      "commitsBetweenForRepo": 243,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (isEnableSubstitutionInVariables()) {\n                                StrBuilder bufName \u003d new StrBuilder(varName);\n                                substitute(bufName, 0, bufName.length());\n                                varName \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        } else {\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 578,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,79 +1,79 @@\n-private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n+private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n     StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     char escape \u003d getEscapeChar();\n     boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (isEnableSubstitutionInVariables()) {\n                                 StrBuilder bufName \u003d new StrBuilder(varName);\n                                 substitute(bufName, 0, bufName.length());\n                                 varName \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             int endPos \u003d pos;\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue !\u003d null) {\n                                 int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         } else {\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List\u003cString\u003e]",
        "newValue": "[buf-StrBuilder(modifiers-final), offset-int(modifiers-final), length-int(modifiers-final), priorVariables-List\u003cString\u003e]"
      }
    },
    "371e866442f46131cc38a9a5018e1703f52f9b60": {
      "type": "Ybodychange",
      "commitMessage": "Remove superfluous parens like:\nreturn (foo + 1);\nint len \u003d (foo + 1);\nif ((foo + 1 \u003e 2))\n((String) foo)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1199894 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/11/10 上午1:53",
      "commitName": "371e866442f46131cc38a9a5018e1703f52f9b60",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011/4/5 下午1:31",
      "commitNameOld": "3a0c152c22b6e96fc809fdee2d6ea5b816a139e6",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 218.52,
      "commitsBetweenForRepo": 424,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d priorVariables \u003d\u003d null;\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (isEnableSubstitutionInVariables()) {\n                                StrBuilder bufName \u003d new StrBuilder(varName);\n                                substitute(bufName, 0, bufName.length());\n                                varName \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + varLen - (endPos - startPos);\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        } else {\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return altered ? 1 : 0;\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 578,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,79 +1,79 @@\n private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n     StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     char escape \u003d getEscapeChar();\n-    boolean top \u003d (priorVariables \u003d\u003d null);\n+    boolean top \u003d priorVariables \u003d\u003d null;\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                         nestedVarCount++;\n                         pos +\u003d endMatchLen;\n                         continue;\n                     }\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         if (nestedVarCount \u003d\u003d 0) {\n                             String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                             if (isEnableSubstitutionInVariables()) {\n                                 StrBuilder bufName \u003d new StrBuilder(varName);\n                                 substitute(bufName, 0, bufName.length());\n                                 varName \u003d bufName.toString();\n                             }\n                             pos +\u003d endMatchLen;\n                             int endPos \u003d pos;\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue !\u003d null) {\n                                 int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n-                                change \u003d change + (varLen - (endPos - startPos));\n+                                change \u003d change + varLen - (endPos - startPos);\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;\n                             }\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         } else {\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n-        return (altered ? 1 : 0);\n+        return altered ? 1 : 0;\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f6eddbf3a41fa2838f062fee7724a69b86206df": {
      "type": "Ybodychange",
      "commitMessage": "[lang-482] Added support for substitution in variable names.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1005974 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/10/9 上午3:17",
      "commitName": "6f6eddbf3a41fa2838f062fee7724a69b86206df",
      "commitAuthor": "Oliver Heger",
      "commitDateOld": "2010/10/3 上午2:37",
      "commitNameOld": "802ebc4279f6020c4bb9a8d11fc164920c54949f",
      "commitAuthorOld": "Oliver Heger",
      "daysBetweenCommits": 6.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                int nestedVarCount \u003d 0;\n                while (pos \u003c bufEnd) {\n                    if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n                        nestedVarCount++;\n                        pos +\u003d endMatchLen;\n                        continue;\n                    }\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        if (nestedVarCount \u003d\u003d 0) {\n                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            if (isEnableSubstitutionInVariables()) {\n                                StrBuilder bufName \u003d new StrBuilder(varName);\n                                substitute(bufName, 0, bufName.length());\n                                varName \u003d bufName.toString();\n                            }\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;\n                            }\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        } else {\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 576,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,63 +1,79 @@\n private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n     StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     char escape \u003d getEscapeChar();\n     boolean top \u003d (priorVariables \u003d\u003d null);\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n+                int nestedVarCount \u003d 0;\n                 while (pos \u003c bufEnd) {\n+                    if (isEnableSubstitutionInVariables() \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd)) !\u003d 0) {\n+                        nestedVarCount++;\n+                        pos +\u003d endMatchLen;\n+                        continue;\n+                    }\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n-                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n-                        pos +\u003d endMatchLen;\n-                        int endPos \u003d pos;\n-                        if (priorVariables \u003d\u003d null) {\n-                            priorVariables \u003d new ArrayList\u003cString\u003e();\n-                            priorVariables.add(new String(chars, offset, length));\n+                        if (nestedVarCount \u003d\u003d 0) {\n+                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n+                            if (isEnableSubstitutionInVariables()) {\n+                                StrBuilder bufName \u003d new StrBuilder(varName);\n+                                substitute(bufName, 0, bufName.length());\n+                                varName \u003d bufName.toString();\n+                            }\n+                            pos +\u003d endMatchLen;\n+                            int endPos \u003d pos;\n+                            if (priorVariables \u003d\u003d null) {\n+                                priorVariables \u003d new ArrayList\u003cString\u003e();\n+                                priorVariables.add(new String(chars, offset, length));\n+                            }\n+                            checkCyclicSubstitution(varName, priorVariables);\n+                            priorVariables.add(varName);\n+                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n+                            if (varValue !\u003d null) {\n+                                int varLen \u003d varValue.length();\n+                                buf.replace(startPos, endPos, varValue);\n+                                altered \u003d true;\n+                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n+                                change \u003d change + (varLen - (endPos - startPos));\n+                                pos +\u003d change;\n+                                bufEnd +\u003d change;\n+                                lengthChange +\u003d change;\n+                                chars \u003d buf.buffer;\n+                            }\n+                            priorVariables.remove(priorVariables.size() - 1);\n+                            break;\n+                        } else {\n+                            nestedVarCount--;\n+                            pos +\u003d endMatchLen;\n                         }\n-                        checkCyclicSubstitution(varName, priorVariables);\n-                        priorVariables.add(varName);\n-                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n-                        if (varValue !\u003d null) {\n-                            int varLen \u003d varValue.length();\n-                            buf.replace(startPos, endPos, varValue);\n-                            altered \u003d true;\n-                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n-                            change \u003d change + (varLen - (endPos - startPos));\n-                            pos +\u003d change;\n-                            bufEnd +\u003d change;\n-                            lengthChange +\u003d change;\n-                            chars \u003d buf.buffer;\n-                        }\n-                        priorVariables.remove(priorVariables.size() - 1);\n-                        break;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return (altered ? 1 : 0);\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                while (pos \u003c bufEnd) {\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        pos +\u003d endMatchLen;\n                        int endPos \u003d pos;\n                        if (priorVariables \u003d\u003d null) {\n                            priorVariables \u003d new ArrayList\u003cString\u003e();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                        if (varValue !\u003d null) {\n                            int varLen \u003d varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered \u003d true;\n                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                            change \u003d change + (varLen - (endPos - startPos));\n                            pos +\u003d change;\n                            bufEnd +\u003d change;\n                            lengthChange +\u003d change;\n                            chars \u003d buf.buffer;\n                        }\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 536,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java",
        "newPath": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                while (pos \u003c bufEnd) {\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        pos +\u003d endMatchLen;\n                        int endPos \u003d pos;\n                        if (priorVariables \u003d\u003d null) {\n                            priorVariables \u003d new ArrayList\u003cString\u003e();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                        if (varValue !\u003d null) {\n                            int varLen \u003d varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered \u003d true;\n                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                            change \u003d change + (varLen - (endPos - startPos));\n                            pos +\u003d change;\n                            bufEnd +\u003d change;\n                            lengthChange +\u003d change;\n                            chars \u003d buf.buffer;\n                        }\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
      "path": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 536,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
        "newPath": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java"
      }
    },
    "654fb75d80a63fa551ced73c3b652f4120573590": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/3/16 上午11:35",
      "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/3/16 上午11:35",
          "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2006/8/28 下午2:21",
          "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 930.88,
          "commitsBetweenForRepo": 510,
          "commitsBetweenForFile": 1,
          "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                while (pos \u003c bufEnd) {\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        pos +\u003d endMatchLen;\n                        int endPos \u003d pos;\n                        if (priorVariables \u003d\u003d null) {\n                            priorVariables \u003d new ArrayList\u003cString\u003e();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                        if (varValue !\u003d null) {\n                            int varLen \u003d varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered \u003d true;\n                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                            change \u003d change + (varLen - (endPos - startPos));\n                            pos +\u003d change;\n                            bufEnd +\u003d change;\n                            lengthChange +\u003d change;\n                            chars \u003d buf.buffer;\n                        }\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
          "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
          "functionStartLine": 536,
          "functionName": "substitute",
          "functionAnnotation": "",
          "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
          "diff": "@@ -1,63 +1,63 @@\n-private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n     StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     char escape \u003d getEscapeChar();\n     boolean top \u003d (priorVariables \u003d\u003d null);\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                         pos +\u003d endMatchLen;\n                         int endPos \u003d pos;\n                         if (priorVariables \u003d\u003d null) {\n-                            priorVariables \u003d new ArrayList();\n+                            priorVariables \u003d new ArrayList\u003cString\u003e();\n                             priorVariables.add(new String(chars, offset, length));\n                         }\n                         checkCyclicSubstitution(varName, priorVariables);\n                         priorVariables.add(varName);\n                         String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                         if (varValue !\u003d null) {\n                             int varLen \u003d varValue.length();\n                             buf.replace(startPos, endPos, varValue);\n                             altered \u003d true;\n                             int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                             change \u003d change + (varLen - (endPos - startPos));\n                             pos +\u003d change;\n                             bufEnd +\u003d change;\n                             lengthChange +\u003d change;\n                             chars \u003d buf.buffer;\n                         }\n                         priorVariables.remove(priorVariables.size() - 1);\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return (altered ? 1 : 0);\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List]",
            "newValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/3/16 上午11:35",
          "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2006/8/28 下午2:21",
          "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 930.88,
          "commitsBetweenForRepo": 510,
          "commitsBetweenForFile": 1,
          "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                while (pos \u003c bufEnd) {\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        pos +\u003d endMatchLen;\n                        int endPos \u003d pos;\n                        if (priorVariables \u003d\u003d null) {\n                            priorVariables \u003d new ArrayList\u003cString\u003e();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                        if (varValue !\u003d null) {\n                            int varLen \u003d varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered \u003d true;\n                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                            change \u003d change + (varLen - (endPos - startPos));\n                            pos +\u003d change;\n                            bufEnd +\u003d change;\n                            lengthChange +\u003d change;\n                            chars \u003d buf.buffer;\n                        }\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
          "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
          "functionStartLine": 536,
          "functionName": "substitute",
          "functionAnnotation": "",
          "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
          "diff": "@@ -1,63 +1,63 @@\n-private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n     StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     char escape \u003d getEscapeChar();\n     boolean top \u003d (priorVariables \u003d\u003d null);\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                         pos +\u003d endMatchLen;\n                         int endPos \u003d pos;\n                         if (priorVariables \u003d\u003d null) {\n-                            priorVariables \u003d new ArrayList();\n+                            priorVariables \u003d new ArrayList\u003cString\u003e();\n                             priorVariables.add(new String(chars, offset, length));\n                         }\n                         checkCyclicSubstitution(varName, priorVariables);\n                         priorVariables.add(varName);\n                         String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                         if (varValue !\u003d null) {\n                             int varLen \u003d varValue.length();\n                             buf.replace(startPos, endPos, varValue);\n                             altered \u003d true;\n                             int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                             change \u003d change + (varLen - (endPos - startPos));\n                             pos +\u003d change;\n                             bufEnd +\u003d change;\n                             lengthChange +\u003d change;\n                             chars \u003d buf.buffer;\n                         }\n                         priorVariables.remove(priorVariables.size() - 1);\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return (altered ? 1 : 0);\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "927e7361037fa495cafece987c1c7d54b7e8128b": {
      "type": "Ybodychange",
      "commitMessage": "Give more power to StrSubstitutor subclasses\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@429507 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/8/8 上午7:06",
      "commitName": "927e7361037fa495cafece987c1c7d54b7e8128b",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2006/8/4 下午2:35",
      "commitNameOld": "2d4e279d1983870d88612afec782f18638b85ce7",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 3.69,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                while (pos \u003c bufEnd) {\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        pos +\u003d endMatchLen;\n                        int endPos \u003d pos;\n                        if (priorVariables \u003d\u003d null) {\n                            priorVariables \u003d new ArrayList();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                        if (varValue !\u003d null) {\n                            int varLen \u003d varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered \u003d true;\n                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                            change \u003d change + (varLen - (endPos - startPos));\n                            pos +\u003d change;\n                            bufEnd +\u003d change;\n                            lengthChange +\u003d change;\n                            chars \u003d buf.buffer;\n                        }\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
      "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
      "functionStartLine": 398,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n",
      "diff": "@@ -1,63 +1,63 @@\n private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n     StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n     StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n     char escape \u003d getEscapeChar();\n     boolean top \u003d (priorVariables \u003d\u003d null);\n     boolean altered \u003d false;\n     int lengthChange \u003d 0;\n     char[] chars \u003d buf.buffer;\n     int bufEnd \u003d offset + length;\n     int pos \u003d offset;\n     while (pos \u003c bufEnd) {\n         int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n         if (startMatchLen \u003d\u003d 0) {\n             pos++;\n         } else {\n             if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                 buf.deleteCharAt(pos - 1);\n                 chars \u003d buf.buffer;\n                 lengthChange--;\n                 altered \u003d true;\n                 bufEnd--;\n             } else {\n                 int startPos \u003d pos;\n                 pos +\u003d startMatchLen;\n                 int endMatchLen \u003d 0;\n                 while (pos \u003c bufEnd) {\n                     endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                     if (endMatchLen \u003d\u003d 0) {\n                         pos++;\n                     } else {\n                         String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                         pos +\u003d endMatchLen;\n                         int endPos \u003d pos;\n                         if (priorVariables \u003d\u003d null) {\n                             priorVariables \u003d new ArrayList();\n                             priorVariables.add(new String(chars, offset, length));\n                         }\n                         checkCyclicSubstitution(varName, priorVariables);\n                         priorVariables.add(varName);\n-                        String varValue \u003d resolveVariable(varName);\n+                        String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                         if (varValue !\u003d null) {\n                             int varLen \u003d varValue.length();\n                             buf.replace(startPos, endPos, varValue);\n                             altered \u003d true;\n                             int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                             change \u003d change + (varLen - (endPos - startPos));\n                             pos +\u003d change;\n                             bufEnd +\u003d change;\n                             lengthChange +\u003d change;\n                             chars \u003d buf.buffer;\n                         }\n                         priorVariables.remove(priorVariables.size() - 1);\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n     if (top) {\n         return (altered ? 1 : 0);\n     }\n     return lengthChange;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4bfa1f6cb94c368ffa4febc3a2236886ced2290f": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit of StrSubstitutor (VariableFormatter) for review\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@424871 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/7/24 上午9:00",
      "commitName": "4bfa1f6cb94c368ffa4febc3a2236886ced2290f",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,63 @@\n+private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n+    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n+    char escape \u003d getEscapeChar();\n+    boolean top \u003d (priorVariables \u003d\u003d null);\n+    boolean altered \u003d false;\n+    int lengthChange \u003d 0;\n+    char[] chars \u003d buf.buffer;\n+    int bufEnd \u003d offset + length;\n+    int pos \u003d offset;\n+    while (pos \u003c bufEnd) {\n+        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+        if (startMatchLen \u003d\u003d 0) {\n+            pos++;\n+        } else {\n+            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n+                buf.deleteCharAt(pos - 1);\n+                chars \u003d buf.buffer;\n+                lengthChange--;\n+                altered \u003d true;\n+                bufEnd--;\n+            } else {\n+                int startPos \u003d pos;\n+                pos +\u003d startMatchLen;\n+                int endMatchLen \u003d 0;\n+                while (pos \u003c bufEnd) {\n+                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                    if (endMatchLen \u003d\u003d 0) {\n+                        pos++;\n+                    } else {\n+                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n+                        pos +\u003d endMatchLen;\n+                        int endPos \u003d pos;\n+                        if (priorVariables \u003d\u003d null) {\n+                            priorVariables \u003d new ArrayList();\n+                            priorVariables.add(new String(chars, offset, length));\n+                        }\n+                        checkCyclicSubstitution(varName, priorVariables);\n+                        priorVariables.add(varName);\n+                        String varValue \u003d resolveVariable(varName);\n+                        if (varValue !\u003d null) {\n+                            int varLen \u003d varValue.length();\n+                            buf.replace(startPos, endPos, varValue);\n+                            altered \u003d true;\n+                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n+                            change \u003d change + (varLen - (endPos - startPos));\n+                            pos +\u003d change;\n+                            bufEnd +\u003d change;\n+                            lengthChange +\u003d change;\n+                            chars \u003d buf.buffer;\n+                        }\n+                        priorVariables.remove(priorVariables.size() - 1);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    if (top) {\n+        return (altered ? 1 : 0);\n+    }\n+    return lengthChange;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n    StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n    StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n    char escape \u003d getEscapeChar();\n    boolean top \u003d (priorVariables \u003d\u003d null);\n    boolean altered \u003d false;\n    int lengthChange \u003d 0;\n    char[] chars \u003d buf.buffer;\n    int bufEnd \u003d offset + length;\n    int pos \u003d offset;\n    while (pos \u003c bufEnd) {\n        int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n        if (startMatchLen \u003d\u003d 0) {\n            pos++;\n        } else {\n            if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                buf.deleteCharAt(pos - 1);\n                chars \u003d buf.buffer;\n                lengthChange--;\n                altered \u003d true;\n                bufEnd--;\n            } else {\n                int startPos \u003d pos;\n                pos +\u003d startMatchLen;\n                int endMatchLen \u003d 0;\n                while (pos \u003c bufEnd) {\n                    endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                    if (endMatchLen \u003d\u003d 0) {\n                        pos++;\n                    } else {\n                        String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                        pos +\u003d endMatchLen;\n                        int endPos \u003d pos;\n                        if (priorVariables \u003d\u003d null) {\n                            priorVariables \u003d new ArrayList();\n                            priorVariables.add(new String(chars, offset, length));\n                        }\n                        checkCyclicSubstitution(varName, priorVariables);\n                        priorVariables.add(varName);\n                        String varValue \u003d resolveVariable(varName);\n                        if (varValue !\u003d null) {\n                            int varLen \u003d varValue.length();\n                            buf.replace(startPos, endPos, varValue);\n                            altered \u003d true;\n                            int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                            change \u003d change + (varLen - (endPos - startPos));\n                            pos +\u003d change;\n                            bufEnd +\u003d change;\n                            lengthChange +\u003d change;\n                            chars \u003d buf.buffer;\n                        }\n                        priorVariables.remove(priorVariables.size() - 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (top) {\n        return (altered ? 1 : 0);\n    }\n    return lengthChange;\n}",
      "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
      "functionStartLine": 391,
      "functionName": "substitute",
      "functionAnnotation": "",
      "functionDoc": "Recursive handler for multiple levels of interpolation. This is the main\ninterpolation method, which resolves the values of all variable references\ncontained in the passed in text.\n\n@param buf the string builder to substitute into, not null\n@param offset the start offset within the builder, must be valid\n@param length the length within the builder to be processed, must be valid\n@param priorVariables the stack keeping track of the replaced variables, may be null\n@return the length change that occurs, unless priorVariables is null when the int\n represents a boolean flag as to whether any change occurred.\n"
    }
  }
}