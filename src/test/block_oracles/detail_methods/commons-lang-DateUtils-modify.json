{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "DateUtils.java",
  "functionName": "modify",
  "functionId": "modify___val-Calendar(modifiers-final)__field-int(modifiers-final)__modType-ModifyType(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
  "functionStartLine": 958,
  "functionEndLine": 1096,
  "numCommitsSeen": 222,
  "timeTaken": 3020,
  "changeHistory": [
    "b610707cd072f07efb816074a4844bb1b31e482c",
    "35f1cc00274122c0274b522d0b544a06faaba931",
    "52e854e3bda9f1b92471884888f430345f73eca2",
    "d6a556dad71a7d785b9c40608d0bf56062b134a5",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "14373ad1b11e5dc3a26457647ddee4e8ada97430",
    "fab64bbdc726cf06c5993b7b8f50557882086002",
    "f446d290d6e0092e67b1a926e1a2e385d5db6c8a",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
    "a6a2d04877d91a4c7cfff889bb64e2627ca60994",
    "db5c7106a44107b94332ee6844514b003f538a51",
    "050fe8e916507c9716983868284d64e58c1b56d2",
    "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61",
    "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
    "4a453bd132aa147607c14a036d23fc1fe524006f",
    "d19d4a852154ef1d38a842d88c34cac6505e5f01",
    "0c40162c2feef6cd17a553a5506666e1f43a7380",
    "c4df48e565253ed75b1a3070b1f01f1d58087a1f",
    "eadb45d1a7b8b16164171c7caa171fd9f911a414",
    "402c8e0846d5ad865226a7488c4bbc803e685719",
    "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
    "9c4166dbb25e1a0b53e0d776cddc9feececccc78",
    "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5"
  ],
  "changeHistoryShort": {
    "b610707cd072f07efb816074a4844bb1b31e482c": "Ybodychange",
    "35f1cc00274122c0274b522d0b544a06faaba931": "Ybodychange",
    "52e854e3bda9f1b92471884888f430345f73eca2": "Ymultichange(Yparameterchange,Ybodychange)",
    "d6a556dad71a7d785b9c40608d0bf56062b134a5": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "14373ad1b11e5dc3a26457647ddee4e8ada97430": "Ybodychange",
    "fab64bbdc726cf06c5993b7b8f50557882086002": "Ybodychange",
    "f446d290d6e0092e67b1a926e1a2e385d5db6c8a": "Ydocchange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "a6a2d04877d91a4c7cfff889bb64e2627ca60994": "Ybodychange",
    "db5c7106a44107b94332ee6844514b003f538a51": "Ybodychange",
    "050fe8e916507c9716983868284d64e58c1b56d2": "Ybodychange",
    "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61": "Ybodychange",
    "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d": "Ybodychange",
    "4a453bd132aa147607c14a036d23fc1fe524006f": "Ybodychange",
    "d19d4a852154ef1d38a842d88c34cac6505e5f01": "Ymultichange(Ybodychange,Ydocchange)",
    "0c40162c2feef6cd17a553a5506666e1f43a7380": "Ybodychange",
    "c4df48e565253ed75b1a3070b1f01f1d58087a1f": "Ybodychange",
    "eadb45d1a7b8b16164171c7caa171fd9f911a414": "Ydocchange",
    "402c8e0846d5ad865226a7488c4bbc803e685719": "Ymultichange(Ybodychange,Ydocchange)",
    "73ee6c3d270a91bd447f732b24c4d65169b0c8d6": "Ymultichange(Ymovefromfile,Ybodychange)",
    "9c4166dbb25e1a0b53e0d776cddc9feececccc78": "Yfilerename",
    "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b610707cd072f07efb816074a4844bb1b31e482c": {
      "type": "Ybodychange",
      "commitMessage": "removes unnecessary class reference of static method calls which are declared in the same class\n",
      "commitDate": "2018/6/20 下午7:28",
      "commitName": "b610707cd072f07efb816074a4844bb1b31e482c",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2017/6/7 上午4:14",
      "commitNameOld": "309b34f0573d0ec593c17008e8ef4151dfc35a12",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 378.63,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(final Calendar val, final int field, final ModifyType modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    final Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    final int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    final int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n            default:\n                break;\n        }\n        if (!offsetSet) {\n            final int min \u003d val.getActualMinimum(aField[0]);\n            final int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 958,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,96 +1,96 @@\n private static void modify(final Calendar val, final int field, final ModifyType modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     final Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     final int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     final int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     final int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (final int[] aField : fields) {\n         for (final int element : aField) {\n             if (element \u003d\u003d field) {\n                 if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n-                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n+                    if (field \u003d\u003d SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n-            case DateUtils.SEMI_MONTH:\n+            case SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             default:\n                 break;\n         }\n         if (!offsetSet) {\n             final int min \u003d val.getActualMinimum(aField[0]);\n             final int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35f1cc00274122c0274b522d0b544a06faaba931": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Useless parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671675 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015/4/7 上午3:48",
      "commitName": "35f1cc00274122c0274b522d0b544a06faaba931",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014/9/28 上午1:33",
      "commitNameOld": "2aae22de23bf47566700c0ca2671d25e30c4a857",
      "commitAuthorOld": "Duncan Jones",
      "daysBetweenCommits": 191.09,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(final Calendar val, final int field, final ModifyType modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    final Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    final int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    final int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n            default:\n                break;\n        }\n        if (!offsetSet) {\n            final int min \u003d val.getActualMinimum(aField[0]);\n            final int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 967,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,96 +1,96 @@\n private static void modify(final Calendar val, final int field, final ModifyType modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     final Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     final int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     final int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     final int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (final int[] aField : fields) {\n         for (final int element : aField) {\n             if (element \u003d\u003d field) {\n-                if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n+                if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             default:\n                 break;\n         }\n         if (!offsetSet) {\n             final int min \u003d val.getActualMinimum(aField[0]);\n             final int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52e854e3bda9f1b92471884888f430345f73eca2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/9/27 下午11:03",
      "commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
      "commitAuthor": "Duncan Jones",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2014/9/27 下午11:03",
          "commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
          "commitAuthor": "Duncan Jones",
          "commitDateOld": "2014/9/26 下午7:19",
          "commitNameOld": "bdb1a684a7b3876d6812d4e281c852face5a5229",
          "commitAuthorOld": "Duncan Jones",
          "daysBetweenCommits": 1.16,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(final Calendar val, final int field, final ModifyType modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    final Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    final int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    final int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n            default:\n                break;\n        }\n        if (!offsetSet) {\n            final int min \u003d val.getActualMinimum(aField[0]);\n            final int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
          "functionStartLine": 967,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,96 +1,96 @@\n-private static void modify(final Calendar val, final int field, final int modType) {\n+private static void modify(final Calendar val, final int field, final ModifyType modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     final Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     final int millisecs \u003d val.get(Calendar.MILLISECOND);\n-    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n+    if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     final int seconds \u003d val.get(Calendar.SECOND);\n-    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n+    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     final int minutes \u003d val.get(Calendar.MINUTE);\n-    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n+    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (final int[] aField : fields) {\n         for (final int element : aField) {\n             if (element \u003d\u003d field) {\n-                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n+                if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             default:\n                 break;\n         }\n         if (!offsetSet) {\n             final int min \u003d val.getActualMinimum(aField[0]);\n             final int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-int(modifiers-final)]",
            "newValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-ModifyType(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2014/9/27 下午11:03",
          "commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
          "commitAuthor": "Duncan Jones",
          "commitDateOld": "2014/9/26 下午7:19",
          "commitNameOld": "bdb1a684a7b3876d6812d4e281c852face5a5229",
          "commitAuthorOld": "Duncan Jones",
          "daysBetweenCommits": 1.16,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(final Calendar val, final int field, final ModifyType modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    final Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    final int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    final int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n            default:\n                break;\n        }\n        if (!offsetSet) {\n            final int min \u003d val.getActualMinimum(aField[0]);\n            final int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
          "functionStartLine": 967,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,96 +1,96 @@\n-private static void modify(final Calendar val, final int field, final int modType) {\n+private static void modify(final Calendar val, final int field, final ModifyType modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     final Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     final int millisecs \u003d val.get(Calendar.MILLISECOND);\n-    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n+    if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     final int seconds \u003d val.get(Calendar.SECOND);\n-    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n+    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     final int minutes \u003d val.get(Calendar.MINUTE);\n-    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n+    if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (final int[] aField : fields) {\n         for (final int element : aField) {\n             if (element \u003d\u003d field) {\n-                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n+                if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             default:\n                 break;\n         }\n         if (!offsetSet) {\n             final int min \u003d val.getActualMinimum(aField[0]);\n             final int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d6a556dad71a7d785b9c40608d0bf56062b134a5": {
      "type": "Ybodychange",
      "commitMessage": "Add explict default case\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1565257 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/2/6 下午9:51",
      "commitName": "d6a556dad71a7d785b9c40608d0bf56062b134a5",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014/1/21 上午1:19",
      "commitNameOld": "0942ef04f1fa911d382b79a92dca1dd4b3eb88e6",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 16.86,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(final Calendar val, final int field, final int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    final Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    final int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    final int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n            default:\n                break;\n        }\n        if (!offsetSet) {\n            final int min \u003d val.getActualMinimum(aField[0]);\n            final int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 956,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,94 +1,96 @@\n private static void modify(final Calendar val, final int field, final int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     final Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     final int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     final int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     final int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (final int[] aField : fields) {\n         for (final int element : aField) {\n             if (element \u003d\u003d field) {\n                 if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n+            default:\n+                break;\n         }\n         if (!offsetSet) {\n             final int min \u003d val.getActualMinimum(aField[0]);\n             final int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:09",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/1/22 下午3:07",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(final Calendar val, final int field, final int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    final Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    final int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    final int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (final int[] aField : fields) {\n        for (final int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            final int min \u003d val.getActualMinimum(aField[0]);\n            final int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 956,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,94 +1,94 @@\n private static void modify(final Calendar val, final int field, final int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n-    Date date \u003d val.getTime();\n+    final Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n-    int millisecs \u003d val.get(Calendar.MILLISECOND);\n+    final int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n-    int seconds \u003d val.get(Calendar.SECOND);\n+    final int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n-    int minutes \u003d val.get(Calendar.MINUTE);\n+    final int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n-    for (int[] aField : fields) {\n-        for (int element : aField) {\n+    for (final int[] aField : fields) {\n+        for (final int element : aField) {\n             if (element \u003d\u003d field) {\n                 if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n-            int min \u003d val.getActualMinimum(aField[0]);\n-            int max \u003d val.getActualMaximum(aField[0]);\n+            final int min \u003d val.getActualMinimum(aField[0]);\n+            final int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:07",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012/9/22 下午9:22",
      "commitNameOld": "ebdef1b95710b44324d40fa1e67a1bc1b370ee81",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 121.74,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(final Calendar val, final int field, final int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int[] aField : fields) {\n        for (int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(aField[0]);\n            int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 956,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,94 +1,94 @@\n-private static void modify(Calendar val, int field, int modType) {\n+private static void modify(final Calendar val, final int field, final int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int[] aField : fields) {\n         for (int element : aField) {\n             if (element \u003d\u003d field) {\n                 if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(aField[0]);\n             int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[val-Calendar, field-int, modType-int]",
        "newValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-int(modifiers-final)]"
      }
    },
    "14373ad1b11e5dc3a26457647ddee4e8ada97430": {
      "type": "Ybodychange",
      "commitMessage": "Convert to Java 5 enhanced for loops. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1144992 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/7/11 上午8:49",
      "commitName": "14373ad1b11e5dc3a26457647ddee4e8ada97430",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011/7/11 上午2:26",
      "commitNameOld": "fab64bbdc726cf06c5993b7b8f50557882086002",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int[] aField : fields) {\n        for (int element : aField) {\n            if (element \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(aField[0]);\n            int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 902,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,94 +1,94 @@\n private static void modify(Calendar val, int field, int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int[] aField : fields) {\n-        for (int j \u003d 0; j \u003c aField.length; j++) {\n-            if (aField[j] \u003d\u003d field) {\n+        for (int element : aField) {\n+            if (element \u003d\u003d field) {\n                 if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(aField[0]);\n             int max \u003d val.getActualMaximum(aField[0]);\n             offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fab64bbdc726cf06c5993b7b8f50557882086002": {
      "type": "Ybodychange",
      "commitMessage": "Convert to Java 5 enhanced loops. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1144929 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/7/11 上午2:26",
      "commitName": "fab64bbdc726cf06c5993b7b8f50557882086002",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011/4/12 下午11:18",
      "commitNameOld": "47132a3fcc7ba92e2f8028ac5261c03fcf94d67b",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 89.13,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int[] aField : fields) {\n        for (int j \u003d 0; j \u003c aField.length; j++) {\n            if (aField[j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(aField[0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (aField[0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(aField[0]);\n            int max \u003d val.getActualMaximum(aField[0]);\n            offset \u003d val.get(aField[0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(aField[0], val.get(aField[0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 902,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,94 +1,94 @@\n private static void modify(Calendar val, int field, int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n-    for (int i \u003d 0; i \u003c fields.length; i++) {\n-        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n-            if (fields[i][j] \u003d\u003d field) {\n+    for (int[] aField : fields) {\n+        for (int j \u003d 0; j \u003c aField.length; j++) {\n+            if (aField[j] \u003d\u003d field) {\n                 if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n-                        val.add(fields[i][0], 1);\n+                        val.add(aField[0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n-                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n+                if (aField[0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n-                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n+                if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n-            int min \u003d val.getActualMinimum(fields[i][0]);\n-            int max \u003d val.getActualMaximum(fields[i][0]);\n-            offset \u003d val.get(fields[i][0]) - min;\n+            int min \u003d val.getActualMinimum(aField[0]);\n+            int max \u003d val.getActualMaximum(aField[0]);\n+            offset \u003d val.get(aField[0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n-            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            val.set(aField[0], val.get(aField[0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f446d290d6e0092e67b1a926e1a2e385d5db6c8a": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1077933 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/3/4 下午9:29",
      "commitName": "f446d290d6e0092e67b1a926e1a2e385d5db6c8a",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2011/3/4 下午9:00",
      "commitNameOld": "bbc7fd046a8a8076cc5bf9fd513ded2c503b0351",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 915,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
        "newValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar, not null\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n"
      }
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 911,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/time/DateUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/time/DateUtils.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 869,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/time/DateUtils.java"
      }
    },
    "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/7/20 上午3:21",
      "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/7/20 上午3:21",
          "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2009/3/16 上午10:11",
          "commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 125.71,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 869,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,94 +1,94 @@\n-private static void modify(Calendar val, int field, boolean round) {\n+private static void modify(Calendar val, int field, int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n-    if (!round || millisecs \u003c 500) {\n+    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n-    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n-    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n-                if (round \u0026\u0026 roundUp) {\n+                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[val-Calendar, field-int, round-boolean]",
            "newValue": "[val-Calendar, field-int, modType-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/7/20 上午3:21",
          "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2009/3/16 上午10:11",
          "commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 125.71,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 869,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,94 +1,94 @@\n-private static void modify(Calendar val, int field, boolean round) {\n+private static void modify(Calendar val, int field, int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n-    if (!round || millisecs \u003c 500) {\n+    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n-    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n-    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n-                if (round \u0026\u0026 roundUp) {\n+                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/7/20 上午3:21",
          "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2009/3/16 上午10:11",
          "commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 125.71,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, int modType) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 869,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,94 +1,94 @@\n-private static void modify(Calendar val, int field, boolean round) {\n+private static void modify(Calendar val, int field, int modType) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n-    if (!round || millisecs \u003c 500) {\n+    if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n-    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n-    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+    if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n-                if (round \u0026\u0026 roundUp) {\n+                if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
            "newValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param modType type to truncate, round or ceiling\n@throws ArithmeticException if the year is over 280 million\n"
          }
        }
      ]
    },
    "a6a2d04877d91a4c7cfff889bb64e2627ca60994": {
      "type": "Ybodychange",
      "commitMessage": "Applying Robert Scholte\u0027s excellent unit tests from LANG-443 and his second patch from LANG-440 fixing a discovered boundary case for AM_PM in round\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@711616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008/11/6 上午1:00",
      "commitName": "a6a2d04877d91a4c7cfff889bb64e2627ca60994",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2008/6/9 下午3:17",
      "commitNameOld": "db5c7106a44107b94332ee6844514b003f538a51",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 149.41,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (!round || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e\u003d 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 766,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,94 +1,94 @@\n private static void modify(Calendar val, int field, boolean round) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (!round || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else if (field \u003d\u003d Calendar.AM_PM) {\n                         if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                         } else {\n                             val.add(Calendar.HOUR_OF_DAY, -12);\n                             val.add(Calendar.DATE, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n-                    roundUp \u003d offset \u003e 6;\n+                    roundUp \u003d offset \u003e\u003d 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "db5c7106a44107b94332ee6844514b003f538a51": {
      "type": "Ybodychange",
      "commitMessage": "Applying Robert Scholte\u0027s fix for LANG-440, replicating the SEMI_MONTH logic for AM_PM requests\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@664643 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008/6/9 下午3:17",
      "commitName": "db5c7106a44107b94332ee6844514b003f538a51",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2008/3/6 上午8:58",
      "commitNameOld": "8e83403ba9a34a2b2540d274c176f025d1ec9f1e",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 95.26,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (!round || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field \u003d\u003d Calendar.AM_PM) {\n                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                            val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            val.add(Calendar.HOUR_OF_DAY, -12);\n                            val.add(Calendar.DATE, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 766,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,87 +1,94 @@\n private static void modify(Calendar val, int field, boolean round) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (!round || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n     }\n     if (field \u003d\u003d Calendar.SECOND) {\n         done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n     }\n     if (field \u003d\u003d Calendar.MINUTE) {\n         done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n+                    } else if (field \u003d\u003d Calendar.AM_PM) {\n+                        if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n+                            val.add(Calendar.HOUR_OF_DAY, 12);\n+                        } else {\n+                            val.add(Calendar.HOUR_OF_DAY, -12);\n+                            val.add(Calendar.DATE, 1);\n+                        }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "050fe8e916507c9716983868284d64e58c1b56d2": {
      "type": "Ybodychange",
      "commitMessage": "Applying the fix and the test patches from LANG-346 - fixes bugs in DateUtils.round() for minutes and seconds. Patch from Dave Meikle\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@564053 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2007/8/9 上午8:24",
      "commitName": "050fe8e916507c9716983868284d64e58c1b56d2",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006/8/28 下午2:21",
      "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 345.75,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (!round || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n    }\n    if (field \u003d\u003d Calendar.SECOND) {\n        done \u003d true;\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n    }\n    if (field \u003d\u003d Calendar.MINUTE) {\n        done \u003d true;\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 620,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,87 +1,87 @@\n private static void modify(Calendar val, int field, boolean round) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     if (field \u003d\u003d Calendar.MILLISECOND) {\n         return;\n     }\n     Date date \u003d val.getTime();\n     long time \u003d date.getTime();\n     boolean done \u003d false;\n     int millisecs \u003d val.get(Calendar.MILLISECOND);\n     if (!round || millisecs \u003c 500) {\n         time \u003d time - millisecs;\n-        if (field \u003d\u003d Calendar.SECOND) {\n-            done \u003d true;\n-        }\n+    }\n+    if (field \u003d\u003d Calendar.SECOND) {\n+        done \u003d true;\n     }\n     int seconds \u003d val.get(Calendar.SECOND);\n     if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n         time \u003d time - (seconds * 1000L);\n-        if (field \u003d\u003d Calendar.MINUTE) {\n-            done \u003d true;\n-        }\n+    }\n+    if (field \u003d\u003d Calendar.MINUTE) {\n+        done \u003d true;\n     }\n     int minutes \u003d val.get(Calendar.MINUTE);\n     if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n         time \u003d time - (minutes * 60000L);\n     }\n     if (date.getTime() !\u003d time) {\n         date.setTime(time);\n         val.setTime(date);\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         if (offset !\u003d 0) {\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61": {
      "type": "Ybodychange",
      "commitMessage": "Adding Niall\u0027s fix for LANG-59 - an edge case in date truncation - and his enhancement \nfor the unit test that was there. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@424192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/7/21 下午1:47",
      "commitName": "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006/7/6 上午7:49",
      "commitNameOld": "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 15.25,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    if (field \u003d\u003d Calendar.MILLISECOND) {\n        return;\n    }\n    Date date \u003d val.getTime();\n    long time \u003d date.getTime();\n    boolean done \u003d false;\n    int millisecs \u003d val.get(Calendar.MILLISECOND);\n    if (!round || millisecs \u003c 500) {\n        time \u003d time - millisecs;\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n    }\n    int seconds \u003d val.get(Calendar.SECOND);\n    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n        time \u003d time - (seconds * 1000L);\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n    }\n    int minutes \u003d val.get(Calendar.MINUTE);\n    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n        time \u003d time - (minutes * 60000L);\n    }\n    if (date.getTime() !\u003d time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        if (offset !\u003d 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 619,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,57 +1,87 @@\n private static void modify(Calendar val, int field, boolean round) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n+    if (field \u003d\u003d Calendar.MILLISECOND) {\n+        return;\n+    }\n+    Date date \u003d val.getTime();\n+    long time \u003d date.getTime();\n+    boolean done \u003d false;\n+    int millisecs \u003d val.get(Calendar.MILLISECOND);\n+    if (!round || millisecs \u003c 500) {\n+        time \u003d time - millisecs;\n+        if (field \u003d\u003d Calendar.SECOND) {\n+            done \u003d true;\n+        }\n+    }\n+    int seconds \u003d val.get(Calendar.SECOND);\n+    if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+        time \u003d time - (seconds * 1000L);\n+        if (field \u003d\u003d Calendar.MINUTE) {\n+            done \u003d true;\n+        }\n+    }\n+    int minutes \u003d val.get(Calendar.MINUTE);\n+    if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+        time \u003d time - (minutes * 60000L);\n+    }\n+    if (date.getTime() !\u003d time) {\n+        date.setTime(time);\n+        val.setTime(date);\n+    }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n-        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+        if (offset !\u003d 0) {\n+            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+        }\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d": {
      "type": "Ybodychange",
      "commitMessage": "Remove debugging code\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@419387 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/7/6 上午7:49",
      "commitName": "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2006/7/5 下午2:14",
      "commitNameOld": "4a453bd132aa147607c14a036d23fc1fe524006f",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 619,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,58 +1,57 @@\n private static void modify(Calendar val, int field, boolean round) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n-        System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a453bd132aa147607c14a036d23fc1fe524006f": {
      "type": "Ybodychange",
      "commitMessage": "Minor style fixes suggested by checkstyle\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@419174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/7/5 下午2:14",
      "commitName": "4a453bd132aa147607c14a036d23fc1fe524006f",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006/4/17 上午4:55",
      "commitNameOld": "12491a6801249b2a582a231b1a40e17b401cc413",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 79.39,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 619,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
      "diff": "@@ -1,57 +1,58 @@\n private static void modify(Calendar val, int field, boolean round) {\n     if (val.get(Calendar.YEAR) \u003e 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n+        System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d19d4a852154ef1d38a842d88c34cac6505e5f01": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Fix DateUtils.truncate oddity at the far end of the Date spectrum\nbug 31395, from Marc Portier\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137984 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/10/17 上午1:43",
      "commitName": "d19d4a852154ef1d38a842d88c34cac6505e5f01",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fix DateUtils.truncate oddity at the far end of the Date spectrum\nbug 31395, from Marc Portier\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137984 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/10/17 上午1:43",
          "commitName": "d19d4a852154ef1d38a842d88c34cac6505e5f01",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/10/17 上午1:08",
          "commitNameOld": "61cccd3e0a4cc51c0956ca90310c8b76d4f6fdeb",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 444,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,54 +1,57 @@\n private static void modify(Calendar val, int field, boolean round) {\n+    if (val.get(Calendar.YEAR) \u003e 280000000) {\n+        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+    }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fix DateUtils.truncate oddity at the far end of the Date spectrum\nbug 31395, from Marc Portier\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137984 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2004/10/17 上午1:43",
          "commitName": "d19d4a852154ef1d38a842d88c34cac6505e5f01",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2004/10/17 上午1:08",
          "commitNameOld": "61cccd3e0a4cc51c0956ca90310c8b76d4f6fdeb",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) \u003e 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 444,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n",
          "diff": "@@ -1,54 +1,57 @@\n private static void modify(Calendar val, int field, boolean round) {\n+    if (val.get(Calendar.YEAR) \u003e 280000000) {\n+        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+    }\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                     offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
            "newValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n@throws ArithmeticException if the year is over 280 million\n"
          }
        }
      ]
    },
    "0c40162c2feef6cd17a553a5506666e1f43a7380": {
      "type": "Ybodychange",
      "commitMessage": "corrected calendar field used to calculate the offset when modifying the hour for a round or truncated based on AM_PM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137881 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/7/12 上午8:04",
      "commitName": "0c40162c2feef6cd17a553a5506666e1f43a7380",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2004/7/12 上午2:40",
      "commitNameOld": "946ba1293b91a73461d7f3db02a99881bed2147b",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 322,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
      "diff": "@@ -1,54 +1,54 @@\n private static void modify(Calendar val, int field, boolean round) {\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n-                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n-                    offset \u003d val.get(Calendar.HOUR);\n+                if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n+                    offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4df48e565253ed75b1a3070b1f01f1d58087a1f": {
      "type": "Ybodychange",
      "commitMessage": "changed modify method to calculate the field offset and use the set method, rather than adding the offset and letting Calendar perform the calculation - this fixes http://issues.apache.org/bugzilla/show_bug.cgi?id\u003d25560;\nupdated javadocs on round method to explain how rounding across daylight saving time is handled\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137866 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/7/6 上午1:54",
      "commitName": "c4df48e565253ed75b1a3070b1f01f1d58087a1f",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2004/6/27 下午2:29",
      "commitNameOld": "5f7e26a978322dd6d09459ecdbefb7a389a86652",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 8.48,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 322,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
      "diff": "@@ -1,54 +1,54 @@\n private static void modify(Calendar val, int field, boolean round) {\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                     offset \u003d val.get(Calendar.HOUR);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n-        val.add(fields[i][0], -offset);\n+        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eadb45d1a7b8b16164171c7caa171fd9f911a414": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc fixes. Shouldn\u0027t have been anything other than javadoc changes in this.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137416 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/15 上午6:25",
      "commitName": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2003/6/29 上午1:49",
      "commitNameOld": "008d16ed5bf041603ee562e48696e5b0f92a4089",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 16.19,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 336,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Internal calculation method\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
        "newValue": "\u003cp\u003eInternal calculation method.\u003c/p\u003e\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n"
      }
    },
    "402c8e0846d5ad865226a7488c4bbc803e685719": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Prepare DateUtils for 2.0 release\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137375 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/6/24 上午7:41",
      "commitName": "402c8e0846d5ad865226a7488c4bbc803e685719",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Prepare DateUtils for 2.0 release\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137375 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/6/24 上午7:41",
          "commitName": "402c8e0846d5ad865226a7488c4bbc803e685719",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/6/9 上午7:14",
          "commitNameOld": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 15.02,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 312,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "Internal calculation method\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
          "diff": "@@ -1,54 +1,54 @@\n private static void modify(Calendar val, int field, boolean round) {\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                     offset \u003d val.get(Calendar.HOUR);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.add(fields[i][0], -offset);\n     }\n-    throw new RuntimeException(\"We do not support that field.\");\n+    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Prepare DateUtils for 2.0 release\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137375 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/6/24 上午7:41",
          "commitName": "402c8e0846d5ad865226a7488c4bbc803e685719",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/6/9 上午7:14",
          "commitNameOld": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 15.02,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 312,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "Internal calculation method\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n",
          "diff": "@@ -1,54 +1,54 @@\n private static void modify(Calendar val, int field, boolean round) {\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n                     if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                     offset \u003d val.get(Calendar.HOUR);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.add(fields[i][0], -offset);\n     }\n-    throw new RuntimeException(\"We do not support that field.\");\n+    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Internal calculation method\n\n@param val the calendar\n@param field the field constant\n@param round true to round, false to truncate\n"
          }
        }
      ]
    },
    "73ee6c3d270a91bd447f732b24c4d65169b0c8d6": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/6/9 上午7:14",
      "commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/6/9 上午7:14",
          "commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/6/8 下午10:19",
          "commitNameOld": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.37,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new RuntimeException(\"We do not support that field.\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 227,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n private static void modify(Calendar val, int field, boolean round) {\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n-                    if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n+                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n-            case CalendarUtils.SEMI_MONTH:\n+            case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                     offset \u003d val.get(Calendar.HOUR);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.add(fields[i][0], -offset);\n     }\n     throw new RuntimeException(\"We do not support that field.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/java/org/apache/commons/lang/time/CalendarUtils.java",
            "newPath": "src/java/org/apache/commons/lang/time/DateUtils.java",
            "oldMethodName": "modify",
            "newMethodName": "modify"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003/6/9 上午7:14",
          "commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003/6/8 下午10:19",
          "commitNameOld": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.37,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new RuntimeException(\"We do not support that field.\");\n}",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 227,
          "functionName": "modify",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n private static void modify(Calendar val, int field, boolean round) {\n     boolean roundUp \u003d false;\n     for (int i \u003d 0; i \u003c fields.length; i++) {\n         for (int j \u003d 0; j \u003c fields[i].length; j++) {\n             if (fields[i][j] \u003d\u003d field) {\n                 if (round \u0026\u0026 roundUp) {\n-                    if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n+                    if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                         if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n                             val.add(Calendar.DATE, -15);\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n         int offset \u003d 0;\n         boolean offsetSet \u003d false;\n         switch(field) {\n-            case CalendarUtils.SEMI_MONTH:\n+            case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                     offset \u003d val.get(Calendar.DATE) - 1;\n                     if (offset \u003e\u003d 15) {\n                         offset -\u003d 15;\n                     }\n                     roundUp \u003d offset \u003e 7;\n                     offsetSet \u003d true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                     offset \u003d val.get(Calendar.HOUR);\n                     if (offset \u003e\u003d 12) {\n                         offset -\u003d 12;\n                     }\n                     roundUp \u003d offset \u003e 6;\n                     offsetSet \u003d true;\n                 }\n                 break;\n         }\n         if (!offsetSet) {\n             int min \u003d val.getActualMinimum(fields[i][0]);\n             int max \u003d val.getActualMaximum(fields[i][0]);\n             offset \u003d val.get(fields[i][0]) - min;\n             roundUp \u003d offset \u003e ((max - min) / 2);\n         }\n         val.add(fields[i][0], -offset);\n     }\n     throw new RuntimeException(\"We do not support that field.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9c4166dbb25e1a0b53e0d776cddc9feececccc78": {
      "type": "Yfilerename",
      "commitMessage": "Create time subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137194 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002/12/19 上午7:30",
      "commitName": "9c4166dbb25e1a0b53e0d776cddc9feececccc78",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2002/12/19 上午7:28",
      "commitNameOld": "55feeb72b96de4da9cc3535762ddf6b9d04209f7",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case CalendarUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new RuntimeException(\"We do not support that field.\");\n}",
      "path": "src/java/org/apache/commons/lang/time/CalendarUtils.java",
      "functionStartLine": 195,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/CalendarUtils.java",
        "newPath": "src/java/org/apache/commons/lang/time/CalendarUtils.java"
      }
    },
    "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5": {
      "type": "Yintroduced",
      "commitMessage": "CalendarUtils from the sandbox, for merger with DateUtils. Or parallel living.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137190 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002/12/17 上午5:55",
      "commitName": "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,54 @@\n+private static void modify(Calendar val, int field, boolean round) {\n+    boolean roundUp \u003d false;\n+    for (int i \u003d 0; i \u003c fields.length; i++) {\n+        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n+            if (fields[i][j] \u003d\u003d field) {\n+                if (round \u0026\u0026 roundUp) {\n+                    if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n+                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n+                            val.add(Calendar.DATE, 15);\n+                        } else {\n+                            val.add(Calendar.DATE, -15);\n+                            val.add(Calendar.MONTH, 1);\n+                        }\n+                    } else {\n+                        val.add(fields[i][0], 1);\n+                    }\n+                }\n+                return;\n+            }\n+        }\n+        int offset \u003d 0;\n+        boolean offsetSet \u003d false;\n+        switch(field) {\n+            case CalendarUtils.SEMI_MONTH:\n+                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n+                    offset \u003d val.get(Calendar.DATE) - 1;\n+                    if (offset \u003e\u003d 15) {\n+                        offset -\u003d 15;\n+                    }\n+                    roundUp \u003d offset \u003e 7;\n+                    offsetSet \u003d true;\n+                }\n+                break;\n+            case Calendar.AM_PM:\n+                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n+                    offset \u003d val.get(Calendar.HOUR);\n+                    if (offset \u003e\u003d 12) {\n+                        offset -\u003d 12;\n+                    }\n+                    roundUp \u003d offset \u003e 6;\n+                    offsetSet \u003d true;\n+                }\n+                break;\n+        }\n+        if (!offsetSet) {\n+            int min \u003d val.getActualMinimum(fields[i][0]);\n+            int max \u003d val.getActualMaximum(fields[i][0]);\n+            offset \u003d val.get(fields[i][0]) - min;\n+            roundUp \u003d offset \u003e ((max - min) / 2);\n+        }\n+        val.add(fields[i][0], -offset);\n+    }\n+    throw new RuntimeException(\"We do not support that field.\");\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static void modify(Calendar val, int field, boolean round) {\n    boolean roundUp \u003d false;\n    for (int i \u003d 0; i \u003c fields.length; i++) {\n        for (int j \u003d 0; j \u003c fields[i].length; j++) {\n            if (fields[i][j] \u003d\u003d field) {\n                if (round \u0026\u0026 roundUp) {\n                    if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n                        if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        int offset \u003d 0;\n        boolean offsetSet \u003d false;\n        switch(field) {\n            case CalendarUtils.SEMI_MONTH:\n                if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                    offset \u003d val.get(Calendar.DATE) - 1;\n                    if (offset \u003e\u003d 15) {\n                        offset -\u003d 15;\n                    }\n                    roundUp \u003d offset \u003e 7;\n                    offsetSet \u003d true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                    offset \u003d val.get(Calendar.HOUR);\n                    if (offset \u003e\u003d 12) {\n                        offset -\u003d 12;\n                    }\n                    roundUp \u003d offset \u003e 6;\n                    offsetSet \u003d true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min \u003d val.getActualMinimum(fields[i][0]);\n            int max \u003d val.getActualMaximum(fields[i][0]);\n            offset \u003d val.get(fields[i][0]) - min;\n            roundUp \u003d offset \u003e ((max - min) / 2);\n        }\n        val.add(fields[i][0], -offset);\n    }\n    throw new RuntimeException(\"We do not support that field.\");\n}",
      "path": "src/java/org/apache/commons/lang/CalendarUtils.java",
      "functionStartLine": 195,
      "functionName": "modify",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}